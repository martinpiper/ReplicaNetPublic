// This source file is the amalgamated source for ReplicaNet and RNLobby from Replica Software. Individual source files are available in the full SDK.
// Define this to disable ReplicaObject integration and stop linker errors about _ReplicaNetPreRegisterReplicasFunc
//#define REPLICANET_NO_REPLICA_OBJECTS
// Define this to use multi-threading
#define RNUSETHREAD
// Define this to remove RNLobby code from the compilation.
//#define REPLICANET_REMOVE_RNLOBBY
// Tells the code below it is amalgamated
#define REPLICANET_AMALGATED
// Switches off CRT and PDB warnings for Microsoft compilers
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif
#ifndef _WINSOCK_DEPRECATED_NO_WARNINGS
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#endif
#include "RNPlatform/Inc/MemoryTracking.h"		// Always the first header in public ReplicaNet library includes
#include <algorithm>
static char _version_id_string[] = "\n\nInfo: " __FILE__ "-" __DATE__ "-" __TIME__ "\n\n";
//The amalgamated code starts here
//From: RNXPSockets/XPSockets.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
/** \page XPSockets XPSockets
 *
 * \section intro Introduction
 *
 * XPSockets is a method for accessing TCPIP networking functions from a cross platform common layer
 *
 * \section usingxpsockets Using XPSockets
 *
 * Include files are in the Includes directory.<br>
 * Use "XPSockets.h" to access all the C++ insterface to sockets or,
 * include "XPSocket.h" to only use the old C style functions.<br>
 * <br>
 * There are four compiled libraries in the Libs directory:<br>
 * XPSocketsDS and XPSocketsRS for debug and release single thread applications.<br>
 * XPSocketsDM and XPSocketsRM for debug and release multi-threaded applications.<br>
 * XPSocketsDMDLL and XPSocketsRMDLL for debug and release multi-threaded DLL applications.<br>
 * 
 *
 */

//From: RNXPSockets/XPSocket.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#include "RNPlatform/Inc/MemoryTracking.h"		// Always has to be the first in the file
#include <stdlib.h>
#include <assert.h>
#include "RNPlatform/Inc/PlatformHeap.h"
#include "RNPlatform/Inc/Rand.h"

/**
 * \file XPSocket.cpp
 * Simple local host packet stuff
 * A lot like standard sockets, but made simpler with all the error handling done internally
 *
 * Handles all these protocols transparently:
 *
 * Localhost sockets.
 * TCPIP using streamed and UDP connections.
 *
 * Sockets with a permanent connection and also connectionless sockets are implemented. Every urgent socket call can be
 * thought of as mapping to equivalent UDP packet protocols.
 *
 */

/* Include the wsock library without having to enter it in the link stage */
#ifdef _WIN32

#if defined(__MINGW32__)
// For getaddrinfo
#define WINVER 0x501
#endif

// If this is not an XBOX build under Win32 then do the library include pragma
// Consider removing this pragma, it is a bit naughty
#ifndef _XBOX
#pragma comment(lib, "ws2_32.lib")
#endif
#endif

/* Include system network headers */

#if defined(_XBOX)
// XBox will use XNetGetTitleXnAddr and return sensible values for:
// XPSock_GetHostAddress
// XPSock_GetHostName
// XPSock_Resolve
// XPSock_GetAddress
// XPSock_GetPeerAddress
// XNADDR Secure NAT Resolution using XNetRegisterKey and XNetXnAddrToInAddr is not the remit of this library, this is handled by lobby and matchmaking services.
#define _USING_W32_SOCKETS
#include <xtl.h>
#include <xonline.h>
#else
#if defined(_WIN32)
#define _USING_W32_SOCKETS
#include <winsock2.h>
#include <Ws2tcpip.h>
#else
#if defined(RN_UNIX_LIKE)
#include <unistd.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <netdb.h>
#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <errno.h>
#include <arpa/inet.h>
#endif /* #if defined(RN_UNIX_LIKE) */

#if defined(_PS2)
#include <libeenet.h>
#include <libeenet/sys/socket.h>
#include <libeenet/sys/select.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <netdb.h>
#include <sys/param.h>
#include <sys/uio.h>
#include <errno.h>
#include <arpa/inet.h>
#include <eenetctl.h>
//#include <netcnf.h>
#endif /* #if defined(_PS2) */
#endif /* WIN32 */
#endif /* XBOX */

#include <stdio.h>
#include <string.h>

// God knows why these are not in the Unix headers I have???
#define RNmax(a,b)			(((a) > (b)) ? (a) : (b))
#define RNmin(a,b)			(((a) < (b)) ? (a) : (b))

#ifndef _USING_W32_SOCKETS

#if defined(_PS2)
#define closesocket	sceEENetClose
#define accept sceEENetAccept
#define socket sceEENetSocket
#define SOCKET_ERROR	-1
#define WSAEWOULDBLOCK EWOULDBLOCK
#define WSAECONNRESET ECONNRESET
#define SOCK_STREAM SCE_EENET_SOCK_STREAM
#ifdef IPPROTO_TCP
#undef IPPROTO_TCP
#endif
#define IPPROTO_TCP (0)
int WSAGetLastError(void)
{
	// As per the Sony docs the real errno variable for the network stack is sceEENetErrno
	return sceEENetErrno;
}
#define WSAENOTCONN ENOTCONN
#else	// if defined(_PS2)

#define closesocket	close
#define ioctlsocket ioctl
#define SOCKET	int
#define INVALID_SOCKET	-1
#define SOCKET_ERROR	-1
#define WSAEWOULDBLOCK EWOULDBLOCK
#define WSAECONNRESET ECONNRESET
#define WSAENOTCONN ENOTCONN

int WSAGetLastError(void)
{
	return errno;
}
#endif
#endif /* USING_W32_SOCKETS */

static char my_special_mach_name[] = "localhost";

//Include inline: #include "RNXPSockets/debug.h"
//From: RNXPSockets/debug.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef DEBUG_H
#define DEBUG_H

void dprintf(const char *format, ...);		/**< output a debug string to the MSDEV console */

#endif
#include "RNXPSockets/Inc/XPSocket.h"

#include "RNPlatform/Inc/ThreadClass.h"
#include "RNPlatform/Inc/SysTime.h"
#include <list>
//Skipping: #include "RNPlatform/Inc/SysTime.h"
//Include inline: #include "RNXPSockets/Ping.h"
//From: RNXPSockets/Ping.h
#if defined(RN_UNIX_LIKE)
#include <netdb.h>
#endif
#if defined(RN_UNIX_LIKE) || defined(_WIN32)
// New versions of GCC support this pragma
#pragma pack(1)
#endif

#define ICMP_ECHOREPLY	0
#define ICMP_ECHOREQ	8

// IP Header -- RFC 791
typedef struct tagIPHDR
{
	u_char  VIHL;			// Version and IHL
	u_char	TOS;			// Type Of Service
	short	TotLen;			// Total Length
	short	ID;				// Identification
	short	FlagOff;		// Flags and Fragment Offset
	u_char	TTL;			// Time To Live
	u_char	Protocol;		// Protocol
	u_short	Checksum;		// Checksum
	struct	in_addr iaSrc;	// Internet Address - Source
	struct	in_addr iaDst;	// Internet Address - Destination
}IPHDR, *PIPHDR;


// ICMP Header -- RFC 792
typedef struct tagICMPHDR
{
	u_char	Type;			// Type
	u_char	Code;			// Code
	u_short	Checksum;		// Checksum
	u_short	ID;				// Identification
	u_short	Seq;			// Sequence
	char	Data;			// Data
}ICMPHDR, *PICMPHDR;

#define REQ_DATASIZE 32

typedef struct tagECHOREQUEST
{
	ICMPHDR icmpHdr;
	unsigned int	dwTime;
	char	cData[REQ_DATASIZE];
}ECHOREQUEST, *PECHOREQUEST;


typedef struct tagECHOREPLY
{
	IPHDR	ipHdr;
	ECHOREQUEST	echoRequest;
	char	cFiller[256];
}ECHOREPLY, *PECHOREPLY;


#if defined(RN_UNIX_LIKE) || defined(_WIN32)
#pragma pack()
#endif
//Skipping: #include "RNPlatform/Inc/SysTime.h"


using namespace RNReplicaNet;

/** Use this to turn off the Nagle packet compression algorithm */

#define NO_NAGLE

#if defined(_PS2) || defined(RN_UNIX_LIKE)
#undef NO_NAGLE
#endif

#ifndef TCP_NODELAY
#undef NO_NAGLE
#endif

#ifndef SOMAXCONN
#define SOMAXCONN 0x7fffffff
#endif

// Airplay SDK tweaks
#ifdef IW_SDK
// MPi: TODO: Find out why Airplay SDK differs
// Note, only for platforms like Airplay SDK that don't define these
//#define AI_NUMERICHOST	4
#define INADDR_NONE			 0xffffffff
//#define s6_addr s_addr
/*
const char *inet_ntop(int af, const void *src,char *dst, socklen_t size)
{
	return 0;
}
*/
#define NO_GETADDRINFO
#endif
// End Airplay SDK tweaks

/** asocket_lasterror This contains the last error value returned from any of the socket functions */
int asocket_lasterror = XPSOCK_EOK;

/* Socket pointers for local host bits */
static t_XPSocket *loopback_socket_listen = NULL;
static t_XPSocket *loopback_socket_server = NULL;
static t_XPSocket *loopback_socket_client = NULL;

/* Urgent socket pointers for local host bits */
static t_XPSocket *loopback_usocket_listen = NULL;
static t_XPSocket *loopback_usocket_server = NULL;
static t_XPSocket *loopback_usocket_client = NULL;

/* Some local variables */
#ifdef _USING_W32_SOCKETS
static WSADATA		winsockdata;
#endif
//static WORD	wVersionRequested;
static int wsockets_started = 0;



namespace RNReplicaNet
{
static bool sXPSocketsHeapBlockDone = false;
class XPSocketsHeapBlock : public RNReplicaNet::PlatformHeapBlock
{
public:
	virtual ~XPSocketsHeapBlock()
	{
		sXPSocketsHeapBlockDone = false;
		XPSock_Quit();
	}
};
}

/* Counters updated by the packet routines */
int	asocket_packets_got = 0;						/**< Total number of packets received */
int	asocket_packets_sent = 0;						/**< Total number of packets sent */
int	asocket_packets_got_size = 0;					/**< Total byte size of packets received */
int	asocket_packets_sent_size = 0;					/**< Total byte size of packets sent */

static int sLastPacketsGot = 0;
static int sLastPacketsSent = 0;
static int sLastPacketsGotSize = 0;
static int sLastPacketsSentSize = 0;
static SysTime sLastGotTime;
float	asocket_packets_got_size_per_second = 0.0f;
float	asocket_packets_sent_size_per_second = 0.0f;
float	asocket_packets_got_per_second = 0.0f;
float	asocket_packets_sent_per_second = 0.0f;

MutexClass g_xpsockets_lockclass;

static bool s_init_done = false;
static SysTime *theTimer = 0;
static SysTimeType lastSentTime = 0;

bool gXPSock_PacketLossEmulation = false;
float gXPSock_PacketLossEmulationPercent = 0.0f;

static unsigned int *s_sentHistogram = 0;
static int s_sentHistogramLen = 0;
static unsigned int *s_recvHistogram = 0;
static int s_recvHistogramLen = 0;

struct ImpairedPacket
{
	t_XPSocket *mSocket;
	char *mData;
	int mLen;
	t_XPAddress mAddr;
	SysTimeType mTime;
};
bool gXPSock_PacketLatencyEmulation = false;
float gXPSock_PacketLatencyEmulationBase = 0.0f;
float gXPSock_PacketLatencyEmulationJitter = 0.0f;

inline static bool KeepPacketYesOrNo(void)
{
	if (!gXPSock_PacketLossEmulation)
	{
		return true;
	}

	// Early less expensive tests
	if (gXPSock_PacketLossEmulationPercent <= 0.0f)
	{
		return true;
	}

	if (gXPSock_PacketLossEmulationPercent >= 100.0f)
	{
		return false;
	}

	// Slightly more expensive test
	float random = float(RNReplicaNet::Rand::FastWeak())/float(RAND_MAX);
	random *= 100.0f;

	if (gXPSock_PacketLossEmulationPercent <= random)
	{
		return true;
	}
	return false;
}

static std::list<ImpairedPacket> *sImpairedPackets = 0;

static int RealXPSock_UrgentSend(t_XPSocket *socket,const char *data,int len,const t_XPAddress *addr);

static void RetireImpairedPackets(void)
{
	if (!sImpairedPackets)
	{
		return;
	}

	if (sImpairedPackets->empty())	// Thread safe read only operation
	{
		return;
	}

	SysTimeType nowTime = theTimer->FloatTime();

	// Check for the call being used far too often. Say quicker than 5ms
	if ( (nowTime - lastSentTime) < 0.005f)
	{
		return;
	}


	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	lastSentTime = nowTime;

	std::list<ImpairedPacket>::iterator st,en,next;
	st = sImpairedPackets->begin();
	en = sImpairedPackets->end();
	
	while (st != en)
	{
		ImpairedPacket &packet = *st;

		next = st;
		next++;

		if (nowTime >= packet.mTime)
		{
			RealXPSock_UrgentSend(packet.mSocket,packet.mData,packet.mLen,&packet.mAddr);
			free(packet.mData);
			sImpairedPackets->erase(st);
		}
		
		st = next;
	}
}

void XPSock_Poll(void)
{
	if (!s_init_done)
	{
		return;
	}
	RetireImpairedPackets();
}

void XPSock_UpdatePerSecondMetrics(void)
{
	SysTimeType theTime = sLastGotTime.FloatTime();
	if (theTime >= 1.0f)
	{
		THREADSAFELOCKCLASS(g_xpsockets_lockclass);
		asocket_packets_got_per_second = (float) (SysTimeType(asocket_packets_got - sLastPacketsGot) / theTime);
		sLastPacketsGot = asocket_packets_got;
		asocket_packets_sent_per_second = (float) (SysTimeType(asocket_packets_sent - sLastPacketsSent) / theTime);
		sLastPacketsSent = asocket_packets_sent;

		asocket_packets_got_size_per_second = (float) (SysTimeType(asocket_packets_got_size - sLastPacketsGotSize) / theTime);
		sLastPacketsGotSize = asocket_packets_got_size;
		asocket_packets_sent_size_per_second = (float) (SysTimeType(asocket_packets_sent_size - sLastPacketsSentSize) / theTime);
		sLastPacketsSentSize = asocket_packets_sent_size;

		sLastGotTime.Reset();
	}
}

static void RetireClosedSocket(t_XPSocket *socket)
{
	if (!sImpairedPackets)
	{
		return;
	}

	if (sImpairedPackets->empty())	// Thread safe read only operation
	{
		return;
	}

	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	std::list<ImpairedPacket>::iterator st,en,next;
	st = sImpairedPackets->begin();
	en = sImpairedPackets->end();
	
	while (st != en)
	{
		ImpairedPacket &packet = *st;

		next = st;
		next++;

		if (packet.mSocket == socket)
		{
			RealXPSock_UrgentSend(packet.mSocket,packet.mData,packet.mLen,&packet.mAddr);
			free(packet.mData);
			sImpairedPackets->erase(st);
		}
		
		st = next;
	}
}

static void RetireAllPackets(void)
{
	if (!sImpairedPackets)
	{
		return;
	}

	if (sImpairedPackets->empty())	// Thread safe read only operation
	{
		return;
	}

	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	std::list<ImpairedPacket>::iterator st,en;
	st = sImpairedPackets->begin();
	en = sImpairedPackets->end();
	
	while (st != en)
	{
		ImpairedPacket &packet = *st;

		free(packet.mData);
		
		st++;
	}
	sImpairedPackets->clear();
}

#ifdef _PS2
//Include inline: #include "RNXPSockets/PS2LoadModules.h"
//Force skipped: RNXPSockets/PS2LoadModules.h
#endif

static bool hostaddr_got = false;
static XPAddress hostaddr;

/**
 * This inits the socket interface
 */
int XPSock_Init(void)
{
	if (s_init_done)
	{
		asocket_lasterror = XPSOCK_EOK;
		return XPSOCK_EOK;
	}

	// Do the lock here
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	wsockets_started = 0;

	// Force the host address to be recalculated every required init call
	hostaddr_got = false;

//	dprintf("Init network code\n");

#ifdef _PS2
	bool ret = PS2LoadModules();
	if (!ret)
	{
		asocket_lasterror = XPSOCK_ESTACKSTARTFAILURE;
		return XPSOCK_EERROR;
	}
#endif

#ifdef _XBOX
	XNetStartupParams xnsp;
	memset(&xnsp, 0, sizeof(xnsp));
	xnsp.cfgSizeOfStruct = sizeof(XNetStartupParams);
	xnsp.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;	// This flag is safely ignored by the release version of the secure library.
	INT err = XNetStartup(&xnsp);
#endif

	/* Start winsock stuff */
#ifdef _USING_W32_SOCKETS
	int ret = -1;
	ret = WSAStartup (MAKEWORD(2, 2), &winsockdata);

	if (!ret)
	{
//		dprintf("Winsock initialisation successfull.\n");
		wsockets_started = 1;
	}
	else
	{
//		dprintf("Winsock did not initialise.\n");
		wsockets_started = 0;
	}
	if (!wsockets_started)
	{
		asocket_lasterror = XPSOCK_ESTACKSTARTFAILURE;
		return XPSOCK_EERROR;
	}
#else
	wsockets_started = 1;
#endif

	{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);
	sImpairedPackets = new std::list<ImpairedPacket>;
	assert(sImpairedPackets);
	}

#if defined(_XBOX360)
	HRESULT hr = XOnlineStartup(); // Do XNET_STARTUP_BYPASS_SECURITY disable as per above for Debug.
	assert(SUCCEEDED(hr));
#elif defined(_XBOX)
	// Before we can enumerate user accounts on any attached Memory Units, we
	// must first allow them sufficient time to mount. 
	while(XGetDeviceEnumerationStatus() == XDEVICE_ENUMERATION_BUSY)	{}

	HRESULT hr = XOnlineStartup(NULL);	// Param just specifies heap size for Live tasks. Takes 8Kb by default.
										// Do XNET_STARTUP_BYPASS_SECURITY disable as per above for Debug.
	assert(SUCCEEDED(hr));
#endif

	theTimer = new SysTime;
	lastSentTime = theTimer->FloatTime();
	RetireAllPackets();

	// Register the heap block
	if (!sXPSocketsHeapBlockDone)
	{
		sXPSocketsHeapBlockDone = true;
		(new XPSocketsHeapBlock())->Register();
	}

	s_init_done = true;
	asocket_lasterror = XPSOCK_EOK;
	return XPSOCK_EOK;
}

/**
 * Quits all sockets and exits
 * Calling PlatformHeap::ForceFree() will call XPSock_Quit() if XPSock_Init() was previously called.
 */
int XPSock_Quit(void)
{
// Maintaining WSA, XNet and XOnline active all the time on the XBox.
// But other platforms open/closes it all down due to IOP memory issues.
// TODO: MPi: Make this a configurable option and expose the access function as XPSock_AllowQuit or similar.
#ifndef _XBOX
	if (!s_init_done)
	{
		asocket_lasterror = XPSOCK_EOK;
		return XPSOCK_EOK;
	}

	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	s_init_done = false;

	delete theTimer;
	theTimer = 0;
	RetireAllPackets();

	delete sImpairedPackets;
	sImpairedPackets = 0;

	wsockets_started = 0;

//#ifdef _XBOX
//	HRESULT hr = XOnlineCleanup();
//	assert(SUCCEEDED(hr));
//#endif

#ifdef _USING_W32_SOCKETS
	WSACleanup();
#endif

#ifdef _PS2
	bool ret = PS2UnLoadModules();
	assert(ret && "PS2UnLoadModules failed\n");
#endif

	hostaddr_got = false;

#endif // ifndef _XBOX

	asocket_lasterror = XPSOCK_EOK;
	return XPSOCK_EOK;
}


/**
 * Creates a socket
 * \return returns the socket pointer or XPSOCK_EERROR if an error occurred
 */
t_XPSocket *XPSock_Create(void)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	t_XPSocket *thissocket;
	int ret = 0;

	thissocket = (t_XPSocket *) calloc(1,sizeof(t_XPSocket));

	/* Allocate the socket */
	if (thissocket == NULL)
	{
		asocket_lasterror = XPSOCK_ENOMEMORY;
		return (t_XPSocket *) XPSOCK_EERROR;
	}

	thissocket->wins_socket = SOCKET_ERROR;
	thissocket->wins_socket6 = SOCKET_ERROR;

	if (wsockets_started)
	{
		int opt = 1;

		/* Open our socket! */
		thissocket->wins_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
//		thissocket->wins_socket6 = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);

		if (thissocket->wins_socket == SOCKET_ERROR)
		{
			free(thissocket);
			asocket_lasterror = XPSOCK_ENOMEMORY;
			return (t_XPSocket *) XPSOCK_EERROR;
		}

		/* Make socket non-blocking */
#ifndef _PS2
		if (ioctlsocket(thissocket->wins_socket,FIONBIO, (unsigned long *) &opt) == SOCKET_ERROR)
		{
//			dprintf("Couldn't make non-blocking socket. Network performance will suffer\n");
		}
#endif

#ifdef _PS2
		ret = setsockopt(thissocket->wins_socket, SOL_SOCKET, SO_NBIO, (const char *) &opt, 4);
#endif

#ifdef NO_NAGLE
		ret = setsockopt(thissocket->wins_socket, IPPROTO_TCP, TCP_NODELAY, (const char *) &opt, 4);
#endif

	}

	asocket_lasterror = XPSOCK_EOK;
	return thissocket;
}

/**
 * Sets the size of the send buffer for a socket
 * \param socket the socket pointer
 * \param size The size to set the send buffer to or -1 to only return the value
 * \return the new size of the send buffer
 */
int XPSock_SetSendBuffer(t_XPSocket *socket,int size)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	XPSOCK_PARANOID(socket);

	if (!wsockets_started)
	{
		return size;
	}

	int retval;

	if (size >= 0)
	{
#ifndef _PS2
		setsockopt(socket->wins_socket, SOL_SOCKET, SO_SNDBUF, (const char *) &size, sizeof(int));
#else
		setsockopt(socket->wins_socket, SOL_SOCKET, SO_SNDBUF, (const void *) &size, sizeof(int));
#endif
	}

#ifdef _USING_W32_SOCKETS
	int optlen = sizeof(int);
	getsockopt(socket->wins_socket, SOL_SOCKET, SO_SNDBUF, (char *) &retval, &optlen);
#else
	socklen_t optlen = sizeof(int);
	getsockopt(socket->wins_socket, SOL_SOCKET, SO_SNDBUF, (void *) &retval, &optlen);
#endif

	return retval;
}

/**
 * Sets the size of the recv buffer for a socket
 * \param socket the socket pointer
 * \param size The size to set the recv buffer to or -1 to only return the value
 * \return the new size of the recv buffer
 */
int XPSock_SetRecvBuffer(t_XPSocket *socket,int size)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	XPSOCK_PARANOID(socket);

	if (!wsockets_started)
	{
		return size;
	}

	int retval;

	if (size >= 0)
	{
#ifndef _PS2
		setsockopt(socket->wins_socket, SOL_SOCKET, SO_RCVBUF, (const char *) &size, sizeof(int));
#else
		setsockopt(socket->wins_socket, SOL_SOCKET, SO_RCVBUF, (const void *) &size, sizeof(int));
#endif
	}

#ifdef _USING_W32_SOCKETS
	int optlen = sizeof(int);
	getsockopt(socket->wins_socket, SOL_SOCKET, SO_RCVBUF, (char *) &retval, &optlen);
#else
	socklen_t optlen = sizeof(int);
	getsockopt(socket->wins_socket, SOL_SOCKET, SO_RCVBUF, (void *) &retval, &optlen);
#endif

	return retval;
}


/**
 * Connect to a machine address
 * \param socket the socket pointer
 * \param addr the address to connect to. If addr is NULL then a local connect is tried
 * \return returns an XPSOCK error code, XPSOCK_EOK is no error.
 */
int XPSock_Connect(t_XPSocket *socket,const t_XPAddress *addr)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	XPSOCK_PARANOID(socket);


	if (addr != NULL && wsockets_started)
	{
		char taddr[64];
#ifndef _PS2
		struct sockaddr_in serveraddr;
#else
/*
struct sceEENetSockaddrIn {
	u_int8_t  sin_len;
	u_int8_t  sin_family;
	u_int16_t sin_port;
	struct	  sceEENetInAddr sin_addr;
	int8_t	  sin_zero[8];
};
*/
		struct sceEENetSockaddrIn serveraddr;
#endif
		int ret;

		sprintf(taddr,"%d.%d.%d.%d",addr->addr[0],addr->addr[1],addr->addr[2],addr->addr[3]);

		/* Get the address of the server. */
		memset(&serveraddr,0,sizeof(serveraddr));
#ifdef _PS2
		serveraddr.sin_len = sizeof(serveraddr);
#endif
		serveraddr.sin_family = AF_INET;
		serveraddr.sin_addr.s_addr = inet_addr(taddr);
		serveraddr.sin_port = htons(addr->port);

		ret = connect(socket->wins_socket,(struct sockaddr *) &serveraddr,sizeof(serveraddr));

		if (ret == SOCKET_ERROR)
		{
			ret = WSAGetLastError();
		}

		socket->addr.port = addr->port;
		socket->addr.addr[0] = addr->addr[0];
		socket->addr.addr[1] = addr->addr[1];
		socket->addr.addr[2] = addr->addr[2];
		socket->addr.addr[3] = addr->addr[3];

		socket->type = XPSOCK_TINET;
		socket->state = XPSOCK_SCONNECT;
		asocket_lasterror = XPSOCK_EWOULDBLOCK;
		return XPSOCK_EOK;
	}

	if (loopback_socket_client != NULL)
	{
		asocket_lasterror = XPSOCK_ENOEXIST;
		return XPSOCK_EERROR;
	}

	if (loopback_socket_listen == NULL)
	{
		asocket_lasterror = XPSOCK_ENOEXIST;
		return XPSOCK_EERROR;
	}

	/* Set the type */
	socket->type = XPSOCK_TLOCALHOST;

	/* Set the state */
	socket->state = XPSOCK_SCONNECT;

	/* Allocate the local buffer */
	if ( (socket->loopback_recvbuffer = (char *) calloc(1,XPSOCK_LOOPBACKBUFFER)) == NULL)
	{
		XPSock_Close(socket);
		asocket_lasterror = XPSOCK_ENOMEMORY;
		return XPSOCK_EERROR;
	}
	((int *) socket->loopback_recvbuffer)[0] = -1;

	loopback_socket_client = socket;

	asocket_lasterror = XPSOCK_EOK;
	return XPSOCK_EOK;
}

/**
 * Tries to send data via the socket
 * \param socket the socket pointer
 * \param data a char pointer to the data buffer
 * \param len the length of the data to send
 * \return returns The number of bytes sent or an SOCKET_ERROR error code, XPSOCK_EOK is no error.
 */
int XPSock_Send(t_XPSocket *socket,const char *data,const int len)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	t_XPSocket *destsocket = NULL;

	XPSOCK_PARANOID(socket);

	if (socket->type == XPSOCK_TINET)
	{
		// First select the socket to see if there is anything in the exception list for it
		struct timeval timeout;
		timeout.tv_sec = 0;
		timeout.tv_usec = 0;
		fd_set desc;
		FD_ZERO(&desc);
		FD_SET(socket->wins_socket , &desc);
		int interestingSocks = select(FD_SETSIZE,0,0,&desc,&timeout);
		if (interestingSocks == 1)
		{
			// There was an exception on our socket so we report a failure to connect
			asocket_lasterror = XPSOCK_ECLOSED;
			return XPSOCK_EERROR;
		}

		int ret,ret2;

		if ((ret2 = send(socket->wins_socket,data,len,0)) == SOCKET_ERROR)
		{
			ret = WSAGetLastError();
			if (ret == WSAENOTCONN)
			{
				asocket_lasterror = XPSOCK_ECONNINPROGRESS;
				return XPSOCK_EOK;
			}

			if (ret == WSAEWOULDBLOCK)
			{
				asocket_lasterror = XPSOCK_EWOULDBLOCK;
				return XPSOCK_EOK;
			}

			asocket_lasterror = XPSOCK_ECLOSED;
			return XPSOCK_EERROR;
		}

		asocket_packets_sent++;
		asocket_packets_sent_size += ret2;

		if (ret2 < len)
		{
			asocket_lasterror = XPSOCK_EWOULDBLOCK;
			return ret2;
		}

		asocket_lasterror = XPSOCK_EOK;
		return ret2;
	}

	asocket_packets_sent++;
	asocket_packets_sent_size += len;

	if (socket->state == XPSOCK_SNULL)
	{
		asocket_lasterror = XPSOCK_ENOTCONNECTED;
		return XPSOCK_EERROR;
	}

	/* See where the data should be sent to depending on what socket this is locally */
	if (socket == loopback_socket_client)
	{
		destsocket = loopback_socket_server;
	}

	if (socket == loopback_socket_server)
	{
		destsocket = loopback_socket_client;
	}

	if (destsocket == NULL)
	{
		asocket_lasterror = XPSOCK_ENOTCONNECTED;
		return XPSOCK_EERROR;
	}

	if ((destsocket->loopback_recvpos + len + 8) >= XPSOCK_LOOPBACKBUFFER)
	{
		((int *)(destsocket->loopback_recvbuffer+destsocket->loopback_recvpos))[0] = -2;
		destsocket->loopback_recvpos = 0;
	}

	memcpy(destsocket->loopback_recvbuffer+destsocket->loopback_recvpos+4,data,len);
	((int *)(destsocket->loopback_recvbuffer+destsocket->loopback_recvpos))[0] = len;
	destsocket->loopback_recvpos += len+4;
	destsocket->loopback_recvpos = (destsocket->loopback_recvpos+3) & (~3);
	((int *)(destsocket->loopback_recvbuffer+destsocket->loopback_recvpos))[0] = -1;
	destsocket->loopback_pending += len;

	if (destsocket->loopback_pending >= XPSOCK_LOOPBACKBUFFER)
	{
		asocket_lasterror = XPSOCK_EBUFFEROVERFLOW;
		return XPSOCK_EERROR;
	}

	asocket_lasterror = XPSOCK_EOK;
	return XPSOCK_EOK;
}

/**
 * Tries to receive data from a socket
 * \param socket the socket pointer
 * \param data a char pointer to the data buffer
 * \param maxlen the maximum length of the data buffer to receive to
 * \param flag the flag to use for this operation. Removes the read message from the queue unless XPSOCKF_PEEK is used
 * \return returns the number of bytes read or 0 if no data is pending or an XPSOCK_EERROR error code.
 */
int XPSock_Recv(t_XPSocket *socket,char *data,int maxlen,int flag)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	int len;

	XPSOCK_PARANOID(socket);

	if (socket->type == XPSOCK_TINET)
	{
		// First select the socket to see if there is anything in the exception list for it
		struct timeval timeout;
		timeout.tv_sec = 0;
		timeout.tv_usec = 0;
		fd_set desc;
		FD_ZERO(&desc);
		FD_SET(socket->wins_socket , &desc);
		int interestingSocks = select(FD_SETSIZE,0,0,&desc,&timeout);
		if (interestingSocks == 1)
		{
			// There was an exception on our socket so we report a failure to connect
			asocket_lasterror = XPSOCK_ECLOSED;
			return XPSOCK_EERROR;
		}

		int ret;

		ret = recv(socket->wins_socket,data,maxlen,0);

		/* Assume a would block situation because a return of zero indicates an error for recv() */
		if (ret < 0)
		{
			int ret2 = WSAGetLastError();
			if (ret2 == WSAENOTCONN)
			{
				asocket_lasterror = XPSOCK_ECONNINPROGRESS;
				return XPSOCK_EOK;
			}
			if (ret2 == WSAEWOULDBLOCK)
			{
				asocket_lasterror = XPSOCK_EWOULDBLOCK;
				return XPSOCK_EOK;
			}

			asocket_lasterror = XPSOCK_ECLOSED;
			return XPSOCK_EERROR;
		}

		if (ret == 0)
		{
			asocket_lasterror = XPSOCK_ECLOSED;
			return XPSOCK_EERROR;
		}

		if (ret > 0)
		{
			asocket_packets_got++;
			asocket_packets_got_size += ret;
		}

		return ret;
	}

	if (socket->state == XPSOCK_SNULL)
	{
		asocket_lasterror = XPSOCK_ENOTCONNECTED;
		return XPSOCK_EERROR;
	}

	len = ((int *)(socket->loopback_recvbuffer+socket->loopback_readpos))[0];
	if (len == -1)
	{
		asocket_lasterror = XPSOCK_EWOULDBLOCK;
		return XPSOCK_EOK;
	}

	if (len == -2)
	{
		socket->loopback_readpos = 0;
		len = ((int *)(socket->loopback_recvbuffer+socket->loopback_readpos))[0];
		if (len == -1)
		{
			asocket_lasterror = XPSOCK_EWOULDBLOCK;
			return XPSOCK_EOK;
		}
	}

	if (len > 0)
	{
		memcpy(data,socket->loopback_recvbuffer + socket->loopback_readpos + 4,len);
		asocket_packets_got++;
		asocket_packets_got_size += len;
	}

	if (flag != XPSOCK_FPEEK)
	{
		socket->loopback_pending -= len;
		socket->loopback_readpos += len+4;
		socket->loopback_readpos = (socket->loopback_readpos+3) & (~3);
	}

	asocket_lasterror = XPSOCK_EOK;
	return len;
}

/**
 * Closes a socket
 * \param socket the socket pointer
 * \return returns an XPSOCK error code, XPSOCK_EOK is no error.
 */
int XPSock_Close(t_XPSocket *socket)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	XPSOCK_PARANOID(socket);

	RetireClosedSocket(socket);

	if (wsockets_started && socket->wins_socket != SOCKET_ERROR)
	{
		/* Close our socket! */
		closesocket(socket->wins_socket);
	}
	if (wsockets_started && socket->wins_socket6 != SOCKET_ERROR)
	{
		/* Close our socket! */
		closesocket(socket->wins_socket6);
	}


	if (socket->state == XPSOCK_SLISTEN || socket == loopback_socket_listen)
	{
		/* Set the loopback socket pointer */
		loopback_socket_listen = NULL;
	}

	if (socket->type == XPSOCK_SCONNECT || socket == loopback_socket_client)
	{
		/* Set the loopback socket pointer */
		loopback_socket_client = NULL;
	}

	if (socket == loopback_socket_server)
	{
		loopback_socket_server = NULL;
	}

	if (socket == loopback_usocket_server)
	{
		loopback_usocket_server = NULL;
	}

	if (socket->loopback_recvbuffer != NULL)
	{
		free(socket->loopback_recvbuffer);
	}


	if (socket == loopback_usocket_listen)
	{
		loopback_usocket_listen = NULL;
	}

	if (socket == loopback_usocket_client)
	{
		loopback_usocket_client = NULL;
	}

	free(socket);
	asocket_lasterror = XPSOCK_EOK;
	return XPSOCK_EOK;
}

/**
 * Sets a socket to be a listen socket for a certain port number.
 * This should only really be used for a server not the client as it is better network programming practice.
 * \param socket the socket pointer
 * \param port the port number to listen from
 * \return returns an XPSOCK error code, XPSOCK_EOK is no error.
 */
int XPSock_Listen(t_XPSocket *socket,int port)
{
	XPAddress addr;
	addr.MakeAny(port);

	return XPSock_Listen(socket,&addr);
}

/**
 * Sets a socket to be a listen socket that is bound to the address supplied.
 * This should only really be used for a server not the client as it is better network programming practice.
 * \param socket the socket pointer
 * \param addr the address to use.
 * \return returns an XPSOCK error code, XPSOCK_EOK is no error.
 */
int XPSock_Listen(t_XPSocket *socket,const RNReplicaNet::t_XPAddress *addr)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	XPSOCK_PARANOID(socket);

	/* Set the type */
	socket->type = XPSOCK_TLOCALHOST;

	/* Setup the port number for our socket structure */
	socket->port = addr->port;

	if (wsockets_started && socket->wins_socket != SOCKET_ERROR && addr->port != XPSOCK_PORT_LOCAL)
	{
		struct sockaddr_in sa;
		int ret;

		memset(&sa,0,sizeof(struct sockaddr_in));
#ifdef _PS2
		sa.sin_len = sizeof(sa);
#endif
		sa.sin_family = AF_INET;

#ifdef _USING_W32_SOCKETS
		sa.sin_addr.S_un.S_un_b.s_b1 = addr->addr[0];
		sa.sin_addr.S_un.S_un_b.s_b2 = addr->addr[1];
		sa.sin_addr.S_un.S_un_b.s_b3 = addr->addr[2];
		sa.sin_addr.S_un.S_un_b.s_b4 = addr->addr[3];
#else
		((unsigned char *)&sa.sin_addr.s_addr)[0] = addr->addr[0];
		((unsigned char *)&sa.sin_addr.s_addr)[1] = addr->addr[1];
		((unsigned char *)&sa.sin_addr.s_addr)[2] = addr->addr[2];
		((unsigned char *)&sa.sin_addr.s_addr)[3] = addr->addr[3];
#endif
		sa.sin_port = htons(addr->port);

		if (bind(socket->wins_socket,(struct sockaddr *)&sa, sizeof(sa)) == SOCKET_ERROR)
		{
			ret = WSAGetLastError();
			asocket_lasterror = XPSOCK_ECANTLISTEN;
			return XPSOCK_EERROR;
		}

		if (listen(socket->wins_socket,SOMAXCONN) == SOCKET_ERROR)
		{
			ret = WSAGetLastError();
			if (ret != WSAEWOULDBLOCK)
			{
				asocket_lasterror = XPSOCK_ECANTLISTEN;
				return XPSOCK_EERROR;
			}
		}

		if (addr->port == 0)
		{
			struct sockaddr name;
#ifdef _USING_W32_SOCKETS
			int namelen;
#else
			socklen_t namelen;
#endif
			namelen = sizeof(sockaddr_in);
			if (getsockname (socket->wins_socket,&name,&namelen)  == SOCKET_ERROR)
			{
//				dprintf("Couldn't get UDP socket port\n");
				asocket_lasterror = XPSOCK_ECANTBIND;
				return XPSOCK_EERROR;
			}

			socket->port = ntohs( ((sockaddr_in *)(&name))->sin_port);
		} 

	}

	/* Set the state */
	socket->state = XPSOCK_SLISTEN;

	/* Set the loopback listen socket pointer */
	loopback_socket_listen = socket;

	asocket_lasterror = XPSOCK_EOK;
	return XPSOCK_EOK;
}

/**
 * Tries to accept any incoming connections and creates a connected socket if successful.
 * \param socket the socket pointer
 * \return returns the new socket connection that got accepted or an XPSOCK error code or null for no socket
 */
t_XPSocket *XPSock_Accept(t_XPSocket *socket)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	t_XPSocket *newsocket;

	XPSOCK_S_PARANOID(socket);

	if (wsockets_started && socket->wins_socket != SOCKET_ERROR)
	{
#ifdef _WIN64
		unsigned __int64 ret;
#else
		int ret;
#endif
		struct sockaddr_in info;
		int addrin;
		int k,opt = 1;

		k = sizeof(info);
#ifdef _USING_W32_SOCKETS
		ret = accept(socket->wins_socket, (struct sockaddr *)&info, &k);
#else
		ret = accept(socket->wins_socket, (struct sockaddr *)&info, (socklen_t *) &k);
#endif


		if (ret != SOCKET_ERROR)
		{
			newsocket = XPSock_Create();
			closesocket(newsocket->wins_socket);
			newsocket->type = XPSOCK_TINET;
			newsocket->state = XPSOCK_SCONNECT;
			newsocket->wins_socket = ret;

#ifndef _PS2
			if (ioctlsocket(newsocket->wins_socket,FIONBIO, (unsigned long *) &opt) == SOCKET_ERROR)
			{
//				dprintf("Couldn't make socket non blocking from listen\n");
			}
#endif

			int iret = 0;
#ifdef _PS2
			iret = setsockopt(newsocket->wins_socket, SOL_SOCKET, SO_NBIO, (const char *) &opt, 4);
#endif

#ifdef NO_NAGLE
			iret = setsockopt(newsocket->wins_socket, IPPROTO_TCP, TCP_NODELAY, (const char *) &opt, 4);
#endif

			addrin=ntohl(info.sin_addr.s_addr);
	
//			dprintf("Socket accept probe from %d.%d.%d.%d:%d\n",(addrin >> 24)&0xff, (addrin >> 16)&0xff, (addrin >> 8)&0xff,addrin&0xff,ntohs(info.sin_port));

			newsocket->addr.port = ntohs(info.sin_port);
			newsocket->addr.addr[0] = addrin & 0xff;
			newsocket->addr.addr[1] = (addrin>>8) & 0xff;
			newsocket->addr.addr[2] = (addrin>>16) & 0xff;
			newsocket->addr.addr[3] = (addrin>>24) & 0xff;

			socket->total_accepts++;
			asocket_lasterror = XPSOCK_EOK;
			return newsocket;
		}
	}


	if (socket->state != XPSOCK_SLISTEN)
	{
		asocket_lasterror = XPSOCK_ENOTALISTEN;
		return (t_XPSocket *) XPSOCK_EERROR;
	}

	/* No local client connect just return */
	if (loopback_socket_client == NULL)
	{
		asocket_lasterror = XPSOCK_EWOULDBLOCK;
		return 0;
	}

	/* Local loopback only has one connection allowed return a would block error */
	if (loopback_socket_server != NULL)
	{
		asocket_lasterror = XPSOCK_EWOULDBLOCK;
		return 0;
	}

	newsocket = XPSock_Create();
	if ( newsocket == NULL)
	{
		asocket_lasterror = XPSOCK_ENOMEMORY;
		return (t_XPSocket *) XPSOCK_EERROR;
	}

	/* Allocate the local buffer */
	if ( (newsocket->loopback_recvbuffer = (char *) calloc(1,XPSOCK_LOOPBACKBUFFER)) == NULL)
	{
		XPSock_Close(newsocket);
		asocket_lasterror = XPSOCK_ENOMEMORY;
		return (t_XPSocket *) XPSOCK_EERROR;
	}
	((int *) newsocket->loopback_recvbuffer)[0] = -1;

	/* Set the type */
	newsocket->type = XPSOCK_TLOCALHOST;

	/* Set the state */
	newsocket->state = XPSOCK_SCONNECT;

	/* Set the loopback pointer for the server */
	loopback_socket_server = newsocket;

	/* Update the stats on the listening socket */
	socket->total_accepts++;

	asocket_lasterror = XPSOCK_EOK;
	return newsocket;
}


/**
 * Fills in the internet address and port of a socket to the address structure.
 * \param socket the socket pointer
 * \param addr the address structure to fill in
 * \return returns XPSOCK_EOK or an XPSOCK error code.
 */
int XPSock_GetAddress(t_XPSocket *socket,t_XPAddress *addr)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	if (socket == NULL)
	{
		asocket_lasterror = XPSOCK_ENOTASOCKET;
		return XPSOCK_EERROR;
	}

	/* Clear the address field */
	memset(addr,0,sizeof(t_XPAddress));

	if (wsockets_started)
	{
		if (socket->mCachedAddressGot)
		{
			*addr = socket->mCachedAddress;
			asocket_lasterror = XPSOCK_EOK;
			return XPSOCK_EOK;
		}


		if (socket->wins_socket != SOCKET_ERROR)
		{
			struct sockaddr_in name;
#ifdef _USING_W32_SOCKETS
			int namelen;
#else
			socklen_t namelen;
#endif
			namelen = sizeof(name);
			if (getsockname (socket->wins_socket,(sockaddr*)&name,&namelen)  == SOCKET_ERROR)
			{
				asocket_lasterror = XPSOCK_ECANTBIND;
				return XPSOCK_EERROR;
			}

#ifdef _USING_W32_SOCKETS
			addr->addr[0] = name.sin_addr.S_un.S_un_b.s_b1;
			addr->addr[1] = name.sin_addr.S_un.S_un_b.s_b2;
			addr->addr[2] = name.sin_addr.S_un.S_un_b.s_b3;
			addr->addr[3] = name.sin_addr.S_un.S_un_b.s_b4;
#else
			addr->addr[0] = ((unsigned char *)&name.sin_addr.s_addr)[0];
			addr->addr[1] = ((unsigned char *)&name.sin_addr.s_addr)[1];
			addr->addr[2] = ((unsigned char *)&name.sin_addr.s_addr)[2];
			addr->addr[3] = ((unsigned char *)&name.sin_addr.s_addr)[3];
#endif

			addr->port = ntohs( name.sin_port);

			/* Check for a listen socket type address */
			if (addr->addr[0] == 0 && addr->addr[1] == 0 && addr->addr[2] == 0 && addr->addr[3] == 0)
			{
				XPAddress addr2;
				XPSock_GetHostAddress(&addr2);
				addr->addr[0] = addr2.addr[0];
				addr->addr[1] = addr2.addr[1];
				addr->addr[2] = addr2.addr[2];
				addr->addr[3] = addr2.addr[3];
			}

			addr->mIPv4 = true;
			socket->mCachedAddressGot = true;
			socket->mCachedAddress = *addr;
		}


		if (socket->wins_socket6 != SOCKET_ERROR)
		{
			struct sockaddr_in6 name;
#ifdef _USING_W32_SOCKETS
			int namelen;
#else
			socklen_t namelen;
#endif
			namelen = sizeof(name);
			if (getsockname (socket->wins_socket6,(sockaddr*)&name,&namelen)  == SOCKET_ERROR)
			{
				asocket_lasterror = XPSOCK_ECANTBIND;
				return XPSOCK_EERROR;
			}

			int i;
			for (i=0;i<16;i++)
			{
				addr->addr6[i] = name.sin6_addr.s6_addr[i];
			}

			addr->port6 = ntohs( name.sin6_port);

			/* Check for a listen socket type address */
			if (addr->addr6[0] == 0 && addr->addr6[1] == 0 && addr->addr6[2] == 0 && addr->addr6[3] == 0 &&
				addr->addr6[4] == 0 && addr->addr6[5] == 0 && addr->addr6[6] == 0 && addr->addr6[7] == 0 &&
				addr->addr6[8] == 0 && addr->addr6[9] == 0 && addr->addr6[10] == 0 && addr->addr6[11] == 0 &&
				addr->addr6[12] == 0 && addr->addr6[13] == 0 && addr->addr6[14] == 0 && addr->addr6[15] == 0)
			{
				XPAddress addr2;
				XPSock_GetHostAddress(&addr2);
				for (i=0;i<16;i++)
				{
					addr->addr6[i] = addr2.addr6[i];
				}
			}

			addr->mIPv6 = true;
			socket->mCachedAddressGot = true;
			socket->mCachedAddress = *addr;
		}
	}

	asocket_lasterror = XPSOCK_EOK;
	return XPSOCK_EOK;
}

/**
 * Fills in the internet address of the peer of a socket to the address structure.
 * \param socket the socket pointer
 * \param addr the address structure to fill in
 * \return returns XPSOCK_EOK or an XPSOCK error code.
 */
int XPSock_GetPeerAddress(t_XPSocket *socket,t_XPAddress *addr)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

//	int ret = 0;

	if (socket == NULL)
	{
		asocket_lasterror = XPSOCK_ENOTASOCKET;
		return XPSOCK_EERROR;
	}

	/* Clear the address field */
	memset(addr,0,sizeof(t_XPAddress));

	if (wsockets_started)
	{
//		int opt = 1;
		struct sockaddr name;
#ifdef _USING_W32_SOCKETS
		int namelen;
#else
		socklen_t namelen;
#endif
		namelen = sizeof(name);
		if (getpeername (socket->wins_socket,&name,&namelen)  == SOCKET_ERROR)
		{
//			dprintf("Couldn't get UDP socket port\n");
			asocket_lasterror = XPSOCK_ECANTBIND;
			return XPSOCK_EERROR;
		}

#ifdef _USING_W32_SOCKETS
		addr->addr[0] = ((sockaddr_in *)(&name))->sin_addr.S_un.S_un_b.s_b1;
		addr->addr[1] = ((sockaddr_in *)(&name))->sin_addr.S_un.S_un_b.s_b2;
		addr->addr[2] = ((sockaddr_in *)(&name))->sin_addr.S_un.S_un_b.s_b3;
		addr->addr[3] = ((sockaddr_in *)(&name))->sin_addr.S_un.S_un_b.s_b4;
#else
		addr->addr[0] = ((unsigned char *)&((sockaddr_in *)(&name))->sin_addr.s_addr)[0];
		addr->addr[1] = ((unsigned char *)&((sockaddr_in *)(&name))->sin_addr.s_addr)[1];
		addr->addr[2] = ((unsigned char *)&((sockaddr_in *)(&name))->sin_addr.s_addr)[2];
		addr->addr[3] = ((unsigned char *)&((sockaddr_in *)(&name))->sin_addr.s_addr)[3];
#endif

		addr->port = ntohs( ((sockaddr_in *)(&name))->sin_port);

		addr->mIPv4 = true;
	}

	asocket_lasterror = XPSOCK_EOK;
	return XPSOCK_EOK;
}

int gXPSock_UDPProtoParameter = IPPROTO_UDP;

/**
 * Creates an urgent socket
 * Returns XPSOCK_EERROR if an error occurred
 * If port is zero (0) then the network layer will pick a port number to be bound to
 * Using a value of zero for the port when operating a client is advised since the any chosen port might already be in use
 * \param port the port number to use
 * \return returns a pointer to new socket or an XPSOCK error code.
 */
t_XPSocket *XPSock_UrgentCreate(int port)
{
	XPAddress addr;
	addr.MakeAny(port);

	return XPSock_UrgentCreate(&addr);
}

/**
 * Creates an urgent socket that is bound to the address supplied.
 * Returns XPSOCK_EERROR if an error occurred
 * If port is zero (0) then the network layer will pick a port number to be bound to
 * Using a value of zero for the port when operating a client is advised since the any chosen port might already be in use
 * \param addr the address to use.
 * \return returns a pointer to new socket or an XPSOCK error code.
 */
t_XPSocket *XPSock_UrgentCreate(const RNReplicaNet::t_XPAddress *addr)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);
	assert(addr && "XPSock_UrgentCreate needs a t_XPAddress");

	t_XPSocket *thissocket;
	struct sockaddr_in clientaddr;
	struct sockaddr_in6 clientaddr6;
	int ret = 0;

	thissocket = (t_XPSocket *) calloc(1,sizeof(t_XPSocket));

	/* Allocate the socket */
	if (thissocket == NULL)
	{
		asocket_lasterror = XPSOCK_ENOMEMORY;
		return (t_XPSocket *) XPSOCK_EERROR;
	}

	thissocket->wins_socket = SOCKET_ERROR;
	thissocket->wins_socket6 = SOCKET_ERROR;

	thissocket->port = addr->port;
	thissocket->port6 = addr->port6;
	thissocket->mCachedAddressGot = false;
	if (wsockets_started && addr->port != XPSOCK_PORT_LOCAL)
	{
		int opt = 1;

		/* Open our socket! */
		if (addr->mIPv4)
		{
			thissocket->wins_socket = socket(AF_INET, SOCK_DGRAM, gXPSock_UDPProtoParameter);
		}
		if (addr->mIPv6)
		{
			thissocket->wins_socket6 = socket(AF_INET6, SOCK_DGRAM, gXPSock_UDPProtoParameter);
		}


		if ((thissocket->wins_socket == SOCKET_ERROR) && (thissocket->wins_socket6 == SOCKET_ERROR))
		{
			free(thissocket);
			asocket_lasterror = XPSOCK_ENOMEMORY;
			return (t_XPSocket *) XPSOCK_EERROR;
		}

		/* Make socket non-blocking */
#ifndef _PS2
		if (thissocket->wins_socket != SOCKET_ERROR)
		{
			if (ioctlsocket(thissocket->wins_socket,FIONBIO, (unsigned long *) &opt) == SOCKET_ERROR)
			{
//				dprintf("Couldn't make UDP non-blocking socket. Network performance will suffer\n");
			}
		}
		if (thissocket->wins_socket6 != SOCKET_ERROR)
		{
			if (ioctlsocket(thissocket->wins_socket6,FIONBIO, (unsigned long *) &opt) == SOCKET_ERROR)
			{
//				dprintf("Couldn't make UDP non-blocking socket. Network performance will suffer\n");
			}
		}
#endif

#ifdef _PS2
		if (thissocket->wins_socket != SOCKET_ERROR)
		{
			ret = setsockopt(thissocket->wins_socket, SOL_SOCKET, SO_NBIO, (const char *) &opt, 4);
		}
		if (thissocket->wins_socket6 != SOCKET_ERROR)
		{
			ret = setsockopt(thissocket->wins_socket6, SOL_SOCKET, SO_NBIO, (const char *) &opt, 4);
		}
#endif

		if (thissocket->wins_socket != SOCKET_ERROR)
		{
			/* Bind socket for replies */
			memset(&clientaddr,0,sizeof(clientaddr));
#ifdef _PS2
			clientaddr.sin_len = sizeof(clientaddr);
#endif
			clientaddr.sin_family = AF_INET;

#ifdef _USING_W32_SOCKETS
			clientaddr.sin_addr.S_un.S_un_b.s_b1 = addr->addr[0];
			clientaddr.sin_addr.S_un.S_un_b.s_b2 = addr->addr[1];
			clientaddr.sin_addr.S_un.S_un_b.s_b3 = addr->addr[2];
			clientaddr.sin_addr.S_un.S_un_b.s_b4 = addr->addr[3];
#else
			((unsigned char *)&clientaddr.sin_addr.s_addr)[0] = addr->addr[0];
			((unsigned char *)&clientaddr.sin_addr.s_addr)[1] = addr->addr[1];
			((unsigned char *)&clientaddr.sin_addr.s_addr)[2] = addr->addr[2];
			((unsigned char *)&clientaddr.sin_addr.s_addr)[3] = addr->addr[3];
#endif
			clientaddr.sin_port = htons(addr->port);

			if (bind(thissocket->wins_socket,(struct sockaddr *) &clientaddr,sizeof(clientaddr)) == SOCKET_ERROR)
			{
//				dprintf("Couldn't bind UDP socket\n");
				asocket_lasterror = XPSOCK_ECANTBIND;
				free(thissocket);
				return (t_XPSocket *) XPSOCK_EERROR;
			}

			if (addr->port == 0)
			{
				struct sockaddr_in name;
#ifdef _USING_W32_SOCKETS
				int namelen;
#else
				socklen_t namelen;
#endif
				namelen = sizeof(name);
				if (getsockname (thissocket->wins_socket,(sockaddr*)&name,&namelen)  == SOCKET_ERROR)
				{
//					dprintf("Couldn't get UDP socket port\n");
					asocket_lasterror = XPSOCK_ECANTBIND;
					free(thissocket);
					return (t_XPSocket *) XPSOCK_EERROR;
				}

				thissocket->port = ntohs(name.sin_port);
			} 
		}


		if (thissocket->wins_socket6 != SOCKET_ERROR)
		{
			/* Bind socket for replies */
			memset(&clientaddr6,0,sizeof(clientaddr6));
#ifdef _PS2
			clientaddr6.sin6_len = sizeof(clientaddr6);
#endif
			clientaddr6.sin6_family = AF_INET6;

			int i;
			for (i=0;i<16;i++)
			{
				clientaddr6.sin6_addr.s6_addr[i] = addr->addr6[i];
			}

			clientaddr6.sin6_port = htons(addr->port);

			if (bind(thissocket->wins_socket6,(struct sockaddr *) &clientaddr6,sizeof(clientaddr6)) == SOCKET_ERROR)
			{
				//				dprintf("Couldn't bind UDP socket\n");
				asocket_lasterror = XPSOCK_ECANTBIND;
				free(thissocket);
				return (t_XPSocket *) XPSOCK_EERROR;
			}

			if (addr->port6 == 0)
			{
				struct sockaddr_in6 name;
#ifdef _USING_W32_SOCKETS
				int namelen;
#else
				socklen_t namelen;
#endif
				namelen = sizeof(name);
				if (getsockname (thissocket->wins_socket6,(sockaddr*)&name,&namelen)  == SOCKET_ERROR)
				{
					//					dprintf("Couldn't get UDP socket port\n");
					asocket_lasterror = XPSOCK_ECANTBIND;
					free(thissocket);
					return (t_XPSocket *) XPSOCK_EERROR;
				}

				thissocket->port6 = ntohs(name.sin6_port);
			} 
		}

	}

	asocket_lasterror = XPSOCK_EOK;
	return thissocket;
}

/**
 * Makes an urgent socket broadcast capable
 * \param socket the socket pointer
 * \return returns an XPSOCK error code.
 */
int XPSock_UrgentMakeBroadcast(t_XPSocket *socket)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	if (wsockets_started)
	{
		int opt;
		int ret;

		XPSOCK_PARANOID(socket);

		opt = 1;
		if (socket->wins_socket != SOCKET_ERROR)
		{
			ret = setsockopt(socket->wins_socket, SOL_SOCKET, SO_BROADCAST, (const char *) &opt, 4);
		}
		if (socket->wins_socket6 != SOCKET_ERROR)
		{
			ret = setsockopt(socket->wins_socket6, SOL_SOCKET, SO_BROADCAST, (const char *) &opt, 4);
		}
	}

	asocket_lasterror = XPSOCK_EOK;
	return XPSOCK_EOK;
}

// This static function is the real send function that always sends the packet, no matter what.
// The XPSock_UrgentSend function is just a wrapper that handles the packet loss and latency emulation code.
static int RealXPSock_UrgentSend(t_XPSocket *socket,const char *data,int len,const t_XPAddress *addr)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	struct sockaddr_in serveraddr;
	struct sockaddr_in6 serveraddr6;
	int ret = 0;
	int ret6 = 0;
	int retLe = 0;
	int ret6Le = 0;

	XPSOCK_PARANOID(socket);

	if ((socket->wins_socket != SOCKET_ERROR) && addr->mIPv4)
	{
		/* MP FIXME Cache this in the structure */
		memset(&serveraddr,0,sizeof(serveraddr));
#ifdef _PS2
		serveraddr.sin_len = sizeof(serveraddr);
#endif
		serveraddr.sin_family = AF_INET;
#ifdef _USING_W32_SOCKETS
		serveraddr.sin_addr.S_un.S_un_b.s_b1 = addr->addr[0];
		serveraddr.sin_addr.S_un.S_un_b.s_b2 = addr->addr[1];
		serveraddr.sin_addr.S_un.S_un_b.s_b3 = addr->addr[2];
		serveraddr.sin_addr.S_un.S_un_b.s_b4 = addr->addr[3];
#else
		((unsigned char *)&serveraddr.sin_addr.s_addr)[0] = addr->addr[0];
		((unsigned char *)&serveraddr.sin_addr.s_addr)[1] = addr->addr[1];
		((unsigned char *)&serveraddr.sin_addr.s_addr)[2] = addr->addr[2];
		((unsigned char *)&serveraddr.sin_addr.s_addr)[3] = addr->addr[3];
#endif

		serveraddr.sin_port = htons(addr->port);
	}

	if ((socket->wins_socket6 != SOCKET_ERROR) && addr->mIPv6)
	{
		memset(&serveraddr6,0,sizeof(serveraddr6));
#ifdef _PS2
		serveraddr6.sin6_len = sizeof(serveraddr6);
#endif
		serveraddr6.sin6_family = AF_INET6;

		int i;
		for (i=0;i<16;i++)
		{
			serveraddr6.sin6_addr.s6_addr[i] = addr->addr6[i];
		}

		serveraddr6.sin6_port = htons(addr->port6);
	}

	// Update the histogram
	if (s_sentHistogramLen > 0 && s_sentHistogram)
	{
		s_sentHistogram[RNmax(RNmin(s_sentHistogramLen-1,len),0)]++;
	}

	// Send to both addresses if they are listed and the sockets are allocated
	if ((socket->wins_socket != SOCKET_ERROR) && addr->mIPv4)
	{
		ret = sendto(socket->wins_socket,data,len,0,(struct sockaddr *) &serveraddr,sizeof(serveraddr));
		if (ret == SOCKET_ERROR)
		{
			retLe = WSAGetLastError();
		}
	}

	if ((socket->wins_socket6 != SOCKET_ERROR) && addr->mIPv6)
	{
		ret6 = sendto(socket->wins_socket6,data,len,0,(struct sockaddr *) &serveraddr6,sizeof(serveraddr6));
		if (ret6 == SOCKET_ERROR)
		{
			ret6Le = WSAGetLastError();
		}
	}

	if (ret == SOCKET_ERROR)
	{
		ret = retLe;
		if (ret == WSAEWOULDBLOCK)
		{
			asocket_lasterror = XPSOCK_EWOULDBLOCK;
			return XPSOCK_EOK;
		}
		else
		{
			asocket_lasterror = XPSOCK_ECLOSED;
			return XPSOCK_EERROR;
		}
	}

	if (ret6 == SOCKET_ERROR)
	{
		ret6 = ret6Le;
		if (ret6 == WSAEWOULDBLOCK)
		{
			asocket_lasterror = XPSOCK_EWOULDBLOCK;
			return XPSOCK_EOK;
		}
		else
		{
			asocket_lasterror = XPSOCK_ECLOSED;
			return XPSOCK_EERROR;
		}
	}

	asocket_lasterror = XPSOCK_EOK;
	return XPSOCK_EOK;
}

/**
 * Send an urgent packet from the socket to the specified address.
 * This will return XPSOCK_EUDPSENDFAILED if this method doesn't exist. If so use a non-urgent socket
 * \param socket the socket pointer
 * \param data the pointer to the data to send
 * \param len the length of the data to send
 * \param the address and port number to send to
 * \return returns an XPSOCK error code.
 */
int XPSock_UrgentSend(t_XPSocket *socket,const char *data,int len,const t_XPAddress *addr)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	if (!KeepPacketYesOrNo())
	{
		asocket_lasterror = XPSOCK_EOK;
		return XPSOCK_EOK;
	}

	int ret;

	XPSOCK_PARANOID(socket);

	/* If this a local host connection the return XPSOCK_EUDPSENDFAILED */
	if (wsockets_started == 0 || (addr->mIPv4 && addr->addr[0] == 0 && addr->addr[1] == 0 && addr->addr[2] == 0 && addr->addr[3] == 0))
	{
		asocket_lasterror = XPSOCK_EUDPSENDFAILED;
		return XPSOCK_EERROR;
	}

	if (addr->mIPv4 && socket->wins_socket == SOCKET_ERROR && !addr->mIPv6)
	{
		asocket_lasterror = XPSOCK_EUDPSENDFAILED;
		return XPSOCK_EERROR;
	}

	if (addr->mIPv6 && socket->wins_socket6 == SOCKET_ERROR && !addr->mIPv4)
	{
		asocket_lasterror = XPSOCK_EUDPSENDFAILED;
		return XPSOCK_EERROR;
	}

	if (!addr->mIPv4 && !addr->mIPv6)
	{
		asocket_lasterror = XPSOCK_EUDPSENDFAILED;
		return XPSOCK_EERROR;
	}


	if (len > XPSOCK_URGENTMAXPACKETSIZE)
	{
		asocket_lasterror = XPSOCK_EURGENTTOOBIG;
		return XPSOCK_EERROR;
	}

	asocket_packets_sent++;
	asocket_packets_sent_size += len;

	// Check for latency emulation
	if (gXPSock_PacketLatencyEmulation)
	{
		asocket_lasterror = XPSOCK_EOK;
		ret = XPSOCK_EOK;

		// Calculate the time I really want the packet to be sent
		float multiplier = float(RNReplicaNet::Rand::FastWeak() - (RAND_MAX/2))  / float(RAND_MAX/2);		// Generate random number between -1.0f to 1.0f
		SysTimeType sendTime = theTimer->FloatTime();
		sendTime += gXPSock_PacketLatencyEmulationBase;
		sendTime += gXPSock_PacketLatencyEmulationJitter * multiplier;
		if (sendTime <= 0.0f)
		{
			sendTime = 0.0f;
		}

		// Create the impaired packet data
		ImpairedPacket packet;
		packet.mAddr = *addr;
		packet.mData = (char *) malloc(len);
		memcpy(packet.mData,data,len);
		packet.mLen = len;
		packet.mSocket = socket;
		packet.mTime = sendTime;

		// Bung it on the end of the list
		if (sImpairedPackets)
		{
			{
			THREADSAFELOCKCLASS(g_xpsockets_lockclass);
			sImpairedPackets->push_back(packet);
			}

			RetireImpairedPackets();
		}
	}
	else
	{
		// Do the real send and return the correct value
		ret = RealXPSock_UrgentSend(socket,data,len,addr);
	}

	return ret;
}

/**
 * Receives data from an urgent socket
 * \param socket the socket pointer
 * \param data pointer to a data buffer
 * \param maximum length of the data buffer
 * \param flag the flag to use for this operation. Removes the read message from the queue unless XPSOCK_FPEEK is used
 * \param addr the address of the sending socket for any data received
 * \return returns the length of the data received or 0 if no data is pending or an XPSOCK_EERROR error code
 */
int XPSock_UrgentRecv(t_XPSocket *socket,char *const data,int maxlen,int flag,t_XPAddress *const addr)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	struct sockaddr_in clientaddr;
	struct sockaddr_in6 clientaddr6;
#ifdef _USING_W32_SOCKETS
	int clientlength;
#else
	socklen_t clientlength;
#endif
	int ret = 0,lastError = WSAEWOULDBLOCK;

	XPSOCK_PARANOID(socket);

	socket->mCounter++;

	/* If this a local host connection then return XPSOCK_EWOULDBLOCK */
	if (wsockets_started == 0 || (socket->wins_socket == SOCKET_ERROR && socket->wins_socket6 == SOCKET_ERROR))
	{
		asocket_lasterror = XPSOCK_EWOULDBLOCK;
		return 0;
	}

	// First try IPv4, if there is no IPv6 then always do this option regardless of mCounter
	if ((socket->wins_socket6 == SOCKET_ERROR) || (!(socket->mCounter & 1) && (socket->wins_socket != SOCKET_ERROR)))
	{
		do
		{
			clientlength = sizeof(clientaddr);
			ret = recvfrom(socket->wins_socket,data,maxlen,0,(struct sockaddr *) &clientaddr,&clientlength);
			lastError = 0;
			if (ret == SOCKET_ERROR)
			{
				lastError = WSAGetLastError();
			}
		} while (lastError == WSAECONNRESET);	// Change made to eat WSAECONNRESET error triggered by ICMP "Port Unreachable".

		if ((ret > 0) && addr)
		{
#ifdef _USING_W32_SOCKETS
			addr->addr[0] = clientaddr.sin_addr.S_un.S_un_b.s_b1;
			addr->addr[1] = clientaddr.sin_addr.S_un.S_un_b.s_b2;
			addr->addr[2] = clientaddr.sin_addr.S_un.S_un_b.s_b3;
			addr->addr[3] = clientaddr.sin_addr.S_un.S_un_b.s_b4;
#else
			addr->addr[0] = ((unsigned char *)&clientaddr.sin_addr.s_addr)[0];
			addr->addr[1] = ((unsigned char *)&clientaddr.sin_addr.s_addr)[1];
			addr->addr[2] = ((unsigned char *)&clientaddr.sin_addr.s_addr)[2];
			addr->addr[3] = ((unsigned char *)&clientaddr.sin_addr.s_addr)[3];
#endif
			addr->port = ntohs(clientaddr.sin_port);

			addr->mIPv4 = true;
		}
	}

	// If nothing sensible was received by the IPv4 attempt then try IPv6
	if (((ret==0) || (ret == WSAEWOULDBLOCK)) && (socket->wins_socket6 != SOCKET_ERROR))
	{
		do
		{
			clientlength = sizeof(clientaddr6);
			ret = recvfrom(socket->wins_socket6,data,maxlen,0,(struct sockaddr *) &clientaddr6,&clientlength);
			lastError = 0;
			if (ret == SOCKET_ERROR)
			{
				lastError = WSAGetLastError();
			}
		} while (lastError == WSAECONNRESET);	// Change made to eat WSAECONNRESET error triggered by ICMP "Port Unreachable".

		if ((ret > 0) && addr)
		{
			int i;
			for (i=0;i<16;i++)
			{
				addr->addr6[i] = clientaddr6.sin6_addr.s6_addr[i];
			}
			addr->port6 = ntohs(clientaddr6.sin6_port);

			addr->mIPv6 = true;
		}
	}


	if (ret == SOCKET_ERROR)
	{
		ret = lastError;
		if (ret == WSAEWOULDBLOCK)
		{
			asocket_lasterror = XPSOCK_EWOULDBLOCK;
			return XPSOCK_EOK;
		}
		else
		{
			if (ret != WSAECONNRESET)
			{
				asocket_lasterror = XPSOCK_ECLOSED;
				return XPSOCK_EERROR;
			}
			asocket_lasterror = XPSOCK_EWOULDBLOCK;
			return 0;
		}
	}

	if (ret == 0)
	{
		asocket_lasterror = XPSOCK_EWOULDBLOCK;
		return 0;
	}

	if (ret > 0)
	{
		asocket_packets_got++;
		asocket_packets_got_size += ret;

		// Update the histogram
		if (s_recvHistogramLen > 0 && s_recvHistogram)
		{
			s_recvHistogram[RNmax(RNmin(s_recvHistogramLen-1,ret),0)]++;
		}
	}

	asocket_lasterror = XPSOCK_EOK;
	return ret;
}

/* An error lookup table that converts a socket error number to a simple of long error message for humans to read */
static t_XPErrorTranslate serrorstrings[] = {
		{ XPSOCK_EOK,"XPSOCK_EOK","Not an error but defined for completeness."	},
		{ XPSOCK_EERROR,"XPSOCK_EERROR","Undefined error." },
		{ XPSOCK_EWOULDBLOCK,"XPSOCK_EWOULDBLOCK","Not a serious error, just informational." },
		{ XPSOCK_ECLOSED,"XPSOCK_ECLOSED","The other end has closed the connection." },
		{ XPSOCK_ENOEXIST,"XPSOCK_ENOEXIST","There is not a machine there to connect to." },
		{ XPSOCK_ENOMEMORY,"XPSOCK_ENOMEMORY","The sockets ran out of memory." },
		{ XPSOCK_ENOTASOCKET,"XPSOCK_ENOTASOCKET","The socket pointer passed into a function was not a socket pointer." },
		{ XPSOCK_ECANTLISTEN,"XPSOCK_ECANTLISTEN","Couldn't make this socket listen." },
		{ XPSOCK_ENOTALISTEN,"XPSOCK_ENOTALISTEN","This socket isn't a listen socket." },
		{ XPSOCK_ENOTCONNECTED,"XPSOCK_ENOTCONNECTED","This socket isn't connected to another socket." },
		{ XPSOCK_EBUFFEROVERFLOW,"XPSOCK_EBUFFEROVERFLOW","The local host buffer has over flowed, increase the standard amount in this header file." },
		{ XPSOCK_EUDPSENDFAILED,"XPSOCK_EUDPSENDFAILED","Sending a UDP packet failed. Resort to sending a slow packet instead." },
		{ XPSOCK_ECANTBIND,"XPSOCK_ECANTBIND","Can't bind the socket to an address." },
		{ XPSOCK_ECANTRESOLVE,"XPSOCK_ECANTRESOLVE","Can't resolve the supplied string to a number." },
		{ XPSOCK_ILLEGALOPERATION,"XPSOCK_ILLEGALOPERATION","The requested operation cannot be performed on this socket due to type differences between urgent and normal sockets." },
		{ XPSOCK_ECONNINPROGRESS,"XPSOCK_ECONNINPROGRESS","A connection is in progress." },
		{ XPSOCK_ESTACKSTARTFAILURE,"XPSOCK_ESTACKSTARTFAILURE","The network stack failed to start." },
		{ XPSOCK_ESTACKNOTSTARTED,"XPSOCK_ESTACKNOTSTARTED","The operation couldn't be completed because the stack has not been started." },

		/* End of list */
		{ 0, NULL,NULL }
	};

/* Default messages that get returned if not found by the lookup routines */
static char seweirderror[] = "UNDEFINED";
static char sweirderror[] = "Undefined error - Unable to match type";

/**
 * This translates an XPSocket error to a text string
 * \param error the XPSOCK error number
 * \return returns a pointer to an XPSOCK error string.
 */
const char *XPSock_TranslateError(int error)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	int i = 0;
	const char *thiserror = seweirderror;

	while(serrorstrings[i].text != NULL)
	{
		if (serrorstrings[i].error == error)
		{
			thiserror = serrorstrings[i].text;
			break;
		}
		i++;
	}

	return thiserror;
}

/**
 * This translates an XPSocket error to a long descriptive text string
 * \param error the XPSOCK error number
 * \return returns a pointer to an XPSOCK long error string.
 */
const char *XPSock_TranslateErrorLong(int error)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	int i = 0;
	const char *thiserror = sweirderror;

	while(serrorstrings[i].text != NULL)
	{
		if (serrorstrings[i].error == error)
		{
			thiserror = serrorstrings[i].longtext;
			break;
		}
		i++;
	}

	return thiserror;
}


#ifdef _PS2
extern char gPS2_Name[256];
#endif

/**
 * Gets the host machine name
 * \param name pointer to a buffer to receive the machines textual name
 * \param name_len the length of the buffer
 * \return returns an XPSOCK error code.
 */
int XPSock_GetHostName(char *name,int name_len)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

#ifndef _PS2
	if (wsockets_started)
	{
// For the XBox do we want to return our special localhost name
#ifdef _XBOX
		//strcpy(name,my_special_mach_name);
		XNADDR xnaddr;
		DWORD xnType;

		ZeroMemory( &xnaddr, sizeof(xnaddr));

		while( (xnType = XNetGetTitleXnAddr(&xnaddr)) == XNET_GET_XNADDR_PENDING)
			Sleep(1);

		sprintf(name, "%d.%d.%d.%d",	xnaddr.ina.S_un.S_un_b.s_b1,
			xnaddr.ina.S_un.S_un_b.s_b2,
			xnaddr.ina.S_un.S_un_b.s_b3,
			xnaddr.ina.S_un.S_un_b.s_b4);

		//typedef struct {
		//	IN_ADDR	 ina;							// IP address (zero if not static/DHCP)
		//	IN_ADDR	 inaOnline;					  // Online IP address (zero if not online)
		//	WORD		wPortOnline;					// Online port
		//	BYTE		abEnet[6];					  // Ethernet MAC address
		//	BYTE		abOnline[20];				   // Online identification
		//} XNADDR;

		//xnType is one of:-
		//XNET_GET_XNADDR_DHCP The host has a dynamic IP address via DHCP. 
		//XNET_GET_XNADDR_DNS The host has one or more DNS servers configured. 
		//XNET_GET_XNADDR_ETHERNET The host has an Ethernet address. 
		//XNET_GET_XNADDR_GATEWAY The host has one or more Internet gateways configured. 
		//XNET_GET_XNADDR_NONE Either the network stack is not initialized or no debugger was found. 
		//XNET_GET_XNADDR_ONLINE The host is currently connected to Xbox Live. 
		//XNET_GET_XNADDR_PENDING The address aquisition is not yet complete. 
		//XNET_GET_XNADDR_PPPOE Host has a PPPoE assigned IP address. 
		//XNET_GET_XNADDR_STATIC The host has a static IP address. 
		//XNET_GET_XNADDR_TROUBLESHOOT The network configuration requires troubleshooting. 

#else
		gethostname(name,name_len);
#endif
	}
	else
	{
		if (name_len < (int) (strlen(my_special_mach_name)+1))
		{
			asocket_lasterror = XPSOCK_ENOMEMORY;
			return XPSOCK_EERROR;
		}

		strcpy(name,my_special_mach_name);
	}

	asocket_lasterror = XPSOCK_EOK;
	return XPSOCK_EOK;
#else
	if (wsockets_started)
	{
		if (name_len < (int) (strlen(gPS2_Name)+1))
		{
			asocket_lasterror = XPSOCK_ENOMEMORY;
			return XPSOCK_EERROR;
		}

		sprintf(name,gPS2_Name);

		asocket_lasterror = XPSOCK_EOK;
		return XPSOCK_EOK;
	}

	if (name_len < (int) (strlen(my_special_mach_name)+1))
	{
		asocket_lasterror = XPSOCK_ENOMEMORY;
		return XPSOCK_EERROR;
	}

	strcpy(name,my_special_mach_name);

	asocket_lasterror = XPSOCK_EOK;
	return XPSOCK_EOK;
#endif
}

/**
 * Gets the host machine address
 * \param addr the XPAddress to fill in
 * \return returns an XPSOCK error code.
 */
int XPSock_GetHostAddress(XPAddress *addr)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	if (hostaddr_got == false)
	{
		// Print some debug info for the server address etc
		char buffer[256];
		XPSock_GetHostName(buffer,sizeof(buffer));
		XPSock_Resolve(addr,buffer);
		hostaddr = *addr;
		hostaddr_got = true;
	}
	else
	{
		*addr = hostaddr;
	}

	return XPSOCK_EOK;
}


/**
 * Handy routine to resolve anything into an address
 * \param resolve the address structure to fill in with the result. Specifically the port and port6 members are left unchanged.
 * \param input the textual name of a machine name to resolve
 * \return returns an XPSOCK error code.
 */
int XPSock_Resolve(t_XPAddress *resolve,const char *input)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);
	if (!resolve)
	{
		asocket_lasterror = XPSOCK_ECANTRESOLVE;
		return XPSOCK_EERROR;
	}

	resolve->mIPv4 = false;
	resolve->mIPv6 = false;

	// If we have no sockets started then just return 127.0.0.1
	if (!wsockets_started)
	{
		resolve->mIPv4 = true;
		resolve->addr[0] = 127;
		resolve->addr[1] = 0;
		resolve->addr[2] = 0;
		resolve->addr[3] = 1;
		asocket_lasterror = XPSOCK_EOK;
		return XPSOCK_EOK;
	}

// For the XBox we do not do any resolve
#ifdef _XBOX
	// However we do a check with our local host name and spit out 127.0.0.1 if it matches
	// TODO: MPi: Use the XBox preferred way to find out the machine IP address
	if (strcmp(input,my_special_mach_name)==0)
	{
		resolve->mIPv4 = true;
		resolve->addr[0] = 127;
		resolve->addr[1] = 0;
		resolve->addr[2] = 0;
		resolve->addr[3] = 1;

		asocket_lasterror = XPSOCK_EOK;
		return XPSOCK_EOK;
	}

	unsigned long addr;

	/* Check by dot name */
	addr = inet_addr(input);
	if (addr != INADDR_NONE)
	{
		// It is a name in number format e.g. xxx.xxx.xxx.xxx
		char *address = (char *)&addr;
		resolve->mIPv4 = true;
		resolve->addr[0] = address[0];
		resolve->addr[1] = address[1];
		resolve->addr[2] = address[2];
		resolve->addr[3] = address[3];

		asocket_lasterror = XPSOCK_EOK;
		return XPSOCK_EOK;
	}

#else

	if (input == NULL)
	{
		input = "localhost";
	}

	bool got4 = false;
	bool got6 = false;

#ifdef NO_GETADDRINFO
	// The old method which gets only IPv4
	unsigned long addr;

	/* Check by dot name */
#ifdef IW_SDK
	// MPi: TODO: Bug report and check. Only for Marmalade builds inet_addr() will return the previous calculation if the input address is not numerical dot format.
	// The workaround is to try the equivalent of INADDR_NONE first to prime the return value.
	addr = inet_addr("255.255.255.255");
#endif
	addr = inet_addr(input);
	if (addr != INADDR_NONE)
	{
		// It is a name in number format e.g. xxx.xxx.xxx.xxx
		char *address = (char *)&addr;
		resolve->mIPv4 = true;
		resolve->addr[0] = address[0];
		resolve->addr[1] = address[1];
		resolve->addr[2] = address[2];
		resolve->addr[3] = address[3];

		asocket_lasterror = XPSOCK_EOK;
		return XPSOCK_EOK;
	}

	struct hostent *hostent = NULL;
	/* Look up the host. */
	hostent = gethostbyname(input);

	if (hostent)
	{
		char **addresses;
		got4 = true;
		addresses = hostent->h_addr_list;
		resolve->addr[0] = addresses[0][0];
		resolve->addr[1] = addresses[0][1];
		resolve->addr[2] = addresses[0][2];
		resolve->addr[3] = addresses[0][3];
	}
#else	//< #ifdef NO_GETADDRINFO
//	dprintf("XPSock : Resolve '%s'\n",input);

	// First try a numeric conversion
	struct addrinfo hints;
	memset( &hints, 0, sizeof(hints) );
	// Only used for number format strings, stops resolving.
	hints.ai_flags = AI_NUMERICHOST;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_family = AF_UNSPEC;
	hints.ai_protocol = IPPROTO_TCP;


	addrinfo *addrInfo = 0;
	int thisRet = getaddrinfo(input,0,&hints,&addrInfo);
	if (!addrInfo)
	{
		// If the numeric conversion failed then try a name resolution
		hints.ai_flags = 0;
		thisRet = getaddrinfo(input,0,&hints,&addrInfo);
	}

	if (addrInfo)
	{
		addrinfo *ptr = addrInfo;
		while (ptr)
		{
			sockaddr_in *IPv4 = 0;
			sockaddr_in6 *IPv6 = 0;

			// RFC3484 says the addresses are sorted in order of proximity to the host. So we pick the last address for v4 and v6.
			if (ptr->ai_family == AF_INET)
			{
				got4 = true;
				IPv4 = (sockaddr_in *)ptr->ai_addr;
#ifdef _USING_W32_SOCKETS
				resolve->addr[0] = IPv4->sin_addr.S_un.S_un_b.s_b1;
				resolve->addr[1] = IPv4->sin_addr.S_un.S_un_b.s_b2;
				resolve->addr[2] = IPv4->sin_addr.S_un.S_un_b.s_b3;
				resolve->addr[3] = IPv4->sin_addr.S_un.S_un_b.s_b4;
#else
				resolve->addr[0] = ((unsigned char *)&(IPv4->sin_addr))[0];
				resolve->addr[1] = ((unsigned char *)&(IPv4->sin_addr))[1];
				resolve->addr[2] = ((unsigned char *)&(IPv4->sin_addr))[2];
				resolve->addr[3] = ((unsigned char *)&(IPv4->sin_addr))[3];
#endif
			}
			else if (ptr->ai_family == AF_INET6)
			{
				got6 = true;
				IPv6 = (sockaddr_in6 *)ptr->ai_addr;
				int i;
				for (i=0;i<16;i++)
				{
					resolve->addr6[i] = IPv6->sin6_addr.s6_addr[i];
				}
			}

#if 0
			// Some debug printing for the resolve
			char outputString[256];
			DWORD ipbufferlength = sizeof(outputString);
			int ret = WSAAddressToString(ptr->ai_addr, (DWORD) addrInfo->ai_addrlen, NULL, outputString, &ipbufferlength );
			printf("XPSock_Resolve = %s\n",outputString);
#endif
			ptr = ptr->ai_next;
		}

		freeaddrinfo(addrInfo);
	}

#endif	//<< #ifdef NO_GETADDRINFO

	resolve->mIPv4 = got4;
	resolve->mIPv6 = got6;

	if (got4 || got6)
	{
		asocket_lasterror = XPSOCK_EOK;
		return XPSOCK_EOK;
	}
#endif // ifdef _XBOX and then else

	// Default condition is to return an error
	asocket_lasterror = XPSOCK_ECANTRESOLVE;
	return XPSOCK_EERROR;
}

XPAddress::XPAddress(const int port) : mIPv4(true) , mIPv6(false)
{
	MakeAny(port);
}

XPAddress::XPAddress(const int port,unsigned char addr1,unsigned char addr2,unsigned char addr3,unsigned char addr4) : mIPv4(true) , mIPv6(false)
{
	this->port = port;
	this->addr[0] = addr1;
	this->addr[1] = addr2;
	this->addr[2] = addr3;
	this->addr[3] = addr4;
}

XPAddress::XPAddress(std::string addr)
{
	Import(addr);
}

XPAddress::XPAddress() : mIPv4(false) , mIPv6(false)
{
}

// WinXP doesn't have this in ws2_32.dll so it is implemented here
// MPi: TODO: Remove this code when dropping support for OS that don't support this function
static int Replacement_inet_pton6(const char *src, unsigned char *dst)
{
	static const char xdigits_l[] = "0123456789abcdef";
	unsigned char tmp[16], *tp, *endp, *colonp;
	const char *curtok;
	int ch, saw_xdigit;
	unsigned int val;

	tp = tmp;
	memset(tp, 0, 16);
	endp = tp + 16;
	colonp = 0;
	// Leading ::
	if (*src == ':')
	{
		if (*++src != ':')
		{
			return 0;
		}
	}
	curtok = src;
	saw_xdigit = 0;
	val = 0;
	while ((ch = *src++) != '\0')
	{
		const char *pch;

		pch = strchr(xdigits_l, tolower(ch));

		if (pch != NULL)
		{
			val <<= 4;
			val |= (pch - xdigits_l);
			if (val > 0xffff)
			{
				return 0;
			}
			saw_xdigit = 1;
			continue;
		}

		if (ch == ':')
		{
			curtok = src;
			if (!saw_xdigit)
			{
				if (colonp)
				{
					return 0;
				}
				colonp = tp;
				continue;
			}
			if (tp + 2 > endp)
			{
				return 0;
			}
			*tp++ = (unsigned char) (val >> 8) & 0xff;
			*tp++ = (unsigned char) val & 0xff;
			saw_xdigit = 0;
			val = 0;
			continue;
		}

		int ti[4];
		if (ch == '.' && ((tp + 4) <= endp) && (sscanf(curtok, "%d.%d.%d.%d" ,ti+0 ,ti+1 ,ti+2 ,ti+3) == 4))
		{
			tp[0] = (unsigned char) ti[0];
			tp[1] = (unsigned char) ti[1];
			tp[2] = (unsigned char) ti[2];
			tp[3] = (unsigned char) ti[3];
			tp += 4;
			saw_xdigit = 0;
			break;
		}
		return (0);
	}
	if (saw_xdigit)
	{
		if (tp + 2 > endp)
		{
			return (0);
		}
		*tp++ = (unsigned char) (val >> 8) & 0xff;
		*tp++ = (unsigned char) val & 0xff;
	}

	if (colonp != 0)
	{
		// Move the address to the correct place
		const int n = (int)(tp - colonp);
		int i;

		for (i = 1; i <= n; i++)
		{
			endp[- i] = colonp[n - i];
			colonp[n - i] = 0;
		}
		tp = endp;
	}

	if (tp != endp)
	{
		return 0;
	}

	memcpy(dst, tmp, 16);
	return 1;
}


bool XPAddress::Import(const std::string address)
{
	// Clear it first
	MakeAny(0);
	mIPv4 = false;
	mIPv6 = false;

	assert(!address.empty() && "The address passed to XPAddress was null");
	if (address.empty())
	{
		return false;
	}

	std::string IPv4;
	std::string IPv6;
	size_t splitPos = address.find('-');
	if (address.find('.') != std::string::npos)
	{
		IPv4 = address.substr(0,splitPos);
	}
	else
	{
		// Otherwise it is just IPv6
		IPv6 = address;
	}
	if (splitPos != std::string::npos)
	{
		IPv6 = address.substr(splitPos+1);
	}

	if (!IPv4.empty())
	{
		// MPi: TODO: Consider using inet_pton and other similar network functions
		int i[4],inport;
		int ret = sscanf(IPv4.c_str(),"%d.%d.%d.%d:%d",i+0,i+1,i+2,i+3,&inport);
		if (ret == 5)
		{
			port = inport;
			addr[0] = i[0];
			addr[1] = i[1];
			addr[2] = i[2];
			addr[3] = i[3];
			mIPv4 = true;
		}
	}

	if (!IPv6.empty())
	{
		in6_addr in;
		int inport;
		if (IPv6[0] == '[')
		{
			IPv6.erase(0,1);
		}
		size_t pos = IPv6.find(']');
		if (pos != std::string::npos)
		{
//			if (inet_pton(AF_INET6,IPv6.substr(0,pos).c_str(),&in) > 0)
			if (Replacement_inet_pton6(IPv6.substr(0,pos).c_str(),(unsigned char*)&in) > 0)
			{
				int ret = sscanf(IPv6.substr(pos).c_str(),"]:%d",&inport);
				if (ret == 1)
				{
					int i;
					for (i=0;i<16;i++)
					{
						addr6[i] = in.s6_addr[i];
					}
					port6 = inport;
					mIPv6 = true;
				}
			}
		}
	}

	return mIPv4 || mIPv6;
}

// WinXP doesn't have this in ws2_32.dll so it is implemented here
// MPi: TODO: Remove this code when dropping support for OS that don't support this function
static void Replacement_inet_ntop6(const u_char *src, char *dst)
{
	char *tp;
	struct { int base, len; } best, cur;
	u_int words[8];
	int i;

	// Make the input 16 bit words
	memset(words, 0, sizeof(words));
	for (i = 0; i < 16; i++)
	{
		words[i / 2] |= (src[i] << ((1 - (i % 2)) << 3));
	}
	// Find the best run of 0s
	best.base = -1;
	cur.base = -1;
	for (i = 0; i < 8; i++)
	{
		if (words[i] == 0)
		{
			if (cur.base == -1)
			{
				cur.base = i, cur.len = 1;
			}
			else
			{
				cur.len++;
			}
		}
		else
		{
			if (cur.base != -1)
			{
				if (best.base == -1 || cur.len > best.len)
				{
					best = cur;
				}
				cur.base = -1;
			}
		}
	}
	if (cur.base != -1)
	{
		if (best.base == -1 || cur.len > best.len)
		{
			best = cur;
		}
	}
	if (best.base != -1 && best.len < 2)
	{
		best.base = -1;
	}

	// Write the resultant IPv6 address
	tp = dst;
	for (i = 0; i < 8; i++)
	{
		// Skip over the run of 0s
		if ((best.base != -1) && (i >= best.base) && (i < (best.base + best.len)))
		{
			if (i == best.base)
			{
				*tp++ = ':';
			}
			continue;
		}

		// Separator
		if (i != 0)
		{
			*tp++ = ':';
		}

		// Find an encapsulated IPv4 address
		if ((i == 6) && (best.base == 0) && (best.len == 6 || (best.len == 5 && words[5] == 0xffff)))
		{
			sprintf(tp,"%d.%d.%d.%d", src[12], src[13], src[14], src[15]);
			tp += strlen(tp);
			break;
		}

		// Just write the word
		sprintf(tp, "%x", words[i]);
		tp += strlen(tp);
	}

	// Trailing 0s?
	if (best.base != -1 && ((best.base + best.len) == 8))
	{
		*tp++ = ':';
	}
	*tp++ = 0;
}

std::string XPAddress::Export(void) const
{
	std::string output;
	if (mIPv4)
	{
		// MPi: TODO: Consider using inet_ntop and other similar network functions
		char buffer[32];
		sprintf(buffer,"%d.%d.%d.%d:%d",addr[0],addr[1],addr[2],addr[3],port);
		output = buffer;
		if (mIPv6)
		{
			output += "-";
		}
	}
	if (mIPv6)
	{
		int i;
		in6_addr inaddr;
		for (i=0;i<16;i++)
		{
			inaddr.s6_addr[i] = addr6[i];
		}
		char buffer[128],buffer2[128];
//		inet_ntop(AF_INET6,&inaddr,buffer2,sizeof(buffer2));
		Replacement_inet_ntop6((u_char *)&inaddr,buffer2);
		sprintf(buffer,"[%s]:%d", buffer2, port6);
		output += buffer;
	}
	return output;
}

void XPAddress::MakeAny(const int inport)
{
	mIPv4 = true;
	mIPv6 = false;
	// In most case INADDR_ANY in going to be 0x00000000
	// But the for the extremely unlikely event that this is not the case we do this conversion instead
	struct sockaddr_in serveraddr;
	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
#ifdef _USING_W32_SOCKETS
	addr[0] = serveraddr.sin_addr.S_un.S_un_b.s_b1;
	addr[1] = serveraddr.sin_addr.S_un.S_un_b.s_b2;
	addr[2] = serveraddr.sin_addr.S_un.S_un_b.s_b3;
	addr[3] = serveraddr.sin_addr.S_un.S_un_b.s_b4;
#else
	addr[0] = ((unsigned char *)&serveraddr.sin_addr.s_addr)[0];
	addr[1] = ((unsigned char *)&serveraddr.sin_addr.s_addr)[1];
	addr[2] = ((unsigned char *)&serveraddr.sin_addr.s_addr)[2];
	addr[3] = ((unsigned char *)&serveraddr.sin_addr.s_addr)[3];
#endif
	
	port = inport;

	// IPv6
	int i;
	for (i=0;i<16;i++)
	{
		// Mostly in6addr_any is going to be zeros, but just to be sure we use the constant
		addr6[i] = in6addr_any.s6_addr[i];
	}

	port6 = inport;
}

XPAddress XPAddress::Null(void)
{
	XPAddress addr;
	memset(&addr,0,sizeof(addr));
	return addr;
}

bool XPAddress::IsLocalhost(void) const
{
	if ( mIPv4 && ( addr[0] == 127 ) && ( addr[1] == 0 ) && ( addr[2] == 0 ) && ( addr[3] == 1 ) )
	{
		return true;
	}

	if ( mIPv6 && ( addr6[15] == 1 ) && ( addr6[14] == 0 ) && ( addr6[13] == 0 ) && ( addr6[12] == 0 )
			&& ( addr6[11] == 0 ) && ( addr6[10] == 0 ) && ( addr6[9] == 0 ) && ( addr6[8] == 0 )
			&& ( addr6[7] == 0 ) && ( addr6[6] == 0 ) && ( addr6[5] == 0 ) && ( addr6[4] == 0 )
			&& ( addr6[3] == 0 ) && ( addr6[2] == 0 ) && ( addr6[1] == 0 ) && ( addr6[0] == 0 ) )
	{
		return true;
	}

	return false;
}

/**
 * Supplies a histogram table and the size of the table for sent packets. Each class entry corresponds to a size of packet.
 * \param classes The pointer to the array of classes.
 * \param numClasses The number of classes in the array.
 */
void XPSock_SentHistogram(unsigned int *classes,int numClasses)
{
	s_sentHistogramLen = 0;
	s_sentHistogram = 0;
	s_sentHistogram = classes;
	s_sentHistogramLen = RNmax(numClasses,0);
}

/**
 * Supplies a histogram table and the size of the table for sent packets. Each class entry corresponds to a size of packet.
 * \param classes The pointer to the array of classes.
 * \param numClasses The number of classes in the array.
 */
void XPSock_RecvHistogram(unsigned int *classes,int numClasses)
{
	s_recvHistogramLen = 0;
	s_recvHistogram = 0;

	s_recvHistogram = classes;
	s_recvHistogramLen = RNmax(numClasses,0);
}

/**
 * Gets the status of the network hardware used by this socket interface.
 * \return 
 */
int XPSock_GetHardwareStatus(void)
{
	int flags = 0;
// Returns a combination of:
//XPSOCK_HARDWARE_AVAILABLE
//XPSOCK_HARDWARE_CABLE_CONNECTED
//XPSOCK_HARDWARE_10MBS
//XPSOCK_HARDWARE_100MBS
//XPSOCK_HARDWARE_FULL_DUPLEX
//XPSOCK_HARDWARE_HALF_DUPLEX
#if defined(_PS2)
	if (PS2NetworkHardwareIsAvailable())
	{
		flags |= XPSOCK_HARDWARE_AVAILABLE;
	}
	if (PS2NetworkHardwareIsCableConnected())
	{
		flags |= XPSOCK_HARDWARE_CABLE_CONNECTED;
	}
#elif defined(_XBOX)
	flags |= XPSOCK_HARDWARE_AVAILABLE;
	DWORD stat = XNetGetEthernetLinkStatus();
	if (stat & XNET_ETHERNET_LINK_ACTIVE)
	{
		flags |= XPSOCK_HARDWARE_CABLE_CONNECTED;
	}
	if (stat & XNET_ETHERNET_LINK_100MBPS)
	{
		flags |= XPSOCK_HARDWARE_100MBS;
	}
	if (stat & XNET_ETHERNET_LINK_10MBPS)
	{
		flags |= XPSOCK_HARDWARE_10MBS;
	}
	if (stat & XNET_ETHERNET_LINK_FULL_DUPLEX)
	{
		flags |= XPSOCK_HARDWARE_FULL_DUPLEX;
	}
	if (stat & XNET_ETHERNET_LINK_HALF_DUPLEX)
	{
		flags |= XPSOCK_HARDWARE_HALF_DUPLEX;
	}
#else
	// MPi: TODO: Implement a proper check for other platforms
	flags |= XPSOCK_HARDWARE_AVAILABLE | XPSOCK_HARDWARE_CABLE_CONNECTED;
#endif

	return flags;
}


///////////////////////////////////////////////////////////////////////////////
// Ping stuff
///////////////////////////////////////////////////////////////////////////////
#ifndef _XBOX

static u_short in_cksum(u_short *addr, int len)
{
	int nleft = len;
	u_short *w = addr;
	u_short answer;
	int sum = 0;

	// Add shorts
	while( nleft > 1 )
	{
		sum += *w++;	// Note endian
		nleft -= 2;
	}

	// Add the last byte if it exists
	if( nleft == 1 )
	{
		u_short	u = 0;

		*(u_char *)(&u) = *(u_char *)w ;	// Note endian
		sum += u;
	}

	// Calculate the final checksum into 16 bits
	sum = (sum >> 16) + (sum & 0xffff);
	// Carry
	sum += (sum >> 16);
	answer = ~sum;
	return answer;
}

t_XPSocket *XPSock_ICMPCreate(void)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	t_XPSocket *thissocket;
	int ret = 0;

	if (!wsockets_started)
	{
		asocket_lasterror = XPSOCK_ENOMEMORY;
		return (t_XPSocket *) XPSOCK_EERROR;
	}

	thissocket = (t_XPSocket *) calloc(1,sizeof(t_XPSocket));

	/* Allocate the socket */
	if (thissocket == NULL)
	{
		asocket_lasterror = XPSOCK_ENOMEMORY;
		return (t_XPSocket *) XPSOCK_EERROR;
	}

	thissocket->wins_socket = SOCKET_ERROR;

	int opt = 1;

	/* Open our socket! */
	thissocket->wins_socket = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);

	if (thissocket->wins_socket == SOCKET_ERROR)
	{
		free(thissocket);
		asocket_lasterror = XPSOCK_ENOMEMORY;
		return (t_XPSocket *) XPSOCK_EERROR;
	}

	/* Make socket non-blocking */
#ifndef _PS2
	ret = ioctlsocket(thissocket->wins_socket,FIONBIO, (unsigned long *) &opt);
#endif

#ifdef _PS2
	ret = setsockopt(thissocket->wins_socket, SOL_SOCKET, SO_NBIO, (const char *) &opt, 4);
#endif

	asocket_lasterror = XPSOCK_EOK;
	return thissocket;
}

int XPSock_ICMPSendPing(RNReplicaNet::t_XPSocket * socket,const RNReplicaNet::t_XPAddress * addr,unsigned short *retID,unsigned short *retSeq,unsigned int *retTimeSent)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);
	assert(addr);

	struct sockaddr_in serveraddr;
	int ret;

	XPSOCK_PARANOID(socket);

	/* If this a local host connection then return XPSOCK_EWOULDBLOCK */
	if (wsockets_started == 0 || socket->wins_socket == SOCKET_ERROR)
	{
		asocket_lasterror = XPSOCK_EWOULDBLOCK;
		return XPSOCK_EOK;
	}

	memset(&serveraddr,0,sizeof(serveraddr));
#ifdef _PS2
	serveraddr.sin_len = sizeof(serveraddr);
#endif
	serveraddr.sin_family = AF_INET;
#ifdef _USING_W32_SOCKETS
	serveraddr.sin_addr.S_un.S_un_b.s_b1 = addr->addr[0];
	serveraddr.sin_addr.S_un.S_un_b.s_b2 = addr->addr[1];
	serveraddr.sin_addr.S_un.S_un_b.s_b3 = addr->addr[2];
	serveraddr.sin_addr.S_un.S_un_b.s_b4 = addr->addr[3];
#else
	((unsigned char *)&serveraddr.sin_addr.s_addr)[0] = addr->addr[0];
	((unsigned char *)&serveraddr.sin_addr.s_addr)[1] = addr->addr[1];
	((unsigned char *)&serveraddr.sin_addr.s_addr)[2] = addr->addr[2];
	((unsigned char *)&serveraddr.sin_addr.s_addr)[3] = addr->addr[3];
#endif

	serveraddr.sin_port = htons(addr->port);


	ECHOREQUEST echoReq;
	memset(&echoReq,0,sizeof(echoReq));
	static int nId = 1;
	static int nSeq = 1;
	int nRet;

	//Fill in echo request
	echoReq.icmpHdr.Type		= ICMP_ECHOREQ;
	echoReq.icmpHdr.Code		= 0;
	echoReq.icmpHdr.Checksum	= 0;
	echoReq.icmpHdr.ID			= nId++;
	echoReq.icmpHdr.Seq			= nSeq++;

	//Fill in some data to send
	for (nRet = 0; nRet < REQ_DATASIZE; nRet++)
		echoReq.cData[nRet] = ' '+nRet;

	//Save tick count when sent
	echoReq.dwTime	= SysTime::GetTickCount();
	if (retID)
	{
		*retID = echoReq.icmpHdr.ID;
	}
	if (retSeq)
	{
		*retSeq = echoReq.icmpHdr.Seq;
	}
	if (retTimeSent)
	{
		*retTimeSent = echoReq.dwTime;
	}
		//
	// Put data in packet and compute checksum
	echoReq.icmpHdr.Checksum = in_cksum((u_short *)&echoReq, sizeof(echoReq));

	ret = sendto(socket->wins_socket,(char *) &echoReq,sizeof(echoReq),0,(struct sockaddr *) &serveraddr,sizeof(serveraddr));

	if (ret == SOCKET_ERROR)
	{
		ret = WSAGetLastError();
		if (ret == WSAEWOULDBLOCK)
		{
			asocket_lasterror = XPSOCK_EWOULDBLOCK;
			return XPSOCK_EOK;
		}
		else
		{
			asocket_lasterror = XPSOCK_ECLOSED;
			return XPSOCK_EERROR;
		}
	}

	asocket_packets_sent++;
	asocket_packets_sent_size += sizeof(echoReq);

	asocket_lasterror = XPSOCK_EOK;
	return XPSOCK_EOK;
}

int XPSock_ICMPRecvPing(RNReplicaNet::t_XPSocket * socket,RNReplicaNet::t_XPAddress *const addr,unsigned short *retID,unsigned short *retSeq,unsigned int *retTimeElapsed)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	struct sockaddr_in clientaddr;
#ifdef _USING_W32_SOCKETS
	int clientlength;
#else
	socklen_t clientlength;
#endif
	int ret,lastError;
	ECHOREPLY echoReply;

	XPSOCK_PARANOID(socket);

	/* If this a local host connection then return XPSOCK_EWOULDBLOCK */
	if (wsockets_started == 0 || socket->wins_socket == SOCKET_ERROR)
	{
		asocket_lasterror = XPSOCK_EWOULDBLOCK;
		return XPSOCK_EOK;
	}

	clientlength = sizeof(clientaddr);
	do
	{
		ret = recvfrom(socket->wins_socket,(char*)&echoReply,sizeof(echoReply),0,(struct sockaddr *) &clientaddr,&clientlength);
		lastError = 0;
		if (ret == SOCKET_ERROR)
		{
			lastError = WSAGetLastError();
		}
	} while (lastError == WSAECONNRESET);	// Change made to eat WSAECONNRESET error triggered by ICMP "Port Unreachable".

	if (ret == SOCKET_ERROR)
	{
		ret = lastError;
		if (ret == WSAEWOULDBLOCK)
		{
			asocket_lasterror = XPSOCK_EWOULDBLOCK;
			return XPSOCK_EOK;
		}
		else
		{
			if (ret != WSAECONNRESET)
			{
				asocket_lasterror = XPSOCK_ECLOSED;
				return XPSOCK_EERROR;
			}
			asocket_lasterror = XPSOCK_EWOULDBLOCK;
			return XPSOCK_EOK;
		}
	}

	if (ret == 0)
	{
		asocket_lasterror = XPSOCK_EWOULDBLOCK;
		return XPSOCK_EOK;
	}

	if (ret >= (int) (sizeof(IPHDR) + sizeof(ECHOREQUEST)))
	{
		if (addr)
		{
#ifdef _USING_W32_SOCKETS
			addr->addr[0] = clientaddr.sin_addr.S_un.S_un_b.s_b1;
			addr->addr[1] = clientaddr.sin_addr.S_un.S_un_b.s_b2;
			addr->addr[2] = clientaddr.sin_addr.S_un.S_un_b.s_b3;
			addr->addr[3] = clientaddr.sin_addr.S_un.S_un_b.s_b4;
#else
			addr->addr[0] = ((unsigned char *)&clientaddr.sin_addr.s_addr)[0];
			addr->addr[1] = ((unsigned char *)&clientaddr.sin_addr.s_addr)[1];
			addr->addr[2] = ((unsigned char *)&clientaddr.sin_addr.s_addr)[2];
			addr->addr[3] = ((unsigned char *)&clientaddr.sin_addr.s_addr)[3];
#endif
			addr->port = ntohs(clientaddr.sin_port);

			addr->mIPv4 = true;
		}

		if (retID)
		{
			*retID = echoReply.echoRequest.icmpHdr.ID;
		}
		if (retSeq)
		{
			*retSeq = echoReply.echoRequest.icmpHdr.Seq;
		}
		if (retTimeElapsed)
		{
			*retTimeElapsed = SysTime::GetTickCount() - echoReply.echoRequest.dwTime;
		}

		asocket_packets_got++;
		asocket_packets_got_size += ret;
	}
	else
	{
		asocket_lasterror = XPSOCK_EWOULDBLOCK;
		return XPSOCK_EOK;
	}

	asocket_lasterror = XPSOCK_EOK;
	return ret;
}

int XPSock_ICMPWaitForPing(RNReplicaNet::t_XPSocket * socket,const float timeoutSeconds)
{
	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	XPSOCK_PARANOID(socket);

	/* If this a local host connection then return XPSOCK_EWOULDBLOCK */
	if (wsockets_started == 0 || socket->wins_socket == SOCKET_ERROR)
	{
		asocket_lasterror = XPSOCK_EWOULDBLOCK;
		return XPSOCK_EOK;
	}


	struct timeval Timeout;
	Timeout.tv_sec = (long)timeoutSeconds;
	Timeout.tv_usec = (long)((timeoutSeconds - (float)Timeout.tv_sec) * 1000.0f);

	fd_set readfds;

	FD_ZERO(&readfds);
	FD_SET(socket->wins_socket , &readfds);

	asocket_lasterror = XPSOCK_EOK;
	return(select(1, &readfds, NULL, NULL, &Timeout));
}
#endif // ifndef _XBOX




int XPSock_GetSocketSelectMaxSize(void)
{
	return FD_SETSIZE;
}

int XPSock_SocketSelect(RNReplicaNet::t_XPSocket **sockets,const int numSockets, const int milliseconds)
{
	if ((numSockets > FD_SETSIZE) || (numSockets <= 0))
	{
		// If we cannot support the number of sockets then return there was data pending.
		return numSockets;
	}
	assert(sockets);

//	THREADSAFELOCKCLASS(g_xpsockets_lockclass);

	/* If this a local host connection then return XPSOCK_ESTACKNOTSTARTED */
	if (wsockets_started == 0)
	{
		asocket_lasterror = XPSOCK_ESTACKNOTSTARTED;
		return XPSOCK_EERROR;
	}

	struct timeval Timeout;
	Timeout.tv_sec = 0;
	Timeout.tv_usec = (long)(milliseconds * 1000);

	fd_set readfds;

	FD_ZERO(&readfds);
	int i;
	for (i=0;i<numSockets;i++)
	{
		XPSOCK_PARANOID(sockets[i]);
		FD_SET(sockets[i]->wins_socket , &readfds);
	}

	asocket_lasterror = XPSOCK_EOK;
	int ret = select(numSockets, &readfds, NULL, NULL, &Timeout);
	if (ret < 0)
	{
		// If there was an error then return there was data pending.
		return numSockets;
	}
	return ret;
}


// Useful operators to compare addresses
bool XPAddress::operator== (const XPAddress& b) const
{
	if ( (mIPv4 != b.mIPv4) || (mIPv6 != b.mIPv6) )
	{
		return false;
	}
	if (mIPv4 && b.mIPv4)
	{
		return (port == b.port) && (memcmp(addr,b.addr,sizeof(addr)) == 0);
	}

	if (mIPv6 && b.mIPv6)
	{
		return (port6 == b.port6) && (memcmp(addr6,b.addr6,sizeof(addr6)) == 0);
	}
	return false;
}

bool XPAddress::operator!= (const XPAddress& b) const
{
	return !(*this == b);
}

// Can be used with STL less<> tests
bool XPAddress::operator< (const XPAddress& b) const
{
	if (mIPv4 && b.mIPv4)
	{
		if (addr[0] < b.addr[0])
		{
			return true;
		}
		else if(addr[0] == b.addr[0])
		{
			if (addr[1] < b.addr[1])
			{
				return true;
			}
			else if (addr[1] == b.addr[1])
			{
				if (addr[2] < b.addr[2])
				{
					return true;
				}
				else if (addr[2] == b.addr[2])
				{
					if (addr[3] < b.addr[3])
					{
						return true;
					}
					else if (addr[3] == b.addr[3])
					{
						return (port < b.port);
					}
				}
			}
		}

		return false;
	}

	if (mIPv6 && b.mIPv6)
	{
		int ret = memcmp(addr6,b.addr6,sizeof(addr));
		if (ret < 0)
		{
			return true;
		}
		else if (ret == 0)
		{
			return (port6 < b.port6);
		}

		return false;
	}

	// For IPv6 with IPv4 checks. Make sure IPv4 is treated as the last half of IPv6
	if (mIPv4 && b.mIPv6)
	{
		unsigned char tempConv[16];
		memset(tempConv,0,sizeof(tempConv));
		tempConv[8] = addr[0];
		tempConv[10] = addr[1];
		tempConv[12] = addr[2];
		tempConv[14] = addr[3];
		int ret = memcmp(tempConv,b.addr6,sizeof(addr6));
		if (ret < 0)
		{
			return true;
		}
		else if (ret == 0)
		{
			return (port < b.port6);
		}

		return false;
	}

	if (mIPv6 && b.mIPv4)
	{
		unsigned char tempConv[16];
		memset(tempConv,0,sizeof(tempConv));
		tempConv[8] = b.addr[0];
		tempConv[10] = b.addr[1];
		tempConv[12] = b.addr[2];
		tempConv[14] = b.addr[3];
		int ret = memcmp(addr6,tempConv,sizeof(addr6));
		if (ret < 0)
		{
			return true;
		}
		else if (ret == 0)
		{
			return (port6 < b.port);
		}

		return false;
	}

	return false;
}

void RNReplicaNet::operator<< (RNReplicaNet::DynamicMessageHelper &message,const XPAddress &a)
{
	unsigned char yes = 1;
	unsigned char no = 0;

	if (a.mIPv4)
	{
		message << yes;
		message << a.addr[0];
		message << a.addr[1];
		message << a.addr[2];
		message << a.addr[3];
		message << a.port;
	}
	else
	{
		message << no;
	}

	if (a.mIPv6)
	{
		message << yes;
		int i;
		for (i=0;i<16;i++)
		{
			message << a.addr6[i];
		}
		message << a.port6;
	}
	else
	{
		message << no;
	}
}

void RNReplicaNet::operator>> (RNReplicaNet::DynamicMessageHelper &message,XPAddress &a)
{
	a.mIPv4 = false;
	a.mIPv6 = false;

	unsigned char included;
	message >> included;
	if (included)
	{
		a.mIPv4 = true;
		message >> a.addr[0];
		message >> a.addr[1];
		message >> a.addr[2];
		message >> a.addr[3];
		message >> a.port;
	}

	message >> included;
	if (included)
	{
		a.mIPv6 = true;
		int i;
		for (i=0;i<16;i++)
		{
			message >> a.addr6[i];
		}
		message >> a.port6;
	}
}
//From: RNXPSockets/XPSocketClass.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
/* A wrapper class for XPSockets */
#include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include "RNXPSockets/Inc/XPSocketClass.h"
//Skipping: #include "RNPlatform/Inc/ThreadClass.h"

using namespace RNReplicaNet;

XPSocket::XPSocket()
{
	// Make sure we have sockets started
	XPSock_Init();

	mSocket = NULL;
	mSocketState = TypeUndefined;
}

XPSocket::~XPSocket()
{
	if (mSocket)
	{
		Close();
	}
}

int XPSocket::GetLastError(void)
{
	return asocket_lasterror;
}

int XPSocket::Create(void)
{
	SOCKET_ASSERT_TYPE(TypeUDP);

	mSocket = XPSock_Create();

	if (mSocket == pXPSOCK_EERROR)
	{
		mSocket = NULL;
		return XPSOCK_EERROR;
	}

	return XPSOCK_EOK;
}

int XPSocket::Connect(const XPAddress &addr)
{
	SOCKET_ASSERT_TYPE(TypeUDP);

	return XPSock_Connect(mSocket,&addr);
}

int XPSocket::Send(const char *data)
{
	SOCKET_ASSERT_TYPE(TypeUDP);

	return XPSock_Send(mSocket,data,(int)strlen(data)+1);
}

int XPSocket::Send(const char *data,const int len)
{
	SOCKET_ASSERT_TYPE(TypeUDP);

	return XPSock_Send(mSocket,data,len);
}

int XPSocket::Recv(char *const data,const int maxlen)
{
	SOCKET_ASSERT_TYPE(TypeUDP);

	int ret = XPSock_Recv(mSocket,data,maxlen,XPSOCK_FNULL);

	return ret;
}

int XPSocket::Close(void)
{
	int ret = XPSOCK_EOK;
	if (mSocket != NULL)
	{
		ret = XPSock_Close(mSocket);
	}
	mSocket = NULL;
	mSocketState = TypeUndefined;
	return ret;
}

int XPSocket::Listen(const int port)
{
	SOCKET_ASSERT_TYPE(TypeUDP);

	return XPSock_Listen(mSocket,port);
}

int XPSocket::Listen(const XPAddress &addr)
{
	SOCKET_ASSERT_TYPE(TypeUDP);

	return XPSock_Listen(mSocket,&addr);
}

XPSocket *XPSocket::Accept(void)
{
	SOCKET_ASSERT_TYPEP(TypeUDP);

	t_XPSocket *socket;
	socket = XPSock_Accept(mSocket);

	if (!socket)
	{
		return 0;
	}

	if (socket == pXPSOCK_EERROR)
	{
		return pcXPSOCK_EERROR;
	}

	XPSocket *newSocket;
	newSocket = new XPSocket();

	newSocket->mSocket = socket;
	newSocket->mSocketState = TypeTCP;

	return newSocket;
}



int XPSocket::SetSendBuffer(const int size)
{
	return XPSock_SetSendBuffer(mSocket,size);
}

int XPSocket::SetRecvBuffer(const int size)
{
	return XPSock_SetRecvBuffer(mSocket,size);
}

int XPSocket::GetAddress(XPAddress *const addr)
{
	return XPSock_GetAddress(mSocket,addr);
}

int XPSocket::GetPeerAddress(XPAddress *const addr)
{
	return XPSock_GetPeerAddress(mSocket,addr);
}


int XPSocket::MutateSocket(XPSocket *socket)
{
	int ret = XPSOCK_EOK;

	ret = XPSock_Close(mSocket);

	mSocket = socket->mSocket;

	socket->mSocket = NULL;

	return ret;
}


bool XPSocket::IsAlive(void)
{
	return mSocket != NULL;
}

t_XPSocket *XPSocket::GetSocketPointer(void)
{
	return mSocket;
}

//From: RNXPSockets/XPSocketUrgentClass.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include "RNXPSockets/Inc/XPSocketUrgentClass.h"
//Skipping: #include "RNPlatform/Inc/ThreadClass.h"

using namespace RNReplicaNet;

int	XPSocketUrgent::Create(const int port)
{
	SOCKET_ASSERT_TYPE(TypeTCP);

	mSocket = XPSock_UrgentCreate(port);

	if (mSocket == pXPSOCK_EERROR)
	{
		mSocket = NULL;
		return XPSOCK_EERROR;
	}

	return XPSOCK_EOK;
}

int	XPSocketUrgent::Create(const XPAddress &addr)
{
	SOCKET_ASSERT_TYPE(TypeTCP);

	mSocket = XPSock_UrgentCreate(&addr);

	if (mSocket == pXPSOCK_EERROR)
	{
		mSocket = NULL;
		return XPSOCK_EERROR;
	}

	return XPSOCK_EOK;
}

int XPSocketUrgent::MakeBroadcast(void)
{
	SOCKET_ASSERT_TYPE(TypeTCP);

	return XPSock_UrgentMakeBroadcast(mSocket);
}

int XPSocketUrgent::Send(const char *data,const XPAddress &addr)
{
	SOCKET_ASSERT_TYPE(TypeTCP);

	return XPSock_UrgentSend(mSocket,data,(int)strlen(data),&addr);
}

int XPSocketUrgent::Send(const char *data,const int len,const XPAddress &addr)
{
	SOCKET_ASSERT_TYPE(TypeTCP);

	return XPSock_UrgentSend(mSocket,data,len,&addr);
}

int XPSocketUrgent::Recv(char *const data,const int maxlen,XPAddress *const addr)
{
	SOCKET_ASSERT_TYPE(TypeTCP);

	int ret = XPSock_UrgentRecv(mSocket,data,maxlen,XPSOCK_FNULL,addr);

	return ret;
}

//From: RNPlatform/MessageHelper.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "RNPlatform/Inc/MessageHelper.h"
#include "RNPlatform/Inc/PlatformInfo.h"
#include "RNXPCompression/Inc/XPCompression.h"

using namespace RNReplicaNet;

MessageHelper::MessageHelper() : mFirstPtr(0) , mBufferPtr(0) , mGuardSize(-1) , mLastSizeAdded(0)
{
}

MessageHelper::~MessageHelper()
{
}

void MessageHelper::SetBuffer(void *const buffer)
{
	mFirstPtr = mBufferPtr = (unsigned char *) buffer;
}

void *MessageHelper::GetBuffer(void) const
{
	return mFirstPtr;
}

void *MessageHelper::GetCurrentPosition(void) const
{
	return mBufferPtr;
}

void MessageHelper::AddVariable(void *buffer, const void *variable, const int size)
{
	assert(buffer);
	assert(variable);

	if (size <= 0)
	{
		return;
	}

	unsigned char *bufferVar = (unsigned char *) variable;
	unsigned char *dataBuffer = (unsigned char *) buffer;

	if (PlatformInfo::IsLittleEndian())
	{
		for (int i=0;i<size;i++)
		{
			dataBuffer[i] = bufferVar[i];
		}
	}
	else
	{
		for (int i=0;i<size;i++)
		{
			dataBuffer[i] = bufferVar[size - i - 1];
		}
	}
}

void MessageHelper::AddVariable(const void *variable,const int size)
{
	assert(mFirstPtr);
	assert(mBufferPtr);

	// This assert can be temporarily enabled to check for variables that are more than 4 bytes large being added.
	// Variables this large are not normally used by the code and can indicate an error.
#if 0
	if (!(size <= 4))
	{
		assert((size <= 4) && "MessageHelper::AddVariable: Trying to use a variable > 4");
	}
#endif

	if (size <= 0)
	{
		return;
	}

	AddVariable(mBufferPtr,variable,size);

	mBufferPtr += size;
	mLastSizeAdded = size;
}

void MessageHelper::AddData(const void *data,const int size)
{
	assert(mFirstPtr);
	assert(mBufferPtr);

	memcpy(mBufferPtr,data,size);

	mBufferPtr += size;
	mLastSizeAdded = size;
}

void MessageHelper::GetVariable(const void *buffer, void *const variable, const int size)
{
	assert(buffer);
	assert(variable);

	// This assert can be temporarily enabled to check for variables that are more than 4 bytes large being added.
	// Variables this large are not normally used by the code and can indicate an error.
#if 0
	if (!(size <= 4))
	{
		assert((size <= 4) && "MessageHelper::GetVariable: Trying to use a variable > 4");
	}
#endif

	if (size <= 0)
	{
		return;
	}

	unsigned char *bufferVar = (unsigned char *) variable;
	unsigned char *dataBuffer = (unsigned char *) buffer;

	if (PlatformInfo::IsLittleEndian())
	{
		for (int i=0;i<size;i++)
		{
			bufferVar[i] = dataBuffer[i];
		}
	}
	else
	{
		for (int i=0;i<size;i++)
		{
			bufferVar[size - i - 1] = dataBuffer[i];
		}
	}
}

void MessageHelper::GetVariable(void *const variable,const int size)
{
	assert(mFirstPtr);
	assert(mBufferPtr);

	if (size <= 0)
	{
		return;
	}

	SanityCheckGuardSize(GetSize() + size);

	GetVariable(mBufferPtr,variable,size);

	mBufferPtr += size;
}

void MessageHelper::GetData(void *const data,const int size)
{
	assert(data);
	assert(mFirstPtr);
	assert(mBufferPtr);

	if (size <= 0)
	{
		return;
	}

	SanityCheckGuardSize(GetSize() + size);

	memcpy(data,mBufferPtr,size);

	mBufferPtr += size;
}

void MessageHelper::SkipData(const int size)
{
	assert(mFirstPtr);
	assert(mBufferPtr);

	if (size <= 0)
	{
		return;
	}

	SanityCheckGuardSize(GetSize() + size);

	mBufferPtr += size;
}

int MessageHelper::GetSize(void) const
{
	return (int)(mBufferPtr - mFirstPtr);
}

void MessageHelper::SetSize(const int size)
{
	assert(size >= 0);

	if (size > 0)
	{
		assert(mFirstPtr);

		mBufferPtr = mFirstPtr + size;

		assert(mBufferPtr);
	}
	else
	{
		mBufferPtr = mFirstPtr;
	}
}


void MessageHelper::AddInteger(const int value)
{
	int copy = value;
	AddVariable(&copy,sizeof(copy));
}

void MessageHelper::AddFloat(const float value)
{
	float copy = value;
	AddVariable(&copy,sizeof(copy));
}

int MessageHelper::GetInteger(void)
{
	int copy;
	GetVariable(&copy,sizeof(copy));
	return copy;
}

float MessageHelper::GetFloat(void)
{
	float copy;
	GetVariable(&copy,sizeof(copy));
	return copy;
}

void MessageHelper::SetInt(void *buffer, const int offset, const int value)
{
	AddVariable( ((char *)buffer) + offset , &value , sizeof(value) );
}

void MessageHelper::SetShort(void *buffer, const int offset, const short value)
{
	AddVariable( ((char *)buffer) + offset , &value , sizeof(value) );
}

int MessageHelper::GetInt(const void *buffer, const int offset)
{
	int ret;
	GetVariable( ((char *)buffer) + offset , &ret , sizeof(ret) );
	return ret;
}

short MessageHelper::GetShort(const void *buffer, const int offset)
{
	short ret;
	GetVariable( ((char *)buffer) + offset , &ret , sizeof(ret) );
	return ret;
}

std::string MessageHelper::DumpAsHex(const void *data,const int size,const bool csv)
{
	std::string ret;
	int index = 0;
	while (index < size)
	{
		char tempHex[8];
		sprintf(tempHex,"%.2x",(unsigned int)((unsigned char *)data)[index]);
		ret += tempHex;
		if (index < (size-1) && csv)
		{
			ret += ",";
		}
		index++;
	}
	return ret;
}

void MessageHelper::SetGuardSize(const int size)
{
	mGuardSize = size;
}

void MessageHelper::SanityCheckGuardSize(const int newSize)
{
	if ((mGuardSize >= 0) && (newSize > mGuardSize) )
	{
#if defined(RN_EXCEPTIONS_ENABLED)
		throw MessageHelper::Exception();
#endif
	}
}

int MessageHelper::GetLastSizeAdded(void) const
{
	return mLastSizeAdded;
}

void MessageHelper::operator<<(const char *rhs)
{
	int len;
	if (!rhs)
	{
		len = 0;
		MESSAGEHELPER_ADDVARIABLE(len);
		return;
	}
	len = (int)strlen(rhs);
	MESSAGEHELPER_ADDVARIABLE(len);
	AddData(rhs,(int)len);
}

void MessageHelper::operator<<(const std::string &rhs)
{
	int len = (int) rhs.length();
	MESSAGEHELPER_ADDVARIABLE(len);
	if (len)
	{
		AddData( rhs.c_str() , len );
	}
}

void MessageHelper::operator>>(std::string &rhs)
{
	int len;
	MESSAGEHELPER_GETVARIABLE(len);
	if (len > 0)
	{
		SanityCheckGuardSize(GetSize() + len);

		std::string temp((char *)GetCurrentPosition(),len);
		rhs = temp;
		SetSize(GetSize() + (int)len);
	}
	else
	{
		rhs = "";
	}
}

void MessageHelper::operator<<(const bool &rhs)
{
	unsigned char myBool = rhs?1:0;
	MESSAGEHELPER_ADDVARIABLE(myBool);
}

void MessageHelper::operator>>(bool &rhs)
{
	unsigned char myBool;
	MESSAGEHELPER_GETVARIABLE(myBool);
	rhs = myBool?true:false;
}


DynamicMessageHelper::DynamicMessageHelper() : mBuffer(0)
{
	SetBufferSize();
}

DynamicMessageHelper::DynamicMessageHelper( const int size ) : mBuffer(0)
{
	SetBufferSize( size );
	EnsureBufferAllocated();
}

DynamicMessageHelper::DynamicMessageHelper( const void * message , const int size ) : mBuffer(0)
{
	SetBufferSize( size );
	EnsureBufferAllocated();
	if ( message )
	{
		AddData( message , size );
	}
}

DynamicMessageHelper::~DynamicMessageHelper()
{
	free(mBuffer);
}

void DynamicMessageHelper::SetBufferSize(const int size)
{
	if (mBuffer)
	{
		FreeBuffer();
	}
	mSize = size;
}

int DynamicMessageHelper::GetBufferSize(void)
{
	return mSize;
}

void DynamicMessageHelper::SetSize(const int size)
{
	CheckBufferSize(size);
	MessageHelper::SetSize(size);
}

void DynamicMessageHelper::AddVariable(const void *variable,const int size)
{
	CheckBufferSize(GetSize() + size);
	MessageHelper::AddVariable(variable,size);
}

void DynamicMessageHelper::AddData(const void *data,const int size)
{
	CheckBufferSize(GetSize() + size);
	MessageHelper::AddData(data,size);
}

void DynamicMessageHelper::EnsureBufferAllocated(void)
{
	CheckBufferSize(mSize);
}

void DynamicMessageHelper::CheckBufferSize(const int newSize)
{
	if (newSize > mSize)
	{
		// Try doubling the size first
		mSize = mSize * 2;
		// Last gasp grow attempt.
		if (newSize > mSize)
		{
			// By design this can include some extra breather space depending on the original size and the requested size.
			mSize += newSize;
		}
		// Allocate a new buffer
		void *newBuffer = malloc(mSize);
		assert(newBuffer);
		int oldSize = GetSize();
		// If there is a previous buffer...
		if (mBuffer)
		{
			// And it contains data then copy it over
			if (oldSize > 0)
			{
				memcpy(newBuffer,mBuffer,(size_t)oldSize);
			}
			// Free the old buffer
			free(mBuffer);
		}
		// Set the new buffer and restore the size it was previously
		mBuffer = newBuffer;
		MessageHelper::SetBuffer(mBuffer);
		SetSize(oldSize);
	}
	// If there is no buffer
	if (!mBuffer && mSize)
	{
		// Allocate and set the new buffer
		mBuffer = malloc(mSize);
		assert(mBuffer);
		MessageHelper::SetBuffer(mBuffer);
	}
}

void DynamicMessageHelper::FreeBuffer(void)
{
	free(mBuffer);
	mBuffer = 0;
	SetBufferSize();
	MessageHelper::SetBuffer(0);
}

static const unsigned int kDynamicMessageHelperMagic = 0x87120976;
static const unsigned int kDynamicMessageHelperVersion = 0;

bool DynamicMessageHelper::Write(const char *filename,const bool rawData)
{
	if (rawData)
	{
		FILE *fp = fopen(filename,"wb");
		if (!fp)
		{
			return false;
		}
		fwrite(GetBuffer(),1,(size_t)GetSize(),fp);
		fclose(fp);
		return true;
	}

	DynamicMessageHelper temp;
	temp << kDynamicMessageHelperMagic;
	temp << kDynamicMessageHelperVersion;
	int theSize = GetSize();
	temp << theSize;

	FILE *fp = fopen(filename,"wb");
	if (!fp)
	{
		return false;
	}

	fwrite(temp.GetBuffer(),1,(size_t)temp.GetSize(),fp);
	fwrite(GetBuffer(),1,(size_t)GetSize(),fp);

	fclose(fp);

	return true;
}

bool DynamicMessageHelper::Read(const char *filename,const bool rawData)
{
	if (rawData)
	{
		FILE *fp = fopen(filename,"rb");
		if (!fp)
		{
			return false;
		}

		fseek(fp,0,SEEK_END);
		int size = ftell(fp);
		fseek(fp,0,SEEK_SET);
		FreeBuffer();
		SetBufferSize(size);
		mLastSizeAdded = size;
		EnsureBufferAllocated();
		size_t freadRet = fread(GetBuffer(),1,size,fp);
		fclose(fp);
		SetSize(0);
		return true;
	}


	DynamicMessageHelper temp;
	temp.SetBufferSize(sizeof(kDynamicMessageHelperMagic) + sizeof(kDynamicMessageHelperVersion));
	temp.EnsureBufferAllocated();

	FILE *fp = fopen(filename,"rb");
	if (!fp)
	{
		return false;
	}

	size_t freadRet = fread(temp.GetBuffer(),1,sizeof(kDynamicMessageHelperMagic) + sizeof(kDynamicMessageHelperVersion),fp);

	unsigned int tempvar;
	temp >> tempvar;
	if (tempvar != kDynamicMessageHelperMagic)
	{
		fclose(fp);
		return false;
	}
	// Check the version
	temp >> tempvar;
	switch(tempvar)
	{
		default:
		{
			fclose(fp);
			return false;
		}
		break;
		case 0:
		{
			int bufSize;
			temp.SetSize(0);
			temp.SetBufferSize(sizeof(int) + sizeof(bool) + sizeof(bool));
			temp.EnsureBufferAllocated();
			size_t freadRet = fread(temp.GetBuffer(),1,sizeof(bufSize),fp);
			temp >> bufSize;
			// Allocate the extra space
			FreeBuffer();
			SetBufferSize(bufSize);
			mLastSizeAdded = bufSize;
			EnsureBufferAllocated();
			size_t ret = fread(GetBuffer(),1,(size_t)GetBufferSize(),fp);
			fclose(fp);
			assert(ret == (size_t)GetBufferSize());
			if (ret != (size_t)GetBufferSize())
			{
				return false;
			}
		}
		break;
	}
	

	return true;
}

void DynamicMessageHelper::operator<<(const char *rhs)
{
	*((MessageHelper*)this) << rhs;
}

void DynamicMessageHelper::operator<<(const std::string &rhs)
{
	*((MessageHelper*)this) << rhs;
}

void DynamicMessageHelper::operator>>(std::string &rhs)
{
	*((MessageHelper*)this) >> rhs;
}

void DynamicMessageHelper::operator<<(const DynamicMessageHelper &rhs)
{
	int len = rhs.GetSize();
	MESSAGEHELPER_ADDVARIABLE(len);
	AddData(rhs.GetBuffer(),rhs.GetSize());
}

void DynamicMessageHelper::operator>>(DynamicMessageHelper &rhs)
{
	int len;
	MESSAGEHELPER_GETVARIABLE(len);
	// Don't append, replace the rhs with our buffer
	rhs.SetSize(0);
	rhs.AddData(GetCurrentPosition(),(int)len);
	// Then reset the position to make sure it is ready to be read again
	rhs.SetSize(0);
	SetSize(GetSize() + (int)len);
}

void DynamicMessageHelper::operator<<(const bool &rhs)
{
	unsigned char myBool = rhs?1:0;
	MESSAGEHELPER_ADDVARIABLE(myBool);
}

void DynamicMessageHelper::operator>>(bool &rhs)
{
	unsigned char myBool;
	MESSAGEHELPER_GETVARIABLE(myBool);
	rhs = myBool?true:false;
}

bool DynamicMessageHelper::operator==(const DynamicMessageHelper &rhs) const
{
	if (this->GetSize() == rhs.GetSize())
	{
		return (memcmp(this->GetBuffer(),rhs.GetBuffer(),this->GetSize()) == 0);
	}
	return false;
}

bool DynamicMessageHelper::operator!=(const DynamicMessageHelper &rhs) const
{
	return !(*this == rhs);
}

static int NibbleDecode(const unsigned char thing)
{
	if (thing >= '0' && thing <= '9')
	{
		return thing - '0';
	}

	if (thing >= 'a' && thing <= 'f')
	{
		return (thing - 'a') + 10;
	}

	if (thing >= 'A' && thing <= 'F')
	{
		return (thing - 'A') + 10;
	}

	return -1;
}

bool DynamicMessageHelper::ReadAsHex(const std::string &data)
{
	size_t i;
	for (i=0;i<data.length();i+=2)
	{
		int nibble1 = NibbleDecode(data[i]);
		int nibble2 = NibbleDecode(data[i+1]);
		if (nibble1 == -1 || nibble2 == -1)
		{
			return false;
		}
		unsigned char value = (unsigned char) nibble2 | (nibble1 << 4);
		*this << value;
	}
	return true;
}
//From: RNPlatform/PlatformInfo.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
//Skipping: #include "RNPlatform/Inc/PlatformInfo.h"
#if defined(RN_UNIX_LIKE)
#include <unistd.h>
#endif
#if defined(_WIN32)
#include <windows.h>
#endif

using namespace RNReplicaNet;

/**
 * A union used to test for endianness of a machine
 */
union EndTest
{
	/**
	 * ctor to set a value directory
	 * \param x the value to set
	 */
	EndTest(int x)
	{
		s_value = x;
	}
	unsigned short s_value;		/**< The short value */
	unsigned char c_value[2];	/**< The two char values */
};

static EndTest s_endian = EndTest(1);

// The PS2 doesn't like to have pre-compile defines set by the build system so we check for the PS2 and always turn on RNUSETHREAD
#ifdef _PS2
#ifndef RNUSETHREAD
#define RNUSETHREAD
#endif
#endif

// Other builds set this flag to enable threading in the library
#ifdef IW_SDK
#include <s3eThread.h>
static bool isthreaded = s3eThreadAvailable()?true:false;
#else
#ifdef RNUSETHREAD
static bool isthreaded = true;
#else
static bool isthreaded = false;
#endif
#endif

bool PlatformInfo::IsThreaded(void)
{
	return isthreaded;
}

void PlatformInfo::SetThreaded(const bool allow)
{
	isthreaded = allow;
}

bool PlatformInfo::IsLittleEndian(void)
{
	if (s_endian.c_value[0] == 1)
	{
		return true;
	}

	return false;
}

static int sProcessorReplicaNet = kReplicaNetPreferredProcessorOSChoice;
void PlatformInfo::SetProcessorReplicaNet(const int processor)
{
	sProcessorReplicaNet = processor;
}
int PlatformInfo::GetProcessorReplicaNet(void)
{
	return sProcessorReplicaNet;
}

static int sProcessorXPSession = kReplicaNetPreferredProcessorOSChoice;
void PlatformInfo::SetProcessorXPSession(const int processor)
{
	sProcessorXPSession = processor;
}
int PlatformInfo::GetProcessorXPSession(void)
{
	return sProcessorXPSession;
}

static int sProcessorXPURL = kReplicaNetPreferredProcessorOSChoice;
void PlatformInfo::SetProcessorXPURL(const int processor)
{
	sProcessorXPURL = processor;
}
int PlatformInfo::GetProcessorXPURL(void)
{
	return sProcessorXPURL;
}

int PlatformInfo::GetNumberOfCores(void)
{
	static int ret = 0;

	// First time round cache the result. Nobody should be adding or removing cores during runtime. :)
	if ( !ret )
	{
		ret = 1;	// Default to 1 core if no other platform code below fills it in
#if defined(RN_UNIX_LIKE)
		ret = (int) sysconf(_SC_NPROCESSORS_ONLN);
#endif
#if defined(_WIN32)
		SYSTEM_INFO sysinfo;
		GetSystemInfo(&sysinfo);
		ret = (int) sysinfo.dwNumberOfProcessors;
#endif
		if ( ret <= 1 )
		{
			ret = 1;
		}
	}
	return ret;
}
//From: RNPlatform/sys_time.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"

#if defined(_XBOX)
#include <xtl.h>			// For XBox builds
#else
#if defined(_WIN32)
#include <windows.h>		// For Windows builds
#endif
#endif

#include <assert.h>

#include <time.h>
#include <memory.h>

#if defined(RN_UNIX_LIKE)
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <stdio.h>
#include <dirent.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/time.h>
#define USETIMEOFDAY
#endif

#if defined(_PS2)
#include <eekernel.h>
#endif

//Skipping: #include "RNPlatform/Inc/SysTime.h"
//Include inline: #include "RNPlatform/DebugSupport.h"
//From: RNPlatform/DebugSupport.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef __DEBUGSUPPORT_H__
#define __DEBUGSUPPORT_H__
// Final builds always disable the debug prints unless REPNET_ENABLEDEBUGPRINT is defined in the pre-processor
#ifndef _FINAL
#define REPNET_ENABLEDEBUGPRINT
#endif

#ifdef REPNET_ENABLEDEBUGPRINT
extern void repnet_dprintf(const char *format, ...);
#else
// Hopefully the compiler will optimise this to be nothing.
inline void repnet_dprintf(const char *, ...) {}
#endif
#define dprintf repnet_dprintf

#endif

// First is the best
// Last is the worst
#if defined(_WIN32)
#define STRES1
//#define STRES2
//#define USECLOCK
#else
#if defined(RN_UNIX_LIKE)
#define USETIMEOFDAY
#endif
#if defined(_PS2)
#define PS2HPF
#endif
#endif

using namespace RNReplicaNet;

SysTime::SysTime(void)
{
	Reset();
}

void SysTime::Reset(void)
{
#ifdef STRES1
	if (!QueryPerformanceFrequency (&PerformanceFreq))
	{
//		MessageBox(NULL,"No hardware timer available","Error",MB_OK);
		assert(false && "No hardware timer available");
		exit(-1);
	}

	first = 1;
	FloatTime ();
	return;

#elif defined(STRES2)

	unsigned int	lowpart, highpart;

	if (!QueryPerformanceFrequency (&PerformanceFreq))
	{
		MessageBox(NULL,"No hardware timer available","Error",MB_OK);
		exit(-1);
	}

// get 32 out of the 64 time bits such that we have around
// 1 microsecond resolution
	lowpart = (unsigned int)PerformanceFreq.LowPart;
	highpart = (unsigned int)PerformanceFreq.HighPart;
	lowshift = 0;

	while (highpart || (lowpart > 2000000.0))
	{
		lowshift++;
		lowpart >>= 1;
		lowpart |= (highpart & 1) << 31;
		highpart >>= 1;
	}

	pfreq = 1.0 / (double)lowpart;


	FloatTime ();
	curtime = 0.0;
	lastcurtime = curtime;

	sametimecount = 0;
	oldtime = 0;
	first = 1;
	return;

#elif defined(PS2HPF)

	mPS2Initial = GetTimerSystemTime();
	FloatTime();

#elif defined(USECLOCK) || defined(USETIMEOFDAY)

	first = 1;
	FloatTime();
	return;

#endif
}

SysTime::~SysTime(void)
{
}

SysTimeType SysTime::FloatTime (void)
{
#ifdef STRES1
	LARGE_INTEGER		PerformanceCount;

	QueryPerformanceCounter (&PerformanceCount);

	if (first)
	{
		startticktime = PerformanceCount;
		first = 0;
	}

	PerformanceCount.QuadPart -= startticktime.QuadPart;

	double floattime = double(PerformanceCount.QuadPart);
	floattime /= double(PerformanceFreq.QuadPart);
	return (SysTimeType) floattime;

#elif defined(STRES2)

	LARGE_INTEGER		PerformanceCount;
	unsigned int		temp, t2;
	double				time;

	QueryPerformanceCounter (&PerformanceCount);

	temp = ((unsigned int)PerformanceCount.LowPart >> lowshift) |
		   ((unsigned int)PerformanceCount.HighPart << (32 - lowshift));

	if (first)
	{
		oldtime = temp;
		first = 0;
	}
	else
	{
	// check for turnover or backward time
		if ((temp <= oldtime) && ((oldtime - temp) < 0x10000000))
		{
			oldtime = temp;	// so we can't get stuck
		}
		else
		{
			t2 = temp - oldtime;
			time = (double)t2 * pfreq;
			oldtime = temp;

			curtime += time;

			if (curtime == lastcurtime)
			{
				sametimecount++;

				if (sametimecount > 100000)
				{
					curtime += 1.0;
					sametimecount = 0;
				}
			}
			else
			{
				sametimecount = 0;
			}

			lastcurtime = curtime;
		}
	}

	return (SysTimeType)curtime;

#elif defined(USECLOCK)

	unsigned int nowtick = clock();

	if (first)
	{
		mBaseTickCount = nowtick;
		first = 0;
	}

	double realtime = (double) (nowtick-mBaseTickCount);
	realtime = realtime / double(CLOCKS_PER_SEC);

//	dprintf("nowtick = %d realtime %f\n",nowtick,realtime);
//	dprintf("CLOCKS_PER_SEC %d\n",CLOCKS_PER_SEC);

	return (SysTimeType) realtime;

#elif defined(USETIMEOFDAY)

	struct timeval tp;
	struct timezone tzp;

	gettimeofday(&tp, &tzp);

	unsigned int curtime;

	if (first)
	{
		mSecBase = tp.tv_sec;
		mBaseTickCount = (tp.tv_usec/1000);
		first = 0;
	}

	curtime = ((tp.tv_sec - mSecBase)*1000) + (tp.tv_usec/1000);

	double realtime = (double) (curtime-mBaseTickCount);
	realtime = realtime / 1000.0f;

//	dprintf("nowtick = %d realtime %f\n",nowtick,realtime);
//	dprintf("CLOCKS_PER_SEC %d\n",CLOCKS_PER_SEC);

	return (SysTimeType) realtime;

#elif defined(PS2HPF)

	// These standard eekernel functions are used in preference to the ProfileAndTiming routines for simplicity
	// It is accurate at ~147 MHz
	u_long now = GetTimerSystemTime();
	now = now - mPS2Initial;

	u_int seconds,usec;
	TimerBusClock2USec(now,&seconds,&usec);

	SysTimeType theTime = SysTimeType(seconds) + (SysTimeType(usec)/1000000.0f);
	return theTime;

#else

	return 0.0f;

#endif
}

unsigned int SysTime::GetTickCount(void)
{
#if defined(_WIN32)
	return (unsigned int) ::GetTickCount();
#elif defined(USETIMEOFDAY)
	struct timeval tv;
	struct timezone tz;

	gettimeofday(&tv, &tz);
	return ( ( u_long) tv.tv_usec / 1000 );
#elif defined(PS2HPF)
	u_long now = GetTimerSystemTime();
	u_int seconds,usec;
	TimerBusClock2USec(now,&seconds,&usec);
	return usec / 1000;
#else
	return 0;
#endif
}

void SysTime::GetSystemTime(SystemTime *sysTime)
{
	assert(sysTime);
	if (!sysTime)
	{
		return;
	}
#if defined(_WIN32)

	::SYSTEMTIME theTime;
	::GetSystemTime(&theTime);
	sysTime->wYear = theTime.wYear;
	sysTime->wMonth = theTime.wMonth;
	sysTime->wDayOfWeek = theTime.wDayOfWeek;
	sysTime->wDay = theTime.wDay;
	sysTime->wHour = theTime.wHour;
	sysTime->wMinute = theTime.wMinute;
	sysTime->wSecond = theTime.wSecond;
	sysTime->wMilliseconds = theTime.wMilliseconds;

	// MPi: TODO: Implement
//#elif defined(RN_UNIX_LIKE)
#else

	// All other unimplemented platforms
	memset(sysTime,0,sizeof(SystemTime));
#endif
}
//From: RNPlatform/CheckSum.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdlib.h>
#include <assert.h>
#include "RNPlatform/Inc/CheckSum.h"

using namespace RNReplicaNet;

int Checksum::ChecksumData( const void *buffer , const size_t length )
{
	// This is the new checksum code
	// Set a seed value for the checksum
	int checksum = 1234567;

	// Checksum the whole data
	size_t i;
	for (i = 0;i<length;i++)
	{
		// Use a simple multiplication and addition step to produce a predictable change in the working checksum value
		int value = ((char *)buffer)[i];
		value = value & 0xff;
		if (value == 0)
		{
			value = 1;
		}

		checksum = checksum ^ value;
		checksum = checksum ^ (value << 7);
		checksum = checksum ^ (value << 14);
		checksum = checksum ^ (value << 21);
		checksum = checksum ^ (value << 28);
		checksum++;

		// If the working value of the checksum is 0 then set it to be 1
		if (checksum == 0)
		{
			checksum = 1;
		}
	}

	return checksum;
}


void Checksum::ChecksumDataWithSlots( int *checksumSlots , const size_t numSlots , const void *buffer , const size_t length , const bool initialiseSlots  , const bool initialiseSlotsWithLength)
{
	assert(numSlots > 0);
	if ( numSlots == 0 )
	{
		return;
	}

	if ( initialiseSlots || initialiseSlotsWithLength)
	{
		size_t i;
		size_t tlength;
		if ( initialiseSlotsWithLength )
		{
			tlength = length;
		}
		else
		{
			tlength = numSlots;
		}
		for ( i = 0 ; i < numSlots ; i++ )
		{
			checksumSlots[i] = (int) ( (((int)tlength)+2) ^ ((((int)tlength)+3) << 8) ^ ((((int)tlength)+5) << 16) ^ ((((int)tlength)+8) << 24) );
			tlength += 13;
			tlength ^= (tlength >> 9);
		}
	}

	if ( length == 0 )
	{
		return;
	}

	char *tbuffer = (char *)buffer;
	size_t tlength = length;
	while (tlength)
	{
		size_t i;
		for (i=0;(i<numSlots) && tlength;i++)
		{
			int value = *tbuffer;
			value = value & 0xff;
			if (value == 0)
			{
				value = 1;
			}

			int checksum = checksumSlots[i];

			checksum = checksum ^ value;
			checksum = checksum ^ (value << 7);
			checksum = checksum ^ (value << 14);
			checksum = checksum ^ (value << 21);
			checksum = checksum ^ (value << 28);
			checksum++;

			checksumSlots[i] = checksum;

			tbuffer++;
			tlength--;
		}
	}
}
//From: RNPlatform/DebugSupport.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>

#ifdef IW_SDK
// Airplay SDK
#include <s3e.h>
#endif

#if defined(_WIN32)
#include <io.h>
#endif

//Skipping: #include "RNPlatform/DebugSupport.h"
#include <stdarg.h>

// Pull in windows or XBox headers
#if defined(_XBOX)
#include <xtl.h>			// For XBox builds
#else
#if defined(_WIN32)
#include <windows.h>		// For Windows builds
#endif
#endif

//#define DEBUG_ON
//#define DEBUG_FILE
//#define DEBUG_OUTPUT
//#define DEBUG_PRINTF

// If we're running Linux or a PS2 version then turn off file and output debug string functionality
#if defined(RN_UNIX_LIKE) || defined(_PS2)
#ifdef DEBUG_FILE
#undef DEBUG_FILE
#endif
#ifdef DEBUG_OUTPUT
#undef DEBUG_OUTPUT
#endif
#endif

#ifdef DEBUG_FILE
static bool fileNameDone = false;
static char bufferName[256];
#endif

// If any kind of final build turn off all prints no matter what we defined above
#ifdef _FINAL
#ifdef DEBUG_ON
#undef DEBUG_ON
#endif
#endif

#ifdef REPNET_ENABLEDEBUGPRINT
#ifdef _MSC_VER
#pragma warning (disable : 4793)
#endif
void repnet_dprintf(const char *format, ...)
{
#ifdef DEBUG_ON
	char buffer[8192];
	va_list	ap;
	va_start(ap, format);
	int len = vsnprintf(buffer, sizeof(buffer)-1, format, ap);
	buffer[sizeof(buffer)-1] = '\0';
	if (len > 0)
	{
		buffer[len] = '\0';
	}
	va_end(ap);

#ifdef DEBUG_FILE
	if (!fileNameDone)
	{
		char buffer[256];
		strcpy(buffer,"dbgXXXXXX");
		_mktemp(buffer);
		sprintf(bufferName,"c:\\Debugging\\%s.txt",buffer);
		fileNameDone = true;
	}
	FILE *outfle = fopen(bufferName,"a+");
	if (outfle)
	{
		fprintf(outfle,"%s",buffer);
		fflush(outfle);
		fclose(outfle);
	}
#endif

#ifdef DEBUG_OUTPUT
#if defined(_WIN32)
	OutputDebugString(buffer);
#endif
#endif

#ifdef DEBUG_PRINTF
	printf("%s",buffer);
#endif

#ifdef IW_SDK
	s3eDebugTraceLine(buffer);
#endif

#endif // ifdef DEBUG_ON
}
#endif // ifdef REPNET_ENABLEDEBUGPRINT
//From: RNPlatform/Encryption.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <assert.h>
#if _MSC_VER >= 1600
#include <stdint.h>
#define GOTUINTPTR
#endif
#if defined(RN_UNIX_LIKE)
#include <stdint.h>
#define GOTUINTPTR
#endif
#include <string.h>
#include "RNPlatform/Inc/Encryption.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"

#if !defined(GOTUINTPTR)
typedef unsigned int   uintptr_t;
#endif

using namespace RNReplicaNet;

static unsigned int RotateRightNH(unsigned int value,int places)
{
	assert(places < 16);
	assert(places >= 0);
	if (!places)
	{
		return value;
	}

	unsigned int work;

	work = value >> places;
	work = work | (value << (32 - places));

	return work;
}

static unsigned int RotateRightN(unsigned int value,int places)
{
	unsigned int work;

	work = RotateRightNH(value , places & 15);
	work = RotateRightNH(work , places >> 4);

	return work;
}

static unsigned char RotateRightNHByte(unsigned char value,int places)
{
	assert(places < 8);
	assert(places >= 0);
	if (!places)
	{
		return value;
	}

	unsigned int work;

	work = value >> places;
	work = work | (value << (8 - places));

	return work;
}

static unsigned char RotateRightNByte(unsigned char value,int places)
{
	unsigned char work;

	work = RotateRightNHByte(value , places & 7);
	work = RotateRightNHByte(work , (places >> 3) & 7);
	work = RotateRightNHByte(work , (places >> 6) & 7);

	return work;
}

static unsigned int RotateLeftNH(unsigned int value,int places)
{
	assert(places < 16);
	assert(places >= 0);
	if (!places)
	{
		return value;
	}

	unsigned int work;

	work = value << places;
	work = work | (value >> (32 - places));

	return work;
}

static unsigned int RotateLeftN(unsigned int value,int places)
{
	unsigned int work;

	work = RotateLeftNH(value , places & 15);
	work = RotateLeftNH(work , places >> 4);

	return work;
}

static unsigned char RotateLeftNHByte(unsigned char value,int places)
{
	assert(places < 8);
	assert(places >= 0);
	if (!places)
	{
		return value;
	}

	unsigned int work;

	work = value << places;
	work = work | (value >> (8 - places));

	return work;
}

static unsigned char RotateLeftNByte(unsigned char value,int places)
{
	unsigned char work;

	work = RotateLeftNHByte(value , places & 7);
	work = RotateLeftNHByte(work , (places >> 3) & 7);
	work = RotateLeftNHByte(work , (places >> 6) & 7);

	return work;
}


void Encryption::Encrypt(void *data,int length,Key *key)
{
	unsigned int work;
	unsigned char workb;
	int i;
	int block = 0;
	int worklength = length;

	worklength &= ~3;

	for (i=0;i<worklength;i+=4)
	{
		MessageHelper::GetVariable( ((unsigned char *)data)+i , &work , sizeof(work));

		work = work ^ ((unsigned int *)(&key->mKey[block&(~3)]))[0];

		work = RotateRightN(work,key->mKey[block]);

		MessageHelper::AddVariable( ((unsigned char *)data)+i , &work , sizeof(work));

		block++;
		if (block >= kEncryptionKeyLengthBytes)
		{
			block = 0;
		}
	}

	for (i=worklength;i<length;i++)
	{
		workb = ((unsigned char *)(((unsigned char *)data)+i))[0];

		workb = workb ^ ((unsigned char *)(&key->mKey[block]))[0];

		workb = RotateRightNByte(workb,key->mKey[block]);

		((unsigned char *)(((unsigned char *)data)+i))[0] = workb;

		block++;
		if (block >= kEncryptionKeyLengthBytes)
		{
			block = 0;
		}
	}
}

void Encryption::Decrypt(void *data,int length,Key *key)
{
	unsigned int work;
	unsigned char workb;
	int i;
	int block = 0;
	int worklength = length;

	worklength &= ~3;

	for (i=0;i<worklength;i+=4)
	{
		MessageHelper::GetVariable( ((unsigned char *)data)+i , &work , sizeof(work));

		work = RotateLeftN(work,key->mKey[block]);

		work = work ^ ((unsigned int *)(&key->mKey[block&(~3)]))[0];

		MessageHelper::AddVariable( ((unsigned char *)data)+i , &work , sizeof(work));

		block++;
		if (block >= kEncryptionKeyLengthBytes)
		{
			block = 0;
		}
	}

	for (i=worklength;i<length;i++)
	{
		workb = ((unsigned char *)(((unsigned char *)data)+i))[0];

		workb = RotateLeftNByte(workb,key->mKey[block]);

		workb = workb ^ ((unsigned char *)(&key->mKey[block]))[0];

		((unsigned char *)(((unsigned char *)data)+i))[0] = workb;

		block++;
		if (block >= kEncryptionKeyLengthBytes)
		{
			block = 0;
		}
	}
}

static void CommutativeCommon(void *data,int length,Encryption::Key *key)
{
	unsigned int work;
	unsigned char workb;
	int i;
	int block = 0;
	int worklength = length;

	worklength &= ~3;

	for (i=0;i<worklength;i+=4)
	{
		MessageHelper::GetVariable( ((unsigned char *)data)+i , &work , sizeof(work));

		work = work ^ ((unsigned int *)(&key->mKey[block&(~3)]))[0];

		MessageHelper::AddVariable( ((unsigned char *)data)+i , &work , sizeof(work));

		block++;
		if (block >= kEncryptionKeyLengthBytes)
		{
			block = 0;
		}
	}

	for (i=worklength;i<length;i++)
	{
		workb = ((unsigned char *)(((unsigned char *)data)+i))[0];

		workb = workb ^ ((unsigned char *)(&key->mKey[block]))[0];

		((unsigned char *)(((unsigned char *)data)+i))[0] = workb;

		block++;
		if (block >= kEncryptionKeyLengthBytes)
		{
			block = 0;
		}
	}
}

void Encryption::CommutativeEncrypt(void *data,int length,Key *key)
{
	assert( (((uintptr_t)data)&3)==0 && "Encryption::Encrypt() passed address to non-aligned buffer" );

	CommutativeCommon( data , length , key );
}

void Encryption::CommutativeDecrypt(void *data,int length,Key *key)
{
	assert( (((uintptr_t)data)&3)==0 && "Encryption::Decrypt() passed address to non-aligned buffer" );

	CommutativeCommon( data , length , key );
}

static void CommutativeBytewiseCommon(void *data,int length,Encryption::Key *key)
{
	unsigned char workb;
	int i;
	int block = 0;
	int worklength = length;

	for (i=0;i<length;i++)
	{
		workb = ((unsigned char *)(((unsigned char *)data)+i))[0];

		workb = workb ^ ((unsigned char *)(&key->mKey[block]))[0] ^ i;

		((unsigned char *)(((unsigned char *)data)+i))[0] = workb;

		block++;
		if (block >= kEncryptionKeyLengthBytes)
		{
			block = 0;
		}
	}
}

void Encryption::CommutativeEncryptBytewise(void *data,int length,Key *key)
{
	CommutativeBytewiseCommon( data , length , key );
}

void Encryption::CommutativeDecryptBytewise(void *data,int length,Key *key)
{
	CommutativeBytewiseCommon( data , length , key );
}


Encryption::Key::Key()
{
	Create(0,0);
}

Encryption::Key::Key(const Key &source)
{
	memcpy(mKey , source.mKey , sizeof(mKey));
}

Encryption::Key::~Key()
{
}

void Encryption::Key::Create(const void *data,const int length)
{
	int i,counter = 0;

	for (i=0;i<kEncryptionKeyLengthBytes;i++)
	{
		mKey[i] = 170+i;
		if (length > 0 && data != 0)
		{
			mKey[i] = ((unsigned char *)data)[counter] ^ (170+i);
			counter++;
			if (counter >= length)
			{
				counter = 0;
			}
		}
	}
}

void Encryption::Key::AddCrypto(const unsigned char salt)
{
	AddCrypto(&salt , sizeof(salt));
}

void Encryption::Key::AddCrypto(const void *data,const int length)
{
	int i,counter = 0;

	for (i=0;i<kEncryptionKeyLengthBytes;i++)
	{
		if (length > 0 && data != 0)
		{
			mKey[i] = ((unsigned char *)data)[counter] ^ mKey[i];
			counter++;
			if (counter >= length)
			{
				counter = 0;
			}
		}
	}
}
//From: RNPlatform/Thread.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#if defined(_XBOX)
#include <xtl.h>			// For XBox builds
#else
#if defined(_WIN32)
#include <windows.h>		// For Windows builds
#include <process.h>
#endif
#endif

#include <assert.h>

#if defined(_PS2)
#include <eekernel.h>
#endif

#include <stdio.h>
#include <assert.h>
#include "RNPlatform/Inc/Thread.h"
//Skipping: #include "RNPlatform/Inc/ThreadClass.h"
//Skipping: #include "RNPlatform/Inc/PlatformInfo.h"
//Skipping: #include "RNPlatform/DebugSupport.h"

#if defined(RN_UNIX_LIKE)
#include <signal.h>
#include <pthread.h>
#endif

using namespace RNReplicaNet;

#if defined(RN_UNIX_LIKE)
//static int sig_list[] = {SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGALRM, SIGTERM, SIGCHLD, SIGWINCH,SIGVTALRM, SIGPROF, 0};
static bool pthreadInitDone = false;
static void setuppthread(void)
{
#if 0
	int i;
	sigset_t mask;

	/* Mask asynchronous signals for this thread */
	sigemptyset(&mask);
	for ( i=0; sig_list[i]; ++i )
	{
		sigaddset(&mask, sig_list[i]);
	}
	pthread_sigmask(SIG_BLOCK, &mask, 0);
#endif

	/* Allow ourselves to be asynchronously canceled */
	// MPi: TODO: Check Airplay SDK
#ifdef pthread_setcanceltype
	int oldstate;
	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &oldstate);
#endif
}
#endif

size_t Thread::mNumAllocated = 0;
size_t Thread::mNumActive = 0;
Thread::Thread() : mThreadClass(0) , mThreadHandle(0) , mProcessor(kReplicaNetPreferredProcessorOSChoice) , mIsRunning(false) , mTerminateCalled(false) , mTerminateCalledNoReset(true)
{
	mNumAllocated++;
#if defined(RN_UNIX_LIKE)
	if (!pthreadInitDone)
	{
		pthreadInitDone = true;
//printf("setuppthread()\n");
		setuppthread();
//printf("setuppthread() end\n");
	}
#endif
}

Thread::~Thread()
{
	mNumAllocated--;
	Terminate();
}

#if defined(_WIN32)
//static DWORD WINAPI ThreadEntry(LPVOID lpThreadParameter)
static unsigned __stdcall ThreadEntry(void *lpThreadParameter)
{
	if (PlatformInfo::IsThreaded())
	{
		return Thread::CallThreadEntry((ThreadClass *) lpThreadParameter);
	}
	return 0;
}
#endif

#if defined(RN_UNIX_LIKE)
static void *ThreadEntry(void *lpThreadParameter)
{
	if (PlatformInfo::IsThreaded())
	{
		return (void *)Thread::CallThreadEntry((ThreadClass *) lpThreadParameter);
	}
	return (void*)0;
}
#endif

#if defined(_PS2)
static void ThreadEntry(void *lpThreadParameter)
{
	if (PlatformInfo::IsThreaded())
	{
		ThreadClass *theClass;
		ThreadParam theParam;
		ReferThreadStatus(GetThreadId(),&theParam);
		theClass = (ThreadClass *) theParam.gpReg;

		Thread::CallThreadEntry(theClass);
		return;
	}
}
#endif

#ifdef _WIN32
#ifdef _DEBUG
//#include <map>
//std::map<DWORD,ThreadClass *> sThreadsAllocated;
#endif
#endif

void Thread::Begin(ThreadClass *thread_class)
{
//dprintf("Thread::Begin $%p\n",this);
	if (PlatformInfo::IsThreaded())
	{
		mNumActive++;
		thread_class->mBoundThread = this;
		thread_class->mThreadExitingCalled = false;
		mTerminateCalled = false;
		mIsRunning = true;
		mThreadClass = thread_class;
		mThreadClass->mQuitNow = false;
#if defined(_WIN32)
//		DWORD threadId;
//		mThreadHandle = CreateThread(0,0,ThreadEntry,thread_class,CREATE_SUSPENDED,&threadId);
		unsigned threadId = 0;
#ifdef RNUSETHREAD
		mThreadHandle = (void*) _beginthreadex( 0 , 0 , ThreadEntry , thread_class , CREATE_SUSPENDED , &threadId);
#else
		assert( !"No _beginthreadex" );
#endif //<ifdef RNUSETHREAD

#ifdef _XBOX360
		if (mProcessor != kReplicaNetPreferredProcessorOSChoice)
		{
			DWORD ret = XSetThreadProcessor(mThreadHandle,(DWORD)mProcessor);
			assert((ret != -1) && "Thread::Begin XSetThreadProcessor failed\n");
		}
#endif

		ResumeThread(mThreadHandle);

#ifdef _DEBUG
//		sThreadsAllocated.insert(std::pair<DWORD,ThreadClass *>(threadId,thread_class));
#endif
//		unsigned lpThreadId;
//		mThreadHandle = _beginthreadex(0,0,ThreadEntry,thread_class,0,&lpThreadId);
#endif
#if defined(RN_UNIX_LIKE)
//		dprintf("Begin()\n");
		pthread_attr_t type;

		/* Set the thread attributes */
		if ( pthread_attr_init(&type) != 0 )
		{
			mIsRunning = false;
			dprintf("Couldn't initialize pthread attributes\n");
			return;
		}
		pthread_attr_setdetachstate(&type, PTHREAD_CREATE_JOINABLE);

//		dprintf("pthread_create()\n");
		/* Create the thread and go! */
		if ( pthread_create(&mThreadHandle, &type, ThreadEntry, thread_class) != 0 )
		{
			mIsRunning = false;
			dprintf("Not enough resources to create thread\n");
			return;
		}
//		dprintf("Begin() end\n");
		return;
#endif
#if defined(_PS2)
	/****** create & start thread ******/
//	struct ThreadParam *st = new ThreadParam;
	struct ThreadParam st;
	memset(&st,0,sizeof(st));
	st.entry = ThreadEntry;
	char *mem = (char *) malloc(4096+16);
	// Align the memory to 16 byte boundary
	mem += 16 - (((int)mem)&15);
	st.stack = mem;
	st.stackSize = 4096;
	st.initPriority = 1;
	st.gpReg = thread_class;
	mThreadHandle = CreateThread( &st );
	StartThread( mThreadHandle, NULL );
	st.gpReg = 0;
#endif
	}
}

void Thread::Terminate(void)
{
	// Outside of the IsThreaded check because it is not reset by Begin()
	mTerminateCalledNoReset = true;

//dprintf("Thread::Terminate $%p\n",this);
	if (PlatformInfo::IsThreaded())
	{
		mTerminateCalled = true;
		if (mThreadClass)
		{
			// Set the thread flag to quit
			mThreadClass->mQuitNow = true;
		}
#if defined(_WIN32)
		// Wait for the exit code to not be STILL_ACTIVE
		DWORD ExitCode;
//		dprintf("Thread::Terminate: handle $%p\n",(int)mThreadHandle);

		if (mThreadHandle && (mThreadHandle != INVALID_HANDLE_VALUE))
		{
			do
			{
				ExitCode = 0;
//				GetExitCodeThread(mThreadHandle,&ExitCode);
				DWORD ret = WaitForSingleObject((HANDLE)mThreadHandle,INFINITE);
				GetExitCodeThread((HANDLE)mThreadHandle,&ExitCode);
//				printf("Waiting for thread exit\n");
				if (ExitCode == STILL_ACTIVE)
				{
					// We should never get here due to the wait for single object
					CurrentThread::Sleep(10);
				}
			} while (ExitCode == STILL_ACTIVE);
			CloseHandle((HANDLE)mThreadHandle);
		}
		mThreadHandle = 0;
#endif
#if defined(RN_UNIX_LIKE)
		if (mThreadClass)
		{
//			printf("Wait pthread_join\n");
			void *ret;
			pthread_join(mThreadHandle,&ret);
//			printf("Got pthread_join\n");
		}
#endif
#if defined(_PS2)
		if (mThreadClass)
		{
			// TODO : Extra clean up of the thread needs to be done here of the thread stack
			SuspendThread(mThreadHandle);
		}
#endif
		mIsRunning = false;
		mThreadClass = 0;
	}
}

int Thread::CallThreadEntry(ThreadClass *thread_class)
{
	if (PlatformInfo::IsThreaded())
	{
//dprintf("CallThreadEntry()\n");
		int ret = thread_class->ThreadEntry();

		thread_class->CallThreadExiting(ret);

		if (thread_class->mBoundThread)
		{
			thread_class->mBoundThread->mIsRunning = false;
		}
		return ret;
	}
	return 0;
}

bool Thread::GetIsRunning(void) const
{
	return mIsRunning;
}

bool Thread::GetTerminated(void)
{
	return mTerminateCalled;
}

bool Thread::GetEverTerminated(void)
{
	return mTerminateCalledNoReset;
}

void Thread::SetPreferredProcessor(int processor)
{
	mProcessor = processor;
}

int Thread::GetPreferredProcessor(void)
{
	return mProcessor;
}

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4035)
#pragma warning(disable : 4793)
#endif
int Thread::GetCurrentProcessorNumber(void)
{
#if defined(_MSC_VER) && defined(_WIN32) && !defined(_WIN64)
	_asm {mov eax, 1}
	_asm {cpuid}
	_asm {shr ebx, 24}
	_asm {mov eax, ebx}
#else
	// MPi: TODO: Implement other platforms
	return -1;
#endif
}
#ifdef _MSC_VER
#pragma warning(pop)
#endif
//From: RNPlatform/ThreadClass.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#if defined(_XBOX)
#include <xtl.h>			// For XBox builds
#include <stdio.h>
#include <stdlib.h>
#else
#if defined(_WIN32)
#include <windows.h>		// For Windows builds
#include <process.h>
#include <stdio.h>
#include <stdlib.h>
#endif
#endif

#include <assert.h>
//Skipping: #include "RNPlatform/Inc/PlatformInfo.h"

#if defined(RN_UNIX_LIKE)
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <signal.h>
#include <unistd.h>
#endif

#if defined(_PS2)
#include <eekernel.h>
#endif

//Skipping: #include "RNPlatform/Inc/ThreadClass.h"
//Skipping: #include "RNPlatform/DebugSupport.h"


using namespace RNReplicaNet;

static volatile bool doneatexit = false;
static volatile bool exitallthreadsnow = false;


extern "C" void atexit_function(void)
{
//printf("exitallthreadsnow = true\n");
	exitallthreadsnow = true;
}

#if defined(_WIN32) || defined(RN_UNIX_LIKE)
const void *nullMutex = 0;
#endif
#if defined(_PS2)
const int nullMutex = -1;
#endif

#if defined(_XBOX)
int atexit( void ( __stdcall *func )( void ) );
#else
#if defined(_WIN32)
int atexit( void ( __cdecl *func )( void ) );
#endif
#endif

#if defined(_PS2)
int MutexClass::mMutex = -1;
#endif


#if 0
#ifdef _WIN32
#ifdef _DEBUG
// This adds some extra debugging code for WIN32 builds to try and detect deadlocks before they happen.
// This is written to take no extra dynamic allocations so we do not get any allocation reentrant problems.
// See notes related to AddMutexLock in the ReplicaNet TODO
const size_t kMaxThreads = 32;
const size_t kMaxMutexPerThread = 20;
static DWORD sThreadIDs[kMaxThreads];
static MutexClass *sMutexByThreadIDs[kMaxThreads][kMaxMutexPerThread];
static bool sDoneCriticalSection = false;
static CRITICAL_SECTION sCriticalSection;

static void AddMutexLock(MutexClass *mutex)
{
	if (!sDoneCriticalSection)
	{
		sDoneCriticalSection = true;
		InitializeCriticalSection(&sCriticalSection);
		memset(sThreadIDs,0,sizeof(sThreadIDs));
	}
	EnterCriticalSection(&sCriticalSection);
	size_t i;
	DWORD threadID = GetCurrentThreadId();

	printf("AddMutexLock mutex $%p threadID $%x\n",mutex,threadID);

	for (i=0;i<kMaxThreads;i++)
	{
		if (sThreadIDs[i] == threadID)
		{
			memmove(&sMutexByThreadIDs[i][0],&sMutexByThreadIDs[i][1],sizeof(sMutexByThreadIDs[i])-sizeof(sMutexByThreadIDs[i][0]));
			sMutexByThreadIDs[i][kMaxMutexPerThread-1] = mutex;
			break;
		}
	}
	// Not found so add it...
	if (i == kMaxThreads)
	{
		for (i=0;i<kMaxThreads;i++)
		{
			if (sThreadIDs[i] == 0)
			{
				sThreadIDs[i] = threadID;
				memset(sMutexByThreadIDs[i],0,sizeof(sMutexByThreadIDs[i]));
				sMutexByThreadIDs[i][kMaxMutexPerThread-1] = mutex;
				break;
			}
		}
	}
	LeaveCriticalSection(&sCriticalSection);
}

static void RemoveMutexLock(MutexClass *mutex)
{
	if (!sDoneCriticalSection)
	{
		return;
	}

	EnterCriticalSection(&sCriticalSection);
	size_t i;
	DWORD threadID = GetCurrentThreadId();

	printf("RemoveMutexLock mutex $%p threadID $%x\n",mutex,threadID);

	for (i=0;i<kMaxThreads;i++)
	{
		if (sThreadIDs[i] == threadID)
		{
			size_t j;
			for (j=0;j<kMaxMutexPerThread;j++)
			{
				if (sMutexByThreadIDs[i][j] == mutex)
				{
					sMutexByThreadIDs[i][j] = 0;
					break;
				}
			}
		}
	}
	LeaveCriticalSection(&sCriticalSection);
}

static void TidyNullHoles(void)
{
	size_t o1,i1,i2;
	// Tidy up any null holes in the lists.
	for (o1 = 0; o1 < kMaxThreads; o1++)
	{
		// Use an active thread list, so skip the null ones.
		if (sThreadIDs[o1] == 0)
		{
			continue;
		}
		bool some = false;
		for (i1 = kMaxMutexPerThread-1; i1 > 0; i1--)
		{
			if (sMutexByThreadIDs[o1][i1] != 0)
			{
				some = true;
				continue;
			}
			// Blank space and some non-blank already found?
			if (sMutexByThreadIDs[o1][i1] == 0 && some)
			{
				for (i2 = i1-1; i2 > 0; i2--)
				{
					// Look for any more non-blank...
					if (sMutexByThreadIDs[o1][i2] != 0)
					{
						// Squash up the blank space and try again
						memmove(&sMutexByThreadIDs[o1][1],&sMutexByThreadIDs[o1][0],sizeof(sMutexByThreadIDs[0][0]) * i1);
						sMutexByThreadIDs[o1][0] = 0;
						some = false;
						i1 = kMaxMutexPerThread-1;
						break;
					}
				}
			}
		}
	}
}

static bool CheckMutexLockSequences(void)
{
	if (!sDoneCriticalSection)
	{
		return true;
	}
	EnterCriticalSection(&sCriticalSection);
	bool breakOut = false;

	TidyNullHoles();
	size_t o1,o2,i1,i2;
	// If the a thread mutex access list is full then try to spot repeated access sequences and remove earlier sequences.
	bool changed = false;
	for (o1 = 0; o1 < kMaxThreads; o1++)
	{
		// Use an active thread list, so skip the null ones.
		if (sThreadIDs[o1] == 0)
		{
			continue;
		}
		if (sMutexByThreadIDs[o1][0] == 0)
		{
			continue;
		}
		// The start pos
		for (o2 = 0;o2 < kMaxMutexPerThread && !changed; o2++)
		{
			// The length
			for (i1 = ((kMaxMutexPerThread-o2)/2);i1 > 1 && !changed; i1--)
			{
				for (i2 = o2 + i1 ; i2 < (kMaxMutexPerThread-i1) ; i2++)
				{
					if (memcmp(&sMutexByThreadIDs[o1][o2],&sMutexByThreadIDs[o1][i2],sizeof(sMutexByThreadIDs[0][0])*i1) == 0)
					{
						// Matched so zero the sequence
						memset(&sMutexByThreadIDs[o1][i2],0,sizeof(sMutexByThreadIDs[0][0])*i1);
						changed = true;
					}
				}
			}
		}
	}
	if (changed)
	{
		TidyNullHoles();
	}
	// Matches pairs of mutex accesses
	for (o1 = 0; o1 < kMaxThreads; o1++)
	{
		// Use an active thread list, so skip the null ones.
		if (sThreadIDs[o1] == 0)
		{
			continue;
		}
		// Find the first (from the end) and second non-null entry
		for (i1 = kMaxMutexPerThread - 2; i1 > 0 ; i1--)
		{
			size_t om1=kMaxMutexPerThread,om2=kMaxMutexPerThread;
			if (sMutexByThreadIDs[o1][i1] == 0)
			{
				continue;
			}
			om1 = i1;
			for (i2 = i1 + 1; i2 < kMaxMutexPerThread ;i2++)
			{
				if (sMutexByThreadIDs[o1][i1] == 0)
				{
					continue;
				}
				om2 = i2;
				break;
			}
			// Check for no interesting pairs
			if (om1 == kMaxMutexPerThread || om2 == kMaxMutexPerThread)
			{
				continue;
			}
			// We have a pair of mutex accesses so look for the first pairs that match this pair and test for them being in the same order.
			for (o2 = 0 ; o2 < kMaxThreads ; o2++)
			{
				// Skip the thread that is the same as out outer loop or a blank thread
				if (o2 == o1 || sThreadIDs[o2] == 0)
				{
					continue;
				}
				size_t im1=kMaxMutexPerThread,im2=kMaxMutexPerThread;
				// Find the two occurrences of the mutexes from om1 and om2.
				for (i2 = kMaxMutexPerThread-1; i2 > 0 ; i2--)
				{
					if (sMutexByThreadIDs[o2][i2] == 0)
					{
						continue;
					}
					if (im1 == kMaxMutexPerThread && sMutexByThreadIDs[o2][i2] == sMutexByThreadIDs[o1][om1])
					{
						im1 = i2;
					}
					if (im2 == kMaxMutexPerThread && sMutexByThreadIDs[o2][i2] == sMutexByThreadIDs[o1][om2])
					{
						im2 = i2;
					}
					if (im1 != kMaxMutexPerThread && im2 != kMaxMutexPerThread)
					{
						break;
					}
				}

				// We found two mutex matches, so we check the order
				if (im1 != kMaxMutexPerThread && im2 != kMaxMutexPerThread)
				{
					// Wrong order
					if (im1 > im2)
					{
						MutexClass *m1 = sMutexByThreadIDs[o1][om1];
						MutexClass *m2 = sMutexByThreadIDs[o1][om2];
//						assert(false && "Potential deadlock");
						printf("Potential deadlock");
						// Blank these out so we can fall through
						sMutexByThreadIDs[o1][om2] = 0;
						sMutexByThreadIDs[o2][im2] = 0;
					}
					// Remove the first of the pairs since we have matched them.
					sMutexByThreadIDs[o1][om1] = 0;
					sMutexByThreadIDs[o2][im1] = 0;
				}
			}
			
		}
		if (breakOut)
		{
			break;
		}
	}

	LeaveCriticalSection(&sCriticalSection);
	return true;
}
#endif
#endif
#endif

// Implementation note:
// For any memory leak detection and unit test code to pass it is very important that MutexClass does not allocate any permanent memory leak checked memory during the constructor.
// This is because this MutexClass can be statically or globally allocated when the application starts and thereafter never freed.
MutexClass::MutexClass()
{
#if !defined(_PS2)
	mMutex = const_cast<void *>(nullMutex);
#endif

	if (PlatformInfo::IsThreaded())
	{
#if defined(_WIN32)
		mMutex = &mSection;
		assert(mMutex && "MutexClass::MutexClass allocate CRITICAL_SECTION failed\n");
		InitializeCriticalSection((CRITICAL_SECTION*)mMutex);
#endif
#if defined(RN_UNIX_LIKE)
		mMutex = 0;
		pthread_mutex_t *mutex;
		pthread_mutexattr_t attr;

		/* Allocate the structure */
		mutex = &mLocalMutex;
		pthread_mutexattr_init(&attr);
		pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);

		if ( pthread_mutex_init(mutex, &attr) != 0 )
		{
			dprintf("pthread_mutex_init() failed");
			mutex = 0;
		}
		mMutex = mutex;
#endif

#if defined(_PS2)
		struct SemaParam s;

		// Set this mutex to be owned by no thread with no reference count
		mCount = 0;
		mOwnerThread = kNoOwnerThread;

		// Check we have the global semaphore allocated, if not then allocate one
		if (mMutex == -1)
		{
			// A binary semaphore for the critical section
			s.maxCount = 1;
			s.initCount = 1;
			mMutex = CreateSema( &s );
		}
#endif
	}
}

MutexClass::~MutexClass()
{
	if (PlatformInfo::IsThreaded() && mMutex != nullMutex)
	{
#if defined(_WIN32)
		CRITICAL_SECTION* LocalCopy = (CRITICAL_SECTION*)mMutex;
		assert(LocalCopy != (CRITICAL_SECTION*)nullMutex);
		mMutex = const_cast<void *>(nullMutex);
		EnterCriticalSection(LocalCopy);
		LeaveCriticalSection(LocalCopy);
		DeleteCriticalSection(LocalCopy);
#endif

#if defined(RN_UNIX_LIKE)
		if (mMutex)
		{
			// MPi: Removed this, since destroy should work without it
/*
			if ( pthread_mutex_lock((pthread_mutex_t*)mMutex) < 0 )
			{
				dprintf("pthread_mutex_lock() failed");
			}
*/

			pthread_mutex_destroy((pthread_mutex_t*)mMutex);
		}
		mMutex = 0;
#endif

#if defined(_PS2)
// Once the MutexClass system starts the semaphore is kept allocated.
//		int id = mMutex;
//		mMutex = -1;
//		DeleteSema(id);
#endif
	}
}

void MutexClass::Lock(void)
{
	if (PlatformInfo::IsThreaded() && mMutex != nullMutex)
	{
#if defined(_WIN32)
		assert(mMutex != nullMutex);
//		dprintf("t $%p req lock $%p\n",GetCurrentThreadId(),mMutex);
		EnterCriticalSection((CRITICAL_SECTION*)mMutex);
//		dprintf("t $%p postlock $%p ret = %d\n",GetCurrentThreadId(),mMutex,ret);
		assert(mMutex != nullMutex);
#endif
#if defined(RN_UNIX_LIKE)
		if ( pthread_mutex_lock((pthread_mutex_t*)mMutex) < 0 )
		{
			dprintf("pthread_mutex_lock() failed");
			return;
		}
#endif
#if defined(_PS2)
		WaitSema(mMutex);
		int callingThread = GetThreadId();
// Critical section
		// If the mutex is owned by a thread then check the thread handle
		if (mOwnerThread != MutexClass::kNoOwnerThread)
		{
			// If we already own this mutex...
			if (callingThread == mOwnerThread)
			{
				// Increase the counter and finish by releasing the semaphore
				mCount++;
				SignalSema(mMutex);
				return;
			}

			// A different thread owns the mutex so spin wait until we grab it...
			if (mOwnerThread != callingThread)
			{
				// Add our thread to the list of threads that want the mutex that will get woken on a FIFO basis by the unlock
				mWaitingThreadIDs.push_back(callingThread);
				while (mOwnerThread != callingThread)
				{
					// Release the semaphore
					SignalSema(mMutex);
					// Yield the thread until the unlock command wakes up our thread again
					SleepThread();
					// Grab the semaphore to see if out thread now owns the mutex
					WaitSema(mMutex);
				}
				// Release the semaphore
				SignalSema(mMutex);
			}
			return;
		}

		// Here mOwnerThread must equal MutexClass::kNoOwnerThread so we can grab the mOwnerThread
		mOwnerThread = callingThread;
		assert(mCount == 0 && "MutexClass::mCount == 0");
		// Set the counter to 1 because we have locked the mutex once
		mCount = 1;
// End critical section
		SignalSema(mMutex);
#endif
	}
}

void MutexClass::UnLock(void)
{
	if (PlatformInfo::IsThreaded() && mMutex != nullMutex)
	{
#if defined(_WIN32)
		assert(mMutex != nullMutex);
//		dprintf("t $%p release $%p\n",GetCurrentThreadId(),mMutex);
		LeaveCriticalSection((CRITICAL_SECTION*)mMutex);
#endif
#if defined(RN_UNIX_LIKE)
		if ( pthread_mutex_unlock((pthread_mutex_t*)mMutex) < 0 )
		{
			dprintf("pthread_mutex_unlock() failed");
			return;
		}
#endif
#if defined(_PS2)
		WaitSema(mMutex);
// Critical section
		int callingThread = GetThreadId();
		// If a thread that doesn't own the mutex tries to unlock then ignore the request
		if (mOwnerThread != callingThread)
		{
			SignalSema(mMutex);
			return;
		}
		// We own the mutex so decrease the counter
		mCount--;
		// If the counter resets to zero then we can release the mutex and set the owner thread to MutexClass::kNoOwnerThread
		if (mCount == 0)
		{
			// No owner for the mutex now
			mOwnerThread = MutexClass::kNoOwnerThread;

			std::list<int>::iterator st,en;
			st = mWaitingThreadIDs.begin();
			en = mWaitingThreadIDs.end();
			// We have an entry for the next thread waiting for the mutex so wake the thread...
			if (st != en)
			{
				int nextThread = *st;
				// Remove the next waiting thread from the list
				mWaitingThreadIDs.erase(st);
				// Set the owner of the mutex to the next thread
				mOwnerThread = nextThread;
				// Check the mutex is in the proper state
				assert(mCount == 0 && "MutexClass::mCount == 0");
				// The next thread now owns the mutex
				mCount = 1;
				// Set the next thread as active so it runs.
				WakeupThread(mOwnerThread);
				// NOTE: We do not sleep the current thread here because unlocking a mutex does not mean the thread current stops.
				// Release the semaphore so the next thread in the active queue gets it
				SignalSema(mMutex);
				return;				
			}

		}
// End critical section
		SignalSema(mMutex);
#endif
	}
}

volatile size_t ThreadClass::mNumAllocated = 0;
static volatile int sIncrementingID = 0;
ThreadClass::ThreadClass() : mQuitNow(false) , mBoundThread(0) , mThreadExitingCalled(false)
{
	mThreadID = sIncrementingID++;
	mNumAllocated++;
//	trigger.Lock();
	if (!doneatexit)
	{
		doneatexit = true;
#ifndef _XBOX
#ifndef REPNETCLR
		atexit(&atexit_function);
#endif
#endif
	}
//	trigger.UnLock();
}

ThreadClass::~ThreadClass()
{
	mNumAllocated--;
	mQuitNow = true;
}

//Skipping: #include "RNPlatform/DebugSupport.h"
#include "RNPlatform/Inc/CThreadClass.h"

void CurrentThread::Sleep(int milliseconds)
{
	CurrentThreadSleep(milliseconds);
}

int ThreadClass::GetThreadID(void)
{
	return mThreadID;
}

void ThreadClass::Sleep(int milliseconds)
{
/** \todo expand to use the WSAEventSelect and SleepEx() function */
	do
	{
		int theTime = milliseconds;
		if (theTime > 100)
		{
			theTime = 100;
		}
		CheckQuit();
		CurrentThread::Sleep(theTime);
		milliseconds -= theTime;
	} while (milliseconds > 0);
}

void ThreadClass::CheckQuit(void)
{
	// It is exiting, no need to check quit
	if (mThreadExitingCalled)
	{
		return;
	}
//	if (PlatformInfo::IsThreaded())
	{
		if (mQuitNow || exitallthreadsnow)
		{
			DoQuitNow(0);
		}
	}
}

void ThreadClass::DoQuitNow(const int returnCode)
{
	mQuitNow = false;
	CallThreadExiting(returnCode);
#if defined(_WIN32)
#ifdef RNUSETHREAD
	_endthreadex(0);
#else
	assert( !"No _endthreadex" );
#endif //<ifdef RNUSETHREAD

#endif
#if defined(RN_UNIX_LIKE)
	pthread_exit(0);
#endif
#if defined(_PS2)
	ExitThread();
#endif
}


void ThreadClass::CallThreadExiting(const int returnCode)
{
	if (!mThreadExitingCalled)
	{
		mThreadExitingCalled = true;
//		printf("CallThreadExiting()\n");
		Thread::mNumActive--;
		ThreadExiting(returnCode);
		if (mBoundThread)
		{
			mBoundThread->mIsRunning = false;
			mBoundThread->mThreadClass = 0;
		}
	}
}

void ThreadClass::ThreadExiting(const int returnCode)
{
}

LockingMechanism::LockingMechanism(MutexClass *lockee) : mLockee(0)
{
//	dprintf(" LockingMechanism::LockingMechanism this $%p t $%x with $%p\n",this,GetCurrentThreadId(),lockee);
	if (lockee)
	{
		lockee->Lock();
		mLockee = lockee;
	}
}

/**
 * The dtor unlocks the class automatically
 */
LockingMechanism::~LockingMechanism()
{
//	dprintf("LockingMechanism::~LockingMechanism this $%p t $%x with $%p\n",this,GetCurrentThreadId(),mLockee);
	if (mLockee)
	{
		MutexClass *tl = mLockee;
		mLockee = 0;
		tl->UnLock();
	}
}
//From: RNPlatform/CThreadClass.c
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#if defined(_XBOX)
#include <xtl.h>			// For XBox builds
#else
#if defined(_WIN32)
#include <windows.h>		// For Windows builds
#endif
#endif

#if defined(RN_UNIX_LIKE)
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <signal.h>
#include <unistd.h>
#include <assert.h>
#endif

#if defined(_PS2)
#include <eekernel.h>
#include <sceerrno.h>
#include <assert.h>
#endif

//Skipping: #include "RNPlatform/Inc/CThreadClass.h"

static tReplicaNet_SleepHookFunc *s_sleepFunction = 0;

void CurrentThreadSleep_SetHook(tReplicaNet_SleepHookFunc *sleepFunction)
{
	s_sleepFunction = sleepFunction;
}

void CurrentThreadSleep(int milliseconds)
{
#if defined(_PS2)
	int ret = 0;
#endif
#if defined(_PS2) || defined(RN_UNIX_LIKE)
	int copym = milliseconds;
#endif

	// If there is a hook set then use the hook specified for the sleep
	if (s_sleepFunction != 0)
	{
		(*s_sleepFunction)(milliseconds);
		return;
	}

#if defined(_WIN32)
	Sleep(milliseconds);
#endif
#if defined(_PS2) || defined(RN_UNIX_LIKE)
	// Do the second long sleeps first...
	while (copym > 1000)
	{
		copym -= 1000;
#if defined(RN_UNIX_LIKE)
		usleep(1000*1000);
#else
		ret = DelayThread(1000*1000);
		assert(ret == 0 && "Could not complete the DelayThread() in CurrentThreadSleep()");
#endif
	}

	// Then do the final sleep for whatever is left
#if defined(RN_UNIX_LIKE)
	usleep(copym*1000);
#else
	ret = DelayThread(copym * 1000);
	assert(ret == 0 && "Could not complete the DelayThread() in CurrentThreadSleep()");
#endif
#endif
}


//From: RNPlatform/PlatformHeap.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
//Skipping: #include "RNPlatform/Inc/PlatformHeap.h"
#include <stdlib.h>
#include <string.h>
#include <assert.h>

using namespace RNReplicaNet;

static PlatformHeapBlock **sBlockList = 0;
static int sBlockSize = 0;
static const int blockStep = 4;
static int sIndex = 0;

static void PlatformHeapAddHeapBlock(PlatformHeapBlock *block)
{
	if (sBlockList == 0)
	{
		sIndex = 0;
		sBlockSize = blockStep;
		sBlockList = (PlatformHeapBlock **)calloc(sBlockSize,sizeof(PlatformHeapBlock *));
	}
	assert(sIndex < sBlockSize);
	sBlockList[sIndex] = block;
	sIndex++;
	if (sIndex == sBlockSize)
	{
		int oldSize = sBlockSize;
		sBlockSize += blockStep;
		PlatformHeapBlock **sNewBlockList = (PlatformHeapBlock **)calloc(sBlockSize,sizeof(PlatformHeapBlock *));

		memcpy(sNewBlockList,sBlockList,oldSize*sizeof(PlatformHeapBlock *));
		free(sBlockList);
		sBlockList = sNewBlockList;
	}
}

static void PlatformHeapRemoveHeapBlock(PlatformHeapBlock *block)
{
	int i;
	for (i=0;i<sBlockSize;i++)
	{
		if (sBlockList[i] == block)
		{
			int j;
			sIndex--;
			for (j=i;j<sIndex;j++)
			{
				sBlockList[j] = sBlockList[j+1];
			}
			break;
		}
	}

	// Shrink the block down if it is too big
	if (sIndex == (sBlockSize-blockStep-blockStep) && sBlockSize > blockStep)
	{
		sBlockSize -= blockStep;
		PlatformHeapBlock **sNewBlockList = (PlatformHeapBlock **)calloc(sBlockSize,sizeof(PlatformHeapBlock *));

		memcpy(sNewBlockList,sBlockList,sBlockSize*sizeof(PlatformHeapBlock *));
		free(sBlockList);
		sBlockList = sNewBlockList;
	}
	assert(sIndex >= 0);
}


PlatformHeapBlock::PlatformHeapBlock()
{
}

void PlatformHeapBlock::Register(void)
{
	PlatformHeapAddHeapBlock(this);
}

PlatformHeapBlock::~PlatformHeapBlock()
{
	PlatformHeapRemoveHeapBlock(this);
}

/**
 * Deletes all heap blocks on the stack in reverse order.
 */
void PlatformHeap::ForceFree(void)
{
	while (sIndex > 0)
	{
		delete sBlockList[sIndex-1];
	}

	sBlockSize = 0;
	free(sBlockList);
	sBlockList = 0;
	sIndex = 0;
}
//From: RNPlatform/StrDup.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include "RNPlatform/Inc/StrDup.h"
#include <stdlib.h>
#include <string.h>
#include <assert.h>

extern char *RNReplicaNet::StrDup(const char *text)
{
	assert(text);
	if (!text)
	{
		return (char *)0;
	}
	
	char *result = (char *) malloc(strlen(text)+1);
	if (!result)
	{
		return (char *)0;
	}
	strcpy(result,text);
	return result;
}

extern char *RNReplicaNet::StrDupA(const char *text)
{
	return RNReplicaNet::StrDup(text);
}
//From: RNPlatform/StringUtils.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include "RNPlatform/Inc/StringUtils.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>

std::string RNReplicaNet::TrimWhite(const std::string &t)
{
	if (t.empty())
	{
		return "";
	}
	size_t pos = 0;
	size_t len = t.length();
	while ((pos < len) && isspace(t[pos]))
	{
		pos++;
	}
	if (pos == len)
	{
		return "";
	}
	size_t end = len - 1;
	while ((end > pos) && isspace(t[end]))
	{
		end--;
	}
	std::string str = t.substr(pos,(end - pos)+1);
	return str;
}

std::string RNReplicaNet::ToLower( const std::string &input )
{
	std::string ret = input;
	std::transform(ret.begin(), ret.end(), ret.begin(), ::tolower);
	return ret;
}

namespace RNReplicaNet
{

template<> int StringTo<int>(const std::string &input , const int defaultValue)
{
	if ( input.empty() )
	{
		return defaultValue;
	}
	return (int) atoi(input.c_str());
}

template<> float StringTo<float>(const std::string &input , const float defaultValue)
{
	if ( input.empty() )
	{
		return defaultValue;
	}
	return (float) atof(input.c_str());
}

template<> double StringTo<double>(const std::string &input , const double defaultValue)
{
	if ( input.empty() )
	{
		return defaultValue;
	}
	return (double) atof(input.c_str());
}

template<> std::string ToString(const int input , const int decimalPlaces)
{
	char buffer[128];
	sprintf( buffer , "%d" , input );
	return std::string(buffer);
}

template<> std::string ToString(const double input , const int decimalPlaces)
{
	char buffer[128];
	if ( decimalPlaces >= 0 )
	{
		char buffer2[32];
		sprintf( buffer2 , "%%.%df" , decimalPlaces );
		sprintf( buffer , buffer2 , input );
	}
	else
	{
		sprintf( buffer , "%f" , input );
	}
	return std::string( buffer );
}

template<> std::string ToString(const float input , const int decimalPlaces)
{
	return ToString( (double) input , decimalPlaces );
}

} // namespace RNReplicaNet

std::string RNReplicaNet::GetStringSafe( const char *input , const int maxLen )
{
	int imaxLen = maxLen;
	std::string ret;

	while ( input && input[0] && ( imaxLen > 0 ) )
	{
		ret += input[0];
		input++;
		imaxLen--;
	}

	return ret;
}

extern std::string RNReplicaNet::ReadTextFile( const char *filename )
{
	FILE *fp = fopen( filename , "rb" );
	if ( !fp )
	{
		return "";
	}

	std::string ret;

	while ( !feof( fp ) )
	{
		char buffer[1024];
		size_t got = fread( buffer , sizeof( buffer[0] ) , sizeof( buffer ) , fp );
		if ( got )
		{
			ret.append( buffer , got );
		}
	}
 
	fclose( fp );
	return ret;
}
//From: RNPlatform/Rand.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdlib.h>
#include <assert.h>
#include <time.h>
//Skipping: #include "RNPlatform/Inc/Rand.h"

static volatile bool sRandSeeded = false;
static volatile unsigned long sRandValue = 1;
void RNReplicaNet::Rand::SeedFastWeak(const unsigned int seed)
{
	sRandValue = (unsigned long) seed;
	sRandSeeded = true;
}

int RNReplicaNet::Rand::FastWeak(void)
{
	if ( !sRandSeeded )
	{
		time_t temp;
		RNReplicaNet::Rand::SeedFastWeak((int)time(&temp));
	}
	return( ((sRandValue = sRandValue * 214013L	+ 2531011L) >> 16) & RAND_MAX );
}

#if 0
// Strong pseudo random number generation
#define N 624
#define M 397
#define MATRIX_A 0x9908b0df
#define UPPER_MASK 0x80000000
#define LOWER_MASK 0x7fffffff

// Tempering parameters
#define TEMPERING_MASK_B 0x9d2c5680
#define TEMPERING_MASK_C 0xefc60000
#define TEMPERING_SHIFT_U(y)  (y >> 11)
#define TEMPERING_SHIFT_S(y)  (y << 7)
#define TEMPERING_SHIFT_T(y)  (y << 15)
#define TEMPERING_SHIFT_L(y)  (y >> 18)

static unsigned long mt[N];
static int mti=N+1;

static void sgenrand(unsigned long seed)
{
	// [KNUTH 1981, The Art of Computer Programming Vol. 2 (2nd Ed.), pp102]
	mt[0]= seed & 0xffffffff;
	for (mti=1; mti<N; mti++)
	{
		mt[mti] = (69069 * mt[mti-1]) & 0xffffffff;
	}
}

static unsigned long genrand()
{
	unsigned long y;
	static unsigned long mag01[2]={0x0, MATRIX_A};

	if (mti >= N)
	{
		int kk;

		if (mti == N+1)
		{
			sgenrand(4357);
		}

		for (kk=0;kk<N-M;kk++)
		{
			y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
			mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];
		}
		for (;kk<N-1;kk++)
		{
			y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
			mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];
		}
		y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
		mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1];

		mti = 0;
	}

	y = mt[mti++];
	y ^= TEMPERING_SHIFT_U(y);
	y ^= TEMPERING_SHIFT_S(y) & TEMPERING_MASK_B;
	y ^= TEMPERING_SHIFT_T(y) & TEMPERING_MASK_C;
	y ^= TEMPERING_SHIFT_L(y);

	return y; 
}
#endif
//From: RNPlatform/JobManager.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"

#include <assert.h>

#include <stdio.h>
#include <assert.h>
#include "RNPlatform/Inc/JobManager.h"
//Skipping: #include "RNPlatform/DebugSupport.h"

using namespace RNReplicaNet;

JobManager::JobManager() : mNumJobsRemaining(0)
{
}

JobManager::~JobManager()
{
	if (!PlatformInfo::IsThreaded())
	{
		return;
	}

	Stop();
}

void JobManager::SetPoolSize(const size_t poolSize)
{
	if (!PlatformInfo::IsThreaded())
	{
		return;
	}

	THREADSAFELOCK();

	if (!mWorkers.empty())
	{
		// No alteration of the pool size once it's been set
		return;
	}

	mWorkers.resize(poolSize);
	size_t i;
	for (i = 0 ; i < mWorkers.size() ; i++)
	{
		mWorkers[i].mParent = this;
	}
}

bool JobManager::Start(void)
{
	if (!PlatformInfo::IsThreaded())
	{
		return true;
	}

	THREADSAFELOCK();

	if (mWorkers.empty())
	{
		SetPoolSize();
	}

	if (!GetIsRunning())
	{
		Begin(this);
	}

	return true;
}

bool JobManager::Stop(void)
{
	if (!PlatformInfo::IsThreaded())
	{
		return true;
	}

	Terminate();

	Tidy();

	return true;
}

int JobManager::ThreadEntry(void)
{
	if (!PlatformInfo::IsThreaded())
	{
		return -1;
	}

	while (true)
	{
		// Stack context for mutex
		{
			THREADSAFELOCK();
			if (mJobsAdded.empty())
			{
				return 0;
			}
			// MPi: TODO: Improve this scan for a free thread by maintaining a list of idle thread pointers from the mWorkers pool
			size_t i;
			bool started = false;
			for (i = 0 ; i < mWorkers.size() ; i++)
			{
				if (!mWorkers[i].GetIsRunning())
				{
					Job *job = mJobsAdded.front();
					mJobsAdded.pop_front();
					job->mJobsAddedIter = mJobsAdded.end();
					mWorkers[i].mFromIdle = job;
					mWorkers[i].Begin(&mWorkers[i]);
					started = true;
					break;
				}
			}
			if (!started)
			{
				// Couldn't find any Worker to start, so exit for now and wait for a bust Worker to execute the job instead
				return -1;
			}
		}
		// Context switch, nicer threading
		Sleep(0);
	}

	return 0;
}

void JobManager::ThreadExiting(const int returnCode)
{
}

void JobManager::Tidy(void)
{
	if (!PlatformInfo::IsThreaded())
	{
		return;
	}

	THREADSAFELOCK();
	mWorkers.resize(0);	// Stops all workers
}

bool JobManager::AddPoolJob(Job *job)
{
	assert(!job->mManager && "Cannot add a job to a JobManager more than once");
	if (job->mManager)
	{
		return false;
	}

	mNumJobsRemaining++;
	job->mManager = this;

	if (!PlatformInfo::IsThreaded())
	{
		// If threading is not enabled then immediately run the job
		job->Run(this);
		delete job;
		return true;
	}

	THREADSAFELOCK();
	mJobsAdded.push_back(job);
	job->mJobsAddedIter = --mJobsAdded.end();

	job->mJobReferenceIter = mJobReference.insert(std::pair<void*, Job*>(job->mReference?job->mReference : job, job));
	Start();

	return true;
}

int JobManager::CancelJobs(void* const ref)
{
	int cancelled = 0;

	THREADSAFELOCK();
	std::pair<std::multimap<void*, Job*>::iterator , std::multimap<void*, Job*>::iterator> found = mJobReference.equal_range(ref);
	while (found.first != found.second)
	{
		Job *job = (*found.first).second;
		found.first++;
		job->mCancelled = true;
		cancelled++;
		if (job->mJobsAddedIter != mJobsAdded.end())
		{
			// It's not been added to the pool yet so remove it from the lists
			mJobsAdded.erase(job->mJobsAddedIter);
			mJobReference.erase(job->mJobReferenceIter);
			delete job;
		}
		// If it's already in the pool then there isn't much we can do, so do nothing
	}

	return cancelled;
}

volatile int JobManager::GetNumberOfJobsRemaining(void)
{
	return mNumJobsRemaining;
}

Worker::Worker() : mParent(0) , mFromIdle(0)
{
}

Worker::~Worker()
{
}

int Worker::ThreadEntry(void)
{
	Job *job = 0;
	job = mFromIdle;
	mFromIdle = 0;

	while (job)
	{
		job->Run(this);

		{
			THREADSAFELOCKCLASSp(mParent);
			if (job->mJobsAddedIter != mParent->mJobsAdded.end())
			{
				mParent->mJobsAdded.erase(job->mJobsAddedIter);
			}
			if (job->mJobReferenceIter != mParent->mJobReference.end())
			{
				mParent->mJobReference.erase(job->mJobReferenceIter);
			}
		}

		// Delete the job, it's done
		delete job;
		job = 0;

		{
			// Look for any more jobs to start running in this thread
			THREADSAFELOCKCLASSp(mParent);
			if (!mParent->mJobsAdded.empty())
			{
				job = mParent->mJobsAdded.front();
				mParent->mJobsAdded.pop_front();
				job->mJobsAddedIter = mParent->mJobsAdded.end();
			}
		}

		// Context switch, nicer threading
		Sleep(0);
	}

	return 0;
}

void Worker::ThreadExiting(const int returnCode)
{
}

Job::Job() : mManager(0) , mReference(0) , mCancelled(false)
{
}

Job::~Job()
{
	if (mManager != 0)
	{
		mManager->mNumJobsRemaining--;
	}
}

bool Job::IsCancelled(void)
{
	if (mManager)
	{
		THREADSAFELOCKCLASSp(mManager);
		return mCancelled;
	}

	// If it's not attached to a manager then it's cancelled
	return true;
}
//From: RNReplicaNet/DataBlock.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "RNReplicaNet/Inc/ReplicaNet.h"
#include "RNReplicaNet/Inc/DataBlock.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
#include "RNReplicaNet/Inc/ReplicaObject.h"
#include "RNXPURL/Inc/XPURL.h"
#include "RNXPURL/Inc/DebugHandler.h"
//Skipping: #include "RNPlatform/Inc/StrDup.h"

using namespace RNReplicaNet;

DataBlock::DataBlock() : mID(0) , mBoundReplicaNet(0) , mBoundObject(0) , mReliable(false) , mCertain(false), mOrdered(false)
							, mAutomaticUpdates(true) , mIsAllocated(true) , mDebugOn(false) , mDebugText(0)
							, mUpdateDelayMinimum(0.0f) , mForceSendMaximumUpdates(0) , mForceSendTimeDelay(0.0f)
							, mVariableName(0) , mBand(0) , mDiscardOlder(0) , mDiscardOlderMidPoint(0) , mDiscardOlderEndPoint(0)
							, mLocalisedOrderingSent(0) , mLocalisedOrderingReceived(0xffffffff) , mForceReflectionUpdate(false)
							, mReflectionMasterUpdate(false)
{
}

DataBlock::~DataBlock()
{
	free(mDebugText);
	free(mVariableName);
}

void DataBlock::SetID(int id)
{
	mID = id;
}

void DataBlock::Poll(DataBlockReason *reason,const bool discardOlderIncluded,const unsigned int discardOrder)
{
	if (!reason)
	{
		return;
	}

	if (!reason->mMessageHelper)
	{
		return;
	}

	reason->mMessageHelper->AddVariable(&mID,sizeof(mID));

	if (mDiscardOlder)
	{
		if (discardOlderIncluded)
		{
			mLocalisedOrderingSent = discardOrder & mDiscardOlderEndPoint;
		}
		else
		{
			mLocalisedOrderingSent = (mLocalisedOrderingSent + 1) & mDiscardOlderEndPoint;
		}
//		printf("mLocalisedOrderingSent = %d\n",mLocalisedOrderingSent);
		reason->mMessageHelper->AddVariable(&mLocalisedOrderingSent,(int)mDiscardOlderRealSize);
	}
}

bool DataBlock::ShouldDiscard(MessageHelper *message)
{
	mDiscardThisUpdate = false;

	if (!mDiscardOlder)
	{
		return false;
	}

	unsigned int orderGot = 0;
	message->GetVariable(&orderGot,(int)mDiscardOlderRealSize);

//	printf("orderGot = %d mLocalisedOrderingReceived = %d\n",orderGot , mLocalisedOrderingReceived);

	// Wrap around sequence tests
	if (
		// First the in sequence check discarding really old packet sequences
		( (orderGot > mLocalisedOrderingReceived) && ((orderGot - mLocalisedOrderingReceived) < mDiscardOlderMidPoint) ) ||
		// Next if there has been a wrap around then the sequence will be less but the gap will be really large
		( (orderGot < mLocalisedOrderingReceived) && ((mLocalisedOrderingReceived - orderGot) >= mDiscardOlderMidPoint) )
		)
	{
		// The packet is OK!
		mLocalisedOrderingReceived = orderGot;
		return false;
	}

	mDiscardThisUpdate = true;
	return true;
}

void DataBlock::ParseMessage(MessageHelper *message)
{
}

void DataBlock::BindReplicaNet(ReplicaNet *current)
{
	mBoundReplicaNet = current;
}

void DataBlock::BindReplicaObject(ReplicaObject *object)
{
	mBoundObject = object;
}

void DataBlock::SetReliableFlag(bool reliable)
{
	mReliable = reliable;
	if (reliable)
	{
		mCertain = false;
		mOrdered = false;
	}
}

bool DataBlock::GetReliableFlag(void) const
{
	return mReliable;
}

void DataBlock::SetCertainFlag(bool certain)
{
	mCertain = certain;
	if (certain)
	{
		mReliable = false;
		mOrdered = false;
	}
}

bool DataBlock::GetCertainFlag(void) const
{
	return mCertain;
}

void DataBlock::SetOrderedFlag(bool ordered)
{
	mOrdered = ordered;
	if (ordered)
	{
		mReliable = false;
		mCertain = false;
	}
}

bool DataBlock::GetOrderedFlag(void) const
{
	return mOrdered;
}

void DataBlock::SetAutomaticUpdatesFlag(bool automatic)
{
	mAutomaticUpdates = automatic;
}

bool DataBlock::GetAutomaticUpdatesFlag(void) const
{
	return mAutomaticUpdates;
}

void DataBlock::GiveDeltaHint(void *pdata,int dataLen)
{
}

void DataBlock::ContinuityBreak(unsigned char breakTypes)
{
}

void DataBlock::SetForceReflectionUpdate(const bool enable)
{
	mForceReflectionUpdate = enable;
}

bool DataBlock::GetForceReflectionUpdate(void)
{
	return mForceReflectionUpdate;
}

void DataBlock::SetReflectionMasterUpdate(const bool enable)
{
	mReflectionMasterUpdate = enable;
}

bool DataBlock::GetReflectionMasterUpdate(void)
{
	return mReflectionMasterUpdate;
}

bool DataBlock::IsAttached(void *data)
{
	return false;
}

bool DataBlock::IsAllocated(void) const
{
	return mIsAllocated;
}

void DataBlock::SetIsAllocated(const bool isAllocated)
{
	mIsAllocated = isAllocated;
}


void DataBlock::SetUpdateDelayMinimum(const float delay)
{
	mUpdateDelayMinimum = delay;
}

float DataBlock::GetUpdateDelayMinimum(void) const
{
	return mUpdateDelayMinimum;
}

void DataBlock::SetForceSendMaximumUpdates(const int updates)
{
	mForceSendMaximumUpdates = updates;
}

int DataBlock::GetForceSendMaximumUpdates(void) const
{
	return mForceSendMaximumUpdates;
}

void DataBlock::SetForceSendTimeDelay(const float delay)
{
	mForceSendTimeDelay = delay;
}

float DataBlock::GetForceSendTimeDelay(void) const
{
	return mForceSendTimeDelay;
}

void DataBlock::SetVariableName(const char *name)
{
	// Free what was here before, if anything.
	free(mVariableName);
	mVariableName = 0;

	// No name?
	if (!name)
	{
		return;
	}

	// Allocate a new space for it. Not using strdup.
	mVariableName = RNReplicaNet::StrDup(name);
}

const char *DataBlock::GetROName(ReplicaObject *from)
{
	if (from)
	{
		return from->_Internal_GetFullyQualifiedName();
	}
	if (mBoundReplicaNet)
	{
		return mBoundObject->_Internal_GetFullyQualifiedName();
	}
	return 0;
}



void DataBlock::EmitBaseDebugInfo(const char *name,const char *className,DataBlockReason *reason)
{
#ifndef _FINAL
	if (!XPURL::GetDebugHandler())
	{
		return;
	}
	// Debug output the DataBlock class information
	if (mReliable)
	{
		XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s.%s (%d).%s.Is Reliable\nbool\ntrue\n\
::_EndClass\n\
::_Flush\n\
",
		reason->mFloatLocalTime,
		GetROName(),name,(int)mID,className
		);
		return;
	}
	if (mOrdered)
	{
		XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
										 ::%s.%s (%d).%s.Is Ordered\nbool\ntrue\n\
										 ::_EndClass\n\
										 ::_Flush\n\
										 ",
										 reason->mFloatLocalTime,
										 GetROName(),name,(int)mID,className
										 );
		return;
	}
	if (mCertain)
	{
		XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s.%s (%d).%s.Is Certain\nbool\ntrue\n\
::_EndClass\n\
::_Flush\n\
",
		reason->mFloatLocalTime,
		GetROName(),name,(int)mID,className
		);
		return;
	}
	if (!mReliable && !mCertain && !mOrdered)
	{
		XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s.%s (%d).%s.Is Unreliable\nbool\ntrue\n\
::_EndClass\n\
::_Flush\n\
",
		reason->mFloatLocalTime,
		GetROName(),name,(int)mID,className
		);
	}
#endif
}

void DataBlock::EmitBaseDebugInfoUpdates(const char *name,const char *className,DataBlockReason *reason)
{
#ifndef _FINAL
	if (!XPURL::GetDebugHandler())
	{
		return;
	}
	// Debug output the DataBlock class information
	if (mUpdateDelayMinimum > 0.0f)
	{
		XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
										 ::%s.%s (%d).%s.mUpdateDelayMinimum\nfloat\n%f\n\
										 ::_EndClass\n\
										 ::_Flush\n\
										 ",
										 reason->mFloatLocalTime,
										 GetROName(),name,(int)mID,className,mUpdateDelayMinimum
										 );
	}

	if (mForceSendMaximumUpdates > 0)
	{
		XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
										 ::%s.%s (%d).%s.mForceSendMaximumUpdates\nint\n%d\n\
										 ::_EndClass\n\
										 ::_Flush\n\
										 ",
										 reason->mFloatLocalTime,
										 GetROName(),name,(int)mID,className,mForceSendMaximumUpdates
										 );
	}

	if (mForceSendTimeDelay > 0.0f)
	{
		XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
										 ::%s.%s (%d).%s.mForceSendTimeDelay\nfloat\n%f\n\
										 ::_EndClass\n\
										 ::_Flush\n\
										 ",
										 reason->mFloatLocalTime,
										 GetROName(),name,(int)mID,className,mForceSendTimeDelay
										 );
	}
#endif
}

std::string DataBlock::GetVariableName(void)
{
	if (mVariableName)
	{
		return std::string(mVariableName);
	}

	char name[256];
	sprintf(name,"<Unknown>%d",(int)mID);
	return std::string(name);
}

void DataBlock::SetBand(const unsigned int band)
{
	mBand = band;
}

unsigned int DataBlock::GetBand(void) const
{
	return mBand;
}

void DataBlock::SetDiscardOlder(const int windowBits)
{
	if (windowBits < 0)
	{
		mDiscardOlder = 0;
		return;
	}
	else if ((windowBits > 0) && (windowBits < 8))
	{
		mDiscardOlder = 8;
	}
	else if (windowBits > 32)
	{
		mDiscardOlder = 32;
	}
	else
	{
		mDiscardOlder = windowBits;
	}
	mDiscardOlderMidPoint = ((unsigned int)1) << (mDiscardOlder-1);
	mDiscardOlderEndPoint = ((unsigned int)1) << mDiscardOlder;
	mDiscardOlderEndPoint--;
	mDiscardOlderRealSize = (mDiscardOlder+7) / 8;
}

int DataBlock::GetDiscardOlder(void) const
{
	return mDiscardOlder;
}

void DataBlock::OwnerChanged(const int sessionID)
{
	mLocalisedOrderingSent = 0;
	mLocalisedOrderingReceived = 0;
}

bool DataBlock::GetDiscardThisUpdate(void) const
{
	return mDiscardThisUpdate;
}

int DataBlock::GetThisClassType(void)
{
	assert(!"DataBlock::GetThisClassType() has been called but the derived class has not used RN_CLASS_MINIMAL_RTTI()");
	return -1;
}
//From: RNReplicaNet/DataBlock_Function.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "RNReplicaNet/Inc/DataBlock_Function.h"
//Skipping: #include "RNReplicaNet/Inc/ReplicaNet.h"
//Skipping: #include "RNReplicaNet/Inc/ReplicaObject.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
//Skipping: #include "RNXPURL/Inc/XPURL.h"
//Skipping: #include "RNXPURL/Inc/DebugHandler.h"

using namespace RNReplicaNet;

// This is the data packet that the macro for serialising the remote functions used
struct RNReplicaNet::CombinedDataPacket
{
	CombinedDataPacket(const void *data,const int len)
	{
		mCombined = malloc(len);
		memcpy(mCombined,data,len);
		mLen = len;
		mRefCount = 0;
	}
	virtual ~CombinedDataPacket()
	{
		free(mCombined);
	}

	void Attach(void)
	{
		mRefCount++;
	}

	bool Delete(void)
	{
		mRefCount--;
		if (mRefCount <= 0)
		{
			return true;
		}
		return false;
	}

	void *mCombined;
	int mLen;
	int mRefCount;
	std::string mDebug;
};

struct RNReplicaNet::SessionBlock_Function
{
	SessionBlock_Function();

	virtual ~SessionBlock_Function();

	CombinedDataPacket *GetNextPacket(void);

	unsigned int mDiscardOrder;
	std::list<CombinedDataPacket *> mCombinedPacketRefs;
};

int DataBlock_Function::mConfiguredNumSessions = 0;
int *DataBlock_Function::mConfiguredSessionIDs = 0;

DataBlock_Function::DataBlock_Function()
{
	SetReliableFlag();
}

DataBlock_Function::~DataBlock_Function()
{
	FreeSessionBlocks();

	std::list<CombinedDataPacket *>::iterator st2,en2;
	st2 = mFunctionStateChanges.begin();
	en2 = mFunctionStateChanges.end();

	while(st2 != en2)
	{
		CombinedDataPacket *packet = *st2++;
		delete packet;
	}
}

void DataBlock_Function::FreeSessionBlocks(void)
{
	SessionBlock_Function *sessdataptr;
	mPerSessionFunction.BeginIterate();

	while( (sessdataptr = mPerSessionFunction.Iterate()) != 0)
	{
		delete sessdataptr;
	}
	mPerSessionFunction.Clear();
}

DataBlock_Function *DataBlock_Function::Register(void *classp,tDataBlock_Function_funcp *data)
{
	DataBlock_Function *object = new DataBlock_Function();

	object->mClassp = classp;
	object->mData = data;

	return object;
}

void DataBlock_Function::Poll(DataBlockReason *reason,const bool discardOlderIncluded,const unsigned int discardOrder)
{
	if (!reason)
	{
		return;
	}

	switch (reason->mReasonCode)
	{
		case kDataBlockReason_SomeoneJoined:
		{
			// Add a session block for the joining session
			SessionBlock_Function *sessdataptr = new SessionBlock_Function();
			mPerSessionFunction.AddItem(reason->mSessionReference,sessdataptr);
			return;
		}

		case kDataBlockReason_SomeoneLeft:
		{
			// Someone left so remove the session block
			SessionBlock_Function *sessdataptr = mPerSessionFunction.FindItem(reason->mSessionReference);
			if (!sessdataptr)
			{
				return;
			}
			mPerSessionFunction.RemoveItem();
			delete sessdataptr;
			return;
			break;
		}

		case kDataBlockReason_NormalPoll:
		{
			if (!reason->mMessageHelper)
			{
				return;
			}

			// This propagates the serialised function call from the combined data to the session in reason->mSessionReference
			SessionBlock_Function *sessdataptr = mPerSessionFunction.FindItem(reason->mSessionReference);
			if (!sessdataptr)
			{
				return;
			}

			CombinedDataPacket *packet;

			packet = sessdataptr->GetNextPacket();
			if (packet)
			{
				DataBlock::Poll(reason,true,++(sessdataptr->mDiscardOrder));
				reason->mMessageHelper->AddData(packet->mCombined,packet->mLen);

#ifndef _FINAL
				if (XPURL::GetDebugHandler())
				{
					std::string theName = GetVariableName();
					const char *name = theName.c_str();
					// Make sure we print something for the debug
					if (packet->mDebug == "")
					{
						packet->mDebug = "No debug\nnull\n";
					}

					EmitBaseDebugInfo(name,"DataBlock_Function",reason);

					XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s.%s (%d)\n\
_PacketSize\n%d\n\
ClassType\nDataBlock_Function\n\
DataBlockID\n%d\n\
To Session ID\n\
%d\n\
Data size\n%d\n\
%s\
::_EndClass\n\
::_Flush\n\
",
					reason->mFloatLocalTime,
					GetROName(),name,(int)mID,
					packet->mLen+2,
					(int)mID,
					reason->mSessionReference,
					packet->mLen,
					packet->mDebug.c_str()
					);
				}
#endif // ifndef _FINAL

				if(packet->Delete())
				{
					delete packet;
				}
			}

			return;

			break;
		}

		case kDataBlockReason_ReplicaCallBackPoll:
		{
			// If there is a function state waiting to be processed on a replica
			while (!mFunctionStateChanges.empty())
			{
				if (!reason->mMessageHelper)
				{
					return;
				}
				if (mFunctionStateChanges.begin() == mFunctionStateChanges.end())
				{
					return;
				}
				// Create a packet from the combined packet data
				CombinedDataPacket *packet;
				std::list<CombinedDataPacket *>::iterator st2 = mFunctionStateChanges.begin();
				packet = (CombinedDataPacket *) *st2;
				mFunctionStateChanges.erase(st2);

				DataBlock::Poll(reason);
				reason->mMessageHelper->AddData(packet->mCombined,packet->mLen);

#ifndef _FINAL
				if (XPURL::GetDebugHandler())
				{
					std::string theName = GetVariableName();
					const char *name = theName.c_str();
					// Make sure we print something for the debug
					if (packet->mDebug == "")
					{
						packet->mDebug = "No debug\nnull\n";
					}

					EmitBaseDebugInfo(name,"DataBlock_Function",reason);

					XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s.%s (%d)\n\
_PacketSize\n%d\n\
ClassType\nDataBlock_Function\n\
DataBlockID\n%d\n\
To Session ID\n\
%d\n\
Callback\n\
Yes\n\
Data size\n%d\n\
%s\
::_EndClass\n\
::_Flush\n\
",
					reason->mFloatLocalTime,
					GetROName(),name,(int)mID,
					packet->mLen+2,
					(int)mID,
					reason->mSessionReference,
					packet->mLen,
					packet->mDebug.c_str()
					);
				}
#endif // ifndef _FINAL


				delete packet;
				return;
			}
			break;
		}

		// This doesn't need to handle kDataBlockReason_AfterDataBlocksReceived because ParseMessage already sets the data when it is received. 

		default:
			break;
	}
}

void DataBlock_Function::ParseMessage(MessageHelper *message)
{
	if (!mBoundObject->IsReplica())
	{
		// The master always accepts updates from all replicas in any order. This is because the message is a callback and the ordering
		// can come from any sessionID.
		// MPi: TODO: An alternative would be to track each sessionID and its order that was sent.
		mDiscardThisUpdate = false;
	}
	void *pDataBlock = (RNReplicaNet::DataBlock*)this;
	// This accepts a message and uses the registered function pointer to call the message cracking function
	(*mData)(mClassp,message,pDataBlock);
}

void DataBlock_Function::AddFunctionStateChange(void *data,int len,const char *debug)
{
	if (!mBoundObject)
	{
		return;
	}

	int numSessions = mConfiguredNumSessions;
	int *sessionIDs = mConfiguredSessionIDs;

	mConfiguredNumSessions = 0;
	mConfiguredSessionIDs = 0;

	// TODO: Might need to make this nominated object aware
	// If this is a master object then...
	if (mBoundObject->IsMaster())
	{
		if (!mPerSessionFunction.IsEmpty())
		{
			// Add the combined data packet describing the function data to each session block queue we know about
			CombinedDataPacket *packet  = new CombinedDataPacket(data,len);
			if (debug && XPURL::GetDebugHandler())
			{
				packet->mDebug = debug;
			}

			SessionBlock_Function *sessdataptr;
			mPerSessionFunction.BeginIterate();

			int index;
			while ( (sessdataptr = mPerSessionFunction.Iterate(&index)) != 0)
			{
				// Only attach the function state change if match == true
				bool match = false;

				if (sessionIDs)
				{
					// Check the list of passed in sessionIDs with the sessionIDs we want to send to and set match if there is one.
					int i;
					for (i=0;i<numSessions;i++)
					{
						if (sessionIDs[i] == index)
						{
							match = true;
							break;
						}
					}
				}
				else
				{
					// No session list so just set match to be true.
					match = true;
				}

				if (match)
				{
					sessdataptr->mCombinedPacketRefs.push_back(packet);
					packet->Attach();
				}
			}
		}
		return;
	}

	// If this is a replica object then only send the combined data to the master
	if (mBoundObject->IsReplica())
	{
		CombinedDataPacket *packet  = new CombinedDataPacket(data,len);
		if (debug && XPURL::GetDebugHandler())
		{
			packet->mDebug = debug;
		}

		mFunctionStateChanges.push_back(packet);
		return;
	}
}

#ifdef __GNUC__
__extension__
#endif

bool DataBlock_Function::IsAttached(void *data)
{
	if (!data)
	{
		return false;
	}
	if (reinterpret_cast<void *>(mData) == data)
	{
		return true;
	}
	return false;
}


void DataBlock_Function::SetSessionIDFilter(const int numSessionIDs,const int *sessionIDs)
{
	mConfiguredNumSessions = numSessionIDs;
	mConfiguredSessionIDs = (int *) sessionIDs;
}


SessionBlock_Function::SessionBlock_Function() : mDiscardOrder(0)
{
}

SessionBlock_Function::~SessionBlock_Function()
{
	CombinedDataPacket *packet;
	while ( (packet = GetNextPacket()) != 0)
	{
		// If the reference count reaches zero then the combined data can be deleted
		if (packet->Delete())
		{
			delete packet;
		}
	}
}

CombinedDataPacket *SessionBlock_Function::GetNextPacket(void)
{
	// Gets the next packet from the queue
	std::list<CombinedDataPacket *>::iterator st,en;
	st = mCombinedPacketRefs.begin();
	en = mCombinedPacketRefs.end();
	if (st != en)
	{
		CombinedDataPacket *packet = (CombinedDataPacket *) *st;
		mCombinedPacketRefs.erase(st);
		return packet;
	}
	return 0;
}

void DataBlock_Function::OwnerChanged(const int sessionID)
{
	DataBlock::OwnerChanged(sessionID);
	FreeSessionBlocks();
}

//From: RNReplicaNet/DataBlock_NData.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "RNReplicaNet/Inc/DataBlock_NData.h"
//Skipping: #include "RNReplicaNet/Inc/ReplicaNet.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
//Skipping: #include "RNXPURL/Inc/XPURL.h"
//Skipping: #include "RNXPURL/Inc/DebugHandler.h"

using namespace RNReplicaNet;


DataBlock_NData::DataBlock_NData() : mData(0) , mSize(0) , mDefaultData(0) , mDisableEndian(false)
{
}

DataBlock_NData::~DataBlock_NData()
{
	FreeSessionBlocks();

	if (mDefaultData)
	{
		free(mDefaultData);
		mDefaultData = 0;
	}
}

void DataBlock_NData::FreeSessionBlocks(void)
{
	SessionBlock_NData *data;
	mPerSessionData.BeginIterate();

	// Delete the remaining session blocks attached to this datablock
	while( (data = mPerSessionData.Iterate()) != 0)
	{
		delete data;
	}
	mPerSessionData.Clear();
}

DataBlock_NData *DataBlock_NData::Register(void *data,int size)
{
	DataBlock_NData *object = new DataBlock_NData();

	object->mData = data;
	object->mSize = size;

	return object;
}

void DataBlock_NData::Poll(DataBlockReason *reason,const bool discardOlderIncluded,const unsigned int discardOrder)
{
	if (!reason)
	{
		return;
	}

	switch (reason->mReasonCode)
	{
		case kDataBlockReason_SomeoneJoined:
		{
			if (reason->mFloatLocalTime < 0.0f)
			{
				assert(0 && "Oops! Someone forgot to set the local time\n");
			}

			if (!reason->mMessageHelper)
			{
				return;
			}
			SessionBlock_NData *sessdataptr = new SessionBlock_NData(mSize);
			mPerSessionData.AddItem(reason->mSessionReference,sessdataptr);
			memcpy(sessdataptr->mTestData,mData,mSize);
			bool aPacketMade = false;
			if (!mDefaultData)
			{
				// Someone joined so calculate an immediate update
				DataBlock::Poll(reason,true,++(sessdataptr->mDiscardOrder));
				if (mDisableEndian)
				{
					reason->mMessageHelper->AddData(sessdataptr->mTestData,mSize);
				}
				else
				{
					reason->mMessageHelper->AddVariable(sessdataptr->mTestData,mSize);
				}
				aPacketMade = true;
				// Store the local time for this update
//				sessdataptr->mLastUpdateSentLocalTime = reason->mFloatLocalTime;
			}
			else
			{
				// We have default data, if the data in the datablock is not the same then send the data,
				// otherwise we don't send data and save packet space
				if (memcmp(mDefaultData,mData,mSize) != 0)
				{
					// Someone joined so calculate an immediate update
					DataBlock::Poll(reason,true,++(sessdataptr->mDiscardOrder));
					if (mDisableEndian)
					{
						reason->mMessageHelper->AddData(sessdataptr->mTestData,mSize);
					}
					else
					{
						reason->mMessageHelper->AddVariable(sessdataptr->mTestData,mSize);
					}
					aPacketMade = true;
					// Store the local time for this update
//					sessdataptr->mLastUpdateSentLocalTime = reason->mFloatLocalTime;
				}
			}

#ifndef _FINAL
			if (aPacketMade && XPURL::GetDebugHandler())
			{
				std::string theName = GetVariableName();
				const char *name = theName.c_str();

				EmitBaseDebugInfo(name,"DataBlock_NData",reason);
				EmitBaseDebugInfoUpdates(name,"DataBlock_NData",reason);

				char theData[128];
				theData[0] = 0;
				int index = 0;
				while (strlen(theData) < 64 && index < mSize)
				{
					char tempHex[8];
					sprintf(tempHex,"%.2x",(unsigned int)((unsigned char *)sessdataptr->mTestData)[index]);
					strcat(theData,tempHex);
					index++;
					if (index < mSize)
					{
						strcat(theData,",");
					}
				}
				if (index < mSize)
				{
					strcat(theData,"...");
				}
				XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s.%s (%d)\n\
_PacketSize\n%d\n\
ClassType\nDataBlock_NData\n\
DataBlockID\n%d\n\
To Session ID\n\
%d\n\
New\n\
Yes\n\
Data size\n%d\n\
Data bytes\n\
%s\n\
::_EndClass\n\
::_Flush\n\
",
				reason->mFloatLocalTime,
				GetROName(),name,(int)mID,
				mSize+2,
				(int)mID,
				reason->mSessionReference,
				mSize,
				theData
				);
			}
#endif // ifndef _FINAL

			return;
		}

		case kDataBlockReason_SomeoneLeft:
		{
			SessionBlock_NData *sessdataptr = mPerSessionData.FindItem(reason->mSessionReference);
			if (sessdataptr)
			{
				mPerSessionData.RemoveItem();
				delete sessdataptr;
				return;
			}
			break;
		}

		case kDataBlockReason_RecordingNormalPoll:
		{
			// Just send out what we have so far
			DataBlock::Poll(reason);
			if (mDisableEndian)
			{
				reason->mMessageHelper->AddData(mData,mSize);
			}
			else
			{
				reason->mMessageHelper->AddVariable(mData,mSize);
			}
			break;
		}

		case kDataBlockReason_NormalPoll:
		{
			if (reason->mFloatLocalTime < 0.0f)
			{
				assert(0 && "Oops! Someone forgot to set the local time\n");
			}

			if (!reason->mMessageHelper)
			{
				return;
			}

			SessionBlock_NData *sessdataptr = mPerSessionData.FindItem(reason->mSessionReference);

			if (!sessdataptr)
			{
				return;
			}
			// If the data is the same then do nothing
			if (memcmp(sessdataptr->mTestData,mData,mSize) == 0)
			{
				// No update, but check for forced updates
				// Check for forced updates
				if (mForceSendMaximumUpdates > 0)
				{
					// If we have a positive time then an update has been sent already
					if (sessdataptr->mLastUpdateSentLocalTime >= 0.0f)
					{
						// Check to see if we want to force send instead
						if (sessdataptr->mNumForcedUpdates < mForceSendMaximumUpdates)
						{
							// Possibly yes send because we have not sent our quota of forced updates yet
							// Now check the delta time
							float delta = (float)(reason->mFloatLocalTime - sessdataptr->mLastUpdateSentLocalTime);
							if (delta >= mForceSendTimeDelay)
							{
								// Yes, we will send an update

								// We force send, so package up a packet to describe the change
								DataBlock::Poll(reason,true,++(sessdataptr->mDiscardOrder));
								if (mDisableEndian)
								{
									reason->mMessageHelper->AddData(mData,mSize);
								}
								else
								{
									reason->mMessageHelper->AddVariable(mData,mSize);
								}


								sessdataptr->mNumForcedUpdates++;
#ifndef _FINAL
								if (XPURL::GetDebugHandler())
								{
									std::string theName = GetVariableName();
									const char *name = theName.c_str();

									EmitBaseDebugInfo(name,"DataBlock_NData",reason);
									EmitBaseDebugInfoUpdates(name,"DataBlock_NData",reason);

									char theData[128];
									theData[0] = 0;
									int index = 0;
									while (strlen(theData) < 64 && index < mSize)
									{
										char tempHex[8];
										sprintf(tempHex,"%.2x",(unsigned int)((unsigned char *)sessdataptr->mTestData)[index]);
										strcat(theData,tempHex);
										index++;
										if (index < mSize)
										{
											strcat(theData,",");
										}
									}
									if (index < mSize)
									{
										strcat(theData,"...");
									}
									XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s.%s (%d)\n\
_PacketSize\n%d\n\
ClassType\nDataBlock_NData\n\
DataBlockID\n%d\n\
To Session ID\n\
%d\n\
Forced\n\
Yes %d\n\
Data size\n%d\n\
Data bytes\n\
%s\n\
::_EndClass\n\
::_Flush\n\
",
									reason->mFloatLocalTime,
									GetROName(),name,(int)mID,
									mSize+2,
									(int)mID,
									reason->mSessionReference,
									sessdataptr->mNumForcedUpdates,
									mSize,
									theData
									);
								}
#endif // ifndef _FINAL

								// Store the local time for this update
								sessdataptr->mLastUpdateSentLocalTime = reason->mFloatLocalTime;
							}
						}
					}
				}

				return;
			}


			// If a normal update is flagged as needing to happen
			if (mUpdateDelayMinimum > 0.0f && sessdataptr->mLastUpdateSentLocalTime >= 0.0f)
			{
				float delta = (float)(reason->mFloatLocalTime - sessdataptr->mLastUpdateSentLocalTime);
				// Then first of all check it isn't shorter than our minimum update delay
				if (delta < mUpdateDelayMinimum)
				{
					// Delay this update by returning
					return;
				}
			}

			// Reset our num forced updates here first
			sessdataptr->mNumForcedUpdates = 0;

			// The data has changed so package up a packet to describe the change
			memcpy(sessdataptr->mTestData,mData,mSize);

			DataBlock::Poll(reason,true,++(sessdataptr->mDiscardOrder));
			if (mDisableEndian)
			{
				reason->mMessageHelper->AddData(mData,mSize);
			}
			else
			{
				reason->mMessageHelper->AddVariable(mData,mSize);
			}


#ifndef _FINAL
			if (XPURL::GetDebugHandler())
			{
				std::string theName = GetVariableName();
				const char *name = theName.c_str();

				EmitBaseDebugInfo(name,"DataBlock_NData",reason);
				EmitBaseDebugInfoUpdates(name,"DataBlock_NData",reason);

				char theData[128];
				theData[0] = 0;
				int index = 0;
				while (strlen(theData) < 64 && index < mSize)
				{
					char tempHex[8];
					sprintf(tempHex,"%.2x",(unsigned int)((unsigned char *)sessdataptr->mTestData)[index]);
					strcat(theData,tempHex);
					index++;
					if (index < mSize)
					{
						strcat(theData,",");
					}
				}
				if (index < mSize)
				{
					strcat(theData,"...");
				}
				XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s.%s (%d)\n\
_PacketSize\n%d\n\
ClassType\nDataBlock_NData\n\
DataBlockID\n%d\n\
To Session ID\n\
%d\n\
Data size\n%d\n\
Data bytes\n\
%s\n\
::_EndClass\n\
::_Flush\n\
",
				reason->mFloatLocalTime,
				GetROName(),name,(int)mID,
				mSize+2,
				(int)mID,
				reason->mSessionReference,
				mSize,
				theData
				);
			}
#endif	// ifndef _FINAL


			// Store the local time for this update
			sessdataptr->mLastUpdateSentLocalTime = reason->mFloatLocalTime;

			return;
			break;
		}

		// This doesn't need to handle kDataBlockReason_AfterDataBlocksReceived because ParseMessage already sets the data when it is received. 

		default:
			break;
	}
}

void DataBlock_NData::ParseMessage(MessageHelper *message)
{
	if (GetDiscardThisUpdate())
	{
		message->SkipData(mSize);
		return;
	}
	if (mDisableEndian)
	{
		message->GetData(mData,mSize);
	}
	else
	{
		message->GetVariable(mData,mSize);
	}
}

DataBlock_NData::SessionBlock_NData::SessionBlock_NData(int datasize) : mDiscardOrder(0)
{
	mTestData = malloc(datasize);

	// A negative time in the past means no update sent yet
	mLastUpdateSentLocalTime = -1.0f;
	// No forced updates sent so far
	mNumForcedUpdates = 0;
}

DataBlock_NData::SessionBlock_NData::~SessionBlock_NData()
{
	if (mTestData)
	{
		free(mTestData);
		mTestData = 0;
	}
}

void DataBlock_NData::SetDefaultData(const void *data)
{
	if (!mDefaultData)
	{
		mDefaultData = malloc(mSize);
	}
	if (mDefaultData)
	{
		memcpy(mDefaultData,data,mSize);
	}
}

bool DataBlock_NData::IsAttached(void *data)
{
	if (!data)
	{
		return false;
	}
	if (mData == data)
	{
		return true;
	}
	return false;
}

void DataBlock_NData::SetEndianTest(const bool test)
{
	mDisableEndian = !test;
}

bool DataBlock_NData::GetEndianTest(void) const
{
	return !mDisableEndian;
}

void DataBlock_NData::OwnerChanged(const int sessionID)
{
	DataBlock::OwnerChanged(sessionID);
	FreeSessionBlocks();
}

//From: RNReplicaNet/DataBlock_Predict_Float.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "RNReplicaNet/Inc/DataBlock_Predict_Float.h"
//Skipping: #include "RNReplicaNet/Inc/ReplicaNet.h"
//Skipping: #include "RNReplicaNet/Inc/ReplicaObject.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
//Include inline: #include "RNPlatform/Options.h"
//From: RNPlatform/Options.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef __OPTIONS_H__
#define __OPTIONS_H__

#ifdef _DEBUG

// Normal printf level
//#define DEBUG_PRINTS1

// Printfs are shown for packet transfers internal to ReplicaNet and XPSesion
//#define DEBUG_PRINTS2

// Printfs are shown for transport packet transfers
//#define DEBUG_PRINTS3

// Warning these two data block debugging defines generate a lot of output
// Printfs are shown for Predict_Float data block calculations
//#define DEBUG_PRINTS4

// Printfs are shown for Predict_Float data block calculations when sending updates
//#define DEBUG_PRINTS5

// Printfs are shown for ReplicaObject functions
//#define DEBUG_PRINTS6

// Printfs are shown for RNLobby logic related to NAT resolving
//#define DEBUG_PRINTS7

#endif

#endif
//Skipping: #include "RNPlatform/DebugSupport.h"
//Skipping: #include "RNXPURL/Inc/XPURL.h"
//Skipping: #include "RNXPURL/Inc/DebugHandler.h"
#include "RNPlatform/Inc/MinMax.h"
//Include inline: #include "RNReplicaNet/SoftFloat16.h"
//From: RNReplicaNet/SoftFloat16.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef __SOFTFLOAT16_H__
#define __SOFTFLOAT16_H__
//Skipping: #include "RNPlatform/Inc/MinMax.h"
#include <math.h>
#include <assert.h>

namespace RNReplicaNet
{

/// This class implements a 16 bit floating point number.
struct SoftFloat16
{
public:
	SoftFloat16 &operator=(const float value)
	{
		assert(sizeof(unsigned int) == sizeof(float));
		assert(sizeof(unsigned short) == 2);
		assert(sizeof(SoftFloat16) == sizeof(unsigned short));

		union
		{
			float aFloat;
			int aInt;
		} working;
		working.aFloat = value;
		mS = (working.aInt >>31) & 1;
		int temp = ((working.aInt) >> 23) & 0xff;
		if (temp >= 127)
		{
			temp = temp - 126;
		}
		else if ((temp < 127) && (temp > 0))
		{
			temp = -(127 - temp);
		}
		// Check for underflow and if it happens return 0.0f instead
		if (temp < -16)
		{
			temp = 0;
			working.aInt = 0;
		}
		mE = min(temp,15);
//		printf("%f = exp %d $%x %d mE %d\n",value,(working.aInt<<1) >> 24,(working.aInt<<1) >> 24,temp,int(mE));
		mM = min((working.aInt & 0x7fffff)>>13,1023);

		return *this;
	}

	operator float() const
	{
		assert(sizeof(unsigned int) == sizeof(float));
		assert(sizeof(unsigned short) == 2);
		assert(sizeof(SoftFloat16) == sizeof(unsigned short));

		union
		{
			float aFloat;
			int aInt;
		} working;
		working.aInt = mS;
		working.aInt = working.aInt << 31;
		int temp = int(mE);
		if (temp > 0)
		{
			temp = temp + 126;
		}
		else if (temp < 0)
		{
			temp = 127 + temp;
		}
		working.aInt |= (temp & 0xff)<<23;
		working.aInt |= int(mM) << 13;

		return working.aFloat;
	}
	
private:
	short mS:1;
	short mE:5;
	unsigned short mM:10;
};

} // namespace RNReplicaNet

#endif

using namespace RNReplicaNet;

DataBlock_Predict_Float::DataBlock_Predict_Float() : mData(0) , mContinuityBreak(true) ,
				mIsDistanceBased(false) ,
				mMinDistance(0.0f) , mMaxDistance(0.0f)  , mMinError(0.0f) , mIsQuadratic(false) ,
				mGotData(false) , mImplementTeleport(false) , mDoPrep(true) , mLagged(0.0f) , mFirstLaggedTime(0.0f) ,
				mBoundaryEnable(false) , mBoundaryIsWrap(false) , mBoundaryLower(0.0f) , mBoundaryUpper(360.0f) ,
				mBoundaryWriteBack(false) , mLastGoodDataTime(-100000.0f) ,
				mShortValue(false) , mShortDelta(false) , mTimeDelta(0.0f)
{
	mMasterData.mDelta = 0.0f;
	mMasterData.mSampleHistory[0] = 0.0f;
	mMasterData.mSampleHistory[1] = 0.0f;
	mMasterData.mSampleHistoryTime[0] = 0.0f;
	mMasterData.mSampleHistoryTime[1] = 0.0f;
	mMasterData.mSampleHistoryTimeLocal[0] = 0.0f;
	mMasterData.mSampleHistoryTimeLocal[1] = 0.0f;
	mMasterData.mSample = 0.0f;
	mMasterData.mSampleTime = 0.0f;
	mMasterData.mGotDeltaHint = false;
	mMasterData.mTheDeltaHint = 0.0f;


	mReplicaData.mDelta = 0.0f;
	mReplicaData.mFirstTime = true;
	mReplicaData.mFirstTimeNotReset = true;
	mReplicaData.mSample = 0.0f;
	mReplicaData.mSampleTime = 0.0f;

	mTestData = 0.0f;

	SetMaxError();
	SetInterpolationFilter();
	SetSnapToDifference();
}

DataBlock_Predict_Float::~DataBlock_Predict_Float()
{
	FreeSessionBlocks();
}

void DataBlock_Predict_Float::FreeSessionBlocks(void)
{
	SessionBlock_Predict_Float *sessdataptr;
	mPerSessionData.BeginIterate();

	while( (sessdataptr = mPerSessionData.Iterate()) != 0)
	{
		delete sessdataptr;
	}
	mPerSessionData.Clear();
}

DataBlock_Predict_Float *DataBlock_Predict_Float::Register(float *data)
{
	DataBlock_Predict_Float *object = new DataBlock_Predict_Float();

	object->mData = data;

	return object;
}

void DataBlock_Predict_Float::SetMinError(float minerror)
{
	mMinError = minerror;
}

void DataBlock_Predict_Float::SetMaxError(float maxerror)
{
	mMaxError = maxerror;
}

void DataBlock_Predict_Float::SetMinDistance(float distance)
{
	mIsDistanceBased = true;
	mMinDistance = distance;
}

void DataBlock_Predict_Float::SetMaxDistance(float distance)
{
	mIsDistanceBased = true;
	mMaxDistance = distance;
}

void DataBlock_Predict_Float::SetInterpolationFilter(float interpolation)
{
	mInterpolationFilter = interpolation;
}

void DataBlock_Predict_Float::Poll(DataBlockReason *reason,const bool discardOlderIncluded,const unsigned int discardOrder)
{
#ifdef DEBUG_PRINTS4
	dprintf("DataBlock_Predict_Float:DataBlock_Predict_Float::Poll for object at time %f sess %d uni %d\n",reason->mFloatTime,mBoundObject->GetSessionID(),mBoundObject->GetUniqueID());
#endif

	if (!reason)
	{
#ifdef DEBUG_PRINTS4
	dprintf("DataBlock_Predict_Float:   NO REASON given!\n");
#endif
		return;
	}

#ifdef DEBUG_PRINTS4
	dprintf("DataBlock_Predict_Float:DataBlock ID %d\n",mID);
	dprintf("DataBlock_Predict_Float:mData = %f\n",*mData);
#endif

	// Now check the reason code passed in for the poll method
	switch (reason->mReasonCode)
	{
		case kDataBlockReason_SomeoneJoined:
		{
			if (reason->mFloatLocalTime < 0.0f)
			{
				assert(0 && "Oops! Someone forgot to set the local time\n");
			}

#ifdef DEBUG_PRINTS4
	dprintf("DataBlock_Predict_Float:kDataBlockReason_SomeoneJoined Someone joined session ref %d\n",reason->mSessionReference);
#endif
			if (!reason->mMessageHelper)
			{
#ifdef DEBUG_PRINTS4
				dprintf("DataBlock_Predict_Float:*** reason->mMessageHelper expected but there was none!\n");
#endif
				return;
			}
			assert(!mDoPrep && "DoPrep shouldn't be set when someone joins");
			// Create a new session data block for the joining session
			SessionBlock_Predict_Float *sessdataptr = new SessionBlock_Predict_Float();
			// Initialise the variables to the known state of the master extrapolation values
			sessdataptr->mTestData = mMasterData.mSample;
			sessdataptr->mDelta = mMasterData.mDelta;
			// Someone joined so calculate an immediate update
			sessdataptr->mSample = mMasterData.mSample;
			sessdataptr->mSampleTime = mMasterData.mSampleTime;
			// Create the data packet
			DataBlock::Poll(reason,true,++(sessdataptr->mDiscardOrder));
			int packetSize = AddDataBlockData(reason->mMessageHelper,sessdataptr->mSample,sessdataptr->mSampleTime,sessdataptr->mDelta);
			packetSize = reason->mMessageHelper->GetSize() - packetSize;
			// Store the local time for this update
//			sessdataptr->mLastUpdateSentLocalTime = reason->mFloatLocalTime;


#ifndef _FINAL
			if (XPURL::GetDebugHandler())
			{
				std::string theName = GetVariableName();
				const char *name = theName.c_str();

				EmitBaseDebugInfo(name,"DataBlock_PredictFloat",reason);
				EmitBaseDebugInfoUpdates(name,"DataBlock_PredictFloat",reason);

				XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s.%s (%d)\n\
_PacketSize\n%d\n\
ClassType\nDataBlock_PredictFloat\n\
DataBlockID\n%d\n\
To Session ID\n\
%d\n\
New joiner\n\
Yes\n\
Float\n%f\n\
SampleTime\n%f\n\
Delta\n%f\n\
::_EndClass\n\
::_Flush\n\
",
				reason->mFloatLocalTime,
				GetROName(),name,(int)mID,
				packetSize,
				(int)mID,
				reason->mSessionReference,
				sessdataptr->mSample,
				sessdataptr->mSampleTime,
				sessdataptr->mDelta
				);
			}
#endif	// ifndef _FINAL


			mPerSessionData.AddItem(reason->mSessionReference,sessdataptr);
#ifdef DEBUG_PRINTS4
			dprintf("DataBlock_Predict_Float:   Adding hard continuity break params samp0 %f,time %f delta %f\n",mMasterData.mSample,mMasterData.mSampleTime,mMasterData.mDelta);
#endif
			return;
		}

		case kDataBlockReason_SomeoneLeft:
		{
#ifdef DEBUG_PRINTS4
	dprintf("DataBlock_Predict_Float:DataBlock_Predict_Float::Poll Someone left session ref %d\n",reason->mSessionReference);
#endif
			// Find the session data block and remove it from the list
			SessionBlock_Predict_Float *sessdataptr = mPerSessionData.FindItem(reason->mSessionReference);
			if (!sessdataptr)
			{
				return;
			}
			mPerSessionData.RemoveItem();
			delete sessdataptr;
			return;
			break;
		}

		case kDataBlockReason_RecordingNormalPoll:
		{
			if (reason->mFloatTime < 0.0f)
			{
				assert(0 && "Oops! Someone forgot to set the time\n");
			}
			if (reason->mFloatLocalTime < 0.0f)
			{
				assert(0 && "Oops! Someone forgot to set the local time\n");
			}
			// Just send out what we have so far
			DataBlock::Poll(reason);
			// If we recently got data then send it back out as it is the better data to use
			if (mGotData)
			{
				AddDataBlockData(reason->mMessageHelper,mReplicaData.mSample,mReplicaData.mSampleTime,mReplicaData.mDelta);
			}
			else
			{
				// No data got recently so we send out a static update
				AddDataBlockData(reason->mMessageHelper,*mData,reason->mFloatTime,0.0f);
			}
			break;
		}

		case kDataBlockReason_MasterPrepAfterTakeover:
		{
#ifdef DEBUG_PRINTS4
			dprintf("DataBlock_Predict_Float:kDataBlockReason_MasterPrepAfterTakeover\n");
#endif
			FreeSessionBlocks();
			mContinuityBreak = true;
			// The object has been taken over by the new session so signal a continuity break
			if (mGotData)
			{
				// No need to do the prep if we got data from an update before
				// So now we copy what we got last sent instead.
				SysTimeType timeLocal = reason->mFloatLocalTime;
				mMasterData.mDelta = mReplicaData.mDelta;
				mMasterData.mSample = mReplicaData.mSample;
				mMasterData.mSampleTime = mReplicaData.mSampleTime;

				mMasterData.mSampleHistory[0] = mMasterData.mSample;
				mMasterData.mSampleHistoryTime[0] = mMasterData.mSampleTime;
				mMasterData.mSampleHistoryTimeLocal[0] = timeLocal;
				mMasterData.mSampleHistory[1] = mMasterData.mSample;
				mMasterData.mSampleHistoryTime[1] = mMasterData.mSampleTime-1.0f;
				mMasterData.mSampleHistoryTimeLocal[1] = timeLocal-1.0f;
			}
			else
			{
				// No previous data, so trigger a prep
				mDoPrep = true;
			}

			// Reset this flag
			mDoneMasterPoll = false;

			mParsedByTime.clear();

			break;
		}

		case kDataBlockReason_ReplicaPrepAfterTakeover:
		{
#ifdef DEBUG_PRINTS4
			dprintf("DataBlock_Predict_Float:kDataBlockReason_ReplicaPrepAfterTakeover\n");
#endif
			FreeSessionBlocks();
			// The object has been taken over by the new session
			// Clear the got data flag, this is until we get fresh new data.
			mGotData = false;
			if (mDoneMasterPoll)
			{
				// So the datablock has sensible replica values we always copy from the master if we can. This is so that when the owner changes
				// there is no use of old data.
				mReplicaData.mDelta = mMasterData.mDelta;
				mReplicaData.mSample = mMasterData.mSample;
				mReplicaData.mSampleTime = mMasterData.mSampleTime;
				mGotData = true;
				// Turn of the position set and allow it to use the interpolate instead.
				mReplicaData.mFirstTime = false;
				mReplicaData.mFirstTimeNotReset = false;
			}

			mParsedByTime.clear();
			break;
		}

		case kDataBlockReason_CalculateMasterPoll:
		{
			// What this does is to track the "master" copy of how the value changes and figure out the internal extrapolation values that track these changes best
			if (reason->mFloatTime < 0.0f)
			{
				assert(0 && "Oops! Someone forgot to set the time\n");
			}
#ifdef DEBUG_PRINTS4
			dprintf("DataBlock_Predict_Float:kDataBlockReason_CalculateMasterPoll\n");
#endif
			mTestData = *mData;
			mTestData = ApplyBoundaryToValue(mTestData);
			if (mBoundaryWriteBack)
			{
				*mData = mTestData;
			}

			SysTimeType time = reason->mFloatTime;
			SysTimeType timeLocal = reason->mFloatLocalTime;

			// Update the history
			mMasterData.mSampleHistory[1] = mMasterData.mSampleHistory[0];
			mMasterData.mSampleHistoryTime[1] = mMasterData.mSampleHistoryTime[0];
			mMasterData.mSampleHistoryTimeLocal[1] = mMasterData.mSampleHistoryTimeLocal[0];
			mMasterData.mSampleHistory[0] = mTestData;
			mMasterData.mSampleHistoryTime[0] = time;
			mMasterData.mSampleHistoryTimeLocal[0] = timeLocal;


			// If mDoPrep is flagged then the first calculation is done here
			// However if the user provides an initial hint then mContinuityBreak is set to be false because the hint clears the continuity break temporarily
			// However the continuity break can be set if the hint is found out to be not good enough down below in the error test.
			if (mDoPrep)
			{
#ifdef DEBUG_PRINTS4
				dprintf("DataBlock_Predict_Float:	  Is a mDoPrep first time type of break\n");
#endif
				// Create two samples the same separated by one second of time
				mMasterData.mSample = mTestData;
				mMasterData.mSampleTime = time;
				mMasterData.mSampleHistory[0] = mTestData;
				mMasterData.mSampleHistoryTime[0] = time;
				mMasterData.mSampleHistoryTimeLocal[0] = timeLocal;
				mMasterData.mSampleHistory[1] = mTestData;
				mMasterData.mSampleHistoryTime[1] = time-1.0f;
				mMasterData.mSampleHistoryTimeLocal[1] = timeLocal-1.0f;

				// Set the calculated delta to be zero
				mMasterData.mDelta = 0.0f;

				// If the master got a delta hint then copy the hint
				if (mMasterData.mGotDeltaHint)
				{
					mMasterData.mDelta = mMasterData.mTheDeltaHint;
					// One second in the past means use the negative delta
					mMasterData.mSampleHistory[1] = mTestData - mMasterData.mTheDeltaHint;
				}

				mDoPrep = false;
			}


			// If the master got a delta hint then copy the hint as a value to use
			if (mMasterData.mGotDeltaHint)
			{
				mMasterData.mDelta = mMasterData.mTheDeltaHint;

				// t0 extrapolation
				mMasterData.mSample = mTestData;
				mMasterData.mSampleTime = time;

				// t-1 prediction
//				float inThePast = time - mMasterData.mSampleHistoryTime[1];
//				mMasterData.mSample = mMasterData.mSampleHistory[1] - (mMasterData.mDelta * time);
//				mMasterData.mSampleTime = mMasterData.mSampleHistoryTime[1];
			}

#ifndef _FINAL
// Output delta hint causes so much debug it is silly.
/*
			if (XPURL::GetDebugHandler() && mMasterData.mGotDeltaHint)
			{
				std::string theName = GetVariableName();
				const char *name = theName.c_str();

				XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s.%s (%d).DataBlock_PredictFloat.mDeltaHint\nfloat\n%f\n\
::_EndClass\n\
::_Flush\n\
",
				reason->mFloatLocalTime,
				GetROName(),name,(int)mID,mMasterData.mTheDeltaHint
				);
			}
*/
#endif

			float extrapolated = (float) (mMasterData.mSample + (mMasterData.mDelta * (time - mMasterData.mSampleTime)));
			extrapolated = ApplyBoundaryToValue(extrapolated);

			float extrapToRealDiff = (float) fabs(extrapolated - mTestData);
			if (mBoundaryEnable && mBoundaryIsWrap)
			{
				// Massage wrap around cases
				// If there is more than 50% swing in a wrap around then it is shorter to swing the other way around
				float swing = mBoundaryUpper - mBoundaryLower;
				if (extrapToRealDiff > (swing/2.0f))
				{
					// Massage the difference to take into account of the swing
					extrapToRealDiff = swing - extrapToRealDiff;
				}
			}

			// Choose the error to use
			float errorToUse = mMaxError;
			if (mIsDistanceBased)
			{
				errorToUse = mMinError;
			}

			// Test the error against the extrapolation
			if (extrapToRealDiff >= errorToUse)
			{
				// If there are automatic updates then signal a continuity break
				if (mAutomaticUpdates)
				{
					mContinuityBreak = true;
#ifdef DEBUG_PRINTS4
					dprintf("DataBlock_Predict_Float:   Extrapolated continuity break\n");
#endif

				}
				else
				{
#ifdef DEBUG_PRINTS4
					dprintf("DataBlock_Predict_Float:   There would have been an extrapolated continuity break but mAutomaticUpdates == false\n");
#endif
				}
			}

			// If there is a continuity break or a doprep then force a recalculation of the delta
			if (mContinuityBreak)
			{
#ifdef DEBUG_PRINTS4
				dprintf("DataBlock_Predict_Float:   Error too large, processing a continuity break\n");
#endif

				// Use the samples to calculate a delta using local time for the delta since it is a cleaner source of time value.
				float deltaT = (float)(mMasterData.mSampleHistoryTimeLocal[0] - mMasterData.mSampleHistoryTimeLocal[1]);
				if (deltaT > 0.0f)
				{
					if (mBoundaryEnable && mBoundaryIsWrap)
					{
						float shorterDiff1 = (mBoundaryUpper - mBoundaryLower) - (mMasterData.mSampleHistory[0] - mMasterData.mSampleHistory[1]);
						float shorterDiff2 = (mMasterData.mSampleHistory[0] - mMasterData.mSampleHistory[1]);
						if (fabs(shorterDiff1) < fabs(shorterDiff2))
						{
							mMasterData.mDelta = shorterDiff1 / deltaT;
						}
						else
						{
							mMasterData.mDelta = shorterDiff2 / deltaT;
						}
					}
					else
					{
						mMasterData.mDelta = (mMasterData.mSampleHistory[0] - mMasterData.mSampleHistory[1]) / deltaT;
					}
				}
				else
				{
					mMasterData.mDelta = 0.0f;
				}

				mMasterData.mSample = mMasterData.mSampleHistory[0];
				// The time used in the replica is the network time and *not* the local time.
				mMasterData.mSampleTime = mMasterData.mSampleHistoryTime[0];

				mContinuityBreak = false;
#ifdef DEBUG_PRINTS4
				dprintf("DataBlock_Predict_Float:   Master poll continuity break params samp0 %f,time %f samp1 %f,time %f  delta %f\n",mMasterData.mSampleHistory[0],mMasterData.mSampleHistoryTimeLocal[0],mMasterData.mSampleHistory[1],mMasterData.mSampleHistoryTimeLocal[1],mMasterData.mDelta);
#endif

			}

			// Make sure the delta hint, if any is set to be false so we don't try to use it again until a new one comes in
			mMasterData.mGotDeltaHint = false;

			if (mReflectionMasterUpdate && mGotData && (mBoundObject->GetMessageReflectionID() != kReplicaNetUnknownUniqueID) && (mBoundObject->GetMessageReflectionID() == reason->mSessionReference))
			{
				mLagged = 0.0f;	// As per SetLagged() NOTE
				float extrapolated = CalculateReplicaValue(reason);
				*mData = extrapolated;
			}

			if (mForceReflectionUpdate && mGotData && (mBoundObject->GetMessageReflectionID() != kReplicaNetUnknownUniqueID) && (mBoundObject->GetMessageReflectionID() == reason->mSessionReference))
			{
				mMasterData.mSample = mReplicaData.mSample;
				mMasterData.mSampleTime = mReplicaData.mSampleTime;
				mMasterData.mDelta = mReplicaData.mDelta;
			}

			// If a teleport continuity break is flagged then signal a teleport to happen for all known session data blocks
			if (mImplementTeleport)
			{
				mImplementTeleport = false;

				// So the datablock has sensible replica values we always copy from the master. This is so that when the owner changes
				// there is no use for old data.
				mReplicaData.mFirstTime = true;

				// Now flag the other blocks
				SessionBlock_Predict_Float *sessdataptr;
				mPerSessionData.BeginIterate();

				while( (sessdataptr = mPerSessionData.Iterate()) != 0)
				{
					sessdataptr->mImplementTeleport = true;
				}
			}

			mDoneMasterPoll = true;
			break;
		}

		case kDataBlockReason_CalculateReplicaPoll:
		{
			if (reason->mFloatTime < 0.0f)
			{
				assert(0 && "Oops! Someone forgot to set the time\n");
			}
#ifdef DEBUG_PRINTS4
	dprintf("DataBlock_Predict_Float:   kDataBlockReason_CalculateReplicaPoll:\n");
#endif


			if (!mGotData)
			{
#ifdef DEBUG_PRINTS4
				dprintf("DataBlock_Predict_Float:   !mGotData\n");
#endif
				break;
			}

			if (mReflectionMasterUpdate && mGotData && (mBoundObject->GetMessageReflectionID() != kReplicaNetUnknownUniqueID) && (mBoundObject->GetMessageReflectionID() == reason->mSessionReference))
			{
#ifdef DEBUG_PRINTS4
				dprintf("DataBlock_Predict_Float:   mReflectionMasterUpdate\n");
#endif
				mLagged = 0.0f;	// As per SetLagged() NOTE
				break;
			}

			float extrapolated = CalculateReplicaValue(reason);
#ifdef DEBUG_PRINTS4
	dprintf("DataBlock_Predict_Float:   Extrapolated = %f Real time %f (samp %f time %f delta %f)\n",extrapolated,reason->mFloatTime,mReplicaData.mSample,mReplicaData.mSampleTime,mReplicaData.mDelta);
#endif
			// If this flag is set then the extrapolated data is not passed through the interpolation filter.
			// This mFirstTime flag is set if the data packet arrives with a negative time indicating a continuity break
			if (mReplicaData.mFirstTime)
			{
#ifdef DEBUG_PRINTS4
				dprintf("DataBlock_Predict_Float:   First time\n");
#endif
				*mData = extrapolated;
				mReplicaData.mFirstTime = false;
				if (mReflectionMasterUpdate)
				{
					mImplementTeleport = true;
				}
			}
			else
			{
#ifdef DEBUG_PRINTS4
				dprintf("DataBlock_Predict_Float:   Interpolated pre mData %f  interp filter %f deltatime %f\n",*mData,mInterpolationFilter,reason->mFloatValue);
#endif
				float resultToStore = *mData;	// Read what is there to begin with so we can perform calculations on it without worrying about a different thread altering the value. Unlikely but could happen.

				// Use the interpolation filter for the extrapolated value based on the delta time
				// This helps to smooth the data and smooth out small jumps caused by latency
				if (reason->mFloatValue >= 1.0f)
				{
					resultToStore = extrapolated;
				}
				else if (reason->mFloatValue > 0.0f)
				{
					float deltaV = 0.0f;
					if (mBoundaryEnable && mBoundaryIsWrap)
					{
						// Apply smoothing through the shortest swing from extrapolated to the target
						float swing = mBoundaryUpper - mBoundaryLower;
						float extrapToRealDiff = 0.0f;
						if (extrapolated > resultToStore)
						{
							extrapToRealDiff = (extrapolated - resultToStore);
							if (extrapToRealDiff > (swing/2.0f))
							{
								extrapToRealDiff = -(swing - extrapToRealDiff);
							}
						}
						else
						{
							extrapToRealDiff = (resultToStore - extrapolated);
							if (extrapToRealDiff > (swing/2.0f))
							{
								extrapToRealDiff = -(swing - extrapToRealDiff);
							}
							extrapToRealDiff = -extrapToRealDiff;
						}

						deltaV = (float)(extrapToRealDiff * mInterpolationFilter * reason->mFloatValue * 100.0f);	// The 100.0f is there to speed up the interpolation filter so it tends faster to the targeted value.

						// Different overshoot and undershoot tests.
						if (extrapToRealDiff < 0.0f)
						{
							if (deltaV < extrapToRealDiff)
							{
								deltaV = extrapToRealDiff;
							}
						}
						else
						{
							if (deltaV > extrapToRealDiff)
							{
								deltaV = extrapToRealDiff;
							}
						}

						resultToStore += deltaV;
					}
					else
					{
						deltaV = (float)((extrapolated - resultToStore) * mInterpolationFilter * reason->mFloatValue * 100.0f);	// The 100.0f is there to speed up the interpolation filter so it tends faster to the targeted value.
						// Overshoot and undershoot tests.
						resultToStore += deltaV;
						if (deltaV > 0.0f)
						{
							if (resultToStore > extrapolated)
							{
								resultToStore = extrapolated;
							}
						}
						else
						{
							if (resultToStore < extrapolated)
							{
								resultToStore = extrapolated;
							}
						}
					}


					resultToStore = ApplyBoundaryToValue(resultToStore);
				}

				// Check the result is within any configured snap to difference.
				if (mSnapToDifference >= 0.0f)
				{
					float theDiff = 0.0f;
					if (mBoundaryEnable && mBoundaryIsWrap)
					{
						// Wrap means the snap across the smallest swing to has to be taken into account
						float shorterDiff1 = (mBoundaryUpper - mBoundaryLower) - (float) fabs(extrapolated - resultToStore);
						float shorterDiff2 = (float) fabs(extrapolated - resultToStore);
						// Pick the smallest swing difference
						theDiff = (float) min(fabs(shorterDiff1),fabs(shorterDiff2));
					}
					else
					{
						// No swing so just diff
						theDiff = (float) fabs(extrapolated - resultToStore);
					}

					if (theDiff > mSnapToDifference)
					{
						resultToStore = extrapolated;
					}
				}

				*mData = resultToStore;

			}

#ifdef DEBUG_PRINTS4
			dprintf("DataBlock_Predict_Float:   Interpolated post mData %f\n",*mData);
#endif

			break;
		}

		case kDataBlockReason_NormalPoll:
		{
			if (reason->mFloatTime < 0.0f)
			{
				assert(0 && "Oops! Someone forgot to set the time\n");
			}

			if (reason->mFloatLocalTime < 0.0f)
			{
				assert(0 && "Oops! Someone forgot to set the local time\n");
			}
#ifdef DEBUG_PRINTS4
	dprintf("DataBlock_Predict_Float:   kDataBlockReason_NormalPoll:\n");
#endif

			if (!reason->mMessageHelper)
			{
#ifdef DEBUG_PRINTS4
				dprintf("DataBlock_Predict_Float:*** reason->mMessageHelper expected but there was none!\n");
#endif
				return;
			}

			// Look for the session block in the list
			SessionBlock_Predict_Float *sessdataptr = mPerSessionData.FindItem(reason->mSessionReference);
			if (!sessdataptr)
			{
				return;
			}

//	dprintf("DataBlock_Predict_Float:Iteration\n");

			sessdataptr->mTestData = *mData;
			SysTimeType time = reason->mFloatTime;

			float extrapolated;
			extrapolated = (float)(sessdataptr->mSample + (sessdataptr->mDelta * (time - sessdataptr->mSampleTime)));
			extrapolated = ApplyBoundaryToValue(extrapolated);

			// Calculate the difference between the extrapolated value for the current session data block and the real value
			float extrapToRealDiff = (float) fabs(extrapolated - sessdataptr->mTestData);
			if (mBoundaryEnable && mBoundaryIsWrap)
			{
				// Massage wrap around cases
				// If there is more than 50% swing in a wrap around then it is shorter to swing the other way around
				float swing = mBoundaryUpper - mBoundaryLower;
				if (extrapToRealDiff > (swing/2.0f))
				{
					// Massage the difference to take into account of the swing
					extrapToRealDiff = swing - extrapToRealDiff;
				}
			}

			// Assume the maximum error to be used because the ROL::Predict_Float::SetError() sets both min and maximum error values to be the same
			float errorToUse = mMaxError;
#ifndef _FINAL
			float debugDistance = -1.0f;
			int debugSessID=-1,debugUniID = -1;
			const char *debugROName = 0;
#endif
			// mIsDistanceBased is set to be true if either the minimum or maximum distance is set by the user
			if (mIsDistanceBased)
			{
				// If there is an observer object then use this fact to calculate what error value to use
				if (reason->mObserver)
				{
					// Assume the minimum error is to be used.
					errorToUse = mMinError;

					// Get the distance to the object we want
#ifndef _FINAL
					if (reason->mObserver)
					{
						debugSessID = reason->mObserver->GetSessionID();
						debugUniID = reason->mObserver->GetUniqueID();
						debugROName = GetROName(reason->mObserver);
					}
#endif
					float distance = mBoundObject->GetDistanceToObject(reason->mObserver);
#ifndef _FINAL
					debugDistance = distance;
#endif
					// If the distance is not infinite
					if (distance != kReplicaObject_InfiniteDistance)
					{
						// Decide what error to use based on distance
						if (distance > mMinDistance && distance < mMaxDistance)
						{
							// Quadratic distance or linear?
							if (mIsQuadratic)
							{
								distance = (distance*distance) - (mMinDistance*mMinDistance);
								distance = distance / ((mMaxDistance - mMinDistance)*(mMaxDistance - mMinDistance));
								errorToUse = mMinError + (distance * (mMaxError - mMinError));
							}
							else
							{
								distance = distance - mMinDistance;
								distance = distance / (mMaxDistance - mMinDistance);
								errorToUse = mMinError + (distance * (mMaxError - mMinError));
							}
						}
						else if (distance <= mMinDistance)
						{
							errorToUse = mMinError;
						}
						else
						{
							errorToUse = mMaxError;
						}
					}
				}
				else
				{
					// Use the minimum error because there is no observer but we don't want to punish the session without an observer by supplying less accurate data
					errorToUse = mMinError;
				}
			}

			// Signal a continuity break if the extrapolated value is outside of the expected error
			// A continuity break can also be flagged by the user
			if (extrapToRealDiff >= errorToUse)
			{
				sessdataptr->mContinuityBreak = true;
			}

			// If a normal update is flagged as needing to happen
			if (sessdataptr->mContinuityBreak && (mUpdateDelayMinimum > 0.0f) && (sessdataptr->mLastUpdateSentLocalTime >= 0.0f))
			{
				float delta = (float)(reason->mFloatLocalTime - sessdataptr->mLastUpdateSentLocalTime);
				// Then first of all check it isn't shorter than our minimum update delay
				if (delta < mUpdateDelayMinimum)
				{
					// Delay this update by setting it to be false
					sessdataptr->mContinuityBreak = false;
				}
			}

			// The continuity break is still going to happen due to filter conditions
			if (sessdataptr->mContinuityBreak)
			{
				// Reset our num forced updates here first
				sessdataptr->mNumForcedUpdates = 0;
			}

			// Check for forced updates
			if (mForceSendMaximumUpdates > 0)
			{
				// If we have a positive time then an update has been sent already
				if (sessdataptr->mLastUpdateSentLocalTime >= 0.0f)
				{
					// No update this time?
					if (!sessdataptr->mContinuityBreak)
					{
						// Check to see if we want to force send instead
						if (sessdataptr->mNumForcedUpdates < mForceSendMaximumUpdates)
						{
							// Possibly yes send because we have not sent our quota of forced updates yet
							// Now check the delta time
							float delta = (float)(reason->mFloatLocalTime - sessdataptr->mLastUpdateSentLocalTime);
							if (delta >= mForceSendTimeDelay)
							{
								// Yes, we will send an update
								sessdataptr->mContinuityBreak = true;

								// Increment the number of forced updates
								sessdataptr->mNumForcedUpdates++;
							}
						}
					}
				}
			}

			// If there is a continuity break then force a recalculation of the delta
			if (sessdataptr->mContinuityBreak || sessdataptr->mImplementTeleport)
			{
				// The samples and delta that are sent to the client come from the master calculated data since this is the most up to date
				sessdataptr->mSample = mMasterData.mSample;
				sessdataptr->mSampleTime = mMasterData.mSampleTime;
				sessdataptr->mDelta = mMasterData.mDelta;

				sessdataptr->mContinuityBreak = false;

				SysTimeType theSampleTime = sessdataptr->mSampleTime;

				// If we have a teleported data block then tell our replica not to use interpolation for the next change by setting a negative time
				if (sessdataptr->mImplementTeleport)
				{
#ifdef DEBUG_PRINTS5
					dprintf("DataBlock_Predict_Float:The next continuity break is a teleport type\n");
#endif

					theSampleTime = -theSampleTime;
				}

				// Create the data packet
				DataBlock::Poll(reason,true,++(sessdataptr->mDiscardOrder));
				int packetSize = AddDataBlockData(reason->mMessageHelper,sessdataptr->mSample,theSampleTime,sessdataptr->mDelta);


#ifndef _FINAL
				if (XPURL::GetDebugHandler())
				{
					std::string theName = GetVariableName();
					const char *name = theName.c_str();

					// Debug output the DataBlock class information
					EmitBaseDebugInfo(name,"DataBlock_PredictFloat",reason);
					EmitBaseDebugInfoUpdates(name,"DataBlock_PredictFloat",reason);

// MPi: TODO: Add a dirty flag to cache most of these (not all, debugDistance, errorToUse for example changes)
					XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s.%s (%d).DataBlock_PredictFloat.mIsDistanceBased\nbool\n%d\n\
::_EndClass\n\
::_Flush\n\
::%s.%s (%d).DataBlock_PredictFloat.mIsQuadratic\nbool\n%d\n\
::_EndClass\n\
::_Flush\n\
::%s.%s (%d).DataBlock_PredictFloat.mMinDistance\nfloat\n%f\n\
::_EndClass\n\
::_Flush\n\
::%s.%s (%d).DataBlock_PredictFloat.mMaxDistance\nfloat\n%f\n\
::_EndClass\n\
::_Flush\n\
::%s.%s (%d).DataBlock_PredictFloat.mMinError\nfloat\n%f\n\
::_EndClass\n\
::_Flush\n\
::%s.%s (%d).DataBlock_PredictFloat.mMaxError\nfloat\n%f\n\
::_EndClass\n\
::_Flush\n\
::%s.%s (%d).DataBlock_PredictFloat.distance calculated\nfloat\n%f\nTo ReplicaObject\n%d:%d _lnk:%s\n\
::_EndClass\n\
::_Flush\n\
::%s.%s (%d).DataBlock_PredictFloat.distance error\nfloat\n%f\n\
::_EndClass\n\
::_Flush\n\
::%s.%s (%d).DataBlock_PredictFloat.error detected\nfloat\n%f\nMaster value\nfloat\n%f\nReplica value\nfloat\n%f\n\
::_EndClass\n\
::_Flush\n\
",
					reason->mFloatLocalTime,
					GetROName(),name,(int)mID,(int)mIsDistanceBased,
					GetROName(),name,(int)mID,(int)mIsQuadratic,
					GetROName(),name,(int)mID,mMinDistance,
					GetROName(),name,(int)mID,mMaxDistance,
					GetROName(),name,(int)mID,mMinError,
					GetROName(),name,(int)mID,mMaxError,
					GetROName(),name,(int)mID,debugDistance,debugSessID,debugUniID,debugROName,
					GetROName(),name,(int)mID,errorToUse,
					GetROName(),name,(int)mID,extrapToRealDiff,sessdataptr->mTestData,extrapolated
					);

					if (sessdataptr->mNumForcedUpdates > 0)
					{
						if (sessdataptr->mImplementTeleport)
						{
							XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s.%s (%d)\n\
_PacketSize\n%d\n\
ClassType\nDataBlock_PredictFloat\n\
DataBlockID\n%d\n\
To Session ID\n\
%d\n\
Forced\n\
Yes %d\n\
Teleport\n\
Yes\n\
Float\n%f\n\
SampleTime\n%f\n\
Delta\n%f\n\
::_EndClass\n\
::_Flush\n\
",
							reason->mFloatLocalTime,
							GetROName(),name,(int)mID,
							packetSize,
							(int)mID,
							reason->mSessionReference,
							sessdataptr->mNumForcedUpdates,
							sessdataptr->mSample,
							sessdataptr->mSampleTime,
							sessdataptr->mDelta
							);
						}
						else
						{
							XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s.%s (%d)\n\
_PacketSize\n%d\n\
ClassType\nDataBlock_PredictFloat\n\
DataBlockID\n%d\n\
To Session ID\n\
%d\n\
Forced\n\
Yes %d\n\
Float\n%f\n\
SampleTime\n%f\n\
Delta\n%f\n\
::_EndClass\n\
::_Flush\n\
",
							reason->mFloatLocalTime,
							GetROName(),name,(int)mID,
							packetSize,
							(int)mID,
							reason->mSessionReference,
							sessdataptr->mNumForcedUpdates,
							sessdataptr->mSample,
							sessdataptr->mSampleTime,
							sessdataptr->mDelta
							);
						}
					}
					else
					{
						if (sessdataptr->mImplementTeleport)
						{
							XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s.%s (%d)\n\
_PacketSize\n%d\n\
ClassType\nDataBlock_PredictFloat\n\
DataBlockID\n%d\n\
To Session ID\n\
%d\n\
Teleport\n\
Yes\n\
Float\n%f\n\
SampleTime\n%f\n\
Delta\n%f\n\
::_EndClass\n\
::_Flush\n\
",
							reason->mFloatLocalTime,
							GetROName(),name,(int)mID,
							packetSize,
							(int)mID,
							reason->mSessionReference,
							sessdataptr->mSample,
							sessdataptr->mSampleTime,
							sessdataptr->mDelta
							);
						}
						else
						{
							// Debug output the change
							XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s.%s (%d)\n\
_PacketSize\n%d\n\
ClassType\nDataBlock_PredictFloat\n\
DataBlockID\n%d\n\
To Session ID\n\
%d\n\
Float\n%f\n\
SampleTime\n%f\n\
Delta\n%f\n\
::_EndClass\n\
::_Flush\n\
",
							reason->mFloatLocalTime,
							GetROName(),name,(int)mID,
							packetSize,
							(int)mID,
							reason->mSessionReference,
							sessdataptr->mSample,
							sessdataptr->mSampleTime,
							sessdataptr->mDelta
							);
						}
					}
				}
#endif // ifndef _FINAL



				// Cancel any outstanding teleport since we have sent a packet that would have contained it
				sessdataptr->mImplementTeleport = false;

				// Store the local time for this update
				sessdataptr->mLastUpdateSentLocalTime = reason->mFloatLocalTime;

#ifndef DEBUG_PRINTS4
#ifdef DEBUG_PRINTS5
dprintf("DataBlock_Predict_Float:DataBlock_Predict_Float::Poll for object at time %f sess %d uni %d\n",reason->mFloatTime,mBoundObject->GetSessionID(),mBoundObject->GetUniqueID());
dprintf("DataBlock_Predict_Float:DataBlock ID %d\n",mID);
dprintf("DataBlock_Predict_Float:mData = %f\n",sessdataptr->mTestData);
#endif
#endif
#ifdef DEBUG_PRINTS5
dprintf("DataBlock_Predict_Float:Sending cont break samp %f time %f delta %f\n",sessdataptr->mSample,sessdataptr->mSampleTime,sessdataptr->mDelta);
#endif
			} //< if (sessdataptr->mContinuityBreak || sessdataptr->mImplementTeleport)
			return;
			break;			
		}


		// kDataBlockReason_AfterDataBlocksReceived needs to be handled because ParseMessage() doesn't directly write the member variable data.
		// ParseMessage() doesn't write the member variable data in this case because it doesn't know the ReplicaNet time to use and it would be a performance issue to find out the time to use because ParseMessage is meant to be fast.
		case kDataBlockReason_AfterDataBlocksReceived:
		{
			if (reason->mFloatTime < 0.0f)
			{
				assert(0 && "Oops! Someone forgot to set the time\n");
			}
#ifdef DEBUG_PRINTS4
	dprintf("DataBlock_Predict_Float:   kDataBlockReason_AfterDataBlocksReceived:\n");
#endif
			if (!mGotData)
			{
#ifdef DEBUG_PRINTS4
				dprintf("DataBlock_Predict_Float:   !mGotData\n");
#endif
				break;
			}

			// This calculates the extrapolated value based on the delta and time values from the data packet
			float intervalue = (float)(reason->mFloatTime - mReplicaData.mSampleTime);

			// Compensate for the lagged time difference
			if (mLagged > 0.0f)
			{
				intervalue -= mLagged;
				// Cap to before time starts to avoid something moving backwards along its path
				if (intervalue < 0.0f)
				{
					intervalue = 0.0f;
				}
			}

			intervalue += mTimeDelta;
			float extrapolated = mReplicaData.mSample + (mReplicaData.mDelta * intervalue);
			extrapolated = ApplyBoundaryToValue(extrapolated);
#ifdef DEBUG_PRINTS4
	dprintf("DataBlock_Predict_Float:   Extrapolated = %f Real time %f (samp %f time %f delta %f)\n",extrapolated,reason->mFloatTime,mReplicaData.mSample,mReplicaData.mSampleTime,mReplicaData.mDelta);
#endif
			*mData = extrapolated;

			// And reset the first time flag since we did place our value at the correct place.
			mReplicaData.mFirstTime = false;
		}
		default:
			break;
	}
}

void DataBlock_Predict_Float::GiveDeltaHint(const float delta)
{
	float copy = delta;
	
	GiveDeltaHint(&copy,sizeof(copy));
}

void DataBlock_Predict_Float::GiveDeltaHint(void *pdata,int dataLen)
{
#ifdef DEBUG_PRINTS4
	dprintf("DataBlock_Predict_Float:DataBlock_Predict_Float::GiveDeltaHint for object at time %f sess %d uni %d\n",mBoundReplicaNet->GetTime(),mBoundObject->GetSessionID(),mBoundObject->GetUniqueID());
	dprintf("DataBlock_Predict_Float:DataBlock ID %d\n",mID);
#endif

	if (dataLen != sizeof(float))
	{
		return;
	}
	float delta;
	delta = *((float *)pdata);

	// No need to store what the current value is since that will be read the next time the poll is done
	mMasterData.mGotDeltaHint = true;
	mMasterData.mTheDeltaHint = delta;

#ifdef DEBUG_PRINTS4
	dprintf("DataBlock_Predict_Float:Supplied delta hint = %f\n",delta);
#endif
}

void DataBlock_Predict_Float::ContinuityBreak(unsigned char breakTypes)
{
	// Signal that we want to start a teleport type of break
	if (breakTypes & kTeleport)
	{
		mImplementTeleport = true;
	}
}

bool DataBlock_Predict_Float::GetLastDelta(bool &continuityBreak, float &sample, SysTimeType &time, float &delta)
{
	if (mBoundObject->IsReplica())
	{
		if (mGotData)
		{
			continuityBreak = mReplicaData.mFirstTimeNotReset;
			sample = mReplicaData.mSample;
			time = mReplicaData.mSampleTime;
			delta = mReplicaData.mDelta;
			return true;
		}
		return false;
	}

	if (mBoundObject->IsMaster())
	{
		if (mDoneMasterPoll)
		{
			continuityBreak = mDoPrep || mContinuityBreak || mImplementTeleport;
			sample = mMasterData.mSample;
			time = mMasterData.mSampleTime;
			delta = mMasterData.mDelta;
			return true;
		}
		return false;
	}

	return false;
}

bool DataBlock_Predict_Float::IsAttached(void *data)
{
	if (!data)
	{
		return false;
	}
	if (mData == data)
	{
		// Return true if our internal data pointer is related to the pointer passed in
		return true;
	}
	return false;
}

void DataBlock_Predict_Float::ParseMessage(MessageHelper *message)
{
	float sample,time,delta;
	SoftFloat16 sSample,sDelta;
	bool firstTime = false;
	// Read in the values represented by the message
	if (mShortValue)
	{
		message->GetVariable(&sSample,sizeof(sSample));
		sample = sSample;
	}
	else
	{
		message->GetVariable(&sample,sizeof(sample));
	}

	message->GetVariable(&time,sizeof(time));

	if (mShortDelta)
	{
		message->GetVariable(&sDelta,sizeof(sDelta));
		delta = sDelta;
	}
	else
	{
		message->GetVariable(&delta,sizeof(delta));
	}

#ifdef DEBUG_PRINTS4
	dprintf("DataBlock_Predict_Float:DataBlock_Predict_Float::ParseMessage for object at time %f sess %d uni %d\n",mBoundReplicaNet->GetTime(),mBoundObject->GetSessionID(),mBoundObject->GetUniqueID());
	dprintf("DataBlock_Predict_Float:DataBlock ID %d\n",mID);
	dprintf("DataBlock_Predict_Float:   sample %f sample time %f delta %f\n",sample,time,delta);
#endif

	// Check the sample time and if it is negative then set the block to do a teleport
	if (time < 0)
	{
#ifdef DEBUG_PRINTS4
		dprintf("DataBlock_Predict_Float:The message update is a teleport type\n");
#endif
		time = -time;
		firstTime = true;
	}

	if (!GetDiscardThisUpdate())
	{
		ReplicaContinuityBreak(time, sample, delta, firstTime);
	}
}

void DataBlock_Predict_Float::ReplicaContinuityBreak(const SysTimeType time, const float sample, const float delta, const bool continuityBreak, const bool ignoreTimeCheck, const bool clearPreviousUpdates)
{
	if (mForceReflectionUpdate && (!mGotData || continuityBreak) && (mBoundObject->GetMessageReflectionID() != kReplicaNetUnknownUniqueID))
	{
		mImplementTeleport = true;
	}

	// If we do not do any lagged stuff then just use the values now
	if (mLagged <= 0.0f)
	{
		// Paranoia check, only allow newer updates to get through.
		if (ignoreTimeCheck || (time >= mLastGoodDataTime))
		{
			mLastGoodDataTime = time;
			mReplicaData.mSample = sample;
			mReplicaData.mSampleTime = time;
			mReplicaData.mDelta = delta;
			mGotData = true;
			if (continuityBreak)
			{
				mReplicaData.mFirstTime = true;
			}
			mReplicaData.mFirstTimeNotReset = continuityBreak;
		}
	}
	else
	{
		if (clearPreviousUpdates)
		{
			mParsedByTime.clear();
		}

		// The first update we use until such time we can start to use the lagged ones
		if (!mGotData)
		{
			mReplicaData.mSample = sample;
			mReplicaData.mSampleTime = time;
			mReplicaData.mDelta = delta;
			mReplicaData.mFirstTimeNotReset = continuityBreak;
			if (continuityBreak)
			{
				mReplicaData.mFirstTime = true;
				if (mReflectionMasterUpdate)
				{
					mImplementTeleport = true;
				}
			}
			mFirstLaggedTime = time;
		}
		else
		{
			if (ignoreTimeCheck || (time >= mLastGoodDataTime))
			{
				// Store all other updates which then get processed by kDataBlockReason_CalculateReplicaPoll
				ParsedData parse;
				parse.mSample = sample;
				parse.mDelta = delta;
				parse.mFirstTime = continuityBreak;
				mParsedByTime.insert(std::pair<SysTimeType,ParsedData>(time,parse));
			}
		}
		mGotData = true;
	}
}

void DataBlock_Predict_Float::SetLagged(const float time)
{
	mLagged = time;
}


// ***** SessionBlock_Predict_Float *****
DataBlock_Predict_Float::SessionBlock_Predict_Float::SessionBlock_Predict_Float() : mDiscardOrder(0)
{
	// We don't need a continuity break now as the data block uses the master poll sample time and delta
	mContinuityBreak = false;
	mTestData = 0.0f;
	mDelta = 0.0f;

	mSample = 0.0f;
	mSampleTime = 0.0f;

	mImplementTeleport = false;

	// A negative time in the past means no update sent yet
	mLastUpdateSentLocalTime = -1.0f;
	// No forced updates sent so far
	mNumForcedUpdates = 0;
}

DataBlock_Predict_Float::SessionBlock_Predict_Float::~SessionBlock_Predict_Float()
{
}

void DataBlock_Predict_Float::SetSnapToDifference(const float difference)
{
	mSnapToDifference = difference;
}



void DataBlock_Predict_Float::BoundaryEnable(void)
{
	mBoundaryEnable = true;
}

void DataBlock_Predict_Float::BoundaryDisable(void)
{
	mBoundaryEnable = false;
}

void DataBlock_Predict_Float::BoundaryWrapAround(void)
{
	mBoundaryIsWrap = true;
}

void DataBlock_Predict_Float::BoundaryCapped(void)
{
	mBoundaryIsWrap = false;
}

void DataBlock_Predict_Float::BoundaryLowerUpper(const float lower,const float upper)
{
	mBoundaryLower = lower;
	mBoundaryUpper = upper;
}

void DataBlock_Predict_Float::BoundaryApplyToMaster(void)
{
	mBoundaryWriteBack = true;
}

void DataBlock_Predict_Float::BoundaryDoNotApplyToMaster(void)
{
	mBoundaryWriteBack = false;
}

float DataBlock_Predict_Float::ApplyBoundaryToValue(const float value) const
{
	float ret = value;
	if(mBoundaryEnable)
	{
		// If enabled then cap/wrap internal value only. Do not change the client exposed value.
		if (mBoundaryEnable && mBoundaryIsWrap)
		{
			ret += -mBoundaryLower;	// Rebase to zero
			bool negSign = false;
			if (ret < 0)
			{
				ret = -ret;
				negSign = true;
			}
			ret = (float) fmod(ret,mBoundaryUpper - mBoundaryLower);
			if (negSign)
			{
				ret = (mBoundaryUpper - mBoundaryLower) - ret;
			}
			ret += mBoundaryLower;	// Rebase to lower
		}
		else
		{
			if (ret < mBoundaryLower)
			{
				ret = mBoundaryLower;
			}
			else if (ret > mBoundaryUpper)
			{
				ret = mBoundaryUpper;
			}
		}
	}
	return ret;
}

bool DataBlock_Predict_Float::BoundaryApplyToValue(ReplicaObject *object,float &value)
{
	if (!object)
	{
		return false;
	}
	DataBlock *block = object->FindDataBlock((void*)&value);
	if (!block)
	{
		return false;
	}
	// MPi: TODO: Need a runtime type check here really. RTTI is not always available on all platforms.
	DataBlock_Predict_Float *realBlock = static_cast<DataBlock_Predict_Float *>(block);
	if (!realBlock)
	{
		return false;
	}
	value = realBlock->ApplyBoundaryToValue(value);
	return true;
}

void DataBlock_Predict_Float::SetValueFloat(void)
{
	mShortValue = false;
}

void DataBlock_Predict_Float::SetValueShortFloat(void)
{
	mShortValue = true;
}

void DataBlock_Predict_Float::SetDeltaFloat(void)
{
	mShortDelta = false;
}

void DataBlock_Predict_Float::SetDeltaShortFloat(void)
{
	mShortDelta = true;
}

int DataBlock_Predict_Float::AddDataBlockData(DynamicMessageHelper *message,const float sample,const SysTimeType time,const float delta)
{
	int theSize = 2;
	float lSample = sample, lTime = (float)time, lDelta = delta;
	SoftFloat16 sSample,sDelta;
	sSample = lSample;
	sDelta = lDelta;

	if (mShortValue)
	{
		message->AddVariable(&sSample,sizeof(sSample));
		theSize += 2;
	}
	else
	{
		message->AddVariable(&lSample,sizeof(lSample));
		theSize += 4;
	}
	message->AddVariable(&lTime,sizeof(lTime));
	theSize += 4;
	if (mShortDelta)
	{
		message->AddVariable(&sDelta,sizeof(sDelta));
		theSize += 2;
	}
	else
	{
		message->AddVariable(&lDelta,sizeof(lDelta));
		theSize += 4;
	}
	return theSize;
}

void DataBlock_Predict_Float::SetTimeDelta(const float timeDelta)
{
	if (timeDelta >= 0.0f)
	{
		mTimeDelta = timeDelta;
	}
	else
	{
		mTimeDelta = 0.0f;
	}
}

float DataBlock_Predict_Float::CalculateReplicaValue(DataBlockReason *reason)
{
	// If we have any parsed pending then check with the time
	if (!mParsedByTime.empty())
	{
		if (mLagged > 0.0f)
		{
			// Process any updates that are allowed due to the lagged time
			while (!mParsedByTime.empty() && ((reason->mFloatTime - (*mParsedByTime.begin()).first) >= mLagged))
			{
				ParsedData &parsed = (*mParsedByTime.begin()).second;
				mReplicaData.mSample = parsed.mSample;
				mReplicaData.mSampleTime = (*mParsedByTime.begin()).first;
				mLastGoodDataTime = mReplicaData.mSampleTime;	// Stops really old updates being added to mParsedByTime
				mReplicaData.mDelta = parsed.mDelta;
				mReplicaData.mFirstTimeNotReset = parsed.mFirstTime;
				if (parsed.mFirstTime)
				{
					mReplicaData.mFirstTime = true;
					mFirstLaggedTime = mReplicaData.mSampleTime;
					if (mReflectionMasterUpdate)
					{
						mImplementTeleport = true;
					}
				}
				mParsedByTime.erase(mParsedByTime.begin());
			}
		}
		else
		{
			mParsedByTime.clear();
		}
	}


	if (!mGotData)
	{
#ifdef DEBUG_PRINTS4
		dprintf("DataBlock_Predict_Float:   !mGotData\n");
#endif
		return 0.0f;
	}

	// This calculates the extrapolated value based on the delta and time values from the data packet
	float intervalue = (float)(reason->mFloatTime - mReplicaData.mSampleTime);

	// Compensate for the lagged time difference
	if (mLagged > 0.0f)
	{
		intervalue -= mLagged;
		float minTime = (float)(mFirstLaggedTime - mReplicaData.mSampleTime);
		// Cap to before time starts to avoid something moving backwards along its path to before it was first updated
		if (intervalue < minTime)
		{
			intervalue = minTime;
		}
	}

	intervalue += mTimeDelta;
	float extrapolated = mReplicaData.mSample + (mReplicaData.mDelta * intervalue);
	extrapolated = ApplyBoundaryToValue(extrapolated);

	return extrapolated;
}
//From: RNReplicaNet/ReplicaManager.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
//Include inline: #include "RNReplicaNet/ReplicaManager.h"
//From: RNReplicaNet/ReplicaManager.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef __REPLICAMANAGER_H__
#define __REPLICAMANAGER_H__

#include "RNPlatform/Inc/RegistryManagerMap.h"
//Skipping: #include "RNReplicaNet/Inc/ReplicaObject.h"

namespace RNReplicaNet
{

struct s_RO_RegistryBlock;

/**
 * This keeps a list of replica objects that are initialised for future reference
 */
class ReplicaManager : public RegistryManagerMap<int,s_RO_RegistryBlock>
{
public:
	/**
	 * The ctor performs some basic initialisation
	 */
	ReplicaManager();

	/**
	 * The dtor makes sure everything is tidy
	 */
	virtual ~ReplicaManager();

private:
};

} // namespace RNReplicaNet

#endif

using namespace RNReplicaNet;

ReplicaManager::ReplicaManager()
{
}

ReplicaManager::~ReplicaManager()
{
}


//From: RNReplicaNet/ReplicaNet.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
//Skipping: #include "RNReplicaNet/Inc/ReplicaNet.h"
//Include inline: #include "RNReplicaNet/ReplicaNetPrivate.h"
//From: RNReplicaNet/ReplicaNetPrivate.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef __REPLICANETPRIVATE_H__
#define __REPLICANETPRIVATE_H__

#include <map>

//Skipping: #include "RNReplicaNet/Inc/ReplicaNet.h"
//Skipping: #include "RNReplicaNet/ReplicaManager.h"
//Skipping: #include "RNPlatform/Inc/RegistryManagerMap.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
//Skipping: #include "RNPlatform/Inc/ThreadClass.h"
#include "RNXPURL/Inc/Transport.h"
//Skipping: #include "RNReplicaNet/Inc/ReplicaObject.h"
//Skipping: #include "RNPlatform/Inc/SysTime.h"

namespace RNReplicaNet
{

struct SessionUnique
{
	SessionUnique(const int sessionID,const int uniqueID) : mSessionID(sessionID) , mUniqueID(uniqueID) {}
	SessionUnique(const ReplicaObject *object) : mSessionID(object->mSessionID) , mUniqueID(object->mUniqueID) {}
	int mSessionID;
	int mUniqueID;
};

struct ltSessionUnique
{
	bool operator()(const SessionUnique &s1, const SessionUnique &s2) const
	{
		// If < return true
		if (s1.mSessionID < s2.mSessionID)
		{
			return true;
		}
		// If same session IDs then compare unique IDs
		if (s1.mSessionID == s2.mSessionID)
		{
			return s1.mUniqueID < s2.mUniqueID;
		}
		// Must be > so return false
		return false;
	}
};

class ReplicaNetPrivate : public ReplicaManager , public DynamicMessageHelper , public ThreadClass
{
public:
	ReplicaNetPrivate(ReplicaNet *realRepNet);

	virtual ~ReplicaNetPrivate();

//	virtual void PreRegisterReplicas(void);

	static ReplicaNet *GetCurrentReplicaNet(void);

	static void SetCurrentReplicaNet(ReplicaNet *const replicanet);

	int GetSessionID(void);

	void AddObject(ReplicaObject *const object);

	void RemoveObject(ReplicaObject *const object,const bool sendDelete = true);

	int GetGameChannel(void);

	void SetGameChannel(const int channel = TransportAnyGameChannel);

	void SessionCreate(const std::string name);

	void SessionCreate(const std::string name,const std::string protocols);

	std::string SessionExportURL(void);

	void SessionJoin(const std::string url);

	void SessionFind(void);

	void SessionFind(const std::string protocols);

	std::string SessionEnumerateFound(void);

	int GetMakeUniqueID(void);

	int GetMakeSessionID(void);

	void LockObjects(void);

	void UnLockObjects(void);

	float GetNetworkSendRate(void);

	float GetNetworkReceiveRate(void);

	int GetNetworkPacketsLost(void);

	int GetNetworkPacketsRejected(void);

	SysTimeType GetTime(void);

	SysTimeType GetLocalTime(void);

	void SetObserver(ReplicaObject *const object = 0);

	ReplicaObject *GetObserver(void);

	void Poll(void);

	void SetPollLayerBelow(bool enable = true);

	bool GetPollLayerBelow(void);

	void SetPollLayerBelowForXPSession(bool enable = true);

	bool GetPollLayerBelowForXPSession(void);

	void SetManualPoll(void);

	void SetAutomaticPoll(void);

	void SetManualPollXPSession(void);

	void SetAutomaticPollXPSession(void);

	void SetManualPollXPURL(void);

	void SetAutomaticPollXPURL(void);

	void GiveOwnership(ReplicaObject *const object,const int sessionID);

	void RequestOwnership(ReplicaObject *const object);

	void SetCanSpider(const bool canSpider);

	bool GetCanSpider(void);

	float GetLatencyToMasterSession(void);

	float GetLatencyToSessionID(const int sessionID);

	void SetLatencyRecalculationDelay(const float seconds = 1.0f);

	bool IsStable(void);

	bool IsMaster(void);

	void SetCanBecomeMaster(const bool canBeMaster = true);

	bool GetCanBecomeMaster(void);

	ReplicaNet::Error GetStatus(void);

	ReplicaNet::Error GetSessionErrorReason(void);

	void SetOnSessionError(const ReplicaNet::OnError whatToDo = ReplicaNet::kMigrateObjects);

	ReplicaNet::OnError GetOnSessionErrorMigrateObjects(void);

	void SetCanAcceptObjects(bool accept = true);

	bool GetCanAcceptObjects(void);

	void SetEncryption(const bool enable = false);

	bool GetEncryption(void);

	void SetLoadBalancing(const bool enable = false);

	bool GetLoadBalancing(void);

	void SetMaximumLoad(float load = 0.0f);

	float GetMaximumLoad(int sessionID = kReplicaNetUnknownUniqueID);

	float GetTotalLoad(int sessionID = kReplicaNetUnknownUniqueID);

	void ObjectListBeginIterate(void);

	void ObjectListFinishIterate(void);

	ReplicaObject *ObjectListIterate(void);

	ReplicaObject *ObjectListFind(const int sessionID,const int uniqueID);


	void Disconnect(const int sessionID = kReplicaNetUnknownUniqueID);

	bool GetPreConnectStatus(void);

	void SetPreConnect(const bool enable = false);

	bool GetPreConnect(void);

	void PreConnectHasFinished(void);

	void InternalPacketSend(const int sessionid, const ReplicaNet::PacketType type, const DynamicMessageHelper &message,const unsigned int band);

	void DataSend(const int sessionid,const void *data,const int length,const ReplicaNet::PacketType type = ReplicaNet::kPacket_Reliable,const unsigned int band = 0);

	bool DataReceive(int *const fromsessionid,void *const data,int *const length,ReplicaNet::PacketType *const type = 0);

	bool DataReceivePeek(int *const fromsessionid,int *const length,ReplicaNet::PacketType *const type = 0);

	void SetDataRetention(const bool enable);

	bool GetDataRetention(void) const;

	void SetDataBlockUpdatePolicy(const bool automatic = true);

	bool GetDataBlockUpdatePolicy(void) const;

	void ProcessDataBlockUpdate(void);

	void SetAutomaticPacketCompression(const bool enable = false);

	bool GetAutomaticPacketCompression(void);

	void GetCompressionStatistics(int *const before=0,int *const after=0,const bool reset = false);

	void GetMergedStatistics(int *const sent=0,int *const received=0,const bool reset = false);

	int GetMasterSessionID(void);

	std::string GetURLFromSessionID(const int sessionID);

	void SetClientOnly(const bool isClient = false);

	bool GetClientOnly(void);

	bool GetBandwidthFromSessionID(const int sessionID,Transport::Bandwidth *const bandwidth,int *const output,int *const input);

	bool BeginSessionRecord(void);

	bool GetSessionRecord(void) const;

	void StopSessionRecord(void);

	bool BeginSessionPlayback(void);

	void StopSessionPlayback(void);

	void SetPlaybackSpeed(const float speed = 1.0f);

	bool PlaybackAdvanceTo(const SysTimeType time);

	bool GetSessionPlayback(void) const;

	void SetPlaybackAllowMasterReplicaObjects(const bool allow);

	bool GetPlaybackAllowMasterReplicaObjects(void);

	void SetAllowConnections(const bool enable);

	bool GetAllowConnections(void);

	void SetNodeBuffers(const bool enable = false);

	bool GetNodeBuffers(void);

	void SetSessionIDCallback(const bool enable = false);

private:
friend class ReplicaObject;		/* A ReplicaObject has direct access to ReplicaNet the class */
friend class ReplicaNet;
	/**
	 * Gets the current make master flag from this ReplicaNet class
	 * \return returns the current flag for the master creation state
	 */
	bool GetMakeMaster(void);

	/**
	 * Gets the next object unique ID to use from this ReplicaNet class
	 * \return the next unique ID to use
	 */
	int CallbackGetObjectUniqueID(ReplicaObject *object);

	void LoadChangedForObject(ReplicaObject *object,float previousLoad,float newLoad);

	void HandleLoadBalancing(void);

	void AttachSession(XPSession *session);
	void DoMasterCreateClassMessage(int sessionid,ReplicaObject *object);
	void DoReflectCreateClassMessage(int sessionid,ReplicaObject *object);
	void DoMasterTakeOverClassMessage(int sessionid,ReplicaObject *object);
	bool DoClassDataMessage(ReplicaObject *object,DynamicMessageHelper *message,DataBlockReason *reason);
	bool DoClassDataCertainMessage(ReplicaObject *object,DynamicMessageHelper *message,DataBlockReason *reason,bool append = false);
	bool DoClassDataReliableMessage(unsigned int band,unsigned int &nextBand,bool doAll,ReplicaObject *object,DynamicMessageHelper *message,DataBlockReason *reason,bool append = false);
	bool DoClassDataOrderedMessage(unsigned int band,unsigned int &nextBand,bool doAll,ReplicaObject *object,DynamicMessageHelper *message,DataBlockReason *reason,bool append = false);
	int ThreadEntry(void);
	void TakeOverObject(ReplicaObject *object);
	void CheckForObjectFaultMigration(bool objectdelete,int sessionleft);

	void			PostCtorStageInit(void);

	ReplicaObject*	AllocateReplicaObject(const int class_id,const int sessionid,const int uniqueid,const int reflect = kReplicaNetUnknownUniqueID);


	/**
	 * This function is used to handle the ReplicaObject::PostObjectCreate() call
	 * \param object the object to handle the test for
	 */
	void HandlePostObjectCreate(ReplicaObject *object);

	void HandleSessionMessages(void);
	void ProcessJoiners(void);
	void HandleSessionChanges(void);
	void HandleSessionErrors(void);
	void HandleSessionLeavers(void);
	void HandleLoad(const SysTimeType nowtime,const SysTimeType nowlocaltime);
	void HandleMasterDataBlocks(const SysTimeType nowtime,const SysTimeType nowlocaltime);
	void HandleReplicaDataBlockPoll(const SysTimeType nowtime,const SysTimeType nowlocaltime);
	void HandleReplicaCallbackPoll(const SysTimeType nowtime,const SysTimeType nowlocaltime);
	void HandleReflectionPoll(const SysTimeType nowtime,const SysTimeType nowlocaltime);
	void HandleCommonDataBlockUpdates(const SysTimeType nowtime,const SysTimeType nowlocaltime);
	void HandleSessionJoin(const int sessionID);
	void RetireObjectPropagationAddRemove(void);
	void HandleMasterSessionPropagateDistanceBased(const SysTimeType nowtime);
	void HandleMasterSessionPropagateDistanceBasedPerObject(const SysTimeType nowtime,ReplicaObject *object);

	void EnsureSessionAllocated(void);

	void DoObjectDelete(ReplicaObject *object);

	// Internal message handlers from HandleSessionMessages()
	void MessageClassData(const int sessionid,int &length);
	void MessageReflectClassData(const int sessionid,int &length);
	void MessageMasterCallbackClassData(const int sessionid,int &length);
	void MessageClassDataCommon(const int sessionid,int &length, ReplicaObject *object);
	void MessageNoClassData(const int sessionid);
	void MessageCreateClass(const int sessionid,const int length);
	void MessageCreateClassReflect(const int sessionid,const int length);
	void MessageDeleteClass(const int sessionid,int &length);
	void MessageReflectDeleteClass(const int sessionid,int &length);
	void MessageUnpublishClass(const int sessionid,int &length);
	void MessageReflectUnpublishClass(const int sessionid,int &length);
	void MessageIsLoadBalanced(const int sessionid,const int length);
	void MessageMyMaximumLoadIs(const int sessionid,const int length);
	void MessageMyTotalLoadIs(const int sessionid,const int length);
	void MessageNotLoadBalanced(const int sessionid,const int length);
	void MessageCanAcceptObjects(const int sessionid,const int length);
	void MessageCanNotAcceptObjects(const int sessionid,const int length);
	void MessageSetObserver(const int sessionid,const int length);
	void MessageSetNoObserver(const int sessionid,const int length);
	void MessageTakeOverObject(const int sessionid,const int length);
	void MessageObjectTakenOver(const int sessionid,const int length);
	void MessageRequestTakeOverObject(const int sessionid,const int length);
	void MessageRequestPreConnectDone(const int sessionid,const int length);
	void MessageDataPacket(const int sessionid,const int length,const unsigned char packetType);
	void MessageReplicaObjectDataPacket(const int sessionid,const int length,const unsigned char packetType);
	void MessageInitDoneSendState(const int sessionid);


// Now the static variables
	static ReplicaNet *mCurrentReplicaNet;	/**< The current replicanet being processed */

// Now the start of the ctor initialisers
	bool mMakeMaster;					/**< A flag indicating whether to make the next allocated object a master object */
	int mNextObjectID;
	XPSession *mSession;				/**< The session allocated to this class */
	int mSessionID;
	int mMakeUniqueID;
	int mMakeSessionID;
	Thread *mThread;					/**< The thread allocated to this class */
	ReplicaObject *mObserver;
	bool mManualPoll;
	int mNextBestSessionIndex;
	bool mPreviousIsMaster;
	bool mConnectionStable;
	SysTimeType mPeviousReplicaPollTime;
	ReplicaNet::OnError mOnSessionErrorMigrateObjects;
	bool mCanAcceptObjects;
	bool mErrorObjectsAreBeingLeft;
	bool mEncryptionOn;
	bool mEnableLoadBalancing;
	float mMaximumLoad;
	float mTotalLoad;
	int mObjectsBalaned;
	bool mTotalLoadChanged;
	bool mMaximumLoadChanged;
	bool mPollLayerBelow;
	ReplicaNet *mParentReplicaNet;		// The parent ReplicaNet class
	int mMakeMasterReflectID;
	bool mRetainRawData;
	bool mPreRegisterReplicasDone;

// End of the ctor initialisers
	void RemoveObjectFromAllLists(const ReplicaObject *object);
	void AddObjectToCorrectLists(ReplicaObject *object);
	RegistryManagerMap<SessionUnique,ReplicaObject,ltSessionUnique> mMasterList;	/**< The master objects allocated to this session */
	RegistryManagerMap<SessionUnique,ReplicaObject,ltSessionUnique> mReplicaList;	/**< The replica objects allocated */
	RegistryManagerMap<SessionUnique,ReplicaObject,ltSessionUnique> mReflectList;	/**< The reflect master objects allocated */
	RegistryManagerMap<SessionUnique,ReplicaObject,ltSessionUnique> mAllKnown;		/**< The objects allocated and known to this session*/

	struct SessionData
	{
	private:
		SessionData();
	public:
		SessionData(int id);

		int mSessionID;
		ReplicaObject *mObserver;
		int mObserverSessionID , mObserverUniqueID;

		bool mCanAcceptObjects;

		bool mIsLoadBalanced;
		float mMaximumLoad;
		float mTotalLoad;

		bool mInitDoneSendStateRecv;		// This means that all the ReplicaNet session state messages, including but not limited to, can accept objects and observer have been received
		bool mObserverPendingSet;
		std::multimap<SessionUnique,int,ltSessionUnique>::iterator mObserverPending;
	};

	/** The known active session data structures for the replicanet class. Indexed by session ID */
	std::map<int,SessionData> mKnownSessions;
	std::multimap<SessionUnique,int,ltSessionUnique> mObserverPendingForSessionID;

	struct WaitingPacket
	{
		ReplicaNet::PacketType mType;
		void *mData;
		int mLength;
		int mFromSessionID;
	};

	std::list<WaitingPacket> mWaitingPackets;

	bool mAutomaticDataBlockUpdates;
	
	bool mIsRecording;
	bool mIsPlayback;

	bool mDoRecordingPrep;

	SysTime mRecordingTime;
	SysTimeType mRecordingZeroTime;
	SysTimeType mPlaybackNextPacketDue;
	bool mDoPlaybackPrep;
	bool mDoneRecordHeader;
	int mPlaybackSessionID;
	bool mOKToDoRecord;		// This is set by a create or a join
	bool mInsideRecordCreate;

	SysTimeType mPlaybackLocalTimeOffset;
	SysTimeType mPlaybackTimeOffset;
	SysTimeType mRecordingTicker;
	bool mPlaybackAllowMasterROs;
	bool mPlaybackEndReachedDoError;
	float mPlaybackSpeed;
	bool mPlaybackAdvanceToRequested;

	SysTimeType GetRecordingTime(void);

	// Spot the void* char* difference for the data parameter. Urghh!
	void RecordCheckDataSendToSession(const int sessionid,const char *data,const int length,const bool reliable = true,const bool certain = false,const bool ordered = false,const unsigned int band = 0);
	void RecordCheckDataSendToSession(const int sessionid,const void *data,const int length,const bool reliable = true,const bool certain = false,const bool ordered = false,const unsigned int band = 0)
	{
		RecordCheckDataSendToSession(sessionid,(char *)data,length,reliable,certain,ordered,band);
	}


	void RecordCheckDataSendToSessionUnreliable(const int sessionid,const void *data,const int length)
	{
		RecordCheckDataSendToSession(sessionid,data,length,false,false);
	}

	void RecordCheckDataSendToSessionCertain(const int sessionid,const void *data,const int length)
	{
		RecordCheckDataSendToSession(sessionid,data,length,false,true);
	}

	void RecordCheckDataSendToSessionReliable(const int sessionid,const void *data,const int length,const unsigned int band)
	{
		RecordCheckDataSendToSession(sessionid,data,length,true,false,false,band);
	}

	void RecordCheckDataSendToSessionOrdered(const int sessionid,const void *data,const int length,const unsigned int band)
	{
		RecordCheckDataSendToSession(sessionid,data,length,false,false,true,band);
	}

	void RecordDataPacket(const int fromSessionID,const int toSessionID,const char *data,const int length,const unsigned char packetType);

	bool RecordCheckDataReceive(int *const fromsessionid,int *const length,unsigned char *const type = 0);

	void RecordingDoTimeCodes(void);

	void DoPromote(void);

	void DoRecordingPrep(void);

	void CheckPlaybackAdvanceToRequested(void);

	void ReplicaObjectDataSend(const int sessionid,const void *data,const int length,const ReplicaNet::PacketType type = ReplicaNet::kPacket_Reliable,ReplicaObject *source = 0,const unsigned int band = 0);

	void CommonCreateClassMessages(ReplicaObject *object,DynamicMessageHelper &message,DataBlockReason &reason);

	ReplicaObject *mLastObjectCreatedbyAClassCreate;		// The last object created by a class create or reflect class create.

	MutexClass mMutexRecvPackets;

	int mLastGoodMasterSessionID;
	
	void HandleMasterSessionChanges(void);

	void SetMaximumDataSize(const int bytes);
	int GetMaximumDataSize(void);

	void SetPacketCompressionLevel(const int level);
	void SetLargePacketCompressionLevel(const int level);

	int GetPacketCompressionLevel(void);
	int GetLargePacketCompressionLevel(void);

	void SetTransparentPacketCompression(const int level = 0);

	int GetTransparentPacketCompression(void);
};

} // namespace RNReplicaNet

#endif
#include "RNXPSession/Inc/XPSession.h"
//Skipping: #include "RNXPURL/Inc/Transport.h"
//Skipping: #include "RNPlatform/Options.h"
#include "RNReplicaNet/Inc/RO_RegistryBlock.h"
//Skipping: #include "RNReplicaNet/Inc/DataBlock.h"
//Skipping: #include "RNPlatform/Inc/Thread.h"
//Skipping: #include "RNPlatform/DebugSupport.h"
//Skipping: #include "RNPlatform/Inc/PlatformInfo.h"
//Skipping: #include "RNXPURL/Inc/XPURL.h"
//Skipping: #include "RNXPURL/Inc/DebugHandler.h"

using namespace RNReplicaNet;


#ifdef REPLICANET_TIME_DOUBLE
// Note different to the values below in the #else
const static unsigned int sReplicaNetVersion = _REPLICANET_VERSION | 0x80000000;
const int kReplicaNet_RecordingMagic = 0x845fca23;
#else
const static unsigned int sReplicaNetVersion = _REPLICANET_VERSION;
const int kReplicaNet_RecordingMagic = 0x6245fca3;
#endif

const int kReplicaNet_RecordingVersion = 4;


ReplicaNet *ReplicaNetPrivate::mCurrentReplicaNet = NULL;

typedef char RepnetMessage;

const RepnetMessage kReplicaNetMessage_CreateClass				= 0;
const RepnetMessage kReplicaNetMessage_DeleteClass				= 1;
const RepnetMessage kReplicaNetMessage_ClassData				= 2;
const RepnetMessage kReplicaNetMessage_InitDoneSendState		= 3;
const RepnetMessage kReplicaNetMessage_SetObserver				= 4;
const RepnetMessage kReplicaNetMessage_SetNoObserver			= 5;
const RepnetMessage kReplicaNetMessage_TakeOverObject			= 6;
const RepnetMessage kReplicaNetMessage_ObjectTakenOver			= 7;
const RepnetMessage kReplicaNetMessage_RequestTakeOverObject	= 8;
const RepnetMessage kReplicaNetMessage_MasterCallbackClassData	= 9;
const RepnetMessage kReplicaNetMessage_CanAcceptObjects			= 10;
const RepnetMessage kReplicaNetMessage_CanNotAcceptObjects		= 11;
const RepnetMessage kReplicaNetMessage_IsLoadBalanced			= 12;
const RepnetMessage kReplicaNetMessage_NotLoadBalanced			= 13;
const RepnetMessage kReplicaNetMessage_MyMaximumLoadIs			= 14;
const RepnetMessage kReplicaNetMessage_MyTotalLoadIs			= 15;
const RepnetMessage kReplicaNetMessage_CreateClassReflect		= 16;
const RepnetMessage kReplicaNetMessage_DataPacket				= 17;
const RepnetMessage kReplicaNetMessage_ReflectClassData			= 18;
const RepnetMessage kReplicaNetMessage_ReflectDeleteClass		= 19;
const RepnetMessage kReplicaNetMessage_RecordingSessionID		= 20;
const RepnetMessage kReplicaNetMessage_RecordingTimeCodes		= 21;
const RepnetMessage kReplicaNetMessage_ReplicaObjectDataPacket	= 22;
const RepnetMessage kReplicaNetMessage_NoClassData				= 23;
const RepnetMessage kReplicaNetMessage_UnpublishClass			= 24;
const RepnetMessage kReplicaNetMessage_ReflectUnpublishClass	= 25;


#ifdef DEBUG_PRINTS2
static int blah = 0;
#endif

ReplicaNetPrivate::ReplicaNetPrivate(ReplicaNet *realRepNet) : mMakeMaster(false) , mNextObjectID(0) , mSession(NULL) ,
		mSessionID(kXPSessionUnknownID) , mMakeUniqueID(kXPSessionUnknownID), mMakeSessionID(kXPSessionUnknownID) ,
		mThread(0) , mObserver(0) , mManualPoll(false) , mNextBestSessionIndex(0) , mPreviousIsMaster(false) ,
		mConnectionStable(false) , mPeviousReplicaPollTime(0.0f) , mOnSessionErrorMigrateObjects(ReplicaNet::kMigrateObjects) ,
		mCanAcceptObjects(true) , mErrorObjectsAreBeingLeft(false) , mEncryptionOn(false) , mEnableLoadBalancing(false) ,
		mMaximumLoad(0.0f) , mTotalLoad(0.0f) , mObjectsBalaned(0) , mTotalLoadChanged(false) , mMaximumLoadChanged(false) ,
		mPollLayerBelow(true) , mParentReplicaNet(realRepNet) , mMakeMasterReflectID(kReplicaNetUnknownUniqueID) , mRetainRawData(false) ,
		mPreRegisterReplicasDone(false) , mAutomaticDataBlockUpdates(true) , mIsRecording(false) , mIsPlayback(false) ,
		mDoRecordingPrep(false) , mRecordingZeroTime(0.0f) , mPlaybackNextPacketDue(0.0f) , mDoPlaybackPrep(false) ,
		mDoneRecordHeader(false) , mPlaybackSessionID(kReplicaNetUnknownUniqueID) , mOKToDoRecord(false) ,
		mInsideRecordCreate(false) , mPlaybackLocalTimeOffset(0.0f) , mPlaybackTimeOffset(0.0f) , mRecordingTicker(0.0f) ,
		mPlaybackAllowMasterROs(false) , mPlaybackEndReachedDoError(false) , mPlaybackSpeed(1.0f) , mPlaybackAdvanceToRequested(false) ,
		mLastObjectCreatedbyAClassCreate(0) , mLastGoodMasterSessionID(kXPSessionUnknownID)
{
	SetCurrentReplicaNet(realRepNet);
#ifndef _FINAL
	if (XPURL::GetDebugHandler())
	{
		XPURL::GetDebugHandler()->Printf("::_Time\n%f\n::ReplicaNet\n::_EndClass\n::_Flush\n");
	}
#endif
}

void ReplicaNetPrivate::PostCtorStageInit(void)
{
#ifdef DEBUG_PRINTS1
	dprintf("*** New ReplicaNet()\n");
#endif
	mMakeMaster = false;

	// This registers the function pointers assigned to each class ID type that is able to allocate a ReplicaObject derived class
	mParentReplicaNet->PreRegisterReplicas();

	// Any ReplicaObject derived classes are allocated to be master objects
	mMakeMaster = true;

	// Start the thread that runs the Poll() method
	mThread = new Thread();
	mThread->SetPreferredProcessor(PlatformInfo::GetProcessorReplicaNet());
	mThread->Begin(this);

#ifdef DEBUG_PRINTS1
	dprintf("*** Finish ReplicaNet()\n");
#endif
}

ReplicaNetPrivate::~ReplicaNetPrivate()
{
	// When the thread is deleted the thread stops running
	if (mThread)
	{
		delete mThread;
		mThread = 0;
	}

	// Lock our class one last time
	THREADSAFELOCK();

	THREADSAFELOCKCLASS(mMutexRecvPackets);

#ifndef _FINAL
	if (XPURL::GetDebugHandler())
	{
		XPURL::GetDebugHandler()->Printf("::_Time\n%f\n::~ReplicaNet\nDeleted at\n%f\n::_EndClass\n::_Flush\n",mParentReplicaNet->GetLocalTime(),mParentReplicaNet->GetLocalTime());
	}
#endif

	// Remove this session from the active session pointer
	SetCurrentReplicaNet(0);

	// Delete the session
	if (mSession)
	{
		// Extra paranoid thread safety for those that may try to access this pointer without locking the class
		XPSession *temp = mSession;
		mSession = 0;
		delete temp;
	}

	BeginIterate();
	s_RO_RegistryBlock *object = Iterate();
	while (object != NULL)
	{
		delete object;
		object = Iterate();
	}

	while (!mWaitingPackets.empty())
	{
		WaitingPacket &waiting = *mWaitingPackets.begin();
		free(waiting.mData);
		waiting.mData = 0;
		mWaitingPackets.pop_front();
	}
}

void ReplicaNetPrivate::Poll(void)
{
	// If we have a session and we poll the layer below then call the poll method of the session
	if (mSession)
	{
		if (mPollLayerBelow)
		{
			mSession->Poll();
		}
	}

	// Mutex lock our class while we are doing some work
	THREADSAFELOCK();

#ifdef DEBUG_PRINTS1
//	dprintf("ReplicaNet : Poll() network time %f\n",mParentReplicaNet->GetTime());
#endif

	SetCurrentReplicaNet(mParentReplicaNet);

	// No session allocated then just return
	if (!mSession && !mIsPlayback)
	{
		return;
	}

	// If the session encryption is not the same as the ReplicaNet encryption flag then set the session to be the same
	if (mSession)
	{
		if (mSession->GetEncryption() != mEncryptionOn)
		{
			mSession->SetEncryption(mEncryptionOn);
		}
	}

	// Do the playback prep
	if (mDoPlaybackPrep)
	{
		EnsureSessionAllocated();
		mDoPlaybackPrep = false;
	}

	// Do the recording prep
	if (mDoRecordingPrep && mOKToDoRecord)
	{
		DoRecordingPrep();
	}

	if (mIsPlayback && mSessionID == kXPSessionUnknownID)
	{
		HandleSessionMessages();
	}

	// Check for the session number changing and act accordingly
	HandleSessionChanges();

	/* Don't waste our time trying to send packets when we've not got a connected session */
	if (mSessionID == kXPSessionUnknownID)
	{
		// Handle session messages here if we want to retain raw data and have the pre-connect mechanism, in case we have pre-connect data.
		if (mSession)
		{
			if (mRetainRawData && mSession->GetPreConnect())
			{
				HandleSessionMessages();
			}
		}
		return;
	}

	if (mIsRecording)
	{
		if (mRecordingTime.FloatTime() > (mRecordingTicker + 1.0f))
		{
			mRecordingTicker = mRecordingTime.FloatTime();
			RecordingDoTimeCodes();
		}
	}

	// First time initialisation stuff when the session is finally stable (the session ID is set so it must be)
	if (!mConnectionStable)
	{
		mConnectionStable = true;
		mPeviousReplicaPollTime = mParentReplicaNet->GetTime();
	}

	// First check and retire the session propagate add/remove lists
	RetireObjectPropagationAddRemove();


	// Now process the joiners etc. This function is the one that sends kReplicaNetMessage_InitDoneSendState when the session
	// is stable and has a valid session ID which then starts off all the other messages.
	ProcessJoiners();

	HandleSessionMessages();


	/* Don't waste our time trying to send packets when we are not a connected session */
	if (mSessionID == kXPSessionUnknownID)
	{
		return;
	}

	HandleMasterSessionChanges();

	HandleSessionErrors();

	HandleSessionLeavers();

	SysTimeType nowtime = mParentReplicaNet->GetTime();
	SysTimeType nowlocaltime = mParentReplicaNet->GetLocalTime();

	HandleMasterSessionPropagateDistanceBased(mParentReplicaNet->GetLocalTime());

	HandleLoad(nowtime,nowlocaltime);

	// Only do this if we are doing automatic updates
	if (mAutomaticDataBlockUpdates)
	{
		HandleCommonDataBlockUpdates(nowtime,nowlocaltime);
	}

	HandleLoadBalancing();
}

void ReplicaNetPrivate::HandleCommonDataBlockUpdates(const SysTimeType nowtime,const SysTimeType nowlocaltime)
{
	HandleMasterDataBlocks(nowtime,nowlocaltime);

	HandleReplicaDataBlockPoll(nowtime,nowlocaltime);

	HandleReplicaCallbackPoll(nowtime,nowlocaltime);

	HandleReflectionPoll(nowtime,nowlocaltime);
}

ReplicaNet *ReplicaNetPrivate::GetCurrentReplicaNet(void)
{
	return mCurrentReplicaNet;
}

void ReplicaNetPrivate::SetCurrentReplicaNet(ReplicaNet *const replicanet)
{
	mCurrentReplicaNet = replicanet;
}

ReplicaObject *ReplicaNetPrivate::AllocateReplicaObject(const int class_id,const int sessionid,const int uniqueid,const int reflect)
{
	THREADSAFELOCK();

	SetCurrentReplicaNet(mParentReplicaNet);

	// The ReplicaObject derived class from the _RO_ framework queries these values from ReplicaNet
	mMakeMaster = false;
	mMakeSessionID = sessionid;
	mMakeUniqueID = uniqueid;
	mMakeMasterReflectID = reflect;

	// Trap out the case when we are playing back a recording of our own master object...
	if (mIsPlayback && sessionid == mSessionID)
	{
		mMakeMaster = mPlaybackAllowMasterROs;
	}

	mInsideRecordCreate = true;
	// First of all try to allocate our known object with the callback
	ReplicaObject *newobj = mParentReplicaNet->CallBackAllocate(class_id,mMakeSessionID,mMakeUniqueID);

	// If the callback did not allocate the object then use the registry block method instead
	if (!newobj)
	{
		// Search through the list of registered class IDs and allocate a copy of the object from the function pointer
		s_RO_RegistryBlock *object = FindItem(class_id);
		if (object)
		{
			assert(object->GetClassID() == class_id);
			// Call the function pointer registered with the class ID
			newobj = object->CallBackAllocate();
		}
	}

	if (newobj)
	{
		// Make sure the object is properly linked and the IDs are set
		if (!newobj->mGetNewSessionIDAndUniqueIDCalled)
		{
			newobj->GetNewSessionIDAndUniqueID(mParentReplicaNet);
		}

		assert(newobj->mGetNewSessionIDAndUniqueIDCalled && "When s_RO_RegistryBlock::CallBackAllocate() or ReplicaNet::CallBackAllocate() returned a ReplicaObject the ReplicaObject instance has not had a successful call to GetNewSessionIDAndUniqueID() during instance creation.");
		assert(!newobj->IsMaster() && "When s_RO_RegistryBlock::CallBackAllocate() or ReplicaNet::CallBackAllocate() returned a ReplicaObject instance the object IsMaster() function returned true, which is wrong because it should be false. Has the ReplicaObject constructor and ReplicaObject::GetNewSessionIDAndUniqueID() been called at the correct time?");

		mMakeMasterReflectID = kReplicaNetUnknownUniqueID;
		mMakeMaster = true;
		mInsideRecordCreate = false;
		return newobj;
	}

	mMakeMasterReflectID = kReplicaNetUnknownUniqueID;
	mMakeMaster = true;
	mInsideRecordCreate = false;

	assert(!"An object classID was asked to be allocated by a session but the classID was not registered with ReplicaNet\n");

	return 0;
}

bool ReplicaNetPrivate::GetMakeMaster(void)
{
	return mMakeMaster;
}

int ReplicaNetPrivate::CallbackGetObjectUniqueID(ReplicaObject *object)
{
	THREADSAFELOCK();

	int retVal = mNextObjectID;

	mNextObjectID++;
	if (mNextObjectID == kReplicaNetUnknownUniqueID)
	{
		mNextObjectID++;
	}

	return retVal;
}

int ReplicaNetPrivate::GetSessionID(void)
{
	THREADSAFELOCK();

	return mSessionID;
}

void ReplicaNetPrivate::AddObject(ReplicaObject *const object)
{
	// Early out tests
	if (!object)
	{
		return;
	}
	if (object->mObjectHasBeenAdded)
	{
//		assert(false && "ReplicaNet::AddObject() used on an object that is already added\n");
//		object->UnLock();
		return;
	}

// Now do our thread lock
	THREADSAFELOCK();

// And the object lock
	object->Lock();

	if (!object->mGetNewSessionIDAndUniqueIDCalled)
	{
		object->GetNewSessionIDAndUniqueID(mParentReplicaNet);
	}

	assert(object->mGetNewSessionIDAndUniqueIDCalled && "During ReplicaNetPrivate::AddObject()");

	object->mObjectHasBeenAdded = true;

#ifdef DEBUG_PRINTS1
	dprintf("ReplicaNetPrivate::AddObject sess id %d uni id %d class id %d\n",object->GetSessionID(),object->GetUniqueID(),object->GetClassID());
#endif

	SetCurrentReplicaNet(mParentReplicaNet);

	// Datablocks can be registered at add time or at another time prior to this so watch out
#ifdef DEBUG_PRINTS1
	dprintf("object->PreRegisterDataBlocks()\n");
#endif
	object->PreRegisterDataBlocks();

	// If the object is the master then a lot of datablock house keeping needs to be done
	if (object->IsMaster())
	{
#ifdef DEBUG_PRINTS1
		dprintf("   Object is a MASTER type\n");
#endif

		// Since the object is a master and it has been newly added to ReplicaNet is needs one calculate master poll to be done to read in data after the ReplicaObject's ctor
		DataBlockReason reason;

#ifdef DEBUG_PRINTS1
		dprintf("   Do the master add calculation for our datablocks\n");
#endif
		// Do the master add calculation for our datablocks
		int i;
		// No kDataBlockReason_MasterPrepAfterTakeover is issued because the object taken over here
		reason.mReasonCode = kDataBlockReason_CalculateMasterPoll;
		reason.mFloatTime = mParentReplicaNet->GetTime();
		reason.mFloatLocalTime = mParentReplicaNet->GetLocalTime();
		reason.mSessionReference = mSessionID;
		for (i=0;i<(int)object->mDataBlocks.size();i++)
		{
			object->mDataBlocks[i]->Poll(&reason);
		}
		object->mMasterOrReplicaDataBlockPollDone = true;

		if (object->mReflectSessionID != kReplicaObjectUnknownUniqueID)
		{
#ifdef DEBUG_PRINTS1
			dprintf("   Do the DoReflectCreateClassMessage() for the reflect session\n");
#endif
			// If we're not propagating to session IDs then notify the reflect session ID
			// The retire add/remove session routine takes care of the reflect session ID
			if (!object->mSessionPropagationFilter)
			{
				DoReflectCreateClassMessage(object->mReflectSessionID,object);
			}
		}
		else
		{
#ifdef DEBUG_PRINTS1
			dprintf("   Do the DoMasterCreateClassMessage() for known sessions\n");
#endif
			// If we're not propagating to session IDs then notify all known sessions
			if (!object->mSessionPropagationFilter)
			{
				std::map<int,SessionData>::iterator st,en;
				st = mKnownSessions.begin();
				en = mKnownSessions.end();
				while (st != en)
				{
					SessionData &sessid = (*st++).second;
					DoMasterCreateClassMessage(sessid.mSessionID,object);
				}
			}
		}
		if (object->GetLoadBalancing() && object->mTryingToGiveTo == kXPSessionUnknownID)
		{
			mTotalLoad += object->GetLoadScore();
			mTotalLoadChanged = true;
		}
	}
	else
	{
		// A replica just needs to be added to the list
#ifdef DEBUG_PRINTS1
		dprintf("   Object is a REPLICA type\n");
#endif

	}

	AddObjectToCorrectLists(object);

	object->UnLock();
}

void ReplicaNetPrivate::RemoveObject(ReplicaObject *const object,const bool sendDelete)
{
	// Early out tests
	if (!object)
	{
		return;
	}
	if (!object->mObjectHasBeenAdded)
	{
//		assert(false && "ReplicaNet::RemoveObject used on an object that hasn't been added\n");
		return;
	}

// Now lock our thread
	THREADSAFELOCK();

// No need to lock the object since we are setting an atomic variable?
	object->Lock();

	if (!sendDelete)
	{
		object->CallbackObjectUnpublishPre();
	}

	// If the object being removed is the observer then tell ReplicaNet that the object is no longer available as an observer
	if (object == mObserver)
	{
		SetObserver();
	}

	std::set<int>::iterator sst,sen;
	sst = object->mObserverFor.begin();
	sen = object->mObserverFor.end();
	while (sst != sen)
	{
		int sessionid = *sst;
		sst++;
		std::map<int,SessionData>::iterator found;
		found = mKnownSessions.find(sessionid);
		// Search for the session parameter block
		if (found != mKnownSessions.end())
		{
			SessionData *sessid = &((*found).second);
			assert(sessid->mSessionID == sessionid);
			if (sessid->mObserver == object)
			{
#ifdef DEBUG_PRINTS2
				dprintf("ReplicaNet::RemoveObject set no observer for sessid %d\n",sessionid);
#endif
				sessid->mObserver = 0;
			}
			else
			{
#ifdef DEBUG_PRINTS2
				dprintf("WARNING : ReplicaNet::RemoveObject set no observer wasn't observing sessid %d\n",sessionid);
#endif
			}
		}
	}
	object->mObserverFor.clear();


	RemoveObjectFromAllLists(object);

	// If it is a master object then send out an update that the object unique id and session id is being removed
	if (object->IsMaster())
	{
		if (object->GetLoadBalancing())
		{
			mTotalLoad -= object->GetLoadScore();
			mTotalLoadChanged = true;
		}
		if (mSessionID != kXPSessionUnknownID)
		{
			// If we propagate to sessions then only notify those that we want to
			if (object->mSessionPropagationFilter)
			{
				object->Lock();
				// Check the propagate list has the sessionID in it
				std::set<int>::iterator st,en;
				st = object->mSessionPropagationFilterIDs.begin();
				en = object->mSessionPropagationFilterIDs.end();
				while (st != en)
				{
					int theID = *st;

					char tempbuff[12];
					MessageHelper message;
					message.SetBuffer(tempbuff);
					RepnetMessage repnetmess;
					if (sendDelete)
					{
						repnetmess = kReplicaNetMessage_DeleteClass;
					}
					else
					{
						repnetmess = kReplicaNetMessage_UnpublishClass;
					}
					MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
					message.AddInteger(object->GetUniqueID());
					// Sent with the certain method
					RecordCheckDataSendToSession(theID,tempbuff,message.GetSize(),false,true);
#ifndef _FINAL
					if (sendDelete)
					{
						object->_DebugInternal_EmitClassDelete(GetSize(),theID);
					}
					else
					{
						object->_DebugInternal_EmitClassUnpublish(GetSize(),theID);
					}
#endif
					st++;
				}

				object->UnLock();
			}
			else
			{
				// No propagate to session, so just broadcast to all known sessions
				char tempbuff[12];
				MessageHelper message;
				message.SetBuffer(tempbuff);
				RepnetMessage repnetmess;
				if (sendDelete)
				{
					repnetmess = kReplicaNetMessage_DeleteClass;
				}
				else
				{
					repnetmess = kReplicaNetMessage_UnpublishClass;
				}
				MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
				message.AddInteger(object->GetUniqueID());
				// Sent with the certain method
				RecordCheckDataSendToSession(kXPSessionBroadcastID,tempbuff,message.GetSize(),false,true);

#ifndef _FINAL
				if (sendDelete)
				{
					object->_DebugInternal_EmitClassDelete(GetSize(),kReplicaNetBroadcastID);
				}
				else
				{
					object->_DebugInternal_EmitClassUnpublish(GetSize(),kReplicaNetBroadcastID);
				}
#endif
			}
		}
	}

	// If we are a reflection master
	if (object->mReflectSessionID != kXPSessionUnknownID && object->mReflectSessionID == GetSessionID())
	{
		// If we propagate to sessions then only notify those that we want to
		if (object->mSessionPropagationFilter)
		{
			object->Lock();
			// Check the propagate list has the sessionID in it
			std::set<int>::iterator st,en;
			st = object->mSessionPropagationFilterIDs.begin();
			en = object->mSessionPropagationFilterIDs.end();
			while (st != en)
			{
				int theID = *st;

				char tempbuff[12];
				MessageHelper message;
				message.SetBuffer(tempbuff);
				RepnetMessage repnetmess;
				if (sendDelete)
				{
					repnetmess = kReplicaNetMessage_ReflectDeleteClass;
				}
				else
				{
					repnetmess = kReplicaNetMessage_ReflectUnpublishClass;
				}
				MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
				message.AddInteger(object->GetUniqueID());
				// Sent with the certain method
				RecordCheckDataSendToSession(theID,tempbuff,message.GetSize(),false,true);
#ifndef _FINAL
				if (sendDelete)
				{
					object->_DebugInternal_EmitClassDelete(GetSize(),theID);
				}
				else
				{
					object->_DebugInternal_EmitClassUnpublish(GetSize(),theID);
				}
#endif
				st++;
			}

			object->UnLock();
		}
		else
		{
			// No propagate to session, so just broadcast to all known sessions
			char tempbuff[12];
			MessageHelper message;
			message.SetBuffer(tempbuff);
			RepnetMessage repnetmess;
			if (sendDelete)
			{
				repnetmess = kReplicaNetMessage_ReflectDeleteClass;
			}
			else
			{
				repnetmess = kReplicaNetMessage_ReflectUnpublishClass;
			}
			MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
			message.AddInteger(object->GetUniqueID());
			// Sent with the certain method
			RecordCheckDataSendToSession(kXPSessionBroadcastID,tempbuff,message.GetSize(),false,true);

#ifndef _FINAL
			if (sendDelete)
			{
				object->_DebugInternal_EmitClassDelete(GetSize(),kReplicaNetBroadcastID);
			}
			else
			{
				object->_DebugInternal_EmitClassUnpublish(GetSize(),kReplicaNetBroadcastID);
			}
#endif
		}
	}

	// If recording then store that the object has been removed.
	if (mIsRecording && object->IsReplica())
	{
		char buffer[64];
		MessageHelper message;
		message.SetBuffer(buffer);
		RepnetMessage repnetmess;
		if (sendDelete)
		{
			repnetmess = kReplicaNetMessage_DeleteClass;
		}
		else
		{
			repnetmess = kReplicaNetMessage_UnpublishClass;
		}
		MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
		message.AddInteger(object->GetUniqueID());
		RecordDataPacket(object->GetSessionID(),kReplicaNetRecordID,buffer,message.GetSize(),0);
	}

	// GetNewSessionIDAndUniqueID() needs mObjectHasBeenAdded and mGetNewSessionIDAndUniqueIDCalled to be false to succeed
	object->mObjectHasBeenAdded = false;
	object->mGetNewSessionIDAndUniqueIDCalled = false;

	if (!sendDelete)
	{
		object->GetNewSessionIDAndUniqueID(mParentReplicaNet);
		object->CallbackObjectUnpublishPost();
	}

	object->UnLock();
}

int ReplicaNetPrivate::GetGameChannel(void)
{
	THREADSAFELOCK();

	// If there is no session then we could be on any game channel to just return that
	if (!mSession)
	{
		return TransportAnyGameChannel;
	}

	// Query the session for the game channel
	return mSession->GetGameChannel();
}

void ReplicaNetPrivate::SetGameChannel(const int channel)
{
	THREADSAFELOCK();

	// Setting a channel before the session is started causes the session class to be allocated
	EnsureSessionAllocated();

	mSession->SetGameChannel(channel);		
}

void ReplicaNetPrivate::SessionCreate(const std::string name,const std::string protocols)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	mOKToDoRecord = true;

	// The check for blank protocols is done here because the operation of the two different XPSession::Create() calls differ significantly
	if (protocols == "")
	{
		mSession->Create(name);
	}
	else
	{
		mSession->Create(name,protocols);
	}

	// Flag that we are a master session
	mPreviousIsMaster = true;

	// Poll the session
	mSession->Poll();

	// Poll this class
	Poll();

}

void ReplicaNetPrivate::SessionCreate(const std::string name)
{
	THREADSAFELOCK();

	SessionCreate(name,"");
}

std::string ReplicaNetPrivate::SessionExportURL(void)
{
	THREADSAFELOCK();

	if (mSession == NULL)
	{
		return "";
	}

	return mSession->ExportURL();
}

void ReplicaNetPrivate::SessionJoin(const std::string url)
{
	THREADSAFELOCK();

	if (mSession == NULL)
	{
		XPSession *aSession;
		aSession = XPSession::Allocate();
		AttachSession(aSession);
	}

	mOKToDoRecord = true;

	mSession->Join(url);
}

void ReplicaNetPrivate::AttachSession(XPSession *session)
{
	THREADSAFELOCK();

	mSession = session;
}

void ReplicaNetPrivate::TakeOverObject(ReplicaObject *object)
{
	assert(object && "No object to take over\n");

	if (!object)
	{
		return;
	}

	THREADSAFELOCK();

	if (object->IsMaster())
	{
		return;
	}

	RemoveObjectFromAllLists(object);

	int oldsessid = object->GetSessionID();
	int olduniid = object->GetUniqueID();
	// Switch the object to be a master
	object->mIsMaster = true;

	object->mSessionID = GetSessionID();
	object->mUniqueID = mParentReplicaNet->CallbackGetObjectUniqueID(object);

	DataBlockReason reason;
	// Do the master add calculation for our datablocks
	reason.mReasonCode = kDataBlockReason_MasterPrepAfterTakeover;
	reason.mFloatTime = mParentReplicaNet->GetTime();
	reason.mFloatLocalTime = mParentReplicaNet->GetLocalTime();
	reason.mSessionReference = mSessionID;
	int i;
	for (i=0;i<(int)object->mDataBlocks.size();i++)
	{
		object->mDataBlocks[i]->OwnerChanged(object->mSessionID);
		object->mDataBlocks[i]->Poll(&reason);
	}
	reason.mReasonCode = kDataBlockReason_CalculateMasterPoll;
	for (i=0;i<(int)object->mDataBlocks.size();i++)
	{
		object->mDataBlocks[i]->Poll(&reason);
	}
	object->mMasterOrReplicaDataBlockPollDone = true;

	// Send a message to all the sessions saying this object has been taken over
	std::map<int,SessionData>::iterator st,en;
	st = mKnownSessions.begin();
	en = mKnownSessions.end();
	while (st != en)
	{
		SessionData sessid = (*st++).second;
		char tempbuff[512];
		MessageHelper message;
		message.SetBuffer(tempbuff);
		RepnetMessage repnetmess = kReplicaNetMessage_ObjectTakenOver;
		MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
		message.AddInteger(oldsessid);
		message.AddInteger(olduniid);
		message.AddInteger(object->GetUniqueID());

		// Data sent with the reliable flag since object fault tolerance is quite important
		RecordCheckDataSendToSession(sessid.mSessionID,tempbuff,message.GetSize(),true);
	}

	// Reset the timer
//	object->SetPropagateToSessionDistanceRecalculationDelay();	// MPi: Don't need to reset the time period
	object->mDistanceBasedLastTime = -object->mDistanceBasedPollTime*2;

	// Do the callback for the object, which may or may not enable the session propagation
	object->OwnerChange();

	// Do the check for the distance based propagation and recalculate the propagated sessions if required
	HandleMasterSessionPropagateDistanceBasedPerObject(mParentReplicaNet->GetLocalTime(),object);

	// Notify the datablocks for this object
	st = mKnownSessions.begin();
	en = mKnownSessions.end();
	while (st != en)
	{
		int sessionID = (*st).second.mSessionID;
		bool processThis = false;

		// If we are only going to propagate to certain session IDs then we need to double check them
		if (object->mSessionPropagationFilter)
		{
			object->Lock();
			// Check the propagate list has the sessionID in it
			if (object->mSessionPropagationFilterIDs.find(sessionID) != object->mSessionPropagationFilterIDs.end())
			{
				processThis = true;
				object->mSessionPropagationFilterDelaySlotAdd.erase(sessionID);
			}
			object->UnLock();
		}
		else
		{
			processThis = true;
		}

		if (processThis)
		{
			SessionData sessid = (*st).second;
			DoMasterTakeOverClassMessage(sessid.mSessionID,object);
		}
		st++;
	}

	AddObjectToCorrectLists(object);

	// Add on our load balancing score if we took over a load balanced object
	if (object->GetLoadBalancing())
	{
		mTotalLoad += object->GetLoadScore();
		mTotalLoadChanged = true;
	}
}

void ReplicaNetPrivate::SessionFind(void)
{
	THREADSAFELOCK();

	if (mSession == NULL)
	{
		XPSession *aSession;
		aSession = XPSession::Allocate();
		AttachSession(aSession);
	}

	if (mSession == NULL)
	{
		return;
	}

	mSession->Find();
}

void ReplicaNetPrivate::SessionFind(const std::string protocols)
{
	THREADSAFELOCK();

	if (mSession == NULL)
	{
		XPSession *aSession;
		aSession = XPSession::Allocate();
		AttachSession(aSession);
	}

	if (mSession == NULL)
	{
		return;
	}

	mSession->Find(protocols);
}

std::string ReplicaNetPrivate::SessionEnumerateFound(void)
{
	THREADSAFELOCK();

	if (mSession == NULL)
	{
		return "";
	}

	return mSession->EnumerateFound();
}

int ReplicaNetPrivate::GetMakeUniqueID(void)
{
	return mMakeUniqueID;
}

int ReplicaNetPrivate::GetMakeSessionID(void)
{
	return mMakeSessionID;
}

void ReplicaNetPrivate::LockObjects(void)
{
	Lock();
}

/**
 * This unlocks the object lists from a previous LockObjects() call
 */
void ReplicaNetPrivate::UnLockObjects(void)
{
	UnLock();
}

float ReplicaNetPrivate::GetNetworkSendRate(void)
{
	THREADSAFELOCK();

	if (mSession)
	{
		return mSession->GetNetworkSendRate();
	}
	return 0;
}

float ReplicaNetPrivate::GetNetworkReceiveRate(void)
{
	THREADSAFELOCK();

	if (mSession)
	{
		return mSession->GetNetworkReceiveRate();
	}
	return 0;
}

int ReplicaNetPrivate::GetNetworkPacketsLost(void)
{
	THREADSAFELOCK();

	if (!mSession)
	{
		return 0;
	}
	return mSession->GetNetworkPacketsLost();
}

int ReplicaNetPrivate::GetNetworkPacketsRejected(void)
{
	THREADSAFELOCK();

	if (!mSession)
	{
		return 0;
	}
	return mSession->GetNetworkPacketsRejected();
}

SysTimeType ReplicaNetPrivate::GetTime(void)
{
	THREADSAFELOCK();

	if (mIsPlayback)
	{
		return mPlaybackTimeOffset + GetRecordingTime();
	}

	EnsureSessionAllocated();

	return mSession->GetTime();
}

SysTimeType ReplicaNetPrivate::GetLocalTime(void)
{
	THREADSAFELOCK();

	if (mIsPlayback)
	{
		return mPlaybackLocalTimeOffset + GetRecordingTime();
	}

	EnsureSessionAllocated();

	return mSession->GetLocalTime();
}

void ReplicaNetPrivate::CommonCreateClassMessages(ReplicaObject *object,DynamicMessageHelper &message,DataBlockReason &reason)
{
	unsigned int band = 0,nextBand = 0;
	bool retval1 = DoClassDataMessage(object,&message,&reason);
	bool retval2 = DoClassDataReliableMessage(band,nextBand,true,object,&message,&reason,retval1);
	bool retval3 = DoClassDataCertainMessage(object,&message,&reason,retval1 || retval2);
	bool retval4 = DoClassDataOrderedMessage(band,nextBand,true,object,&message,&reason,retval1);
	// If there was no class data at all then we add this flag to signal this special case
	if (!(retval1 || retval2 || retval3 || retval4))
	{
		RepnetMessage repnetmess = kReplicaNetMessage_NoClassData;
		MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
	}
}

/**
 * This makes the message for when a master class needs it's state sent to a session, or a broadcast session id
 * \param session the session id to send this classes message to, can be a broadcast session id
 * \param object the master object to create the message for
 */
void ReplicaNetPrivate::DoMasterCreateClassMessage(int sessionid,ReplicaObject *object)
{
	assert(sessionid != kXPSessionUnknownID && "Master create message trying to send to a broadcast address");
	if (object->mReflectSessionID != kReplicaNetUnknownUniqueID)
	{
		if (object->mReflectSessionID != sessionid)
		{
			assert(false && "DoMasterCreateClassMessage: Failed because the create was being sent to other than the reflect master");
		}
	}

	if (mSession != NULL && (mSessionID != kXPSessionUnknownID || sessionid == kReplicaNetRecordID))
	{
#ifdef DEBUG_PRINTS2
		dprintf("DoMasterCreateClassMessage : Master object classid %d sesid %d, uniid %d I'm sending it to sess%d\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID(),sessionid);
#endif
		DynamicMessageHelper message;
		RepnetMessage repnetmess = kReplicaNetMessage_CreateClass;

		// Add the message, classid and uniqueid to the message
		MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
		message.AddInteger(object->GetClassID());
		message.AddInteger(object->GetUniqueID());

#ifndef _FINAL
		object->_DebugInternal_EmitClassCreate(message.GetSize(),sessionid);
#endif

		// Notify the datablocks that someone has joined
		DataBlockReason reason;
		reason.mFloatLocalTime = mParentReplicaNet->GetLocalTime();
		reason.mReasonCode = kDataBlockReason_SomeoneJoined;
		reason.mSessionReference = sessionid;

		// Accept the packet information, if any from the polled datablocks
		CommonCreateClassMessages(object,message,reason);

		// The data is sent with the configured type
		if (object->UpdateIsReliable())
		{
			RecordCheckDataSendToSession(sessionid,message.GetBuffer(),message.GetSize(),true,false,false,object->GetBand());
		}
		else if (object->UpdateIsCertain())
		{
			RecordCheckDataSendToSession(sessionid,message.GetBuffer(),message.GetSize(),false,true);
		}
		else if (object->UpdateIsOrdered())
		{
			RecordCheckDataSendToSession(sessionid,message.GetBuffer(),message.GetSize(),false,false,true,object->GetBand());
		}
		else
		{
			RecordCheckDataSendToSession(sessionid,message.GetBuffer(),message.GetSize(),false,false);
		}
	}
	else
	{
#ifdef DEBUG_PRINTS2
		dprintf("DoMasterCreateClassMessage : Didn't succeed because the ReplicaNet session ID was not complete\n");
#endif
	}
}

void ReplicaNetPrivate::DoReflectCreateClassMessage(int sessionid,ReplicaObject *object)
{
	assert(sessionid != kXPSessionUnknownID && "Reflect create message trying to send to a broadcast address");
	assert(object->mReflectSessionID != kReplicaNetUnknownUniqueID && "Reflect create message being sent from a non-reflect object");
	assert(sessionid != object->mSessionID && "Reflect create message being sent to the source master sessionID");

	if (mSession != NULL && (mSessionID != kXPSessionUnknownID || sessionid == kReplicaNetRecordID))
	{
#ifdef DEBUG_PRINTS2
		dprintf("DoReflectCreateClassMessage : Master object classid %d sesid %d, uniid %d I'm sending it to sess%d\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID(),sessionid);
#endif
		DynamicMessageHelper message;
		RepnetMessage repnetmess = kReplicaNetMessage_CreateClassReflect;
		MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);

		// Add the message, classid and uniqueid and reflect sessionid to the message
		message.AddInteger(object->GetSessionID());
		message.AddInteger(object->GetClassID());
		message.AddInteger(object->GetUniqueID());
		message.AddInteger(object->mReflectSessionID);

#ifndef _FINAL
		object->_DebugInternal_EmitClassCreate(message.GetSize(),sessionid);
#endif

		// Notify the datablocks that someone has joined
		DataBlockReason reason;
		reason.mFloatLocalTime = mParentReplicaNet->GetLocalTime();
		reason.mReasonCode = kDataBlockReason_SomeoneJoined;
		reason.mSessionReference = sessionid;

		// Accept the packet information, if any from the polled datablocks
		CommonCreateClassMessages(object,message,reason);

		// The data is sent with the configured type
		if (object->UpdateIsReliable())
		{
			RecordCheckDataSendToSession(sessionid,message.GetBuffer(),message.GetSize(),true,false,false,object->GetBand());
		}
		else if (object->UpdateIsCertain())
		{
			RecordCheckDataSendToSession(sessionid,message.GetBuffer(),message.GetSize(),false,true);
		}
		else if (object->UpdateIsOrdered())
		{
			RecordCheckDataSendToSession(sessionid,message.GetBuffer(),message.GetSize(),false,false,true,object->GetBand());
		}
		else
		{
			RecordCheckDataSendToSession(sessionid,message.GetBuffer(),message.GetSize(),false,false);
		}
	}
	else
	{
#ifdef DEBUG_PRINTS2
		dprintf("DoReflectCreateClassMessage : Didn't succeed because the ReplicaNet session ID was not complete\n");
#endif
	}
}





void ReplicaNetPrivate::DoMasterTakeOverClassMessage(int sessionid,ReplicaObject *object)
{
	assert( sessionid != kXPSessionUnknownID && "Master take over message trying to send to a broadcast address");

	if (mSession != NULL && (mSessionID != kXPSessionUnknownID || sessionid == kReplicaNetRecordID || mIsPlayback))
	{
#ifdef DEBUG_PRINTS2
		dprintf("DoMasterTakeOverClassMessage : Master object classid %d sesid %d, uniid %d I'm sending it to sess%d\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID(),sessionid);
#endif
		DynamicMessageHelper message;
		DataBlockReason reason;

		// Create the packet message by polling the datablocks with the joined reason code
		reason.mFloatLocalTime = mParentReplicaNet->GetLocalTime();
		reason.mReasonCode = kDataBlockReason_SomeoneJoined;
		reason.mSessionReference = sessionid;
		unsigned int band = 0,nextBand = 0;
		do
		{
			message.SetSize(0);
			band = nextBand;
			if (DoClassDataReliableMessage(band,nextBand,false,object,&message,&reason))
			{
				RecordCheckDataSendToSession(sessionid,message.GetBuffer(),message.GetSize(),true,false,false,band);
			}
		} while (band != nextBand);

		message.SetSize(0);
		reason.mReasonCode = kDataBlockReason_SomeoneJoined;
		reason.mSessionReference = sessionid;
		if (DoClassDataCertainMessage(object,&message,&reason))
		{
			RecordCheckDataSendToSession(sessionid,message.GetBuffer(),message.GetSize(),false,true);
		}

		band = 0;
		nextBand = 0;
		do
		{
			message.SetSize(0);
			band = nextBand;
			if (DoClassDataOrderedMessage(band,nextBand,false,object,&message,&reason))
			{
				RecordCheckDataSendToSession(sessionid,message.GetBuffer(),message.GetSize(),false,false,true,band);
			}
		} while (band != nextBand);

		message.SetSize(0);
		reason.mReasonCode = kDataBlockReason_SomeoneJoined;
		reason.mSessionReference = sessionid;
		if (DoClassDataMessage(object,&message,&reason))
		{
			RecordCheckDataSendToSession(sessionid,message.GetBuffer(),message.GetSize(),false);
		}
	}
	else
	{
#ifdef DEBUG_PRINTS2
		dprintf("DoMasterTakeOverClassMessage : Didn't succeed because the ReplicaNet session ID was not complete\n");
#endif
	}
}

bool ReplicaNetPrivate::DoClassDataMessage(ReplicaObject *object,DynamicMessageHelper *message,DataBlockReason *reason)
{
	assert( reason != NULL && "ReplicaNetPrivate::DoClassDataMessage : Reason is NULL\n" );
	assert( (reason->mSessionReference >= 0 || reason->mSessionReference == kReplicaNetRecordID || mIsPlayback) && "ReplicaNetPrivate::DoClassDataMessage : Reason session is invalid\n" );

	if (object->mUpdateSendDormant)
	{
		return false;
	}

	reason->mMessageHelper = message;

	// Remember the size of the message
	int temp, oldsize = message->GetSize();
	// Add the relevant class data message based on the reason code
	RepnetMessage repnetmess = kReplicaNetMessage_ClassData;
	// If we have a reflect to check for then..
	if (object->mReflectSessionID != kXPSessionUnknownID)
	{
		// If the destination session is not the reflect object then use a different message
		if (reason->mSessionReference != object->mReflectSessionID)
		{
			repnetmess = kReplicaNetMessage_ReflectClassData;
		}
	}
	if (reason->mReasonCode == kDataBlockReason_ReplicaCallBackPoll)
	{
		repnetmess = kReplicaNetMessage_MasterCallbackClassData;
	}


	message->AddVariable(&repnetmess,sizeof(repnetmess));
	temp = object->GetUniqueID();
	message->AddVariable(&temp,sizeof(temp));
	int backupsize = message->GetSize();
	int i;
	// Poll the datablocks with this reason
	for (i=0;i<(int)object->mDataBlocks.size();i++)
	{
		if (!object->mDataBlocks[i]->GetReliableFlag() && !object->mDataBlocks[i]->GetCertainFlag() && !object->mDataBlocks[i]->GetOrderedFlag())
		{
			object->mDataBlocks[i]->Poll(reason);
		}
	}
	// If there was no class data then restore the message length to the old size and signal no data got added
	if (backupsize == message->GetSize())
	{
		message->SetSize(oldsize);
		return false;
	}

#ifdef DEBUG_PRINTS2
	dprintf("DoClassDataMessage : Master object classid %d sesid %d, uniid %d\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID());
#endif

	// Return with a signal to say there is added class data and DataBlock packet data
	return true;
}

bool ReplicaNetPrivate::DoClassDataCertainMessage(ReplicaObject *object,DynamicMessageHelper *message,DataBlockReason *reason,bool append)
{
	assert( reason != NULL && "ReplicaNetPrivate::DoClassDataCertainMessage : Reason is NULL\n" );
	assert( (reason->mSessionReference >= 0 || reason->mSessionReference == kReplicaNetRecordID || mIsPlayback) && "ReplicaNetPrivate::DoClassDataCertainMessage : Reason session is invalid\n" );

	if (object->mUpdateSendDormant)
	{
		return false;
	}

	reason->mMessageHelper = message;

	// Remember the size of the message
	int temp, oldsize = message->GetSize();

	// Add the relevent class data message based on the reason code if there is no append flag
	if (!append)
	{
		RepnetMessage repnetmess = kReplicaNetMessage_ClassData;
		// If we have a reflect to check for then..
		if (object->mReflectSessionID != kXPSessionUnknownID)
		{
			// If the destination session is not the reflect object then use a different message
			if (reason->mSessionReference != object->mReflectSessionID)
			{
				repnetmess = kReplicaNetMessage_ReflectClassData;
			}
		}
		if (reason->mReasonCode == kDataBlockReason_ReplicaCallBackPoll)
		{
			repnetmess = kReplicaNetMessage_MasterCallbackClassData;
		}

		message->AddVariable(&repnetmess,sizeof(repnetmess));
		temp = object->GetUniqueID();
		message->AddVariable(&temp,sizeof(temp));
	}
	int backupsize = message->GetSize();
	int i;
	for (i=0;i<(int)object->mDataBlocks.size();i++)
	{
		if (object->mDataBlocks[i]->GetCertainFlag())
		{
			object->mDataBlocks[i]->Poll(reason);
		}
	}
	// If there was no class data then restore the message length to the old size and flag no data got added
	if (backupsize == message->GetSize())
	{
		message->SetSize(oldsize);
		return false;
	}

#ifdef DEBUG_PRINTS2
	dprintf("DoClassDataCertainMessage : Master object classid %d sesid %d, uniid %d\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID());
#endif

	// Return with a flag to say there is added class data and DataBlock packet data
	return true;
}

bool ReplicaNetPrivate::DoClassDataReliableMessage(unsigned int band,unsigned int &nextBand,bool doAll,ReplicaObject *object,DynamicMessageHelper *message,DataBlockReason *reason,bool append)
{
	assert( reason != NULL && "ReplicaNetPrivate::DoClassDataReliableMessage : Reason is NULL\n" );
	assert( (reason->mSessionReference >= 0 || reason->mSessionReference == kReplicaNetRecordID || mIsPlayback) && "ReplicaNetPrivate::DoClassDataReliableMessage : Reason session is invalid\n" );

	if (object->mUpdateSendDormant)
	{
		return false;
	}

	unsigned int nextHighest = nextBand;

	reason->mMessageHelper = message;

	// Remember the size of the message
	int temp, oldsize = message->GetSize();

	// Add the relevant class data message based on the reason code if there is no append flag
	if (!append)
	{
		RepnetMessage repnetmess = kReplicaNetMessage_ClassData;
		// If we have a reflect to check for then..
		if (object->mReflectSessionID != kXPSessionUnknownID)
		{
			// If the destination session is not the reflect object then use a different message
			if (reason->mSessionReference != object->mReflectSessionID)
			{
				repnetmess = kReplicaNetMessage_ReflectClassData;
			}
		}
		if (reason->mReasonCode == kDataBlockReason_ReplicaCallBackPoll)
		{
			repnetmess = kReplicaNetMessage_MasterCallbackClassData;
		}

		message->AddVariable(&repnetmess,sizeof(repnetmess));
		temp = object->GetUniqueID();
		message->AddVariable(&temp,sizeof(temp));
	}
	int backupsize = message->GetSize();
	int i;
	for (i=0;i<(int)object->mDataBlocks.size();i++)
	{
		int thisSize = message->GetSize();
		if (object->mDataBlocks[i]->GetReliableFlag())
		{
			// Decide if we should be processing the banded datablocks yet
			if (doAll || object->mDataBlocks[i]->GetBand() == band)
			{
				object->mDataBlocks[i]->Poll(reason);
			}
			else if (object->mDataBlocks[i]->GetBand() > band)
			{
				// Starting condition or test for the lowest of the next band
				if (nextHighest == nextBand)
				{
					nextHighest = object->mDataBlocks[i]->GetBand();
				}
				else if (object->mDataBlocks[i]->GetBand() < nextHighest)
				{
					nextHighest = object->mDataBlocks[i]->GetBand();
				}
			}
		}
	}
	nextBand = nextHighest;

	// If there was no class data then restore the message length to the old size and flag no data got added
	if (backupsize == message->GetSize())
	{
		message->SetSize(oldsize);
		return false;
	}

#ifdef DEBUG_PRINTS2
	dprintf("DoClassDataReliableMessage : Master object classid %d sesid %d, uniid %d band %d nextBand %d\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID(),band,nextBand);
#endif

	// Return with a flag to say there is added class data and datablock packet data
	return true;
}

// MPi: TOOD: Think about merging functionality with DoClassDataReliableMessage above since most of the code is common
bool ReplicaNetPrivate::DoClassDataOrderedMessage(unsigned int band,unsigned int &nextBand,bool doAll,ReplicaObject *object,DynamicMessageHelper *message,DataBlockReason *reason,bool append)
{
	assert( reason != NULL && "ReplicaNetPrivate::DoClassDataOrderedMessage : Reason is NULL\n" );
	assert( (reason->mSessionReference >= 0 || reason->mSessionReference == kReplicaNetRecordID || mIsPlayback) && "ReplicaNetPrivate::DoClassDataOrderedMessage : Reason session is invalid\n" );

	if (object->mUpdateSendDormant)
	{
		return false;
	}

	unsigned int nextHighest = nextBand;

	reason->mMessageHelper = message;

	// Remember the size of the message
	int temp, oldsize = message->GetSize();

	// Add the relevant class data message based on the reason code if there is no append flag
	if (!append)
	{
		RepnetMessage repnetmess = kReplicaNetMessage_ClassData;
		// If we have a reflect to check for then..
		if (object->mReflectSessionID != kXPSessionUnknownID)
		{
			// If the destination session is not the reflect object then use a different message
			if (reason->mSessionReference != object->mReflectSessionID)
			{
				repnetmess = kReplicaNetMessage_ReflectClassData;
			}
		}
		if (reason->mReasonCode == kDataBlockReason_ReplicaCallBackPoll)
		{
			repnetmess = kReplicaNetMessage_MasterCallbackClassData;
		}

		message->AddVariable(&repnetmess,sizeof(repnetmess));
		temp = object->GetUniqueID();
		message->AddVariable(&temp,sizeof(temp));
	}
	int backupsize = message->GetSize();
	int i;
	for (i=0;i<(int)object->mDataBlocks.size();i++)
	{
		int thisSize = message->GetSize();
		if (object->mDataBlocks[i]->GetOrderedFlag())
		{
			// Decide if we should be processing the banded datablocks yet
			if (doAll || object->mDataBlocks[i]->GetBand() == band)
			{
				object->mDataBlocks[i]->Poll(reason);
			}
			else if (object->mDataBlocks[i]->GetBand() > band)
			{
				// Starting condition or test for the lowest of the next band
				if (nextHighest == nextBand)
				{
					nextHighest = object->mDataBlocks[i]->GetBand();
				}
				else if (object->mDataBlocks[i]->GetBand() < nextHighest)
				{
					nextHighest = object->mDataBlocks[i]->GetBand();
				}
			}
		}
	}
	nextBand = nextHighest;

	// If there was no class data then restore the message length to the old size and flag no data got added
	if (backupsize == message->GetSize())
	{
		message->SetSize(oldsize);
		return false;
	}

#ifdef DEBUG_PRINTS2
	dprintf("DoClassDataOrderedMessage : Master object classid %d sesid %d, uniid %d band %d nextBand %d\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID(),band,nextBand);
#endif

	// Return with a flag to say there is added class data and datablock packet data
	return true;
}

int ReplicaNetPrivate::ThreadEntry(void)
{
	while (1)
	{
		if (!mManualPoll)
		{
			Poll();
		}
		else
		{
			Sleep(100);
		}

		Sleep(10);
	}

	return 0;
}

void ReplicaNetPrivate::SetObserver(ReplicaObject *const object)
{
	THREADSAFELOCK();

	if (mObserver == object)
	{
		return;
	}

	mObserver = object;

	if (mSession)
	{
		// Send the observer update packet or the clear observer packet
		if (mObserver)
		{
			assert(object->IsPublished() && "ReplicaNet::SetObserver() The ReplicaObject has not been published to the network session");
#ifdef DEBUG_PRINTS1
			dprintf("ReplicaNet : Sending observer update to sessid ALL for objid %d\n",mObserver->GetUniqueID());
#endif
			char tempbuff[16];
			MessageHelper message;
			message.SetBuffer(tempbuff);
			RepnetMessage repnetmess = kReplicaNetMessage_SetObserver;
			MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
			message.AddInteger(mObserver->GetSessionID());
			message.AddInteger(mObserver->GetUniqueID());
			// Sent with the reliable method
			RecordCheckDataSendToSession(kXPSessionBroadcastID,tempbuff,message.GetSize(),true,false);
		}
		else
		{
#ifdef DEBUG_PRINTS1
			dprintf("ReplicaNet : Sending no observer update to sessid ALL\n");
#endif
			char tempbuff[12];
			MessageHelper message;
			message.SetBuffer(tempbuff);
			RepnetMessage repnetmess = kReplicaNetMessage_SetNoObserver;
			MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
			// Sent with the reliable method
			RecordCheckDataSendToSession(kXPSessionBroadcastID,tempbuff,message.GetSize(),true,false);
		}
	}

}

ReplicaObject *ReplicaNetPrivate::GetObserver(void)
{
	return mObserver;
}

ReplicaNetPrivate::SessionData::SessionData(int id)
{
	mSessionID = id;
	mObserver = 0;
	mObserverSessionID = kReplicaNetUnknownUniqueID;
	mObserverUniqueID = kReplicaObjectUnknownUniqueID;
	mCanAcceptObjects = false;
	mIsLoadBalanced = false;
	mMaximumLoad = 0.0f;
	mTotalLoad = 0.0f;
	mObserverPendingSet = false;
}

void ReplicaNetPrivate::GiveOwnership(ReplicaObject *const object,const int sessionID)
{
	THREADSAFELOCK();

	// Paranoia check the input values to make sure we can give ownership of the object
	if (!object)
	{
		return;
	}
	
	if (!object->IsMaster())
	{
		return;
	}

	if (sessionID == object->GetSessionID())
	{
		return;
	}

	if (!object->ApproveMigration())
	{
		return;
	}

	if (!mSession)
	{
		return;
	}

	// Create the message to say what object is being given
	char tempbuff[512];
	MessageHelper message;
	message.SetBuffer(tempbuff);
	RepnetMessage repnetmess = kReplicaNetMessage_TakeOverObject;
	MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
	message.AddInteger(object->GetSessionID());
	message.AddInteger(object->GetUniqueID());

	// Data sent with the certain flag since object fault tolerance is quite important
	RecordCheckDataSendToSession(sessionID,tempbuff,message.GetSize(),false,true);

	// Flag the sessionID for the object so we know that we are trying to give the object to that sessionID
	// Later on if the session fails, due to the other session disconnecting then the object is flagged as not being given
	object->mTryingToGiveTo = sessionID;
}

void ReplicaNetPrivate::RequestOwnership(ReplicaObject *const object)
{
	THREADSAFELOCK();

	// Paranoia check the input values to make sure we can request ownership of the object
	if (!object)
	{
		return;
	}
	
	if (object->IsMaster())
	{
		return;
	}

	if (GetSessionID() == object->GetSessionID())
	{
		return;
	}

	if (!object->ApproveMigration())
	{
		return;
	}

	if (!mSession)
	{
		return;
	}

	// Create the message to the object owner asking for ownership
	char tempbuff[512];
	MessageHelper message;
	message.SetBuffer(tempbuff);
	RepnetMessage repnetmess = kReplicaNetMessage_RequestTakeOverObject;
	MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
	message.AddInteger(object->GetUniqueID());

	// Data sent with the certain flag since object fault tolerance is quite important
	RecordCheckDataSendToSession(object->GetSessionID(),tempbuff,message.GetSize(),false,true);
}

// Can be called as a master or a client.
void ReplicaNetPrivate::CheckForObjectFaultMigration(bool objectdelete,int sessionleft)
{
	std::vector<int> listofsessions;
	// If a master session then build a list of known sessionIDs that can accept objects, this list is used to pick the next available object migration sessionID
	if (mSession->IsMaster())
	{
		if (mOnSessionErrorMigrateObjects != ReplicaNet::kMigrateObjectsToNewMaster)
		{
			std::map<int,SessionData>::iterator st,en;
			st = mKnownSessions.begin();
			en = mKnownSessions.end();
			while (st != en)
			{
				SessionData sessid = (*st).second;
				if (sessid.mCanAcceptObjects)
				{
					listofsessions.push_back(sessid.mSessionID);
				}
				st++;
			}
		}

		if (mCanAcceptObjects)
		{
			listofsessions.push_back(mSessionID);
		}
	}

	// Hunt through the objects allocated to the session id that left
	mReplicaList.BeginIterate();
	ReplicaObject *object;
	while ( (object = mReplicaList.Iterate()) )
	{
		if (object->GetSessionID() == sessionleft || (sessionleft == kXPSessionUnknownID && object->mFlagForLaterMigration))
		{
			// If the object approves a fault then continue and wait around a bit for a new master to be decided on
			if (object->ApproveFault())
			{
				// The master session decides who takes over an object due to a fault
				if (mSession->IsMaster())
				{
					object->mFlagForLaterMigration = false;

					mNextBestSessionIndex++;
					if (mNextBestSessionIndex >= (int)listofsessions.size())
					{
						mNextBestSessionIndex = 0;
					}

					// If there are no sessions able to accept migrated objects then perform the configured action set by the user
					// This can be to force migration of objects to this session, delete the objects or just leave them
					if (listofsessions.size() == 0)
					{
						switch (mOnSessionErrorMigrateObjects)
						{
							case ReplicaNet::kMigrateObjects:
							case ReplicaNet::kMigrateObjectsToNewMaster:
								TakeOverObject(object);
								continue;
								break;
							case ReplicaNet::kDeleteObjects:
								DoObjectDelete(object);
								continue;
								break;
							case ReplicaNet::kLeaveObjects:
								object->mFlagForLaterMigration = true;
								// This causes the ReplicaNet session to report an error since leaving objects that need migration means that there are serious session problems.
								mErrorObjectsAreBeingLeft = true;
								continue;
								break;
						}
					}

					// If the target sessionID is not our sessionID then send a message to that session to take over the object instead
					if (listofsessions[mNextBestSessionIndex] != mSessionID)
					{
						char tempbuff[512];
						MessageHelper message;
						message.SetBuffer(tempbuff);
						RepnetMessage repnetmess = kReplicaNetMessage_TakeOverObject;
						MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
						message.AddInteger(object->GetSessionID());
						message.AddInteger(object->GetUniqueID());

						// Data sent with the certain flag since object fault tolerance is quite important
						RecordCheckDataSendToSession(listofsessions[mNextBestSessionIndex],tempbuff,message.GetSize(),false,true);
					}
					else
					{
						// This session has been chosen to get the object to take it over
						TakeOverObject(object);
					}
				}
				else
				{
					// The session is not the master yet and might not be, so just flag that the object has been processed for later migration
					if (sessionleft != kXPSessionUnknownID)
					{
						object->mFlagForLaterMigration = true;
					}
				}
				continue;
			}
			// If the object is to be deleted when not handled by the above code then do so
			if (objectdelete)
			{
				// Delete each object if it doesn't pass the tests above
				DoObjectDelete(object);
				continue;
			}
		}
	}
}

void ReplicaNetPrivate::SetCanSpider(const bool canSpider)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	mSession->SetCanSpider(canSpider);
}

bool ReplicaNetPrivate::GetCanSpider(void)
{
	THREADSAFELOCK();

	if (!mSession)
	{
		return false;
	}

	return mSession->GetCanSpider();
}

float ReplicaNetPrivate::GetLatencyToMasterSession(void)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	return mSession->GetLatencyToMasterSession();
}

float ReplicaNetPrivate::GetLatencyToSessionID(const int sessionID)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	return mSession->GetLatencyToSessionID(sessionID);
}

void ReplicaNetPrivate::SetLatencyRecalculationDelay(const float seconds)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	mSession->SetLatencyRecalculationDelay(seconds);
}

bool ReplicaNetPrivate::IsMaster(void)
{
	THREADSAFELOCK();

	if (!mSession)
	{
		return false;
	}

	return mSession->IsMaster();
}

bool ReplicaNetPrivate::IsStable(void)
{
	return mConnectionStable;
}

void ReplicaNetPrivate::SetManualPoll(void)
{
	mManualPoll = true;
}

void ReplicaNetPrivate::SetAutomaticPoll(void)
{
	mManualPoll = false;
}

void ReplicaNetPrivate::SetCanBecomeMaster(const bool canBeMaster)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	mSession->SetCanBecomeMaster(canBeMaster);
}

bool ReplicaNetPrivate::GetCanBecomeMaster(void)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	return mSession->GetCanBecomeMaster();
}

ReplicaNet::Error ReplicaNetPrivate::GetStatus(void)
{
	THREADSAFELOCK();

	// This is set when the session has serious problems and objects are unable to be migrated due to there being no master capable sessions
	if (mErrorObjectsAreBeingLeft)
	{
		return ReplicaNet::kReplicaNet_EERROR;
	}
	if (mPlaybackEndReachedDoError)
	{
		return ReplicaNet::kReplicaNet_EERROR;
	}

	// If the session reports an error then pass it on
	if (mSession->GetStatus() == XPSession::kXPSession_EERROR)
	{
		return ReplicaNet::kReplicaNet_EERROR;
	}

	return ReplicaNet::kReplicaNet_EOK;
}

ReplicaNet::Error ReplicaNetPrivate::GetSessionErrorReason(void)
{
	THREADSAFELOCK();
	if (mPlaybackEndReachedDoError)
	{
		return ReplicaNet::kReplicaNet_EEND_RECORDING;
	}
	if (!mSession)
	{
		return ReplicaNet::kReplicaNet_EOK;
	}

	switch (mSession->GetSessionErrorReason())
	{
		default:
		case XPSession::kXPSession_EERROR:
		{
			return ReplicaNet::kReplicaNet_EERROR;
			break;
		}
		case XPSession::kXPSession_ETRANSPORT_CLOSED:
		{
			return ReplicaNet::kReplicaNet_ETRANSPORT_CLOSED;
			break;
		}
		case XPSession::kXPSession_ETRANSPORT_ERROR:
		{
			return ReplicaNet::kReplicaNet_ETRANSPORT_ERROR;
			break;
		}
		case XPSession::kXPSession_EOK:
		{
			return ReplicaNet::kReplicaNet_EOK;
			break;
		}
	}

	// Should never get here
	return ReplicaNet::kReplicaNet_EERROR;
}


void ReplicaNetPrivate::SetOnSessionError(const ReplicaNet::OnError whatToDo)
{
	mOnSessionErrorMigrateObjects = whatToDo;
}

ReplicaNet::OnError ReplicaNetPrivate::GetOnSessionErrorMigrateObjects(void)
{
	return mOnSessionErrorMigrateObjects;
}

void ReplicaNetPrivate::SetCanAcceptObjects(bool accept)
{
	mCanAcceptObjects = accept;
}

bool ReplicaNetPrivate::GetCanAcceptObjects(void)
{
	return mCanAcceptObjects;
}

void ReplicaNetPrivate::SetManualPollXPSession(void)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	mSession->SetManualPoll();
}

void ReplicaNetPrivate::SetAutomaticPollXPSession(void)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	mSession->SetAutomaticPoll();
}

void ReplicaNetPrivate::SetManualPollXPURL(void)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	mSession->SetManualPollXPURL();
}

void ReplicaNetPrivate::SetAutomaticPollXPURL(void)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	mSession->SetAutomaticPollXPURL();
}

void ReplicaNetPrivate::SetEncryption(const bool enable)
{
	mEncryptionOn = enable;
}

bool ReplicaNetPrivate::GetEncryption(void)
{
	return mEncryptionOn;
}

void ReplicaNetPrivate::SetLoadBalancing(const bool enable)
{
	mEnableLoadBalancing = enable;
}

bool ReplicaNetPrivate::GetLoadBalancing(void)
{
	return mEnableLoadBalancing;
}

void ReplicaNetPrivate::SetMaximumLoad(float load)
{
	THREADSAFELOCK();

	if (load != mMaximumLoad)
	{
		mMaximumLoad = load;
		mMaximumLoadChanged = true;
	}
}

float ReplicaNetPrivate::GetMaximumLoad(int sessionID)
{
	THREADSAFELOCK();

	if (sessionID == kXPSessionUnknownID || mSessionID == sessionID)
	{
		return mMaximumLoad;
	}

	std::map<int,SessionData>::iterator found;
	found = mKnownSessions.find(sessionID);
	if (found != mKnownSessions.end())
	{
		SessionData *sessid = &((*found).second);
		assert(sessid->mSessionID == sessionID);
		return sessid->mMaximumLoad;
	}

	return -1.0f;
}

void ReplicaNetPrivate::LoadChangedForObject(ReplicaObject *object,float previousLoad,float newLoad)
{
	THREADSAFELOCK();

	if (object->GetSessionID() == mSessionID && object->mObjectHasBeenAdded)
	{
		mTotalLoad -= previousLoad;
		mTotalLoad += newLoad;
		mTotalLoadChanged = true;
	}
}

float ReplicaNetPrivate::GetTotalLoad(int sessionID)
{
	THREADSAFELOCK();

	if (sessionID == kXPSessionUnknownID || mSessionID == sessionID)
	{
		return mTotalLoad;
	}

	
	std::map<int,SessionData>::iterator found;
	found = mKnownSessions.find(sessionID);
	if (found != mKnownSessions.end())
	{
		SessionData *sessid = &((*found).second);
		assert(sessid->mSessionID == sessionID);
		return sessid->mTotalLoad;
	}

	return -1.0f;
}

void ReplicaNetPrivate::HandleLoadBalancing(void)
{
	THREADSAFELOCK();

	if (!mEnableLoadBalancing)
	{
		return;
	}

	std::vector<int> loadBalancedSessionsThatCanAcceptObjects;
	std::vector<float> loadBalancedSessionsThatCanAcceptObjectsScore;
	std::vector<std::map<int,SessionData>::iterator> loadBalancedSessionsThatCanAcceptObjectsIterator;
	std::vector<int> loadBalancedSessions;
	std::map<int,SessionData>::iterator st,en;

	// Go through the list of known sessions and add their ID to the lists based on if they can accept objects and are load balanced
	st = mKnownSessions.begin();
	en = mKnownSessions.end();
	while (st != en)
	{
		SessionData *sessid = &((*st).second);
		if (sessid->mIsLoadBalanced && sessid->mCanAcceptObjects)
		{
			loadBalancedSessionsThatCanAcceptObjects.push_back(sessid->mSessionID);
			loadBalancedSessionsThatCanAcceptObjectsScore.push_back(sessid->mTotalLoad);
			loadBalancedSessionsThatCanAcceptObjectsIterator.push_back(st);
		}
		if (sessid->mIsLoadBalanced)
		{
			loadBalancedSessions.push_back(sessid->mSessionID);
		}
		st++;
	}

	// If the total load has changed then send out messages to other load balanced sessions
	if (mTotalLoadChanged)
	{
#ifdef DEBUG_PRINTS1
		dprintf("ReplicaNet : mTotalLoadChanged So Sending mTotalLoad of %f to ",mTotalLoad);
#endif
		char tempbuff[32];
		MessageHelper message;
		message.SetBuffer(tempbuff);
		RepnetMessage repnetmess = kReplicaNetMessage_MyTotalLoadIs;
		MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
		message.AddFloat(mTotalLoad);
		int i;
		for (i=0;i<(int)loadBalancedSessions.size();i++)
		{
			// Sent with the reliable method
			RecordCheckDataSendToSession(loadBalancedSessions[i],tempbuff,message.GetSize(),true);
#ifdef DEBUG_PRINTS1
			dprintf("%d , ",loadBalancedSessions[i]);
#endif
		}
		mTotalLoadChanged = false;

#ifdef DEBUG_PRINTS1
		dprintf("\n");
#endif
	}

	// If the maximum load has changed then send out messages to other load balanced sessions
	if (mMaximumLoadChanged)
	{
#ifdef DEBUG_PRINTS1
		dprintf("ReplicaNet : mMaximumLoadChanged So Sending mMaximumLoad to ");
#endif
		char tempbuff[32];
		MessageHelper message;
		message.SetBuffer(tempbuff);
		RepnetMessage repnetmess = kReplicaNetMessage_MyMaximumLoadIs;
		MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
		message.AddFloat(mMaximumLoad);
		int i;
		for (i=0;i<(int)loadBalancedSessions.size();i++)
		{
			// Sent with the reliable method
			RecordCheckDataSendToSession(loadBalancedSessions[i],tempbuff,message.GetSize(),true);
#ifdef DEBUG_PRINTS1
			dprintf("%d , ",loadBalancedSessions[i]);
#endif
		}
		mMaximumLoadChanged = false;
#ifdef DEBUG_PRINTS1
		dprintf("\n");
#endif
	}

	// We this session is not over loaded then do nothing so far
	if (mTotalLoad <= mMaximumLoad || loadBalancedSessionsThatCanAcceptObjects.size() <= 0)
	{
		return;
	}

#ifdef DEBUG_PRINTS1
	dprintf("ReplicaNet : mTotalLoad (%f) > mMaximumLoad (%f) So doing load balance\n",mTotalLoad,mMaximumLoad);
#endif

#ifdef DEBUG_PRINTS1
	int i;
	for (i=0;i<(int)loadBalancedSessionsThatCanAcceptObjects.size();i++)
	{
		dprintf("RepliceNet : PotSess %d Load %f\n",loadBalancedSessionsThatCanAcceptObjects[i],loadBalancedSessionsThatCanAcceptObjectsScore[i]);
	}
#endif

	// While the session is over loaded then see if we can migrate objects to other sessions with lower loads
	while (mTotalLoad > mMaximumLoad)
	{
		// Find objects that we can move to reduce our load balance score
		mMasterList.BeginIterate();

		bool moved = false;

		ReplicaObject *object = mMasterList.Iterate();
		while(object != NULL)
		{
			// Only test objects that allow migration etc
			if (object->ApproveMigration() && object->GetLoadBalancing() && object != mObserver)
			{
				// And only pass objects that have a load score and are not being potentially moved to other sessions
				if (object->GetLoadScore() > 0.0f && object->mTryingToGiveTo == kXPSessionUnknownID)
				{
					// Search for a low load session
					size_t count = loadBalancedSessionsThatCanAcceptObjects.size();
					while (count)
					{
						int potentialindex = mObjectsBalaned++;
						potentialindex = potentialindex % loadBalancedSessionsThatCanAcceptObjects.size();
						if (potentialindex >= (int)loadBalancedSessionsThatCanAcceptObjects.size())
						{
							potentialindex = 0;
						}
						SessionData *sessid = &((*loadBalancedSessionsThatCanAcceptObjectsIterator[potentialindex]).second);
						if (sessid->mTotalLoad+object->GetLoadScore() <= sessid->mMaximumLoad)
						{
							// Try to migrate the object to the session that was found
#ifdef DEBUG_PRINTS1
	dprintf("ReplicaNet : Moving object %d,%d  with load %f to sessid %d\n",object->GetSessionID(),object->GetUniqueID(),object->GetLoadScore(),loadBalancedSessionsThatCanAcceptObjects[potentialindex]);
#endif

							object->GiveOwnership(loadBalancedSessionsThatCanAcceptObjects[potentialindex]);
							mTotalLoad -= object->GetLoadScore();
							loadBalancedSessionsThatCanAcceptObjectsScore[potentialindex] += object->GetLoadScore();
							SessionData *sessid = &((*loadBalancedSessionsThatCanAcceptObjectsIterator[potentialindex]).second);
							sessid->mTotalLoad += object->GetLoadScore();
							moved = true;
							break;
						}
						count--;
					}
				}
			}
			if (moved)
			{
				break;
			}

			object = mMasterList.Iterate();
		}

		// Early out from the tests
		if (!moved || loadBalancedSessionsThatCanAcceptObjects.size() <= 0)
		{
			break;
		}
	}
	
}


void ReplicaNetPrivate::ObjectListBeginIterate(void)
{
	THREADSAFELOCK();

	LockObjects();

	mAllKnown.BeginIterate();
}

void ReplicaNetPrivate::ObjectListFinishIterate(void)
{
	THREADSAFELOCK();

	UnLockObjects();
}

ReplicaObject *ReplicaNetPrivate::ObjectListIterate(void)
{
	THREADSAFELOCK();

	ReplicaObject *ret = mAllKnown.Iterate();

	return ret;
}

ReplicaObject *ReplicaNetPrivate::ObjectListFind(const int sessionID,const int uniqueID)
{
	THREADSAFELOCK();
	SessionUnique id(sessionID,uniqueID);
	ReplicaObject *ret = mAllKnown.FindItemNoIterator(id);
	return ret;
}

void ReplicaNetPrivate::SetPollLayerBelow(bool enable)
{
	if (PlatformInfo::IsThreaded())
	{
		mPollLayerBelow = enable;
	}
	else
	{
		mPollLayerBelow = true;
	}
}

bool ReplicaNetPrivate::GetPollLayerBelow(void)
{
	return mPollLayerBelow;
}

void ReplicaNetPrivate::SetPollLayerBelowForXPSession(bool enable)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	mSession->SetPollLayerBelow(enable);
}

bool ReplicaNetPrivate::GetPollLayerBelowForXPSession(void)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	return mSession->GetPollLayerBelow();
}

typedef void func(ReplicaNet *repNet);

void *_gReplicaNet_PreRegisterReplicasFunc = 0;

#ifdef __GNUC__
__extension__
#endif

void ReplicaNet::PreRegisterReplicas(void)
{
	if (mPrivateReplicaNet->mPreRegisterReplicasDone)
	{
		return;
	}
	mPrivateReplicaNet->mPreRegisterReplicasDone = true;
#ifndef REPLICANET_NO_REPLICA_OBJECTS
	_gReplicaNet_PreRegisterReplicasFunc = reinterpret_cast<void *>(&_ReplicaNetPreRegisterReplicasFunc);
#endif

	assert(_gReplicaNet_PreRegisterReplicasFunc && "_gReplicaNet_PreRegisterReplicasFunc must be set before any instances of ReplicaNet are created.");

	// Call the function pointer that was set to register the classIDs
	if (_gReplicaNet_PreRegisterReplicasFunc)
	{
		(*(reinterpret_cast<func*>(_gReplicaNet_PreRegisterReplicasFunc)))(this);
	}
}


void ReplicaNetPrivate::HandlePostObjectCreate(ReplicaObject *object)
{
	// mPostObjectCreateDone is initially false, after a ReplicaObject is created it needs to send a PostObjectCreate() call to let the user know the object has been created.
	if (object->mPostObjectCreateDone)
	{
		return;
	}

	object->mPostObjectCreateDone = true;

	DataBlockReason reason;
	reason.mReasonCode = kDataBlockReason_AfterDataBlocksReceived;
	reason.mFloatTime = mParentReplicaNet->GetTime();
	reason.mFloatLocalTime = mParentReplicaNet->GetLocalTime();
	int i;
	for (i=0;i<(int)object->mDataBlocks.size();i++)
	{
		object->mDataBlocks[i]->Poll(&reason);
	}

#ifdef DEBUG_PRINTS1
	dprintf("Doing HandlePostObjectCreate() for obj:%d sessid:%d\n",object->GetUniqueID(),object->GetSessionID());
#endif

	// However if the object is a reflection object and the sessionID is this session...
	// Then before the post object creation call ReplicaNet needs to add all the remaining known sessions for the DataBlocks
	if (object->mReflectSessionID != kReplicaObjectUnknownUniqueID)
	{
		if (object->mReflectSessionID == mSessionID)
		{
#ifdef DEBUG_PRINTS1
			dprintf("Do the reflection master add calculation for our datablocks (kDataBlockReason_CalculateMasterPoll)\n");
#endif
			// Do the master add calculation for our datablocks
			DataBlockReason reason;
			reason.mReasonCode = kDataBlockReason_CalculateMasterPoll;
			reason.mFloatTime = mParentReplicaNet->GetTime();
			reason.mFloatLocalTime = mParentReplicaNet->GetLocalTime();
			reason.mSessionReference = mSessionID;
			for (i=0;i<(int)object->mDataBlocks.size();i++)
			{
				object->mDataBlocks[i]->Poll(&reason);
			}
			object->mMasterOrReplicaDataBlockPollDone = true;

#ifdef DEBUG_PRINTS1
			dprintf("Do the DoReflectCreateClassMessage() for known sessions\n");
#endif
			std::map<int,SessionData>::iterator st,en;
			st = mKnownSessions.begin();
			en = mKnownSessions.end();
			while (st != en)
			{
				SessionData &sessid = (*st++).second;
				if (sessid.mSessionID != object->mSessionID)
				{
					DoReflectCreateClassMessage(sessid.mSessionID,object);
				}
			}
		}
	}

	object->PostObjectCreate();
}


// TODO: Hmm split this up in to smaller functions at some point soon as it really is getting quite large
void ReplicaNetPrivate::HandleSessionMessages(void)
{
	if (!mSession && !mIsPlayback)
	{
		return;
	}
	/* Get the data blocks for this session */
	int sessionid,length;
	SetBufferSize(2048);

	unsigned char packetType;

	while(RecordCheckDataReceive(&sessionid,&length,&packetType))
	{
#ifdef DEBUG_PRINTS2
		dprintf("ReplicaNet: Got a packet %d from %d of length %d\n",blah++,sessionid,length);
#endif
		// If we are recording the store out all incoming packets
		if (mIsRecording)
		{
			RecordDataPacket(sessionid,kReplicaNetUnknownUniqueID,(char *) GetBuffer(),length,packetType);
		}

		SetSize(0);
		while (GetSize() < length)
		{
			RepnetMessage repnetmess;
			MESSAGEHELPER_GETVARIABLE(repnetmess);

#ifdef DEBUG_PRINTS2
			dprintf("ReplicaNet: Packet id type %d when len = %d\n",repnetmess,length);
#endif

			switch(repnetmess)
			{
				case kReplicaNetMessage_ClassData:
				{
					MessageClassData(sessionid,length);
					break;
				}

				case kReplicaNetMessage_NoClassData:
				{
					MessageNoClassData(sessionid);
					break;
				}

				case kReplicaNetMessage_ReflectClassData:
				{
					MessageReflectClassData(sessionid,length);
					break;
				}

				case kReplicaNetMessage_MasterCallbackClassData:
				{
					MessageMasterCallbackClassData(sessionid,length);
					break;
				}

				case kReplicaNetMessage_CreateClass:
				{
					MessageCreateClass(sessionid,length);
					break;
				}

				case kReplicaNetMessage_CreateClassReflect:
				{
					MessageCreateClassReflect(sessionid,length);
					break;
				}

				case kReplicaNetMessage_DeleteClass:
				{
					MessageDeleteClass(sessionid,length);
					break;
				}

				case kReplicaNetMessage_ReflectDeleteClass:
				{
					MessageReflectDeleteClass(sessionid,length);
					break;
				}

				case kReplicaNetMessage_UnpublishClass:
				{
					MessageUnpublishClass(sessionid,length);
					break;
				}

				case kReplicaNetMessage_ReflectUnpublishClass:
				{
					MessageReflectUnpublishClass(sessionid,length);
					break;
				}

				case kReplicaNetMessage_IsLoadBalanced:
				{
					MessageIsLoadBalanced(sessionid,length);
					break;
				}

				case kReplicaNetMessage_MyMaximumLoadIs:
				{
					MessageMyMaximumLoadIs(sessionid,length);
					break;
				}

				case kReplicaNetMessage_MyTotalLoadIs:
				{
					MessageMyTotalLoadIs(sessionid,length);
					break;
				}

				case kReplicaNetMessage_NotLoadBalanced:
				{
					MessageNotLoadBalanced(sessionid,length);
					break;
				}

				case kReplicaNetMessage_CanAcceptObjects:
				{
					MessageCanAcceptObjects(sessionid,length);
					break;
				}

				case kReplicaNetMessage_CanNotAcceptObjects:
				{
					MessageCanNotAcceptObjects(sessionid,length);
					break;
				}

				case kReplicaNetMessage_SetObserver:
				{
					MessageSetObserver(sessionid,length);
					break;
				}

				case kReplicaNetMessage_SetNoObserver:
				{
					MessageSetNoObserver(sessionid,length);
					break;
				}

				case kReplicaNetMessage_InitDoneSendState:
				{
					MessageInitDoneSendState(sessionid);
					break;
				}

				case kReplicaNetMessage_TakeOverObject:
				{
					MessageTakeOverObject(sessionid,length);
					break;
				}

				case kReplicaNetMessage_ObjectTakenOver:
				{
					MessageObjectTakenOver(sessionid,length);
					break;
				}

				case kReplicaNetMessage_RequestTakeOverObject:
				{
					MessageRequestTakeOverObject(sessionid,length);
					break;
				}

				case kReplicaNetMessage_DataPacket:
				{
					MessageDataPacket(sessionid,length,packetType);
					break;
				}

				case kReplicaNetMessage_ReplicaObjectDataPacket:
				{
					MessageReplicaObjectDataPacket(sessionid,length,packetType);
					break;
				}

				case kReplicaNetMessage_RecordingSessionID:
				{
#ifdef DEBUG_PRINTS2
					dprintf("ReplicaNet got a kReplicaNetMessage_RecordingSessionID from %d\n",sessionid);
#endif
					assert(mIsPlayback);
					int temp = GetInteger();
					bool doPromote = false;
					if (temp != mSessionID)
					{
						doPromote = true;
					}
					mSessionID = temp;
					if (doPromote)
					{
						DoPromote();
					}
					break;
				}

				case kReplicaNetMessage_RecordingTimeCodes:
				{
#ifdef DEBUG_PRINTS2
					dprintf("ReplicaNet got a kReplicaNetMessage_RecordingTimeCodes from %d\n",sessionid);
#endif
					assert(mIsPlayback);
					MESSAGEHELPER_GETVARIABLE(mPlaybackLocalTimeOffset);
					MESSAGEHELPER_GETVARIABLE(mPlaybackTimeOffset);
					break;
				}

				default:
				{
#ifdef DEBUG_PRINTS2
					dprintf("ReplicaNet: Unhandled packet type\n");
#endif
					assert(0 && "ReplicaNet: Not allowed to leave unknown packets types in the queue\n");
					break;
				}
			}
		}
	}

	// Frees the buffer because we are probably done with it until next time and we don't want to have large buffers always allocated.
	SetBufferSize(2048);
}

void ReplicaNetPrivate::ProcessJoiners(void)
{
	int ret;

	/* Only process joiners (and leavers after the messages) if we are part of a proper session */
	if (mSessionID != kXPSessionUnknownID)
	{
		/* Go through the joiners before we parse messages */
		while( (ret=mSession->GetJoiner()) != kXPSessionUnknownID)
		{
#ifdef DEBUG_PRINTS1
			dprintf("ReplicaNet : Session ID %d noticed that sessid %d joined\n",mSessionID,ret);
#endif
			if (mDoRecordingPrep)
			{
				DoRecordingPrep();
			}
			HandleSessionJoin(ret);
		}
	}
}


void ReplicaNetPrivate::HandleSessionChanges(void)
{
	if (!mSession)
	{
		return;
	}
	if (mIsPlayback)
	{
		return;
	}
	/* If the session number changes, when we join a session for example, then we do two things... */
	if (mSession->GetSessionID() != mSessionID)
	{
		mSessionID = mSession->GetSessionID();

		if (mIsRecording)
		{
			char buffer[64];
			MessageHelper message;
			message.SetBuffer(buffer);
			RepnetMessage repnetmess = kReplicaNetMessage_RecordingSessionID;
			MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
			message.AddInteger(mSessionID);
			RecordDataPacket(GetSessionID(),kReplicaNetRecordID,buffer,message.GetSize(),0);
			RecordingDoTimeCodes();
		}

		DoPromote();
		mPreviousIsMaster = mSession->IsMaster();
	}

	// TODO: Implement this for playback?
	// We changed from being a non-master to a master so...
	if (!mPreviousIsMaster && mSession->IsMaster())
	{
#ifdef DEBUG_PRINTS1
		dprintf("ReplicaNet : Poll() : This is the new master session so check the replica list for flagged objects\n");
#endif
		mPreviousIsMaster = true;
		CheckForObjectFaultMigration(true,kXPSessionUnknownID);
	}
}

void ReplicaNetPrivate::RecordingDoTimeCodes(void)
{
	assert(mIsRecording);
	char buffer[64];
	MessageHelper message;
	message.SetBuffer(buffer);
	RepnetMessage repnetmess = kReplicaNetMessage_RecordingTimeCodes;
	MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
	SysTimeType value = mParentReplicaNet->GetLocalTime() - GetRecordingTime();
	message << value;
	value = mParentReplicaNet->GetTime() - GetRecordingTime();
	message << value;
	RecordDataPacket(mParentReplicaNet->GetSessionID(),kReplicaNetRecordID,buffer,message.GetSize(),0);
}

void ReplicaNetPrivate::DoPromote(void)
{
	/* Promote all the master list objects from their old session ID to the new session ID */
	mMasterList.BeginIterate();

	ReplicaObject *object = mMasterList.Iterate();

	while(object != NULL)
	{
		if (object->mSessionID != mSessionID)
		{
			RemoveObjectFromAllLists(object);
			object->mSessionID = mSessionID;
			AddObjectToCorrectLists(object);
			// Remove item advances the iterator, hence the continue.
			continue;
		}

		object = mMasterList.Iterate();
	}

#ifdef _DEBUG
	// This double checks to see if we have missed any objects.
	// It should *never* happen.
	mMasterList.BeginIterate();

	object = mMasterList.Iterate();

	while(object != NULL)
	{
		assert(object->mSessionID == mSessionID);
		object = mMasterList.Iterate();
	}
#endif

	// If we playback a file then we promote all objects that have a session ID equal to the initial playback session ID
	if (mIsPlayback)
	{
		mAllKnown.BeginIterate();

		ReplicaObject *object = mAllKnown.Iterate();

		while(object != NULL)
		{
			if (object->GetSessionID() == mPlaybackSessionID)
			{
				RemoveObjectFromAllLists(object);
				object->mSessionID = mSessionID;
				AddObjectToCorrectLists(object);
				// Remove item advances the iterator, hence the continue.
				continue;
			}

			object = mAllKnown.Iterate();
		}
	}
}

void ReplicaNetPrivate::HandleSessionErrors(void)
{
	// A fatal session error happened so kill all known sessions and check faults on replica objects
	if (mSession->GetStatus() != XPSession::kXPSession_EERROR)
	{
		return;
	}

	// Erase this session from our internal lists
	// Tell all the objects that the session has left
	std::map<int,SessionData>::iterator st,en;//,next;
	st = mKnownSessions.begin();
	en = mKnownSessions.end();
	while (st != en)
	{
		SessionData *sessid = &((*st).second);
		int ret = sessid->mSessionID;

// TODO: Tidy this block in to the leaver code
		ReplicaObject *object;

		mMasterList.BeginIterate();
		
		while ( (object = mMasterList.Iterate()) )
		{
			DataBlockReason reason;
			reason.mReasonCode = kDataBlockReason_SomeoneLeft;
			reason.mSessionReference = ret;
			int i;
			for (i=0;i<(int)object->mDataBlocks.size();i++)
			{
				object->mDataBlocks[i]->Poll(&reason);
			}
		}

		st++;
	}
	// Now clear all the known sessions
	mKnownSessions.clear();

	// Migrate all objects
	if ((mOnSessionErrorMigrateObjects == ReplicaNet::kMigrateObjects) || (mOnSessionErrorMigrateObjects == ReplicaNet::kMigrateObjectsToNewMaster))
	{
		mReplicaList.BeginIterate();
		ReplicaObject *object;
		while ( (object = mReplicaList.Iterate()) )
		{
			// If the object approves a fault then continue and wait around a bit for a new master to be decided on
			if (object->ApproveFault())
			{
				TakeOverObject(object);
			}
			else
			{
				DoObjectDelete(object);
				continue;
			}
		}
	}
	else if (mOnSessionErrorMigrateObjects == ReplicaNet::kDeleteObjects)
	{
		mReplicaList.BeginIterate();
		ReplicaObject *object;
		while ( (object = mReplicaList.Iterate()) )
		{
			DoObjectDelete(object);
			continue;
		}
	}
	else
	{
		// Can only be leave them left...
		mReplicaList.BeginIterate();
		ReplicaObject *object;
		while ( (object = mReplicaList.Iterate()) )
		{
			object->mFlagForLaterMigration = true;
		}
	}
}

void ReplicaNetPrivate::HandleSessionLeavers(void)
{
	int ret;
	/* Now go through the leavers this iteration */
	/* If a session leaves then check all objects from the session that belong to the session id for fault migration */
	while( (ret=mSession->GetLeaver()) != kXPSessionUnknownID)
	{
#ifdef DEBUG_PRINTS1
		dprintf("ReplicaNet : Session ID %d noticed that sessid %d left\n",mSessionID,ret);
#endif
		// Notify the leaver callback
		mParentReplicaNet->LeaverSessionIDPre(ret);

		std::map<int,SessionData>::iterator found;
		found = mKnownSessions.find(ret);
		if (found != mKnownSessions.end())
		{
			SessionData *sessid = &((*found).second);
			assert(sessid->mSessionID == ret);
			if (sessid->mObserver)
			{
				sessid->mObserver->mObserverFor.erase(ret);
			}

			if (sessid->mObserverPendingSet)
			{
				mObserverPendingForSessionID.erase(sessid->mObserverPending);
			}
		}
		// Erase this session from our internal lists
		mKnownSessions.erase(ret);

		ReplicaObject *object;

		// Do the real masters first
		mMasterList.BeginIterate();
		while ( (object = mMasterList.Iterate()) )
		{
			bool processThis = false;

			// If we are only going to propagate to certain session IDs then we need to double check them
			if (object->mSessionPropagationFilter)
			{
				int sessionID = ret;
#ifdef DEBUG_PRINTS1
				dprintf("ReplicaNet : Master object class id %d session %d uniid %d check propagate remove from sessid %d\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID(),ret);
#endif
				object->Lock();
				// Check the propagate list has the sessionID in it
				if (object->mSessionPropagationFilterIDs.erase(sessionID) > 0)
				{
					processThis = true;
					object->mSessionPropagationFilterDelaySlotRemove.erase(sessionID);
					// Might as well double check the delay slot add also has it removed since it is going to be useless.
					object->mSessionPropagationFilterDelaySlotAdd.erase(sessionID);
				}
				object->UnLock();
			}
			else
			{
				processThis = true;
			}

			if (processThis)
			{
#ifdef DEBUG_PRINTS1
				dprintf("ReplicaNet : Master object class id %d session %d uniid %d do propagate remove from sessid %d\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID(),ret);
#endif
				DataBlockReason reason;
				reason.mReasonCode = kDataBlockReason_SomeoneLeft;
				reason.mSessionReference = ret;
				int i;
				for (i=0;i<(int)object->mDataBlocks.size();i++)
				{
					object->mDataBlocks[i]->Poll(&reason);
				}
				// If the session was the one we were trying to move to then we need to add back on out load balancing score
				if (object->mTryingToGiveTo == ret)
				{
					object->mTryingToGiveTo = kXPSessionUnknownID;
					if (object->GetLoadBalancing())
					{
						mTotalLoad += object->GetLoadScore();
						mTotalLoadChanged = true;
					}
				}
			}
			else
			{
#ifdef DEBUG_PRINTS1
				dprintf("ReplicaNet : Master object class id %d session %d uniid %d do not do propagate remove from sessid %d\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID(),ret);
#endif
			}
		}


		// Do the reflect masters
		mReflectList.BeginIterate();
		while ( (object = mReflectList.Iterate()) )
		{
			bool processThis = false;

			// If we are only going to propagate to certain session IDs then we need to double check them
			if (object->mSessionPropagationFilter)
			{
				int sessionID = ret;
#ifdef DEBUG_PRINTS1
				dprintf("ReplicaNet : Master object class id %d session %d uniid %d check propagate remove from sessid %d\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID(),ret);
#endif
				object->Lock();
				// Check the propagate list has the sessionID in it
				if (object->mSessionPropagationFilterIDs.erase(sessionID) > 0)
				{
					processThis = true;
					object->mSessionPropagationFilterDelaySlotRemove.erase(sessionID);
					object->mSessionPropagationFilterDelaySlotAdd.erase(sessionID);
				}
				object->UnLock();
			}
			else
			{
				processThis = true;
			}

			if (processThis)
			{
#ifdef DEBUG_PRINTS1
				dprintf("ReplicaNet : Master object class id %d session %d uniid %d do propagate remove from sessid %d\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID(),ret);
#endif
				DataBlockReason reason;
				reason.mReasonCode = kDataBlockReason_SomeoneLeft;
				reason.mSessionReference = ret;
				int i;
				for (i=0;i<(int)object->mDataBlocks.size();i++)
				{
					object->mDataBlocks[i]->Poll(&reason);
				}
				// If the session was the one we were trying to move to then we need to add back on out load balancing score
				if (object->mTryingToGiveTo == ret)
				{
					object->mTryingToGiveTo = kXPSessionUnknownID;
					if (object->GetLoadBalancing())
					{
						mTotalLoad += object->GetLoadScore();
						mTotalLoadChanged = true;
					}
				}
			}
			else
			{
#ifdef DEBUG_PRINTS1
				dprintf("ReplicaNet : Master object class id %d session %d uniid %d do not do propagate remove from sessid %d\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID(),ret);
#endif
			}
		}


		CheckForObjectFaultMigration(true,ret);

		// Notify the leaver callback
		mParentReplicaNet->LeaverSessionIDPost(ret);
	}
}

void ReplicaNetPrivate::HandleLoad(const SysTimeType nowtime,const SysTimeType nowlocaltime)
{
	float totalLoad = 0.0f;

	/* Now update the data blocks on our masters */
	mMasterList.BeginIterate();
	ReplicaObject *object;
	while( (object = mMasterList.Iterate()) != 0 )
	{
		if (object->mDelayDelete && (mParentReplicaNet->GetLocalTime() >= object->mDelayDeleteTime))
		{
			DoObjectDelete(object);
			continue;
		}
		if (object->GetLoadBalancing())
		{
			totalLoad += object->GetLoadScore();
		}
	}

	if (totalLoad != mTotalLoad)
	{
		mTotalLoad = totalLoad;
		mTotalLoadChanged = true;
	}
}

void ReplicaNetPrivate::HandleMasterDataBlocks(const SysTimeType nowtime,const SysTimeType nowlocaltime)
{
	/* Now update the data blocks on our masters */
	mMasterList.BeginIterate();
	ReplicaObject *object;
	while( (object = mMasterList.Iterate()) != 0 )
	{
		if (object->mDormantDelayActive && (mParentReplicaNet->GetLocalTime() >= object->mDormantDelayTime))
		{
			object->mDormantDelayActive = false;
			object->UpdateSendDormantDelayStateChange(object->mDormantDelayState);
			object->UpdateSendDormant(object->mDormantDelayState);
		}
		if (object->mDelayDelete && (mParentReplicaNet->GetLocalTime() >= object->mDelayDeleteTime))
		{
			DoObjectDelete(object);
			continue;
		}
		DataBlockReason reason;

		// Do the master calculation for our datablock
		reason.mReasonCode = kDataBlockReason_CalculateMasterPoll;
		reason.mFloatTime = nowtime;
		reason.mFloatLocalTime = nowlocaltime;
		reason.mSessionReference = mSessionID;
		int i;
		for (i=0;i<(int)object->mDataBlocks.size();i++)
		{
			object->mDataBlocks[i]->Poll(&reason);
		}
		object->mMasterOrReplicaDataBlockPollDone = true;


		if (object->mMasterOrReplicaDataBlockPollDone)
		{
			DynamicMessageHelper message;

			if (object->mSessionPropagationFilter)
			{
				// Only propagate to those sessions we are really interested about
				object->Lock();
				// Check the propagate list has the sessionID in it
				std::set<int>::iterator st,en;
				std::map<int,SessionData>::iterator sessFound;

				st = object->mSessionPropagationFilterIDs.begin();
				en = object->mSessionPropagationFilterIDs.end();
				while (st != en)
				{
					sessFound = mKnownSessions.find(*st++);
					if (sessFound != mKnownSessions.end())
					{
						SessionData &sessid = (*sessFound).second;
						// Fill in the reason code and the target session ID
						reason.mReasonCode = kDataBlockReason_NormalPoll;
						reason.mFloatTime = nowtime;
						reason.mFloatLocalTime = nowlocaltime;
						reason.mSessionReference = sessid.mSessionID;
						reason.mObserver = sessid.mObserver;
						message.SetSize(0);

						unsigned int band = 0,nextBand = 0;
						do
						{
							message.SetSize(0);
							band = nextBand;
							if (DoClassDataReliableMessage(band,nextBand,false,object,&message,&reason))
							{
		#ifdef DEBUG_PRINTS2
								dprintf("Sending reliable data block changed packet for sessid%d uniid %d of %d size\n",object->GetSessionID(),object->GetUniqueID(),message.GetSize());
		#endif
								RecordCheckDataSendToSession(reason.mSessionReference,message.GetBuffer(),message.GetSize(),true,false,false,band);
							}
						} while (band != nextBand);


						// Fill in the reason code and the target session ID
						reason.mReasonCode = kDataBlockReason_NormalPoll;
						reason.mFloatTime = nowtime;
						reason.mFloatLocalTime = nowlocaltime;
						reason.mSessionReference = sessid.mSessionID;
						reason.mObserver = sessid.mObserver;
						message.SetSize(0);

						if (DoClassDataCertainMessage(object,&message,&reason))
						{
	#ifdef DEBUG_PRINTS2
							dprintf("Sending certain data block changed packet for sessid%d uniid %d of %d size\n",object->GetSessionID(),object->GetUniqueID(),message.GetSize());
	#endif
							RecordCheckDataSendToSession(reason.mSessionReference,message.GetBuffer(),message.GetSize(),false,true);
						}


						// Fill in the reason code and the target session ID
						reason.mReasonCode = kDataBlockReason_NormalPoll;
						reason.mFloatTime = nowtime;
						reason.mFloatLocalTime = nowlocaltime;
						reason.mSessionReference = sessid.mSessionID;
						reason.mObserver = sessid.mObserver;
						message.SetSize(0);

						band = 0;
						nextBand = 0;
						do
						{
							message.SetSize(0);
							band = nextBand;
							if (DoClassDataOrderedMessage(band,nextBand,false,object,&message,&reason))
							{
#ifdef DEBUG_PRINTS2
								dprintf("Sending ordered data block changed packet for sessid%d uniid %d of %d size\n",object->GetSessionID(),object->GetUniqueID(),message.GetSize());
#endif
								RecordCheckDataSendToSession(reason.mSessionReference,message.GetBuffer(),message.GetSize(),false,false,true,band);
							}
						} while (band != nextBand);


						// Fill in the reason code and the target session ID
						reason.mReasonCode = kDataBlockReason_NormalPoll;
						reason.mFloatTime = nowtime;
						reason.mFloatLocalTime = nowlocaltime;
						reason.mSessionReference = sessid.mSessionID;
						reason.mObserver = sessid.mObserver;
						message.SetSize(0);

						if (DoClassDataMessage(object,&message,&reason))
						{
	#ifdef DEBUG_PRINTS2
							dprintf("Sending data block changed packet for sessid%d uniid %d of %d size\n",object->GetSessionID(),object->GetUniqueID(),message.GetSize());
	#endif
							RecordCheckDataSendToSession(reason.mSessionReference,message.GetBuffer(),message.GetSize(),false);
						}
					}
				}

				object->UnLock();
			}
			else // end else... if (object->mSessionPropagationFilter)
			{
				// Go through the reliable class data
				std::map<int,SessionData>::iterator st,en;
				st = mKnownSessions.begin();
				en = mKnownSessions.end();

				while (st != en)
				{
					// Fill in the reason code and the target session ID
					reason.mReasonCode = kDataBlockReason_NormalPoll;
					reason.mFloatTime = nowtime;
					reason.mFloatLocalTime = nowlocaltime;
					SessionData sessid = (*st++).second;
					reason.mSessionReference = sessid.mSessionID;
					reason.mObserver = sessid.mObserver;
					message.SetSize(0);

					unsigned int band = 0,nextBand = 0;
					do
					{
						message.SetSize(0);
						band = nextBand;
						if (DoClassDataReliableMessage(band,nextBand,false,object,&message,&reason))
						{
		#ifdef DEBUG_PRINTS2
							dprintf("Sending reliable data block changed packet for sessid%d uniid %d of %d size\n",object->GetSessionID(),object->GetUniqueID(),message.GetSize());
		#endif
							RecordCheckDataSendToSession(reason.mSessionReference,message.GetBuffer(),message.GetSize(),true,false,false,band);
						}
					} while (band != nextBand);
				}

				// Go through the certain class data
				st = mKnownSessions.begin();
				en = mKnownSessions.end();

				while (st != en)
				{
					// Fill in the reason code and the target session ID
					reason.mReasonCode = kDataBlockReason_NormalPoll;
					reason.mFloatTime = nowtime;
					reason.mFloatLocalTime = nowlocaltime;
					SessionData sessid = (*st++).second;
					reason.mSessionReference = sessid.mSessionID;
					reason.mObserver = sessid.mObserver;
					message.SetSize(0);

					if (DoClassDataCertainMessage(object,&message,&reason))
					{
	#ifdef DEBUG_PRINTS2
						dprintf("Sending certain data block changed packet for sessid%d uniid %d of %d size\n",object->GetSessionID(),object->GetUniqueID(),message.GetSize());
	#endif
						RecordCheckDataSendToSession(reason.mSessionReference,message.GetBuffer(),message.GetSize(),false,true);
					}
				}

				st = mKnownSessions.begin();
				en = mKnownSessions.end();

				while (st != en)
				{
					// Fill in the reason code and the target session ID
					reason.mReasonCode = kDataBlockReason_NormalPoll;
					reason.mFloatTime = nowtime;
					reason.mFloatLocalTime = nowlocaltime;
					SessionData sessid = (*st++).second;
					reason.mSessionReference = sessid.mSessionID;
					reason.mObserver = sessid.mObserver;
					message.SetSize(0);

					unsigned int band = 0,nextBand = 0;
					do
					{
						message.SetSize(0);
						band = nextBand;
						if (DoClassDataOrderedMessage(band,nextBand,false,object,&message,&reason))
						{
#ifdef DEBUG_PRINTS2
							dprintf("Sending ordered data block changed packet for sessid%d uniid %d of %d size\n",object->GetSessionID(),object->GetUniqueID(),message.GetSize());
#endif
							RecordCheckDataSendToSession(reason.mSessionReference,message.GetBuffer(),message.GetSize(),false,false,true,band);
						}
					} while (band != nextBand);
				}

				// Go through the unreliable class data
				st = mKnownSessions.begin();
				en = mKnownSessions.end();

				while (st != en)
				{
					// Fill in the reason code and the target session ID
					reason.mReasonCode = kDataBlockReason_NormalPoll;
					reason.mFloatTime = nowtime;
					reason.mFloatLocalTime = nowlocaltime;
					SessionData sessid = (*st++).second;
					reason.mSessionReference = sessid.mSessionID;
					reason.mObserver = sessid.mObserver;
					message.SetSize(0);

					if (DoClassDataMessage(object,&message,&reason))
					{
	#ifdef DEBUG_PRINTS2
						dprintf("Sending data block changed packet for sessid%d uniid %d of %d size\n",object->GetSessionID(),object->GetUniqueID(),message.GetSize());
	#endif
						RecordCheckDataSendToSession(reason.mSessionReference,message.GetBuffer(),message.GetSize(),false);
					}
				}
			}
		} // end else... if (object->mSessionPropagationFilter)
	}
}

void ReplicaNetPrivate::HandleReplicaDataBlockPoll(const SysTimeType nowtime,const SysTimeType nowlocaltime)
{
	ReplicaObject *object;
	float deltatime = (float)(nowtime - mPeviousReplicaPollTime);

//	dprintf("nowtime %f previous %f Deltatime %f\n",nowtime,mPeviousReplicaPollTime,deltatime);

	// Sanity check. Shouldn't ever happen but you never know. :)
	if (deltatime <= 0.0f)
	{
		return;
	}
	mPeviousReplicaPollTime = nowtime;

	mReplicaList.BeginIterate();
	while( (object = mReplicaList.Iterate()) != 0 )
	{
		if (object->mDormantDelayActive && (mParentReplicaNet->GetLocalTime() >= object->mDormantDelayTime))
		{
			object->mDormantDelayActive = false;
			object->UpdateSendDormantDelayStateChange(object->mDormantDelayState);
			object->UpdateSendDormant(object->mDormantDelayState);
		}
		if (object->mDelayDelete && (mParentReplicaNet->GetLocalTime() >= object->mDelayDeleteTime))
		{
			DoObjectDelete(object);
			continue;
		}
		int i;
		for (i=0;i<(int)object->mDataBlocks.size();i++)
		{
			/* Now update the data blocks on our replicas */
			DataBlockReason reason;
			reason.mFloatValue = deltatime;
			reason.mFloatTime = nowtime;
			reason.mFloatLocalTime = nowlocaltime;
			reason.mSessionReference = mSessionID;

			// Do the replica calculation for our datablock
			reason.mReasonCode = kDataBlockReason_CalculateReplicaPoll;

			object->mDataBlocks[i]->Poll(&reason);
		}
		object->mMasterOrReplicaDataBlockPollDone = true;
	}

	// If doing a playback, make the masters process the data we might have got during a playback
	if (mIsPlayback)
	{
		mMasterList.BeginIterate();
		while( (object = mMasterList.Iterate()) != 0 )
		{
			if (object->mDelayDelete && (mParentReplicaNet->GetLocalTime() >= object->mDelayDeleteTime))
			{
				DoObjectDelete(object);
				continue;
			}
			int i;
			for (i=0;i<(int)object->mDataBlocks.size();i++)
			{
				/* Now update the data blocks on our replicas */
				DataBlockReason reason;
				reason.mFloatValue = deltatime;
				reason.mFloatTime = nowtime;
				reason.mFloatLocalTime = nowlocaltime;
				reason.mSessionReference = mSessionID;

				// Do the replica calculation for our datablock
				reason.mReasonCode = kDataBlockReason_CalculateReplicaPoll;

				object->mDataBlocks[i]->Poll(&reason);
			}
			object->mMasterOrReplicaDataBlockPollDone = true;
		}
	}
}

void ReplicaNetPrivate::HandleReplicaCallbackPoll(const SysTimeType nowtime,const SysTimeType nowlocaltime)
{
	ReplicaObject *object;

	/* Now do the replica callback polls on each datablock */
	mReplicaList.BeginIterate();
	while( (object = mReplicaList.Iterate()) != 0 )
	{
		if (!object->mPostObjectCreateDone)
		{
#ifdef DEBUG_PRINTS2
			dprintf("mReplicaList.BeginIterate() stage mPostObjectCreateDone\n");
#endif
			HandlePostObjectCreate(object);
		}

		DataBlockReason reason;
		DynamicMessageHelper message;

		// Fill in the reason code and the target session ID
		reason.mReasonCode = kDataBlockReason_ReplicaCallBackPoll;
		reason.mFloatTime = nowtime;
		reason.mFloatLocalTime = nowlocaltime;
		reason.mSessionReference = object->GetSessionID();
		reason.mObserver = 0;
		message.SetSize(0);

		unsigned int band = 0,nextBand = 0;
		do
		{
			message.SetSize(0);
			band = nextBand;
			if (DoClassDataReliableMessage(band,nextBand,false,object,&message,&reason))
			{
	#ifdef DEBUG_PRINTS2
				dprintf("Sending reliable replica callback data block changed packet for sessid%d uniid %d of %d size\n",object->GetSessionID(),object->GetUniqueID(),message.GetSize());
	#endif
				RecordCheckDataSendToSession(reason.mSessionReference,message.GetBuffer(),message.GetSize(),true,false,false,band);
			}
		} while (band != nextBand);

		// Fill in the reason code and the target session ID
		reason.mReasonCode = kDataBlockReason_ReplicaCallBackPoll;
		reason.mFloatTime = nowtime;
		reason.mFloatLocalTime = nowlocaltime;
		reason.mSessionReference = object->GetSessionID();
		reason.mObserver = 0;
		message.SetSize(0);

		if (DoClassDataCertainMessage(object,&message,&reason))
		{
#ifdef DEBUG_PRINTS2
			dprintf("Sending certain replica callback data block changed packet for sessid%d uniid %d of %d size\n",object->GetSessionID(),object->GetUniqueID(),message.GetSize());
#endif
			RecordCheckDataSendToSession(reason.mSessionReference,message.GetBuffer(),message.GetSize(),false,true);
		}

		// Fill in the reason code and the target session ID
		reason.mReasonCode = kDataBlockReason_ReplicaCallBackPoll;
		reason.mFloatTime = nowtime;
		reason.mFloatLocalTime = nowlocaltime;
		reason.mSessionReference = object->GetSessionID();
		reason.mObserver = 0;
		message.SetSize(0);

		band = 0;
		nextBand = 0;
		do
		{
			message.SetSize(0);
			band = nextBand;
			if (DoClassDataOrderedMessage(band,nextBand,false,object,&message,&reason))
			{
#ifdef DEBUG_PRINTS2
				dprintf("Sending ordered replica callback data block changed packet for sessid%d uniid %d of %d size\n",object->GetSessionID(),object->GetUniqueID(),message.GetSize());
#endif
				RecordCheckDataSendToSession(reason.mSessionReference,message.GetBuffer(),message.GetSize(),false,false,true,band);
			}
		} while (band != nextBand);

		// Fill in the reason code and the target session ID
		reason.mReasonCode = kDataBlockReason_ReplicaCallBackPoll;
		reason.mFloatTime = nowtime;
		reason.mFloatLocalTime = nowlocaltime;
		reason.mSessionReference = object->GetSessionID();
		reason.mObserver = 0;
		message.SetSize(0);

		if (DoClassDataMessage(object,&message,&reason))
		{
#ifdef DEBUG_PRINTS2
			dprintf("Sending replica callback data block changed packet for sessid%d uniid %d of %d size\n",object->GetSessionID(),object->GetUniqueID(),message.GetSize());
#endif
			RecordCheckDataSendToSession(reason.mSessionReference,message.GetBuffer(),message.GetSize(),false);
		}
	}
}

void ReplicaNetPrivate::HandleReflectionPoll(const SysTimeType nowtime,const SysTimeType nowlocaltime)
{
	ReplicaObject *object;

	// Reflection poll for data blocks
	/* Now update the data blocks on our reflection objects */
	mReplicaList.BeginIterate();
	while( (object = mReplicaList.Iterate()) != 0 )
	{
		if (object->GetMessageReflectionID() == kReplicaNetUnknownUniqueID)
		{
			continue;
		}
		if (object->GetMessageReflectionID() != mSessionID)
		{
			continue;
		}
		DataBlockReason reason;

		// Do the master reflection calculation for our datablock
		reason.mReasonCode = kDataBlockReason_CalculateMasterPoll;
		reason.mFloatTime = nowtime;
		reason.mFloatLocalTime = nowlocaltime;
		reason.mSessionReference = mSessionID;
		int i;
		for (i=0;i<(int)object->mDataBlocks.size();i++)
		{
			object->mDataBlocks[i]->Poll(&reason);
		}
		object->mMasterOrReplicaDataBlockPollDone = true;

		if (object->mMasterOrReplicaDataBlockPollDone)
		{
			DynamicMessageHelper message;

			// Go through the reliable class data
			std::map<int,SessionData>::iterator st,en;
			st = mKnownSessions.begin();
			en = mKnownSessions.end();

			while (st != en)
			{
				SessionData sessid = (*st++).second;
				if (sessid.mSessionID == object->GetSessionID())
				{
					continue;
				}

				// Fill in the reason code and the target session ID
				reason.mReasonCode = kDataBlockReason_NormalPoll;
				reason.mFloatTime = nowtime;
				reason.mFloatLocalTime = nowlocaltime;
				reason.mSessionReference = sessid.mSessionID;
				reason.mObserver = sessid.mObserver;
				message.SetSize(0);

				unsigned int band = 0,nextBand = 0;
				do
				{
					message.SetSize(0);
					band = nextBand;
					if (DoClassDataReliableMessage(band,nextBand,false,object,&message,&reason))
					{
	#ifdef DEBUG_PRINTS2
						dprintf("Sending reliable data block changed packet for sessid%d uniid %d of %d size\n",object->GetSessionID(),object->GetUniqueID(),message.GetSize());
	#endif
						RecordCheckDataSendToSession(reason.mSessionReference,message.GetBuffer(),message.GetSize(),true,false,false,band);
					}
				} while (band != nextBand);
			}

			// Go through the certain class data
			st = mKnownSessions.begin();
			en = mKnownSessions.end();

			while (st != en)
			{
				SessionData sessid = (*st++).second;
				if (sessid.mSessionID == object->GetSessionID())
				{
					continue;
				}

				// Fill in the reason code and the target session ID
				reason.mReasonCode = kDataBlockReason_NormalPoll;
				reason.mFloatTime = nowtime;
				reason.mFloatLocalTime = nowlocaltime;
				reason.mSessionReference = sessid.mSessionID;
				reason.mObserver = sessid.mObserver;
				message.SetSize(0);

				if (DoClassDataCertainMessage(object,&message,&reason))
				{
#ifdef DEBUG_PRINTS2
					dprintf("Sending certain data block changed packet for sessid%d uniid %d of %d size\n",object->GetSessionID(),object->GetUniqueID(),message.GetSize());
#endif
					RecordCheckDataSendToSession(reason.mSessionReference,message.GetBuffer(),message.GetSize(),false,true);
				}
			}

			// Go through the ordered class data
			st = mKnownSessions.begin();
			en = mKnownSessions.end();

			while (st != en)
			{
				SessionData sessid = (*st++).second;
				if (sessid.mSessionID == object->GetSessionID())
				{
					continue;
				}

				// Fill in the reason code and the target session ID
				reason.mReasonCode = kDataBlockReason_NormalPoll;
				reason.mFloatTime = nowtime;
				reason.mFloatLocalTime = nowlocaltime;
				reason.mSessionReference = sessid.mSessionID;
				reason.mObserver = sessid.mObserver;
				message.SetSize(0);

				unsigned int band = 0,nextBand = 0;
				do
				{
					message.SetSize(0);
					band = nextBand;
					if (DoClassDataOrderedMessage(band,nextBand,false,object,&message,&reason))
					{
#ifdef DEBUG_PRINTS2
						dprintf("Sending ordered data block changed packet for sessid%d uniid %d of %d size\n",object->GetSessionID(),object->GetUniqueID(),message.GetSize());
#endif
						RecordCheckDataSendToSession(reason.mSessionReference,message.GetBuffer(),message.GetSize(),false,false,true,band);
					}
				} while (band != nextBand);
			}

			// Go through the unreliable class data
			st = mKnownSessions.begin();
			en = mKnownSessions.end();

			while (st != en)
			{
				SessionData sessid = (*st++).second;
				if (sessid.mSessionID == object->GetSessionID())
				{
					continue;
				}

				// Fill in the reason code and the target session ID
				reason.mReasonCode = kDataBlockReason_NormalPoll;
				reason.mFloatTime = nowtime;
				reason.mFloatLocalTime = nowlocaltime;
				reason.mSessionReference = sessid.mSessionID;
				reason.mObserver = sessid.mObserver;
				message.SetSize(0);

				if (DoClassDataMessage(object,&message,&reason))
				{
#ifdef DEBUG_PRINTS2
					dprintf("Sending data block changed packet for sessid%d uniid %d of %d size\n",object->GetSessionID(),object->GetUniqueID(),message.GetSize());
#endif
					RecordCheckDataSendToSession(reason.mSessionReference,message.GetBuffer(),message.GetSize(),false);
				}
			}
		} // if (object->mMasterOrReplicaDataBlockPollDone)
	}
// End reflection poll
}

void ReplicaNetPrivate::EnsureSessionAllocated(void)
{
	if (!mSession)
	{
		XPSession *aSession;
		aSession = XPSession::Allocate();
		AttachSession(aSession);
	}

	assert(mSession);
}

// length can be updated by this function
void ReplicaNetPrivate::MessageClassData(const int sessionid,int &length)
{
	// Unset this so we don't try to process anything else involving this pointer later on.
	mLastObjectCreatedbyAClassCreate = 0;
	int dest_id;
	ReplicaObject *object = 0;

	GetVariable(&dest_id,sizeof(dest_id));

#ifdef DEBUG_PRINTS2
	dprintf("Packet ClassData for object ses%d uni%d\n",sessionid,dest_id);
#endif

	if (mIsPlayback)
	{
		// The object could be anywhere...
		object = mAllKnown.FindItem(SessionUnique(sessionid,dest_id));
	}
	else
	{
		/* Search the replicas until we get a perfect match with unique and session IDs */
		object = mReplicaList.FindItem(SessionUnique(sessionid,dest_id));
	}

	// If the replica object isn't found then we ignore the whole packet by setting the length to 0
	if (!object)
	{
#ifdef DEBUG_PRINTS2
		dprintf("Packet ClassData ignored packet as object is not alive\n");
#endif
		length = 0;
		return;
	}

	MessageClassDataCommon(sessionid,length,object);

	// Class data got, so do a post object create check
	HandlePostObjectCreate(object);
}

// length can be updated by this function
void ReplicaNetPrivate::MessageReflectClassData(const int sessionid,int &length)
{
	// Unset this so we don't try to process anything else involving this pointer later on.
	mLastObjectCreatedbyAClassCreate = 0;
	int dest_id;
	ReplicaObject *object = 0,*search;

	GetVariable(&dest_id,sizeof(dest_id));

#ifdef DEBUG_PRINTS2
	dprintf("Packet ClassData for object ses%d uni%d\n",sessionid,dest_id);
#endif

	/* Search the replicas until we get a perfect match with unique and reflect session IDs */
	mReplicaList.BeginIterate();
	while ( (search = mReplicaList.Iterate()) != 0)
	{
		if ((search->GetUniqueID() == dest_id) && (search->mReflectSessionID == sessionid))
		{
			object = search;
			break;
		}
	}

	// If the replica object isn't found then we ignore the packet
	if (!object)
	{
#ifdef DEBUG_PRINTS2
		dprintf("Packet MessageReflectClassData ignored packet as object is not alive\n");
#endif
		length = 0;
		return;
	}

	MessageClassDataCommon(sessionid,length,object);

	// Class data got, so do a post object create check
	HandlePostObjectCreate(object);
}

// length can be updated by this function
void ReplicaNetPrivate::MessageMasterCallbackClassData(const int sessionid,int &length)
{
	int dest_id;
	ReplicaObject *object = 0;

	GetVariable(&dest_id,sizeof(dest_id));

#ifdef DEBUG_PRINTS2
	dprintf("Packet MasterCallbackClassData for object ses%d uni%d\n",mSessionID,dest_id);
#endif

	/* Search the masters until we get a perfect match with unique and session IDs */
	object = mMasterList.FindItem(SessionUnique(mSessionID,dest_id));

	// If the master replica object isn't found then we ignore the packet
	if (!object)
	{
#ifdef DEBUG_PRINTS2
		dprintf("Packet MasterCallbackClassData ignored packet as object is not alive\n");
#endif
		length = 0;
		return;
	}

	MessageClassDataCommon(sessionid,length,object);
}

void ReplicaNetPrivate::MessageClassDataCommon(const int sessionid,int &length, ReplicaObject *object)
{
	object->mProcessingDataBlocksFromSessionID = sessionid;

	while (GetSize() < length)
	{
		short mID;
		MESSAGEHELPER_GETVARIABLE(mID);
		assert ((mID >= 0) && (mID < (int) object->mDataBlocks.size()) && "DataBlock mID is out of range");

		if ((mID >= 0) && mID < (int) object->mDataBlocks.size())
		{
			// Send the callback
			object->DataBlockPacketDataReceived(object->mDataBlocks[mID]);

			object->mDataBlocks[mID]->ShouldDiscard(this);
			object->mDataBlocks[mID]->ParseMessage(this);

			object->DataBlockPacketDataReceivedPost(object->mDataBlocks[mID]);
		}
	}

	object->mProcessingDataBlocksFromSessionID = kXPSessionUnknownID;
}


void ReplicaNetPrivate::MessageNoClassData(const int sessionid)
{
#ifdef DEBUG_PRINTS2
	dprintf("Packet NoClassData for object ses%d\n",sessionid);
#endif

	if (mLastObjectCreatedbyAClassCreate)
	{
		// No class data got, so do a post object create check
		HandlePostObjectCreate(mLastObjectCreatedbyAClassCreate);
	}
	// Unset this so we don't try to process anything else involving this pointer later on.
	mLastObjectCreatedbyAClassCreate = 0;
}

void ReplicaNetPrivate::MessageCreateClass(const int sessionid,const int length)
{
	int temp;
	MESSAGEHELPER_GETVARIABLE(temp);
	int temp2;
	MESSAGEHELPER_GETVARIABLE(temp2);

#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a CreateClass from sessid %d of classid %d, uniqueid %d\n",sessionid,temp,temp2);
#endif

	ReplicaObject *object;

#ifdef _DEBUG
	if (!mIsPlayback && sessionid != kReplicaNetRecordID)
	{
		if (mAllKnown.FindItem(SessionUnique(sessionid,temp2)))
		{
			assert(0 && "Something really bad happened as we have duplicate object messages being received\n");
			exit(-1);
		}
	}					
#endif


	object = AllocateReplicaObject(temp,sessionid,temp2);
	if (object != NULL)
	{
		AddObject(object);
	}
	mLastObjectCreatedbyAClassCreate = object;
}

void ReplicaNetPrivate::MessageCreateClassReflect(const int sessionid,const int length)
{
	int realSessID;
	MESSAGEHELPER_GETVARIABLE(realSessID);
	int temp;
	MESSAGEHELPER_GETVARIABLE(temp);
	int temp2;
	MESSAGEHELPER_GETVARIABLE(temp2);
	int temp3;
	MESSAGEHELPER_GETVARIABLE(temp3);

#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a CreateClassReflect from sessid %d for objsessid %d of classid %d, uniqueid %d to sessid %d\n",sessionid,realSessID,temp,temp2,temp3);
#endif

	ReplicaObject *object;

#ifdef _DEBUG
	if (mAllKnown.FindItem(SessionUnique(realSessID,temp2)))
	{
		assert(0 && "Something really bad happened as we have duplicate object messages being received\n");
		exit(-1);
	}
#endif


	object = AllocateReplicaObject(temp,realSessID,temp2,temp3);
	if (object != NULL)
	{
		AddObject(object);
	}
	mLastObjectCreatedbyAClassCreate = object;
}

// length can be updated by this function
void ReplicaNetPrivate::MessageDeleteClass(const int sessionid,int &length)
{
#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a DeleteClass from %d\n",sessionid);
#endif
	int dest_id;
	ReplicaObject *object = 0;

	GetVariable(&dest_id,sizeof(dest_id));

	if (mIsPlayback)
	{
		/* Search the masters until we get a perfect match with unique and session IDs */
		// It could be anywhere... Like the replica list...
		object = mAllKnown.FindItem(SessionUnique(sessionid,dest_id));
	}
	else
	{
		/* Search the replicas until we get a perfect match with unique and session IDs */
		object = mReplicaList.FindItem(SessionUnique(sessionid,dest_id));
	}

	// If the replica object isn't found then we ignore the packet
	if (!object)
	{
		length = 0;
		return;
	}

	DoObjectDelete(object);
}

// length can be updated by this function
void ReplicaNetPrivate::MessageReflectDeleteClass(const int sessionid,int &length)
{
#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a ReflectDeleteClass from %d\n",sessionid);
#endif
	int dest_id;
	ReplicaObject *object = 0,*search;

	GetVariable(&dest_id,sizeof(dest_id));

	/* Search the replicas until we get a perfect match with unique and session IDs */
	mReplicaList.BeginIterate();
	while ( (search = mReplicaList.Iterate()) != 0)
	{
		if (search->GetUniqueID() == dest_id && search->mReflectSessionID == sessionid)
		{
			object = search;
			break;
		}
	}

	// If the replica object isn't found then we ignore the packet
	if (!object)
	{
		length = 0;
		return;
	}

	DoObjectDelete(object);
}

// length can be updated by this function
void ReplicaNetPrivate::MessageUnpublishClass(const int sessionid,int &length)
{
#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a UnpublishClass from %d\n",sessionid);
#endif
	int dest_id;
	ReplicaObject *object = 0;

	GetVariable(&dest_id,sizeof(dest_id));

	if (mIsPlayback)
	{
		/* Search the masters until we get a perfect match with unique and session IDs */
		// It could be anywhere... Like the replica list...
		object = mAllKnown.FindItem(SessionUnique(sessionid,dest_id));
	}
	else
	{
		/* Search the replicas until we get a perfect match with unique and session IDs */
		object = mReplicaList.FindItem(SessionUnique(sessionid,dest_id));
	}

	// If the replica object isn't found then we ignore the packet
	if (!object)
	{
		length = 0;
		return;
	}

	RemoveObject(object,false);
}

// length can be updated by this function
void ReplicaNetPrivate::MessageReflectUnpublishClass(const int sessionid,int &length)
{
#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a ReflectUnpublishClass from %d\n",sessionid);
#endif
	int dest_id;
	ReplicaObject *object = 0,*search;

	GetVariable(&dest_id,sizeof(dest_id));

	/* Search the replicas until we get a perfect match with unique and session IDs */
	mReplicaList.BeginIterate();
	while ( (search = mReplicaList.Iterate()) != 0)
	{
		if (search->GetUniqueID() == dest_id && search->mReflectSessionID == sessionid)
		{
			object = search;
			break;
		}
	}

	// If the replica object isn't found then we ignore the packet
	if (!object)
	{
		length = 0;
		return;
	}

	RemoveObject(object,false);
}

void ReplicaNetPrivate::MessageIsLoadBalanced(const int sessionid,const int length)
{
#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a kReplicaNetMessage_IsLoadBalanced from %d\n",sessionid);
#endif
	std::map<int,SessionData>::iterator found;
	found = mKnownSessions.find(sessionid);
	// Search for the session parameter blocks
	if (found != mKnownSessions.end())
	{
		SessionData *sessid = &((*found).second);
		assert(sessid->mSessionID == sessionid);
		// Set the found session parameters as being load balanced
		sessid->mIsLoadBalanced = true;
		return;
	}
#ifdef DEBUG_PRINTS2
	dprintf("WARNING : ReplicaNet kReplicaNetMessage_IsLoadBalanced sessid not found\n");
#endif
}

void ReplicaNetPrivate::MessageMyMaximumLoadIs(const int sessionid,const int length)
{
#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a kReplicaNetMessage_MyMaximumLoadIs from %d\n",sessionid);
#endif
	float loadvalue;
	MESSAGEHELPER_GETVARIABLE(loadvalue);
	std::map<int,SessionData>::iterator found;
	found = mKnownSessions.find(sessionid);
	if (found != mKnownSessions.end())
	{
		SessionData *sessid = &((*found).second);
		assert(sessid->mSessionID == sessionid);
		sessid->mMaximumLoad = loadvalue;
		return;
	}
#ifdef DEBUG_PRINTS2
	dprintf("WARNING : ReplicaNet kReplicaNetMessage_MyMaximumLoadIs sessid not found\n");
#endif
}

void ReplicaNetPrivate::MessageMyTotalLoadIs(const int sessionid,const int length)
{
	float loadvalue;
	MESSAGEHELPER_GETVARIABLE(loadvalue);

#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a kReplicaNetMessage_MyTotalLoadIs of %f from %d\n",loadvalue);
#endif

	std::map<int,SessionData>::iterator found;
	found = mKnownSessions.find(sessionid);
	// Search for the session
	if (found != mKnownSessions.end())
	{
		SessionData *sessid = &((*found).second);
		assert(sessid->mSessionID == sessionid);
		// Update the found session load value
		sessid->mTotalLoad = loadvalue;
		return;
	}
#ifdef DEBUG_PRINTS2
	dprintf("WARNING : ReplicaNet kReplicaNetMessage_MyTotalLoadIs sessid not found\n");
#endif
}

void ReplicaNetPrivate::MessageNotLoadBalanced(const int sessionid,const int length)
{
#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a kReplicaNetMessage_NotLoadBalanced from %d\n",sessionid);
#endif
	std::map<int,SessionData>::iterator found;
	found = mKnownSessions.find(sessionid);
	// Search for the session parameter block
	if (found != mKnownSessions.end())
	{
		SessionData *sessid = &((*found).second);
		assert(sessid->mSessionID == sessionid);
		sessid->mIsLoadBalanced = false;
		return;
	}
#ifdef DEBUG_PRINTS2
	dprintf("WARNING : ReplicaNet kReplicaNetMessage_NotLoadBalanced sessid not found\n");
#endif
}

void ReplicaNetPrivate::MessageCanAcceptObjects(const int sessionid,const int length)
{
#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a CanAcceptObjects from %d\n",sessionid);
#endif
	std::map<int,SessionData>::iterator found;
	found = mKnownSessions.find(sessionid);
	// Search for the session parameter block
	if (found != mKnownSessions.end())
	{
		SessionData *sessid = &((*found).second);
		assert(sessid->mSessionID == sessionid);
		sessid->mCanAcceptObjects = true;
		return;
	}
#ifdef DEBUG_PRINTS2
	dprintf("WARNING : ReplicaNet CanAcceptObjects sessid not found\n");
#endif
}

void ReplicaNetPrivate::MessageCanNotAcceptObjects(const int sessionid,const int length)
{
#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a CanNotAcceptObjects from %d\n",sessionid);
#endif
	std::map<int,SessionData>::iterator found;
	found = mKnownSessions.find(sessionid);
	// Search for the session parameter block
	if (found != mKnownSessions.end())
	{
		SessionData *sessid = &((*found).second);
		assert(sessid->mSessionID == sessionid);
		sessid->mCanAcceptObjects = false;
		return;
	}
#ifdef DEBUG_PRINTS2
	dprintf("WARNING : ReplicaNet CanNotAcceptObjects sessid not found\n");
#endif
}

void ReplicaNetPrivate::MessageSetObserver(const int sessionid,const int length)
{
#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a SetObserver from %d\n",sessionid);
#endif
	SessionData *psessid = 0;
	std::map<int,SessionData>::iterator found;
	found = mKnownSessions.find(sessionid);
	// Search for the session parameter block
	if (found != mKnownSessions.end())
	{
		SessionData *sessid = &((*found).second);
		assert(sessid->mSessionID == sessionid);
		psessid = sessid;
	}

	int dest_sessid;
	int dest_id;
	ReplicaObject *object = 0;

	GetVariable(&dest_sessid,sizeof(dest_sessid));
	GetVariable(&dest_id,sizeof(dest_id));

	if (!psessid)
	{
#ifdef DEBUG_PRINTS2
		dprintf("WARNING : ReplicaNet SetObserver sessid not found\n");
#endif
		return;
	}

	if ( (psessid->mObserverSessionID == dest_sessid) && (psessid->mObserverUniqueID == dest_id) )
	{
#ifdef DEBUG_PRINTS2
		dprintf("SetObserver from %d already set, so don't do anything\n",sessionid);
#endif
		return;
	}

	psessid->mObserverSessionID = dest_sessid;
	psessid->mObserverUniqueID = dest_id;

	/* Search the replicas until we get a perfect match with unique and session IDs */
	if (dest_sessid == GetSessionID())
	{
		object = mMasterList.FindItem(SessionUnique(dest_sessid,dest_id));
	}
	else
	{
		object = mReplicaList.FindItem(SessionUnique(dest_sessid,dest_id));
	}

	if (object)
	{
		if (psessid->mObserver)
		{
			psessid->mObserver->mObserverFor.erase(sessionid);
		}
#ifdef DEBUG_PRINTS2
		dprintf("Acting on incoming network message SetObserver for objid %d as object found\n",dest_id);
#endif
		psessid->mObserver = object;
		object->mObserverFor.insert(sessionid);
	}
	else
	{
		// Remove any old requested one first...
		if (psessid->mObserverPendingSet)
		{
			mObserverPendingForSessionID.erase(psessid->mObserverPending);
		}
		psessid->mObserverPending = mObserverPendingForSessionID.insert(std::pair<SessionUnique,int>(SessionUnique(dest_sessid,dest_id),sessionid));
		psessid->mObserverPendingSet = true;
#ifdef DEBUG_PRINTS2
		dprintf("Adding SetObserver mObserverPendingForSessionID for objid %d as object wasn't found\n",dest_id);
#endif
	}
}

void ReplicaNetPrivate::MessageSetNoObserver(const int sessionid,const int length)
{
#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a SetNoObserver from %d\n",sessionid);
#endif
	SessionData *psessid = 0;
	std::map<int,SessionData>::iterator found;
	found = mKnownSessions.find(sessionid);
	// Search for the session parameter block
	if (found != mKnownSessions.end())
	{
		SessionData *sessid = &((*found).second);
		assert(sessid->mSessionID == sessionid);
		psessid = sessid;

		if (!psessid)
		{
#ifdef DEBUG_PRINTS2
			dprintf("WARNING : ReplicaNet SetObserver sessid not found\n");
#endif
			return;
		}

		if (psessid->mObserverPendingSet)
		{
			mObserverPendingForSessionID.erase(psessid->mObserverPending);
		}
		psessid->mObserverPendingSet = false;

		psessid->mObserverSessionID = kReplicaNetUnknownUniqueID;
		psessid->mObserverUniqueID = kReplicaObjectUnknownUniqueID;

		if (psessid->mObserver)
		{
			psessid->mObserver->mObserverFor.erase(sessionid);
		}
		psessid->mObserver = 0;
#ifdef DEBUG_PRINTS2
		dprintf("ReplicaNet acting on SetNoObserver from %d as sessid was found\n",sessionid);
#endif
	}
}

void ReplicaNetPrivate::MessageTakeOverObject(const int sessionid,const int length)
{
#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a kReplicaNetMessage_TakeOverObject from %d\n",sessionid);
#endif
	int sess_id;
	int dest_id;
	ReplicaObject *object = 0;

	GetVariable(&sess_id,sizeof(sess_id));
	GetVariable(&dest_id,sizeof(dest_id));

#ifdef DEBUG_PRINTS2
	dprintf("   for object ses%d uni%d\n",sess_id,dest_id);
#endif

	/* Search the replicas until we get a perfect match with unique and session IDs */
	object = mReplicaList.FindItem(SessionUnique(sess_id,dest_id));

	// If the replica object isn't found then we ignore the packet
	if (!object)
	{
#ifdef DEBUG_PRINTS2
		dprintf("   packet ignored as stated object is not alive\n");
#endif
		return;
	}

	// Take over the object
	TakeOverObject(object);
}

void ReplicaNetPrivate::MessageObjectTakenOver(const int sessionid,const int length)
{
#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a kReplicaNetMessage_ObjectTakenOver from %d\n",sessionid);
#endif
	int oldsess_id;
	int olddest_id;
	int dest_id;
	ReplicaObject *object = 0;

	GetVariable(&oldsess_id,sizeof(oldsess_id));
	GetVariable(&olddest_id,sizeof(olddest_id));
	GetVariable(&dest_id,sizeof(dest_id));

#ifdef DEBUG_PRINTS2
	dprintf("   for object ses%d uni%d to be sessid %d uni%d\n",oldsess_id,olddest_id,sessionid,dest_id);
#endif

	if (oldsess_id == mSessionID)
	{
		/* Search the masters until we get a perfect match with unique and session IDs */
		object = mMasterList.FindItem(SessionUnique(oldsess_id,olddest_id));
		if (object)
		{
			assert(object->GetUniqueID() == olddest_id && object->GetSessionID() == oldsess_id);
			RemoveObjectFromAllLists(object);
			object->Lock();

			object->mIsMaster = false;

			// Erase this session from our internal lists for the master object
			std::map<int,SessionData>::iterator st,en;
			st = mKnownSessions.begin();
			en = mKnownSessions.end();
			while (st != en)
			{
				SessionData *sessid = &((*st).second);

				DataBlockReason reason;
				reason.mReasonCode = kDataBlockReason_SomeoneLeft;
				reason.mSessionReference = sessid->mSessionID;
				int i;
				for (i=0;i<(int)object->mDataBlocks.size();i++)
				{
					object->mDataBlocks[i]->Poll(&reason);
				}

				st++;
			}

			DataBlockReason reason;
			reason.mReasonCode = kDataBlockReason_ReplicaPrepAfterTakeover;
			reason.mSessionReference = sessionid;	// The new session ID hint
			int i;
			for (i=0;i<(int)object->mDataBlocks.size();i++)
			{
				object->mDataBlocks[i]->OwnerChanged(sessionid);
				object->mDataBlocks[i]->Poll(&reason);
			}
		}
	}
	else
	{
		/* Search the replicas until we get a perfect match with unique and session IDs */
		object = mReplicaList.FindItem(SessionUnique(oldsess_id,olddest_id));
		if (object)
		{
			assert(object->GetUniqueID() == olddest_id && object->GetSessionID() == oldsess_id);
			RemoveObjectFromAllLists(object);
			object->Lock();
		}
	}

	// If the replica object isn't found then we ignore the packet
	if (!object)
	{
#ifdef DEBUG_PRINTS2
		dprintf("   packet ignored as stated object is not alive\n");
#endif
		return;
	}

	object->mSessionID = sessionid;
	object->mUniqueID = dest_id;
	object->SetPropagateToSessionDistanceRecalculationDelay();
	object->mDistanceBasedLastTime = -object->mDistanceBasedPollTime*2;
	object->OwnerChange();
	object->UnLock();

	AddObjectToCorrectLists(object);
}

void ReplicaNetPrivate::MessageRequestTakeOverObject(const int sessionid,const int length)
{
#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a kReplicaNetMessage_RequestTakeOverObject from %d\n",sessionid);
#endif
	int dest_id;
	ReplicaObject *object = 0;

	GetVariable(&dest_id,sizeof(dest_id));

#ifdef DEBUG_PRINTS2
	dprintf("   for master object uni%d\n",dest_id);
#endif

	/* Search the replicas until we get a perfect match with unique and session IDs */
	object = mMasterList.FindItem(SessionUnique(mSessionID,dest_id));
	if (object)
	{
		assert(object->GetUniqueID() == dest_id);
		GiveOwnership(object,sessionid);
		return;
	}

#ifdef DEBUG_PRINTS2
	dprintf("   packet ignored as stated object is not alive\n");
#endif
}

void ReplicaNetPrivate::HandleSessionJoin(const int sessionID)
{
	int ret = sessionID;
	if (sessionID != kReplicaNetRecordID)
	{
		// Notify the joiner callback
		mParentReplicaNet->JoinerSessionIDPre(ret);
	}

	// Add this session ID to our known active sessions list
	mKnownSessions.insert(std::pair<int,SessionData>(ret,SessionData(ret)));

	ReplicaObject *object;

	// First of all process the real master objects
	mMasterList.BeginIterate();
	object = mMasterList.Iterate();
	while(object != NULL)
	{
		/* Tell the joining session that we have objects that need adding now */
#ifdef DEBUG_PRINTS1
		dprintf("ReplicaNet : Master object class id %d session %d uniid %d check propagate to sessid %d\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID(),ret);
#endif
		bool processThis = false;

		// If we are only going to propagate to certain session IDs then we need to double check them
		if (object->mSessionPropagationFilter)
		{
			object->Lock();
			// Check the propagate list has the sessionID in it
			if (object->mSessionPropagationFilterIDs.find(sessionID) != object->mSessionPropagationFilterIDs.end())
			{
				processThis = true;
				object->mSessionPropagationFilterDelaySlotAdd.erase(sessionID);
			}
			object->UnLock();

		}
		else
		{
			processThis = true;
		}

		if (sessionID == kReplicaNetRecordID)
		{
			processThis = true;
		}

		if (processThis)
		{
#ifdef DEBUG_PRINTS1
			dprintf("ReplicaNet : Master object class id %d session %d uniid %d telling sessid %d of new dataset\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID(),ret);
#endif
			if (object->mReflectSessionID == kReplicaNetUnknownUniqueID)
			{
				DoMasterCreateClassMessage(ret,object);
			}
			else
			{
				// Since it is the master object on a join event and we reflect, we only want to send messages to the reflect session
				if (object->mReflectSessionID == ret)
				{
					DoReflectCreateClassMessage(ret,object);
				}
			}
		}
		else
		{
#ifdef DEBUG_PRINTS1
			dprintf("ReplicaNet : Master object class id %d session %d uniid %d not propagate to %d\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID(),ret);
#endif
		}

		object = mMasterList.Iterate();
	}


	// Then process all the reflect objects
	mReflectList.BeginIterate();
	object = mReflectList.Iterate();
	while(object != NULL)
	{
		/* Tell the joining session that we have objects that need adding now */
#ifdef DEBUG_PRINTS1
		dprintf("ReplicaNet : Master object class id %d session %d uniid %d check propagate to sessid %d\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID(),ret);
#endif
		bool processThis = false;

		// If we are only going to propagate to certain session IDs then we need to double check them
		if (object->mSessionPropagationFilter)
		{
			object->Lock();
			// Check the propagate list has the sessionID in it
			if (object->mSessionPropagationFilterIDs.find(sessionID) != object->mSessionPropagationFilterIDs.end())
			{
				processThis = true;
				object->mSessionPropagationFilterDelaySlotAdd.erase(sessionID);
			}
			object->UnLock();

		}
		else
		{
			processThis = true;
		}

		if (processThis)
		{
#ifdef DEBUG_PRINTS1
			dprintf("ReplicaNet : Master object class id %d session %d uniid %d telling sessid %d of new dataset\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID(),ret);
#endif
			// Since we are a reflect master we do not want to send message back to our source session
			if (object->GetSessionID() != ret)
			{
				DoReflectCreateClassMessage(ret,object);
			}
		}
		else
		{
#ifdef DEBUG_PRINTS1
			dprintf("ReplicaNet : Master object class id %d session %d uniid %d not propagate to %d\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID(),ret);
#endif
		}

		object = mReflectList.Iterate();
	}

	// Send a message to say that this session accepts objects if it is configured to do so
	if (mCanAcceptObjects)
	{
#ifdef DEBUG_PRINTS1
		dprintf("ReplicaNet : For joiner Sending can accept objects update to sessid %d\n",ret);
#endif
		char tempbuff[12];
		MessageHelper message;
		message.SetBuffer(tempbuff);
		RepnetMessage repnetmess = kReplicaNetMessage_CanAcceptObjects;
		MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
		// Sent with the reliable method
		RecordCheckDataSendToSession(ret,tempbuff,message.GetSize(),true);
	}

	// Send the load balancing information if we are configured to do so
	if (mEnableLoadBalancing)
	{
#ifdef DEBUG_PRINTS1
		dprintf("ReplicaNet : For joiner Sending is load balanced update to sessid %d\n",ret);
#endif
		char tempbuff[32];
		MessageHelper message;
		message.SetBuffer(tempbuff);
		RepnetMessage repnetmess = kReplicaNetMessage_IsLoadBalanced;
		MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
		repnetmess = kReplicaNetMessage_MyMaximumLoadIs;
		MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
		message.AddFloat(mMaximumLoad);
		repnetmess = kReplicaNetMessage_MyTotalLoadIs;
		MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
		message.AddFloat(mTotalLoad);
		// Sent with the reliable method
		RecordCheckDataSendToSession(ret,tempbuff,message.GetSize(),true);
	}

	// If there is an observer then send which object is the observer
	// Since SessionData ctor sets the observer to be null then we don't need to send a "clear observer" message for the joiner
	if (mObserver)
	{
#ifdef DEBUG_PRINTS1
		dprintf("ReplicaNet : For joiner Sending observer update to sessid %d for objid %d\n",ret,mObserver->GetUniqueID());
#endif
		char tempbuff[16];
		MessageHelper message;
		message.SetBuffer(tempbuff);
		RepnetMessage repnetmess = kReplicaNetMessage_SetObserver;
		MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
		message.AddInteger(mObserver->GetSessionID());
		message.AddInteger(mObserver->GetUniqueID());
		// Sent with the reliable method
		RecordCheckDataSendToSession(ret,tempbuff,message.GetSize(),true);
	}

#ifdef DEBUG_PRINTS1
	dprintf("ReplicaNet : For joiner Sending kReplicaNetMessage_InitDoneSendState\n");
#endif
	char tempbuff[12];
	MessageHelper message;
	message.SetBuffer(tempbuff);
	RepnetMessage repnetmess = kReplicaNetMessage_InitDoneSendState;
	MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
	// Sent with the reliable method
	RecordCheckDataSendToSession(ret,tempbuff,message.GetSize(),true);

	if (sessionID != kReplicaNetRecordID)
	{
		// Notify the joiner callback
		mParentReplicaNet->JoinerSessionIDPost(ret);
	}
}

void ReplicaNetPrivate::Disconnect(const int sessionID)
{
	THREADSAFELOCK();

	if (!mSession)
	{
		return;
	}

	mSession->Disconnect(sessionID);
}

bool ReplicaNetPrivate::GetPreConnectStatus(void)
{
	THREADSAFELOCK();

	if (!mSession)
	{
		return false;
	}

	return mSession->GetPreConnectStatus();
}

void ReplicaNetPrivate::SetPreConnect(const bool enable)
{
	THREADSAFELOCK();

	// Setting a channel before the session is started causes the session class to be allocated
	EnsureSessionAllocated();

	mSession->SetPreConnect(enable);
}

bool ReplicaNetPrivate::GetPreConnect(void)
{
	THREADSAFELOCK();

	if (!mSession)
	{
		return false;
	}

	return mSession->GetPreConnect();
}

void ReplicaNetPrivate::PreConnectHasFinished(void)
{
	THREADSAFELOCK();

	if (!mSession)
	{
		return;
	}

	mSession->PreConnectHasFinished();
}

void ReplicaNetPrivate::InternalPacketSend(const int sessionid, const ReplicaNet::PacketType type, const DynamicMessageHelper &message,const unsigned int band)
{
	switch(type)
	{
	case ReplicaNet::kPacket_Unreliable:
		RecordCheckDataSendToSessionUnreliable(sessionid,message.GetBuffer(),message.GetSize());
		break;
	case ReplicaNet::kPacket_Certain:
		RecordCheckDataSendToSessionCertain(sessionid,message.GetBuffer(),message.GetSize());
		break;
	case ReplicaNet::kPacket_Ordered:
		RecordCheckDataSendToSessionOrdered(sessionid,message.GetBuffer(),message.GetSize(),band);
		break;
	case ReplicaNet::kPacket_Reliable:
	default:
		RecordCheckDataSendToSessionReliable(sessionid,message.GetBuffer(),message.GetSize(),band);
		break;
	}
}

void ReplicaNetPrivate::DataSend(const int sessionid,const void *data,const int length,const ReplicaNet::PacketType type,const unsigned int band)
{
	assert(data && "There is no data pointer to send");

	if (!data)
	{
		return;
	}

	if (length <= 0)
	{
		return;
	}

	THREADSAFELOCK();

	if (!mSession)
	{
		return;
	}

	DynamicMessageHelper message;
	RepnetMessage repnetmess = kReplicaNetMessage_DataPacket;
	MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
	int plength = length;
	message.AddVariable(&plength,sizeof(plength));
	message.AddData(data,plength);

	InternalPacketSend(sessionid,type,message,band);
}

void ReplicaNetPrivate::ReplicaObjectDataSend(const int sessionid,const void *data,const int length,const ReplicaNet::PacketType type,ReplicaObject *source,const unsigned int band)
{
	assert(data && "There is no data pointer to send");
	assert(source && "There is no source ReplicaObject");

	if (!data || !source)
	{
		return;
	}

	if (length <= 0)
	{
		return;
	}

	THREADSAFELOCK();

	if (!mSession)
	{
		return;
	}

	DynamicMessageHelper message;
	RepnetMessage repnetmess = kReplicaNetMessage_ReplicaObjectDataPacket;
	MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
	message.AddInteger(source->GetSessionID());
	message.AddInteger(source->GetUniqueID());
	int plength = length;
	message.AddVariable(&plength,sizeof(plength));
	message.AddData(data,plength);

	InternalPacketSend(sessionid,type,message,band);
}

bool ReplicaNetPrivate::DataReceive(int *const fromsessionid,void *const data,int *const length,ReplicaNet::PacketType *const type)
{
	// Don't want the main class THREADSAFELOCK now.
//	THREADSAFELOCK();
	if (!mSession)
	{
		return false;
	}

	// Thread safe const read only operation
	if (mWaitingPackets.empty())
	{
		return false;
	}

	THREADSAFELOCKCLASS(mMutexRecvPackets);
	// Now do the real read once we have the lock
	if (mWaitingPackets.empty())
	{
		return false;
	}

	WaitingPacket &waiting = *mWaitingPackets.begin();
	memcpy(data,waiting.mData,waiting.mLength);
	if (length)
	{
		*length = waiting.mLength;
	}
	if (type)
	{
		*type = waiting.mType;
	}
	if (fromsessionid)
	{
		*fromsessionid = waiting.mFromSessionID;
	}
	free(waiting.mData);
	waiting.mData = 0;
	mWaitingPackets.pop_front();
	return true;
}

bool ReplicaNetPrivate::DataReceivePeek(int *const fromsessionid,int *const length,ReplicaNet::PacketType *const type)
{
	// Don't want the main class THREADSAFELOCK now.
//	THREADSAFELOCK();

	if (!mSession)
	{
		return false;
	}

	// Thread safe const read only operation
	if (mWaitingPackets.empty())
	{
		return false;
	}

	THREADSAFELOCKCLASS(mMutexRecvPackets);
	// Now do the real read once we have the lock
	if (mWaitingPackets.empty())
	{
		return false;
	}

	WaitingPacket &waiting = *mWaitingPackets.begin();
	if (length)
	{
		*length = waiting.mLength;
	}
	if (type)
	{
		*type = waiting.mType;
	}
	if (fromsessionid)
	{
		*fromsessionid = waiting.mFromSessionID;
	}
	return true;
}

void ReplicaNetPrivate::MessageDataPacket(const int sessionid,const int length,const unsigned char packetType)
{
#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a kReplicaNetMessage_DataPacket from %d\n",sessionid);
#endif
	int plength;

	if (!mRetainRawData)
	{
		GetVariable(&plength,sizeof(plength));
		// Advance over the data if we are ignoring data packets.
		SetSize(GetSize()+plength);
		return;
	}

	GetVariable(&plength,sizeof(plength));

	WaitingPacket waiting;

	waiting.mLength = plength;

	waiting.mData = malloc(plength);
	assert(waiting.mData && "Out of memory");
	GetData(waiting.mData,waiting.mLength);

	switch(packetType)
	{
		case kXPSessionPacketType_Unreliable:
			waiting.mType = ReplicaNet::kPacket_Unreliable;
			break;
		case kXPSessionPacketType_Certain:
			waiting.mType = ReplicaNet::kPacket_Certain;
			break;
		case kXPSessionPacketType_Ordered:
			waiting.mType = ReplicaNet::kPacket_Ordered;
			break;
		case kXPSessionPacketType_Reliable:
		default:
			waiting.mType = ReplicaNet::kPacket_Reliable;
			break;
	}
	waiting.mFromSessionID = sessionid;

	// Stack context for the lock
	{
	THREADSAFELOCKCLASS(mMutexRecvPackets);
	mWaitingPackets.push_back(waiting);
	}
}

void ReplicaNetPrivate::MessageReplicaObjectDataPacket(const int sessionid,const int length,const unsigned char packetType)
{
#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a kReplicaNetMessage_ReplicaObjectDataPacket from %d\n",sessionid);
#endif
	int plength;

	int sessionID = GetInteger();
	int uniqueID = GetInteger();

	ReplicaObject *object = 0;
	object = mAllKnown.FindItem(SessionUnique(sessionID,uniqueID));

	GetVariable(&plength,sizeof(plength));

	assert(plength >= 0 && "Packet length is wrong, corrupt packet?");
	if (plength < 0)
	{
		return;
	}

	if (!object)
	{
#ifdef DEBUG_PRINTS2
		dprintf("Couldn't find object %d:%d\n",sessionID,uniqueID);
#endif
		// Skip over the rest of the data if the object isn't found
		SetSize(GetSize()+plength);
		return;
	}

	ReplicaObject::PacketType type;
	switch(packetType)
	{
		case kXPSessionPacketType_Unreliable:
			type = ReplicaObject::kPacket_Unreliable;
			break;
		case kXPSessionPacketType_Certain:
			type = ReplicaObject::kPacket_Certain;
			break;
		case kXPSessionPacketType_Ordered:
			type = ReplicaObject::kPacket_Ordered;
			break;
		case kXPSessionPacketType_Reliable:
		default:
			type = ReplicaObject::kPacket_Reliable;
			break;
	}

	// We malloc a chunk of memory to make sure the data received is on a sensible alignment for the user.
	void *data = malloc(plength);
	assert(data && "Out of memory");
	// In release builds we try to fail gracefully instead...
	if (!data)
	{
		// Skip over the rest of the data if there isn't enough memory
		SetSize(GetSize()+plength);
		return;
	}
	GetData(data,plength);
	object->CallBackDataReceive(sessionid,data,plength,type);
	free(data);
}

void ReplicaNetPrivate::SetDataRetention(const bool enable)
{
	mRetainRawData = enable;
}

bool ReplicaNetPrivate::GetDataRetention(void) const
{
	return mRetainRawData;
}

void ReplicaNetPrivate::RetireObjectPropagationAddRemove(void)
{
	mMasterList.BeginIterate();
	
	ReplicaObject *object = mMasterList.Iterate();

	while(object != NULL)
	{
		/* Tell the joining session that we have objects that need adding now */

		// If we are only going to propagate to certain session IDs then we need to double check them
		if (object->mSessionPropagationFilter)
		{
			object->Lock();
			// Check the propagate delay lists

			std::set<int>::iterator st,en;
			st = object->mSessionPropagationFilterDelaySlotAdd.begin();
			en = object->mSessionPropagationFilterDelaySlotAdd.end();
			while (st != en)
			{
				int theID = *st;

#ifdef DEBUG_PRINTS1
				dprintf("ReplicaNet : RetireObjectPropagationAddRemove Master object class id %d session %d uniid %d telling sessid %d of new dataset\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID(),theID);
#endif
				if (object->mReflectSessionID == kReplicaNetUnknownUniqueID)
				{
					DoMasterCreateClassMessage(theID,object);
				}
				else
				{
					if (object->mReflectSessionID == theID)
					{
						DoReflectCreateClassMessage(theID,object);
					}
				}

				st++;
			}


			st = object->mSessionPropagationFilterDelaySlotRemove.begin();
			en = object->mSessionPropagationFilterDelaySlotRemove.end();
			while (st != en)
			{
				int theID = *st;

#ifdef DEBUG_PRINTS1
				dprintf("ReplicaNet : RetireObjectPropagationAddRemove Master object class id %d session %d uniid %d do propagate remove from sessid %d\n",object->GetClassID(),object->GetSessionID(),object->GetUniqueID(),theID);
#endif
				DataBlockReason reason;
				reason.mReasonCode = kDataBlockReason_SomeoneLeft;
				reason.mSessionReference = theID;
				int i;
				for (i=0;i<(int)object->mDataBlocks.size();i++)
				{
					object->mDataBlocks[i]->Poll(&reason);
				}

				char tempbuff[12];
				MessageHelper message;
				message.SetBuffer(tempbuff);
				RepnetMessage repnetmess = kReplicaNetMessage_DeleteClass;
				MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
				message.AddInteger(object->GetUniqueID());
				// Sent with the certain method
				RecordCheckDataSendToSession(theID,tempbuff,message.GetSize(),false,true);


				st++;
			}

			// Now clear both the add and remove list
			object->mSessionPropagationFilterDelaySlotAdd.clear();
			object->mSessionPropagationFilterDelaySlotRemove.clear();

			object->UnLock();

		}

		object = mMasterList.Iterate();
	}
}

void ReplicaNetPrivate::HandleMasterSessionPropagateDistanceBased(const SysTimeType nowtime)
{
	/* Now update the data blocks on our masters */
	mMasterList.BeginIterate();
	ReplicaObject *object;
	while( (object = mMasterList.Iterate()) != 0 )
	{
		if (!object->mEnableDistanceBased)
		{
			continue;
		}
		HandleMasterSessionPropagateDistanceBasedPerObject(nowtime,object);
	}
}


void ReplicaNetPrivate::HandleMasterSessionPropagateDistanceBasedPerObject(const SysTimeType nowtime,ReplicaObject *object)
{
	if (!object->mEnableDistanceBased)
	{
		return;
	}

	if (nowtime <= (object->mDistanceBasedLastTime + object->mDistanceBasedPollTime) )
	{
//		OutputDebugString("Skipping\n");
		return;
	}

//	OutputDebugString("Processing\n");
	object->mDistanceBasedLastTime = nowtime;

	std::map<int,SessionData>::iterator st,en;
	st = mKnownSessions.begin();
	en = mKnownSessions.end();
	while (st != en)
	{
		// Only consider doing this for sessions where we know we either have or don't have observers set
		// In other words ones that have received the kReplicaNetMessage_InitDoneSendState message
		if ((*st).second.mInitDoneSendStateRecv)
		{
			if ((*st).second.mObserver)
			{
				// Use the observer if one is set
				object->PollInternalForDistance(nowtime,(*st).second.mObserver,(*st).second.mSessionID);
			}
			else if (((*st).second.mObserverSessionID != kReplicaNetUnknownUniqueID) && ((*st).second.mObserverUniqueID != kReplicaObjectUnknownUniqueID) && !(*st).second.mObserver)
			{
				// If an observer is requested but not set then skip the session for now
			}
			else
			{
				// Without an observer then always propagate to the session
				object->SessionPropagationAddSession((*st).second.mSessionID);
			}
		}
		st++;
	}
}


void ReplicaNetPrivate::MessageInitDoneSendState(const int sessionid)
{
#ifdef DEBUG_PRINTS2
	dprintf("ReplicaNet got a MessageInitDoneSendState from %d\n",sessionid);
#endif
	std::map<int,SessionData>::iterator found;
	found = mKnownSessions.find(sessionid);
	// Search for the session parameter block
	if (found != mKnownSessions.end())
	{
		SessionData *sessid = &((*found).second);
		assert(sessid->mSessionID == sessionid);
		sessid->mInitDoneSendStateRecv = true;
		return;
	}

#ifdef DEBUG_PRINTS2
	dprintf("WARNING : ReplicaNet MessageInitDoneSendState sessid not found\n");
#endif
}


void ReplicaNetPrivate::SetDataBlockUpdatePolicy(const bool automatic)
{
	mAutomaticDataBlockUpdates = automatic;
}

bool ReplicaNetPrivate::GetDataBlockUpdatePolicy(void) const
{
	return mAutomaticDataBlockUpdates;
}

void ReplicaNetPrivate::ProcessDataBlockUpdate(void)
{
	if (mAutomaticDataBlockUpdates)
	{
		return;
	}
	THREADSAFELOCK();
	SysTimeType nowtime = mParentReplicaNet->GetTime();
	SysTimeType nowlocaltime = mParentReplicaNet->GetLocalTime();

	HandleCommonDataBlockUpdates(nowtime,nowlocaltime);
}

void ReplicaNetPrivate::SetAutomaticPacketCompression(const bool enable)
{
	THREADSAFELOCK();

	// Setting a channel before the session is started causes the session class to be allocated
	EnsureSessionAllocated();

	mSession->SetAutomaticPacketCompression(enable);
}

bool ReplicaNetPrivate::GetAutomaticPacketCompression(void)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	return mSession->GetAutomaticPacketCompression();
}

void ReplicaNetPrivate::GetCompressionStatistics(int *const before,int *const after,const bool reset)
{
	THREADSAFELOCK();

	if (!mSession)
	{
		if (before)
		{
			*before = 0;
		}
		if (after)
		{
			*after = 0;
		}
		return;
	}

	mSession->GetCompressionStatistics(before,after,reset);
}

void ReplicaNetPrivate::GetMergedStatistics(int *const sent,int *const received,const bool reset)
{
	THREADSAFELOCK();

	if (!mSession)
	{
		if (sent)
		{
			*sent = 0;
		}
		if (received)
		{
			*received = 0;
		}
		return;
	}

	mSession->GetMergedStatistics(sent,received,reset);
}

int ReplicaNetPrivate::GetMasterSessionID(void)
{
	THREADSAFELOCK();

	if (!mSession)
	{
		return kReplicaNetUnknownUniqueID;
	}

	return mSession->GetMasterSessionID();
}

std::string ReplicaNetPrivate::GetURLFromSessionID(const int sessionID)
{
	THREADSAFELOCK();

	if (!mSession)
	{
		return "";
	}

	return mSession->GetURLFromSessionID(sessionID);
}

void ReplicaNetPrivate::SetClientOnly(const bool isClient)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	mSession->SetClientOnly(isClient);
}

bool ReplicaNetPrivate::GetClientOnly(void)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	return mSession->GetClientOnly();
}

bool ReplicaNetPrivate::GetBandwidthFromSessionID(const int sessionID,Transport::Bandwidth *const bandwidth,int *const output,int *const input)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	return mSession->GetBandwidthFromSessionID(sessionID,bandwidth,output,input);
}

void ReplicaNetPrivate::DoObjectDelete(ReplicaObject *object)
{
	// First of all try to delete our known object with the callback
	ReplicaObject *newobj = mParentReplicaNet->CallBackDelete(object);
	if (newobj)
	{
		// The callback didn't do the job so we carry on
		assert(object->GetRegistryBlock());
		object->GetRegistryBlock()->CallBackDelete(object);
		return;
	}

}

SysTimeType ReplicaNetPrivate::GetRecordingTime(void)
{
	if (mIsRecording)
	{
		return mRecordingTime.FloatTime() - mRecordingZeroTime;
	}
	return (mRecordingTime.FloatTime() * mPlaybackSpeed) - mRecordingZeroTime;
}

bool ReplicaNetPrivate::BeginSessionRecord(void)
{
	THREADSAFELOCK();

	if (mIsRecording)
	{
		return false;
	}

	// The first format of the data stream is:
	// 00/03	kReplicaNet_RecordingMagic
	// 04/07	kReplicaNet_RecordingVersion
	// 08/11	The real session ID. This is added by the first packet to be appended to the output stream.

	MessageHelper message;
	char buffer[32];
	message.SetBuffer(buffer);
	message.AddInteger(kReplicaNet_RecordingMagic);
	message.AddInteger(kReplicaNet_RecordingVersion);
	if (!mParentReplicaNet->CallbackSessionRecord(buffer,message.GetSize()))
	{
		mIsRecording = false;
		return false;
	}

	// After this all messages are in the format:
	// 00/03/07	SysTimeTime (float or double) network time the packet arrives
	// Then the time is stored in mPlaybackNextPacketDue and checked for
	// 00/04	Unsigned int of the length of the *data* in the packet. 0 Means end of the stream.
	// 04		Type as an unsigned char.
	// 05/08	From session ID
	// 09/12	To session ID
	// 13+		Packet data

	mIsRecording = true;
	mDoRecordingPrep = true;

	// Now if any replicas exist then save them for exporting.
	// We don't do this in the prep because we don't want to risk recording already recorded replicas.
	ReplicaObject *object;

	mReplicaList.BeginIterate();
	object = mReplicaList.Iterate();
	while(object != NULL)
	{
		// Skip objects that are reflections
		if (object->mReflectSessionID != kXPSessionUnknownID)
		{
			object = mReplicaList.Iterate();
			continue;
		}

		// Do a check here since we cannot do a RecordCheckDataSendToSession() because we need to fake the from sessionID
		if (mDoRecordingPrep)
		{
			DoRecordingPrep();
		}

		// Do a fake kReplicaNetMessage_CreateClass
		DynamicMessageHelper message;
		RepnetMessage repnetmess = kReplicaNetMessage_CreateClass;

		// Add the message, classid and uniqueid to the message
		MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
		message.AddInteger(object->GetClassID());
		message.AddInteger(object->GetUniqueID());

		// Notify the datablocks that we want a recording packet
		DataBlockReason reason;
		// Do the master add calculation for our datablocks
		reason.mReasonCode = kDataBlockReason_RecordingNormalPoll;
		reason.mFloatTime = mParentReplicaNet->GetTime();
		reason.mFloatLocalTime = mParentReplicaNet->GetLocalTime();
		reason.mSessionReference = kReplicaNetRecordID;
		int i;

		// Accept the packet information, if any from the recording polled datablocks
		CommonCreateClassMessages(object,message,reason);

		// Store the packet by sending it to kReplicaNetRecordID
		// We also fake the from sessionID to be the sessionID of the object.
		RecordDataPacket(object->GetSessionID(),GetSessionID(),(char *)message.GetBuffer(),message.GetSize(),0);

		// Then tell the datablocks the record session left
		reason.mReasonCode = kDataBlockReason_SomeoneLeft;
		reason.mSessionReference = kReplicaNetRecordID;
		for (i=0;i<(int)object->mDataBlocks.size();i++)
		{
			object->mDataBlocks[i]->Poll(&reason);
		}

		object = mReplicaList.Iterate();
	}

	return true;
}

bool ReplicaNetPrivate::GetSessionRecord(void) const
{
	return mIsRecording;
}

void ReplicaNetPrivate::StopSessionRecord(void)
{
	THREADSAFELOCK();
	if (mIsRecording)
	{
		MessageHelper message;
		char buffer[64];
		message.SetBuffer(buffer);
		SysTimeType value= GetRecordingTime();
		message << value;
		unsigned int temp = 0;
		message.AddVariable(&temp,sizeof(temp));
		message.AddVariable(&temp,sizeof(unsigned char));
		message.AddInteger(kReplicaNetUnknownUniqueID);
		message.AddInteger(kReplicaNetUnknownUniqueID);
		mParentReplicaNet->CallbackSessionRecord(buffer,message.GetSize());
	}
	mIsRecording = false;
}

bool ReplicaNetPrivate::BeginSessionPlayback(void)
{
	THREADSAFELOCK();

	if (mIsPlayback)
	{
		return false;
	}

	MessageHelper message;
	char buffer[32];
	message.SetBuffer(buffer);

	if (!mParentReplicaNet->CallbackSessionPlayback(buffer,sizeof(int) * 3))
	{
		return false;
	}

	if (message.GetInteger() != kReplicaNet_RecordingMagic)
	{
		return false;
	}

	if (message.GetInteger() != kReplicaNet_RecordingVersion)
	{
		return false;
	}

	// This comes from RecordDataPacket and the mDoneRecordHeader check.
	// It is like this to get a good session ID.
	mPlaybackSessionID = message.GetInteger();

	if (!mParentReplicaNet->CallbackSessionPlayback(buffer,sizeof(SysTimeType)))
	{
		return false;
	}

//	mRecordingZeroTime = mRecordingTime.FloatTime();
	mRecordingZeroTime = (mRecordingTime.FloatTime() * mPlaybackSpeed);	// The playback speed may have been set before this function is called
	message.SetBuffer(buffer);

	message >> mPlaybackNextPacketDue;

	mIsPlayback = true;
	mDoPlaybackPrep = true;
	return true;
}

void ReplicaNetPrivate::SetPlaybackSpeed(const float speed)
{
	// Quick check, don't do anything if it is the same
	if (mPlaybackSpeed == speed || speed < 0.0f)
	{
		return;
	}

	THREADSAFELOCK();

	// Adjust the zero time to compensate for the different time.
	SysTimeType timeNow = GetRecordingTime();
	mPlaybackSpeed = speed;
	mRecordingZeroTime = (mRecordingTime.FloatTime() * mPlaybackSpeed) - timeNow;
}

bool ReplicaNetPrivate::PlaybackAdvanceTo(const SysTimeType time)
{
	THREADSAFELOCK();

	float deltaTime = (float)(time - mParentReplicaNet->GetTime());
	if (deltaTime < 0.0f)
	{
		return false;
	}

	mRecordingZeroTime -= deltaTime;

	mPlaybackAdvanceToRequested = true;

	return true;
}

void ReplicaNetPrivate::StopSessionPlayback(void)
{
	THREADSAFELOCK();
	// The mIsPlayback is not meant to be set to be false here so we can continue to do GetSessionPlayback() properly.
	// The mPlaybackEndReachedDoError is set to be true, to stop packets from being requested from the recording.
	// mPlaybackEndReachedDoError also sets the session error.
	mIsRecording = false;
	mDoPlaybackPrep = false;
	mDoneRecordHeader = false;
	mPlaybackEndReachedDoError = true;
}

bool ReplicaNetPrivate::GetSessionPlayback(void) const
{
	return mIsPlayback;
}

void ReplicaNetPrivate::RecordCheckDataSendToSession(const int sessionid,const char *data,const int length,const bool reliable,const bool certain,const bool ordered,const unsigned int band)
{
	THREADSAFELOCK();
	if (mDoRecordingPrep)
	{
		DoRecordingPrep();
	}
	if (mIsRecording)
	{
		if (sessionid == kReplicaNetRecordID || sessionid == kReplicaNetUnknownUniqueID || sessionid == kReplicaNetBroadcastID)
		{
			RecordDataPacket(GetSessionID(),sessionid,data,length,0);
		}

		// Only if it's a recording sessionID then return and don't sent it to the session.
		if (sessionid == kReplicaNetRecordID)
		{
			return;
		}
	}

	// Discard outgoing packets if we are playing back a recorded session
	if (mIsPlayback)
	{
		return;
	}

	assert(mSession && "There should be a session pointer, where is it?");
	if (mSession)
	{
		mSession->DataSendToSession(sessionid,data,length,reliable,certain,ordered,band);
	}
}

void ReplicaNetPrivate::RecordDataPacket(const int fromSessionID,const int toSessionID,const char *data,const int length,const unsigned char packetType)
{
	THREADSAFELOCK();
	if (!mIsRecording)
	{
		return;
	}
	if (!data || length <= 0)
	{
		return;
	}

	if (!mDoneRecordHeader)
	{
		MessageHelper message;
		char buffer[32];
		message.SetBuffer(buffer);
		// This is read into mPlaybackSessionID by BeginSessionPlayback
		message.AddInteger(GetSessionID());
		if (!mParentReplicaNet->CallbackSessionRecord(buffer,message.GetSize()))
		{
			StopSessionPlayback();
			return;
		}
		mDoneRecordHeader = true;
	}

	MessageHelper message;
	char buffer[32];
	message.SetBuffer(buffer);
	SysTimeType value = GetRecordingTime();
	message << value;
	unsigned int temp = (unsigned int) length;
	message.AddVariable(&temp,sizeof(temp));
	message.AddVariable(&packetType,sizeof(packetType));
	message.AddInteger(fromSessionID);
	message.AddInteger(toSessionID);
	if (!mParentReplicaNet->CallbackSessionRecord(buffer,message.GetSize()))
	{
		StopSessionPlayback();
	}
	if (!mParentReplicaNet->CallbackSessionRecord(data,length))
	{
		StopSessionPlayback();
	}
}

bool ReplicaNetPrivate::RecordCheckDataReceive(int *const fromsessionid,int *const length,unsigned char *const type)
{
	THREADSAFELOCK();
	if (mIsPlayback)
	{
		if (mPlaybackEndReachedDoError)
		{
			CheckPlaybackAdvanceToRequested();
			return false;
		}
		// Is our next packet due yet?
		if (GetRecordingTime() >= mPlaybackNextPacketDue)
		{
			MessageHelper message;
			char buffer[32];
			message.SetBuffer(buffer);
			if (!mParentReplicaNet->CallbackSessionPlayback(buffer,sizeof(unsigned int) + sizeof(unsigned char) + (sizeof(int)*2)))
			{
				StopSessionPlayback();
				return false;
			}
			unsigned int temp;
			unsigned char ptype;
			message.GetVariable(&temp,sizeof(temp));
			message.GetVariable(&ptype,sizeof(ptype));
			int fromid = message.GetInteger();
			int toid = message.GetInteger();
			toid = toid;	// Stops the warning about unused variable. We want to read it

			SetBufferSize(temp);
			EnsureBufferAllocated();

			if (temp == 0)
			{
				StopSessionPlayback();
				return false;
			}
			if (!mParentReplicaNet->CallbackSessionPlayback(GetBuffer(),temp))
			{
				StopSessionPlayback();
				return false;
			}

			// Get our next packet time while we are here...
			message.SetBuffer(buffer);
			if (!mParentReplicaNet->CallbackSessionPlayback(buffer,sizeof(SysTimeType)))
			{
				StopSessionPlayback();
				return false;
			}
			message >> mPlaybackNextPacketDue;


			if (length)
			{
				*length = temp;
			}
			if (type)
			{
				*type = ptype;
			}
			if (fromsessionid)
			{
				*fromsessionid = fromid;
			}
			return true;
		}
		else // ... if (GetRecordingTime() >= mPlaybackNextPacketDue)
		{
			CheckPlaybackAdvanceToRequested();
		}
		return false;
	}

	assert(mSession && "There should be a session pointer, where is it?");
	if (mSession)
	{
		bool ret = mSession->DataReceivePeek(fromsessionid,length,type);
		if (!ret)
		{
			return false;
		}
		SetBufferSize(*length);
		EnsureBufferAllocated();
		return mSession->DataReceive(fromsessionid,(char *) GetBuffer(),length,type);
	}
	return false;
}

void ReplicaNetPrivate::SetPlaybackAllowMasterReplicaObjects(const bool allow)
{
	mPlaybackAllowMasterROs = allow;
}

bool ReplicaNetPrivate::GetPlaybackAllowMasterReplicaObjects(void)
{
	return mPlaybackAllowMasterROs;
}

void ReplicaNetPrivate::SetAllowConnections(const bool enable)
{
	THREADSAFELOCK();
	EnsureSessionAllocated();

	mSession->SetAllowConnections(enable);
}

bool ReplicaNetPrivate::GetAllowConnections(void)
{
	THREADSAFELOCK();
	EnsureSessionAllocated();

	return 	mSession->GetAllowConnections();
}

void ReplicaNetPrivate::DoRecordingPrep(void)
{
	assert(mDoRecordingPrep);
	mDoRecordingPrep = false;
	mRecordingZeroTime = mRecordingTime.FloatTime();
	RecordingDoTimeCodes();

	// If we already have a session ID different to kReplicaNetUnknownUniqueID then we record it, to be sure.
	if (mSessionID != kReplicaNetUnknownUniqueID)
	{
		char buffer[64];
		MessageHelper message;
		message.SetBuffer(buffer);
		RepnetMessage repnetmess = kReplicaNetMessage_RecordingSessionID;
		MESSAGEHELPER_ADDVARIABLEp(message,repnetmess);
		message.AddInteger(mSessionID);
		RecordDataPacket(GetSessionID(),kReplicaNetRecordID,buffer,message.GetSize(),0);
	}

	HandleSessionJoin(kReplicaNetRecordID);
}

void ReplicaNetPrivate::SetNodeBuffers(const bool enable)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	mSession->SetNodeBuffers(enable);
}

bool ReplicaNetPrivate::GetNodeBuffers(void)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	return mSession->GetNodeBuffers();
}

void ReplicaNetPrivate::RemoveObjectFromAllLists(const ReplicaObject *object)
{
	if (object->IsMaster())
	{
		mMasterList.RemoveItem(SessionUnique(object));
	}
	else
	{
		mReplicaList.RemoveItem(SessionUnique(object));
	}
	if (object->mReflectSessionID != kXPSessionUnknownID && object->mReflectSessionID == GetSessionID())
	{
		mReflectList.RemoveItem(SessionUnique(object));
	}
	mAllKnown.RemoveItem(SessionUnique(object));
}

void ReplicaNetPrivate::AddObjectToCorrectLists(ReplicaObject *object)
{
	if (object->IsMaster())
	{
		mMasterList.AddItem(SessionUnique(object),object);
	}
	else
	{
		mReplicaList.AddItem(SessionUnique(object),object);
	}

	// Add the object to the list of all known objects
	mAllKnown.AddItem(SessionUnique(object),object);

	// If we are adding a reflect master then add it to the list
	if (object->mReflectSessionID != kXPSessionUnknownID && object->mReflectSessionID == GetSessionID())
	{
		mReflectList.AddItem(SessionUnique(object),object);
	}

	// Now check for pending observers to be attached to their respective sessions
	std::multimap<SessionUnique,int,ltSessionUnique>::iterator lb = mObserverPendingForSessionID.lower_bound(SessionUnique(object));
	std::multimap<SessionUnique,int,ltSessionUnique>::iterator ub = mObserverPendingForSessionID.upper_bound(SessionUnique(object));
	while (lb != ub)
	{
		int sessionid = lb->second;

		std::map<int,SessionData>::iterator found;
		found = mKnownSessions.find(sessionid);
		if (found != mKnownSessions.end())
		{
			SessionData *sessid = &((*found).second);
			assert(sessid->mSessionID == sessionid);
			assert(sessid->mObserverPendingSet);
			assert(sessid->mObserverSessionID == object->GetSessionID());
			assert(sessid->mObserverUniqueID == object->GetUniqueID());
			assert(sessid->mObserverPending == lb);

			if (sessid->mObserver)
			{
				sessid->mObserver->mObserverFor.erase(sessionid);
			}

			sessid->mObserver = object;
			object->mObserverFor.insert(sessionid);

			sessid->mObserverPendingSet = false;

#ifdef DEBUG_PRINTS2
			dprintf("Acting on delayed SetObserver for objid %d:%d for session %d as object found\n",object->GetSessionID(),object->GetUniqueID(),sessionid);
#endif
		}
		else
		{
#ifdef DEBUG_PRINTS2
			dprintf("Retire delayed SetObserver for objid %d:%d for session %d as session not found\n",object->GetSessionID(),object->GetUniqueID(),sessionid);
#endif
		}

		mObserverPendingForSessionID.erase(lb++);
	}
}

void ReplicaNetPrivate::CheckPlaybackAdvanceToRequested(void)
{
	if (mPlaybackAdvanceToRequested)
	{
		mPlaybackAdvanceToRequested = false;
		mParentReplicaNet->CallbackPlaybackAdvanceToFinished();
	}
}

void ReplicaNetPrivate::HandleMasterSessionChanges(void)
{
	// Update the master session
	if (mLastGoodMasterSessionID == kXPSessionUnknownID)
	{
		mLastGoodMasterSessionID = GetMasterSessionID();
		mParentReplicaNet->CallbackMasterSessionIDChanged(kXPSessionUnknownID);
	}
	else
	{
		int temp = GetMasterSessionID();
		if (mLastGoodMasterSessionID != temp)
		{
			mParentReplicaNet->CallbackMasterSessionIDChanged(mLastGoodMasterSessionID);
			mLastGoodMasterSessionID = temp;
		}
	}
}

static int sReplicaNetGetSessionIDCallback(void *context)
{
	return ((ReplicaNet *)context)->CallbackGetSessionID();
}

void ReplicaNetPrivate::SetSessionIDCallback(const bool enable)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();

	if (enable)
	{
		mSession->RegisterSessionIDCallback(sReplicaNetGetSessionIDCallback,mParentReplicaNet);
	}
	else
	{
		mSession->RegisterSessionIDCallback(0);
	}
}

void ReplicaNetPrivate::SetMaximumDataSize(const int bytes)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();
	mSession->SetMaximumDataSize(bytes);
}

int ReplicaNetPrivate::GetMaximumDataSize(void)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();
	return mSession->GetMaximumDataSize();
}

void ReplicaNetPrivate::SetPacketCompressionLevel(const int level)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();
	mSession->SetPacketCompressionLevel(level);
}
void ReplicaNetPrivate::SetLargePacketCompressionLevel(const int level)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();
	mSession->SetLargePacketCompressionLevel(level);
}

int ReplicaNetPrivate::GetPacketCompressionLevel(void)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();
	return mSession->GetPacketCompressionLevel();
}
int ReplicaNetPrivate::GetLargePacketCompressionLevel(void)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();
	return mSession->GetLargePacketCompressionLevel();
}

void ReplicaNetPrivate::SetTransparentPacketCompression(const int level)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();
	mSession->SetTransparentPacketCompression(level);
}

int ReplicaNetPrivate::GetTransparentPacketCompression(void)
{
	THREADSAFELOCK();

	EnsureSessionAllocated();
	return mSession->GetTransparentPacketCompression();
}
//From: RNReplicaNet/ReplicaNetDoc.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
/** \page ReplicaNet ReplicaNet
 *
 * \section intro Introduction
 *
 * RNReplicaNet::ReplicaNet is a management class that enables different RNReplicaNet::ReplicaObject derived C++ classes to be created, destroyed and updated across a network of computers without having to worry about specific network programing knowledge.<br>
 * To enable integration between the ReplicaNet system and the user classes a tool is used to create extra class definitions to be used in the project.<br>
 * ReplicaNet uses an XPSession as the base network layer and expands upon it.
 *
 * \section usingreplicanet Using ReplicaNet
 *
 * ReplicaNet include files are in the Includes directory.
 * Use "RNReplicaNet/Inc/ReplicaNet.h" to access all of the C++ interface to the RNReplicaNet::ReplicaNet class.<br>
 * RNReplicaNet::ReplicaNet is primarily a multi-threaded library as the session framework uses threads to reduce CPU load. Single-threading is supported by means of using a RNReplicaNet::ReplicaNet::Poll() call to ensure data is processed regularly.<br>
 * To allow ReplicaNet to include debugging information, that can be used with the ReplicaNet Visual Debugger, use the preprocessor to define REPLICANET_VISUALDEBUGGER , however <b>please note</b> including this define adds extra debugging information as plain text that may not be wanted in final publicly released versions of applications.
 * <br>
 * Compile and link with ReplicaNetPublic/AmalgamatedReplicaNet.cpp<br>
 * This source file is the amalgamated source for the ReplicaNet and RNLobby client APIs from Replica Software. Individual source files are available in the full SDK. Be sure to set a path to the Includes directory.<br>
 * When not using ReplicaObject derived classes use the pre-processor define REPLICANET_NO_REPLICA_OBJECTS<br>
 * When not using RNLobby components use the pre-processor define REPLICANET_REMOVE_RNLOBBY<br>
 *
 */

/** \mainpage The ReplicaNet and RNLobby family
\ref ReplicaNet and \ref RNROLCompiler work together to provide a high level object oriented class management system.
ReplicaNet uses the session management features of \ref XPSession and this library can be used instead of ReplicaNet for those that only require data and session management.
The transport system used by XPSession and ReplicaNet is provided by \ref XPURL which includes a configurable reliable UDP protocol. XPURL uses \ref XPSockets which provides a thin platform agnostic socket layer.<br>

\ref RNLobby provides lobby and matchmaking services. It is a system designed to work with ReplicaNet / XPSession / XPURL but can also be used separately.<br>

\ref RNPlatform is a platform agnostic library providing support for serialisation, threads, synchronisation and other OS APIs.<br>
*/
//From: RNReplicaNet/ReplicaObject.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
//Skipping: #include "RNReplicaNet/Inc/ReplicaObject.h"
//Skipping: #include "RNReplicaNet/Inc/ReplicaNet.h"
//Skipping: #include "RNReplicaNet/ReplicaNetPrivate.h"
//Skipping: #include "RNReplicaNet/Inc/DataBlock.h"
//Skipping: #include "RNXPSession/Inc/XPSession.h"
#include "RNReplicaNet/Inc/ROConstants.h"
//Skipping: #include "RNReplicaNet/Inc/DataBlock_NData.h"
//Skipping: #include "RNPlatform/DebugSupport.h"
//Skipping: #include "RNPlatform/Options.h"
//Skipping: #include "RNXPURL/Inc/XPURL.h"
//Skipping: #include "RNXPURL/Inc/DebugHandler.h"

using namespace RNReplicaNet;

bool ReplicaObject::mDelayIDFetch = false;
bool ReplicaObject::mDelayBind = false;

ReplicaObject::ReplicaObject() : mIsMaster(true) , mUniqueID(kReplicaNetUnknownUniqueID) , mSessionID(kXPSessionUnknownID) ,
			mBoundReplicaNet(0) , mBeingDeleted(false) , mDataBlocksRegistered(false) , mFlagForLaterMigration(false) ,
			mOpaquePointer(0) , mOpaquePointerSet(false) , mIsReliable(true) , mIsCertain(false) , mIsOrdered(false) ,
			mTryingToGiveTo(kXPSessionUnknownID) , mObjectHasBeenAdded(false) ,
			mEnableLoadBalancing(false) , mLoadScore(0.0f) , mEnableLoadBalancingDefault(false) , mLoadScoreDefault(0.0f) ,
			mReflectSessionID(kReplicaNetUnknownUniqueID) ,
			mDistanceToSessionPropagate(kReplicaObject_InfiniteDistance), mDistanceToSessionPropagateDefault(kReplicaObject_InfiniteDistance) ,
			mDistanceToSessionPropagateOuter(kReplicaObject_InfiniteDistance), mDistanceToSessionPropagateOuterDefault(kReplicaObject_InfiniteDistance) ,
			mSessionPropagationFilter(false) , mEnableDistanceBased(false) , mDistanceBasedPollTime(0.0f) , mDistanceBasedLastTime(-1.0f) , mMasterOrReplicaDataBlockPollDone(false) ,
			mFullyQualifiedName(0) , mPostObjectCreateDone(false) , mProcessingDataBlocksFromSessionID(kXPSessionUnknownID) , mDelayDelete(false) ,
			mDelayDeleteSeconds(0.0f) , mDelayDeleteTime(0.0f) , mUpdateSendDormant(false) ,
			mDormantDelayActive(false) , mDormantDelayState(false) , mDormantDelaySeconds(0.0f) , mDormantDelayTime(0.0f) ,
			mBand(0) , mGetNewSessionIDAndUniqueIDCalled(false)
{
	// Lock this object to every thread except the calling thread
	THREADSAFELOCK();

	SetPropagateToSessionDistanceRecalculationDelay();
	mDistanceBasedLastTime = -mDistanceBasedPollTime*2;

	if (!mDelayBind)
	{
		if (mDelayIDFetch)
		{
			mBoundReplicaNet = ReplicaNet::GetCurrentReplicaNet();
#ifdef DEBUG_PRINTS6
			dprintf("ReplicaObject::ReplicaObject : $%p DelayIDFetch\n",this);
#endif
		}
		else
		{
			GetNewSessionIDAndUniqueID(ReplicaNet::GetCurrentReplicaNet());
		}
	}
	else
	{
#ifdef DEBUG_PRINTS6
		dprintf("ReplicaObject::ReplicaObject : $%p DelayBind\n",this);
#endif
	}
#ifdef DEBUG_PRINTS6
	dprintf("ReplicaObject::ReplicaObject : $%p SID%d UID%d M%d RID%d\n",this,
												GetSessionID(),
												GetUniqueID(),
												IsMaster(),
												GetMessageReflectionID());
#endif
}

bool ReplicaObject::GetNewSessionIDAndUniqueID(RNReplicaNet::ReplicaNet *toBindTo)
{
	if (toBindTo)
	{
		if ( mBoundReplicaNet )
		{
			assert( ( mBoundReplicaNet == toBindTo ) && "Attempting to rebind an already bound ReplicaObject to a different ReplicaNet instance" );
		}
		mBoundReplicaNet = toBindTo;
	}
	if (mBoundReplicaNet && !mObjectHasBeenAdded && !mGetNewSessionIDAndUniqueIDCalled)
	{
		mGetNewSessionIDAndUniqueIDCalled = true;
		mBoundReplicaNet->LockObjects();

		bool skip = false;
		if (mBoundReplicaNet->mPrivateReplicaNet->mIsPlayback && !mBoundReplicaNet->mPrivateReplicaNet->mInsideRecordCreate)
		{
			mIsMaster = true;
			mUniqueID = kReplicaObjectUnknownClassID;
			mSessionID = kReplicaObjectUnknownClassID;
			skip = true;
		}
		if (!skip)
		{
			mIsMaster = mBoundReplicaNet->GetMakeMaster();

			if (mIsMaster)
			{
				mPostObjectCreateDone = true;	// Master objects don't get post object create messages. Ever.
				mSessionID = mBoundReplicaNet->GetSessionID();
				mUniqueID = mBoundReplicaNet->CallbackGetObjectUniqueID(this);
			}
			else
			{
				mSessionID = mBoundReplicaNet->GetMakeSessionID();
				mUniqueID = mBoundReplicaNet->GetMakeUniqueID();
			}
		}
		mReflectSessionID = mBoundReplicaNet->mPrivateReplicaNet->mMakeMasterReflectID;

		mBoundReplicaNet->UnLockObjects();
		return true;
	}
	return false;
}

ReplicaObject::~ReplicaObject()
{
	// Lock this object to every thread except the calling thread
	THREADSAFELOCK();

#ifdef DEBUG_PRINTS6
	dprintf("ReplicaObject::~ReplicaObject : $%p SID%d UID%d M%d RID%d\n",this,
												GetSessionID(),
												GetUniqueID(),
												IsMaster(),
												GetMessageReflectionID());
#endif

	if (mBeingDeleted)
	{
		assert(false && "ReplicaObject already being deleted! Indicates threading problems. Is the object list locked for access?\n");
	}

	assert ( (mProcessingDataBlocksFromSessionID == kXPSessionUnknownID) && "Trying to delete ReplicaObject when processing DataBlock updates indicates this object is being deleted during a network function or the object list is not locked for access.");


	mBeingDeleted = true;

	ReplicaNet *LocalCopy = mBoundReplicaNet;
	if (LocalCopy)
	{
		LocalCopy->RemoveObject(this);
		mBoundReplicaNet = 0;
	}

	int i;
	for (i=0;i<(int)mDataBlocks.size();i++)
	{
		DataBlock *datablock = mDataBlocks[i];
		if (datablock && datablock->IsAllocated())
		{
			delete datablock;
		}
	}
	free(mFullyQualifiedName);
	mFullyQualifiedName = 0;
}

bool ReplicaObject::IsReplica(void) const
{
	return !mIsMaster;
}

bool ReplicaObject::IsMaster(void) const
{
	return mIsMaster;
}

bool ReplicaObject::IsPublished(void) const
{
	return mObjectHasBeenAdded;
}

void ReplicaObject::Publish(void)
{
	// If the object has not yet got its IDs then get them now.
	if (!mGetNewSessionIDAndUniqueIDCalled)
	{
		if (!mBoundReplicaNet)
		{
			GetNewSessionIDAndUniqueID(ReplicaNet::GetCurrentReplicaNet());
		}
		else
		{
			GetNewSessionIDAndUniqueID();
		}
	}

	assert(mGetNewSessionIDAndUniqueIDCalled && "This ReplicaObject instance has not had a successful call to GetNewSessionIDAndUniqueID() during instance creation. Is there a valid bound ReplicaNet instance?");
	assert(!mObjectHasBeenAdded && "Trying to call ReplicaObject::Publish() when this object has already been published or added to ReplicaNet\n");
	THREADSAFELOCK();

#ifdef DEBUG_PRINTS6
	dprintf("ReplicaObject::Publish : $%p SID%d UID%d CID%d M%d RID%d\n",this,
												GetSessionID(),
												GetUniqueID(),
												GetClassID(),
												IsMaster(),
												GetMessageReflectionID());
#endif

	if (mBoundReplicaNet)
	{
		assert (GetClassID() != kReplicaObjectUnknownClassID && "This object class has not been registered with ReplicaNet and it is being published\n");
		if (GetClassID() != kReplicaObjectUnknownClassID)
		{
			if (mBoundReplicaNet->mPrivateReplicaNet->mIsPlayback)
			{
				// Do nothing, we don't publish objects if we are playing back the session.
			}
			else
			{
				mBoundReplicaNet->AddObject(this);
			}
		}
	}
}

void ReplicaObject::Unpublish(void)
{
	THREADSAFELOCK();

#ifdef DEBUG_PRINTS6
	dprintf("ReplicaObject::Unpublish : $%p SID%d UID%d CID%d M%d RID%d\n",this,
												GetSessionID(),
												GetUniqueID(),
												GetClassID(),
												IsMaster(),
												GetMessageReflectionID());
#endif

	if (mBoundReplicaNet)
	{
		if (GetClassID() != kReplicaObjectUnknownClassID)
		{
			mBoundReplicaNet->RemoveObject(this,false);
		}
	}
}

int ReplicaObject::GetUniqueID(void)
{
	return mUniqueID;
}

int ReplicaObject::GetSessionID(void)
{
	return mSessionID;
}

void ReplicaObject::PreRegisterDataBlocks(void)
{
	THREADSAFELOCK();

	// We want to return here if we are not ready to do this
	if (mDataBlocksRegistered || !GetBoundReplicaNet())
	{
		return;
	}

	// Try to get the expected number of DataBlock classes from the derived object
	int numExpected = GetNumExpectedDataBlocks();
	if (numExpected > 0)
	{
		mDataBlocks.reserve((size_t)numExpected);
	}

	// Set this here now
	mDataBlocksRegistered = true;

	// Register some internal variables
	// These use the corresponding "default" values where appropriate to save bandwidth
	DataBlock *datablock;
	datablock = DataBlock_NData::Register(&mLoadScore,sizeof(mLoadScore));
	((DataBlock_NData *)datablock)->SetDefaultData(&mLoadScoreDefault);
	datablock->SetCertainFlag(true);
	datablock->SetReliableFlag(false);
	datablock->SetVariableName("_Internal_LoadScoreDefault");
	RegisterDataBlock(datablock);

	datablock = DataBlock_NData::Register(&mEnableLoadBalancing,sizeof(mEnableLoadBalancing));
	((DataBlock_NData *)datablock)->SetDefaultData(&mEnableLoadBalancingDefault);
	datablock->SetCertainFlag(true);
	datablock->SetReliableFlag(false);
	datablock->SetVariableName("_Internal_EnableLoadBalancingDefault");
	RegisterDataBlock(datablock);

	datablock = DataBlock_NData::Register(&mDistanceToSessionPropagate,sizeof(mDistanceToSessionPropagate));
	((DataBlock_NData *)datablock)->SetDefaultData(&mDistanceToSessionPropagateDefault);
	datablock->SetCertainFlag(true);
	datablock->SetReliableFlag(false);
	datablock->SetVariableName("_Internal_DistanceToSessionPropagate");
	RegisterDataBlock(datablock);

	datablock = DataBlock_NData::Register(&mDistanceToSessionPropagateOuter,sizeof(mDistanceToSessionPropagateOuter));
	((DataBlock_NData *)datablock)->SetDefaultData(&mDistanceToSessionPropagateOuterDefault);
	datablock->SetCertainFlag(true);
	datablock->SetReliableFlag(false);
	datablock->SetVariableName("_Internal_DistanceToSessionPropagateOuter");
	RegisterDataBlock(datablock);

	// Then register the ROL defined data blocks
	RegisterDataBlocks();		// Virtual function call

	// Then add the pre-registered datablocks
	int i;
	for (i=0;i<(int)mAutoRegister.size();i++)
	{
		RegisterDataBlock(mAutoRegister[i]);
	}

	// And lastly call the user function to see if we need to add any extra blocks
	UserRegisterDataBlocks();	// Virtual function call

	// Only do this once if the expected number of DataBlocks is not set by anything else
	if ( numExpected == -1 )
	{
		SetNumExpectedDataBlocks((int)mDataBlocks.size());
	}
}

void ReplicaObject::RegisterDataBlocks(void)
{
}

void ReplicaObject::UserRegisterDataBlocks(void)
{
}

void ReplicaObject::RegisterDataBlock(DataBlock *datablock)
{
	THREADSAFELOCK();
	assert(datablock);

	datablock->BindReplicaNet(GetBoundReplicaNet());
	datablock->BindReplicaObject(this);

	int size = (int)mDataBlocks.size();
	datablock->SetID(size);
	mDataBlocks.push_back(datablock);
}

ReplicaNet *ReplicaObject::GetBoundReplicaNet(void)
{
	THREADSAFELOCK();

	return mBoundReplicaNet;
}

bool ReplicaObject::ApproveFault(void)
{
	return false;
}

bool ReplicaObject::ApproveMigration(void)
{
	return false;
}

void ReplicaObject::OwnerChange(void)
{
}

float ReplicaObject::GetDistanceToObject(ReplicaObject *object)
{
	if (!object)
	{
		return kReplicaObject_InfiniteDistance;
	}
	return CalculateDistanceToObject(object);
}

float ReplicaObject::CalculateDistanceToObject(ReplicaObject *object)
{
	if (!object)
	{
		return kReplicaObject_InfiniteDistance;
	}

	return kReplicaObject_InfiniteDistance;
}

void ReplicaObject::SetOpaquePointer(void *data)
{
	mOpaquePointerSet = true;
	mOpaquePointer = data;
}

void *ReplicaObject::GetOpaquePointer(void *data)
{
	if (!mOpaquePointerSet)
	{
		THREADSAFELOCK();
		mOpaquePointerSet = true;
		_Internal_SetupOpaquePointer();
	}
	return mOpaquePointer;
}

DataBlock *ReplicaObject::FindDataBlock(void *pdata)
{
	THREADSAFELOCK();
	
	// Ensure they are allocated
	PreRegisterDataBlocks();

	int i;
	for (i=0;i<(int)mDataBlocks.size();i++)
	{
		if (mDataBlocks[i]->IsAttached(pdata))
		{
			return mDataBlocks[i];
		}
	}
	return 0;
}

void ReplicaObject::GiveDeltaHint(float &variable,float delta)
{
	THREADSAFELOCK();

	if (!IsMaster())
	{
		return;
	}

	DataBlock *datablock = FindDataBlock(&variable);
	if (datablock)
	{
		datablock->GiveDeltaHint(delta);
	}
}

void ReplicaObject::ContinuityBreak(float &variable,unsigned char breakTypes)
{
	THREADSAFELOCK();

	if (!IsMaster())
	{
		return;
	}

	DataBlock *datablock = FindDataBlock(&variable);
	if (datablock)
	{
		datablock->ContinuityBreak(breakTypes);
	}
}

void ReplicaObject::GiveOwnership(int sessionID)
{
	THREADSAFELOCK();
	
	if (!mBoundReplicaNet)
	{
		return;
	}

	mBoundReplicaNet->GiveOwnership(this,sessionID);
}

void ReplicaObject::RequestOwnership(void)
{
	THREADSAFELOCK();
	
	if (!mBoundReplicaNet)
	{
		return;
	}

	mBoundReplicaNet->RequestOwnership(this);
}

void ReplicaObject::UpdateSetReliable(void)
{
	THREADSAFELOCK();
	mIsReliable = true;
	mIsCertain = false;
	mIsOrdered = false;
}

void ReplicaObject::UpdateSetCertain(void)
{
	THREADSAFELOCK();
	mIsReliable = false;
	mIsCertain = true;
	mIsOrdered = false;
}

void ReplicaObject::UpdateSetUnreliable(void)
{
	THREADSAFELOCK();
	mIsReliable = false;
	mIsCertain = false;
	mIsOrdered = false;
}

void ReplicaObject::UpdateSetOrdered(void)
{
	THREADSAFELOCK();
	mIsReliable = false;
	mIsCertain = false;
	mIsOrdered = true;
}

bool ReplicaObject::UpdateIsReliable(void)
{
	return mIsReliable;
}

bool ReplicaObject::UpdateIsCertain(void)
{
	return mIsCertain;
}

bool ReplicaObject::UpdateIsUnreliable(void)
{
	if (!mIsCertain && !mIsReliable && !mIsOrdered)
	{
		return true;
	}
	return false;
}

bool ReplicaObject::UpdateIsOrdered(void)
{
	return mIsOrdered;
}

float ReplicaObject::GetLoadScore(void)
{
	return mLoadScore;
}

void ReplicaObject::SetLoadScore(const float load)
{
	THREADSAFELOCK();

	if (!IsMaster())
	{
		return;
	}

	float oldload = mLoadScore;
	mLoadScore = load;

	if (mBoundReplicaNet)
	{
		mBoundReplicaNet->LoadChangedForObject(this,oldload,mLoadScore);
	}
}

void ReplicaObject::SetLoadScoreDefault(const float load)
{
	THREADSAFELOCK();

	mLoadScoreDefault = load;

	DataBlock *datablock = FindDataBlock(&mLoadScore);
	if (datablock)
	{
		((DataBlock_NData *)datablock)->SetDefaultData(&mLoadScoreDefault);
	}
}

void ReplicaObject::SetLoadBalancing(const bool enable)
{
	mEnableLoadBalancing = enable;
}

void ReplicaObject::SetLoadBalancingDefault(const bool enable)
{
	THREADSAFELOCK();

	mEnableLoadBalancingDefault = enable;

	DataBlock *datablock = FindDataBlock(&mEnableLoadBalancing);
	if (datablock)
	{
		((DataBlock_NData *)datablock)->SetDefaultData(&mEnableLoadBalancingDefault);
	}
}

bool ReplicaObject::GetLoadBalancing(void)
{
	return mEnableLoadBalancing;
}

void ReplicaObject::PostObjectCreate(void)
{
}

void ReplicaObject::AddAutoRegisterDataBlock(DataBlock *const dataBlock)
{
	mAutoRegister.push_back(dataBlock);
}

void ReplicaObject::SetMessageReflectionID(const int sessionID)
{
	if (!mObjectHasBeenAdded)
	{
		if (sessionID != mSessionID)
		{
			mReflectSessionID = sessionID;
		}
	}
}

int ReplicaObject::GetMessageReflectionID(void) const
{
	return mReflectSessionID;
}


// Object propagate distance to session variable management
void ReplicaObject::SetPropagateToSessionDistance(const float distance)
{
	mDistanceToSessionPropagate = distance;
	mDistanceToSessionPropagateOuter = distance;

	if (distance == kReplicaObject_InfiniteDistance)
	{
		mSessionPropagationFilter = false;
		mEnableDistanceBased = false;
		return;
	}

	mSessionPropagationFilter = true;
	mEnableDistanceBased = true;
}

void ReplicaObject::SetPropagateToSessionDistanceInclude(const float distance)
{
	mDistanceToSessionPropagate = distance;

	if (distance == kReplicaObject_InfiniteDistance)
	{
		mSessionPropagationFilter = false;
		mEnableDistanceBased = false;
		return;
	}

	mSessionPropagationFilter = true;
	mEnableDistanceBased = true;
}

void ReplicaObject::SetPropagateToSessionDistanceExclude(const float distance)
{
	mDistanceToSessionPropagateOuter = distance;

	if (distance == kReplicaObject_InfiniteDistance)
	{
		mSessionPropagationFilter = false;
		mEnableDistanceBased = false;
		return;
	}

	mSessionPropagationFilter = true;
	mEnableDistanceBased = true;
}



void ReplicaObject::SetPropagateToSessionDistanceDefault(const float distance)
{
	mDistanceToSessionPropagateDefault = distance;
	mDistanceToSessionPropagateOuterDefault = distance;

	DataBlock *datablock = FindDataBlock(&mDistanceToSessionPropagate);
	if (datablock)
	{
		((DataBlock_NData *)datablock)->SetDefaultData(&mDistanceToSessionPropagateDefault);
	}

	datablock = FindDataBlock(&mDistanceToSessionPropagateOuter);
	if (datablock)
	{
		((DataBlock_NData *)datablock)->SetDefaultData(&mDistanceToSessionPropagateOuterDefault);
	}
}

void ReplicaObject::SetPropagateToSessionDistanceIncludeDefault(const float distance)
{
	mDistanceToSessionPropagateDefault = distance;

	DataBlock *datablock = FindDataBlock(&mDistanceToSessionPropagate);
	if (datablock)
	{
		((DataBlock_NData *)datablock)->SetDefaultData(&mDistanceToSessionPropagateDefault);
	}
}

void ReplicaObject::SetPropagateToSessionDistanceExcludeDefault(const float distance)
{
	mDistanceToSessionPropagateOuterDefault = distance;

	DataBlock *datablock = FindDataBlock(&mDistanceToSessionPropagateOuter);
	if (datablock)
	{
		((DataBlock_NData *)datablock)->SetDefaultData(&mDistanceToSessionPropagateOuterDefault);
	}
}

float ReplicaObject::GetPropagateToSessionDistance(void) const
{
	return mDistanceToSessionPropagate;
}

float ReplicaObject::GetPropagateToSessionDistanceInclude(void) const
{
	return mDistanceToSessionPropagate;
}

float ReplicaObject::GetPropagateToSessionDistanceExclude(void) const
{
	return mDistanceToSessionPropagateOuter;
}

ReplicaObject *ReplicaObject::AllocateForReplicaNet(void)
{
	assert(false && "The implementation of ReplicaObject::AllocateForReplicaNet() has not been implemented in the derived class");
	return 0;
}

void ReplicaObject::DeleteForReplicaNet(ReplicaObject *object)
{
	assert(false && "The implementation of ReplicaObject::DeleteForReplicaNet() has not been implemented in the derived class");
}


void ReplicaObject::SetSessionPropagationFilter(const bool enable)
{
	if (mObjectHasBeenAdded)
	{
		return;
	}

	if (mEnableDistanceBased)
	{
		mEnableDistanceBased = false;
	}

	mSessionPropagationFilter = enable;
}

bool ReplicaObject::GetSessionPropagationFilter(void) const
{
	if (mEnableDistanceBased)
	{
		return false;
	}
	return mSessionPropagationFilter;
}

void ReplicaObject::GetSessionPropagationSet(std::set<int> &theSet)
{
	THREADSAFELOCK();

	theSet.clear();
	theSet = mSessionPropagationFilterIDs;
}

bool ReplicaObject::SessionPropagationAddSession(const int sessionID)
{
	if (!mSessionPropagationFilter)
	{
		return false;
	}

	THREADSAFELOCK();

	std::pair<std::set<int>::iterator,bool> ret;
	ret = mSessionPropagationFilterIDs.insert(sessionID);
	// Did it insert?
	if (ret.second)
	{
		// If yes
		mSessionPropagationFilterDelaySlotAdd.insert(sessionID);
		return true;
	}
	return false;
}

bool ReplicaObject::SessionPropagationRemoveSession(const int sessionID)
{
	if (!mSessionPropagationFilter)
	{
		return false;
	}

	THREADSAFELOCK();

	size_t erased = mSessionPropagationFilterIDs.erase(sessionID);
	if (erased > 0)
	{
		// If there was a sessionID erased then check the add list and clear it out if required.
		mSessionPropagationFilterDelaySlotAdd.erase(sessionID);
		mSessionPropagationFilterDelaySlotRemove.insert(sessionID);
		return true;
	}
	return false;
}

void ReplicaObject::DataBlockPacketDataReceived(const DataBlock *datablock)
{
}

void ReplicaObject::DataBlockPacketDataReceivedPost(const DataBlock *datablock)
{
}

void ReplicaObject::PollInternalForDistance(const SysTimeType localTime,ReplicaObject *observer,const int sessionID)
{
	if (!mBoundReplicaNet)
	{
		return;
	}

	if (!mEnableDistanceBased)
	{
		return;
	}

	THREADSAFELOCK();

	float distance = GetDistanceToObject(observer);
	// If it is within the distance
	if ((distance <= mDistanceToSessionPropagate) || (distance == kReplicaObject_InfiniteDistance))
	{
		SessionPropagationAddSession(sessionID);
	}
	else if (distance > mDistanceToSessionPropagateOuter)
	{
		SessionPropagationRemoveSession(sessionID);
	}
}

void ReplicaObject::SetPropagateToSessionDistanceRecalculationDelay(const float delay)
{
	THREADSAFELOCK();

	if (delay < 0)
	{
		return;
	}

	mDistanceBasedPollTime = delay;
	// Causes a refresh the next tick.
	mDistanceBasedLastTime = -mDistanceBasedPollTime*2;
}

void ReplicaObject::_Internal_SetFullyQualifiedName(const char *name)
{
	THREADSAFELOCK();

	free(mFullyQualifiedName);
	mFullyQualifiedName = 0;

	if (!name)
	{
		name = "<Unknown>";
	}

	char buffer[1024];
	sprintf(buffer,"ReplicaNet.%s.Session %d.ID %d",name,GetSessionID(),GetUniqueID());

	mFullyQualifiedName = (char *) malloc(strlen(buffer)+1);
	strcpy(mFullyQualifiedName,buffer);
}

const char *ReplicaObject::_Internal_GetFullyQualifiedName(void)
{
	return mFullyQualifiedName;
}


void ReplicaObject::_DebugInternal_EmitClassCreate(const int packetSize,const int toSession)
{
#ifndef _FINAL
	if (RNReplicaNet::XPURL::GetDebugHandler())
	{
		RNReplicaNet::XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s\n\
_PacketSize\n\
%d\n\
Session ID\n%d\n\
Unique ID\n%d\n\
Reflect Session Id\n%d\n\
To Session Id\n%d\n\
::_EndClass\n\
::_Flush\n",
		GetBoundReplicaNet()->GetLocalTime(),
		_Internal_GetFullyQualifiedName(),
		packetSize,
		GetSessionID(),
		GetUniqueID(),
		GetMessageReflectionID(),
		toSession
		);

			XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s.ReplicaObject.ClassID %d\n\
::_EndClass\n\
::_Flush\n\
",
			GetBoundReplicaNet()->GetLocalTime(),
			_Internal_GetFullyQualifiedName(),
			GetClassID()
			);

		if (mIsReliable)
		{
			XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s.ReplicaObject.Is Reliable\nbool\ntrue\n\
::_EndClass\n\
::_Flush\n\
",
			GetBoundReplicaNet()->GetLocalTime(),
			_Internal_GetFullyQualifiedName()
			);
			return;
		}
		if (mIsOrdered)
		{
			XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
											 ::%s.ReplicaObject.Is Ordered\nbool\ntrue\n\
											 ::_EndClass\n\
											 ::_Flush\n\
											 ",
											 GetBoundReplicaNet()->GetLocalTime(),
											 _Internal_GetFullyQualifiedName()
											 );
			return;
		}
		if (mIsCertain)
		{
			XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s.ReplicaObject.Is Certain\nbool\ntrue\n\
::_EndClass\n\
::_Flush\n\
",
			GetBoundReplicaNet()->GetLocalTime(),
			_Internal_GetFullyQualifiedName()
			);
			return;
		}
		if (!mIsReliable && !mIsCertain && !mIsOrdered)
		{
			XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::%s.ReplicaObject.Is Unreliable\nbool\ntrue\n\
::_EndClass\n\
::_Flush\n\
",
			GetBoundReplicaNet()->GetLocalTime(),
			_Internal_GetFullyQualifiedName()
			);
			return;
		}
	}
#endif
}

void ReplicaObject::_DebugInternal_EmitClassDelete(const int packetSize,const int toSession)
{
#ifndef _FINAL
	if (RNReplicaNet::XPURL::GetDebugHandler())
	{
		RNReplicaNet::XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::~%s\n\
_PacketSize\n\
%d\n\
To Session Id\n%d\n\
::_EndClass\n\
::_Flush\n",	\
		GetBoundReplicaNet()->GetLocalTime(),
		_Internal_GetFullyQualifiedName(),
		packetSize,
		toSession
		);
	}
#endif
}

void ReplicaObject::_DebugInternal_EmitClassUnpublish(const int packetSize,const int toSession)
{
#ifndef _FINAL
	if (RNReplicaNet::XPURL::GetDebugHandler())
	{
		RNReplicaNet::XPURL::GetDebugHandler()->Printf("::_Time\n%f\n\
::~%s\n\
_PacketSize\n\
%d\n\
Unpublish to Session Id\n%d\n\
::_EndClass\n\
::_Flush\n",	\
		GetBoundReplicaNet()->GetLocalTime(),
		_Internal_GetFullyQualifiedName(),
		packetSize,
		toSession
		);
	}
#endif
}

void ReplicaObject::DataSend(const int sessionid,const void *data,const int length,const PacketType type,const unsigned int band)
{
	THREADSAFELOCK();

#ifdef DEBUG_PRINTS6
	dprintf("ReplicaObject::DataSend : $%p SID%d UID%d\n",this,
												GetSessionID(),
												GetUniqueID());
#endif

	ReplicaNet::PacketType theType = ReplicaNet::kPacket_Reliable;
	switch(type)
	{
		case kPacket_Ordered:
			theType = ReplicaNet::kPacket_Ordered;
			break;
		case kPacket_Certain:
			theType = ReplicaNet::kPacket_Certain;
			break;
		case kPacket_Unreliable:
			theType = ReplicaNet::kPacket_Unreliable;
			break;
		case kPacket_Reliable:
		default:
			theType = ReplicaNet::kPacket_Reliable;
			break;
	}

	if (mBoundReplicaNet)
	{
		mBoundReplicaNet->ReplicaObjectDataSend(sessionid,data,length,theType,this,band);
	}
}

void ReplicaObject::CallBackDataReceive(const int fromsessionid,const void *data,const int length,const PacketType type)
{
#ifdef DEBUG_PRINTS6
	dprintf("ReplicaObject::CallBackDataReceive : $%p SID%d UID%d Unhandled\n",this,
												GetSessionID(),
												GetUniqueID());
#endif
}

void ReplicaObject::CallbackObjectUnpublishPre(void)
{
}

void ReplicaObject::CallbackObjectUnpublishPost(void)
{
}

int ReplicaObject::GetProcessingDataBlocksFromSessionID(void)
{
	return mProcessingDataBlocksFromSessionID;
}

void ReplicaObject::DelayedDelete(const float delaySeconds)
{
	mDelayDeleteSeconds = delaySeconds;
	if (mBoundReplicaNet)
	{
		if (delaySeconds < 0.0f)
		{
			mDelayDeleteTime = mBoundReplicaNet->GetLocalTime();
		}
		else
		{
			mDelayDeleteTime = mBoundReplicaNet->GetLocalTime() + delaySeconds;
		}
	}
	mDelayDelete = true;
}

void ReplicaObject::DelayedDeleteCancel(void)
{
	mDelayDelete = false;
}

bool ReplicaObject::GetDelayedDelete(void)
{
	return mDelayDelete;
}

bool ReplicaObject::GetDelayedDelete(float &delaySeconds)
{
	if (mDelayDelete)
	{
		delaySeconds = mDelayDeleteSeconds;
	}
	return mDelayDelete;
}

void ReplicaObject::UpdateSendDormant(const bool dormant)
{
	mUpdateSendDormant = dormant;
}

bool ReplicaObject::GetUpdateSendDormant(void) const
{
	return mUpdateSendDormant;
}

void ReplicaObject::UpdateSendDormantDelay(const bool dormant,const float delaySeconds)
{
	mDormantDelayState = dormant;
	mDormantDelaySeconds = delaySeconds;

	if (delaySeconds <= 0.0f)
	{
		UpdateSendDormantDelayStateChange(dormant);
		UpdateSendDormant(dormant);
		return;
	}
	if (mBoundReplicaNet)
	{
		mDormantDelayTime = mBoundReplicaNet->GetLocalTime() + delaySeconds;
		mDormantDelayActive = true;
	}
}

void ReplicaObject::UpdateSendDormantDelayCancel(void)
{
	mDormantDelayActive = false;
}

bool ReplicaObject::GetUpdateSendDormantDelay(bool &dormant,float &delaySeconds) const
{
	if (!mDormantDelayActive)
	{
		return false;
	}

	dormant = mDormantDelayState;
	delaySeconds = mDormantDelaySeconds;
	return true;
}

void ReplicaObject::UpdateSendDormantDelayStateChange(const bool dormant)
{
}

void ReplicaObject::SetBand(const unsigned int band)
{
	mBand = band;
}

unsigned int ReplicaObject::GetBand(void) const
{
	return mBand;
}

void ReplicaObject::SetDelayIDFetch(const bool delay)
{
	mDelayIDFetch = delay;
}

bool ReplicaObject::GetDelayIDFetch(void)
{
	return mDelayIDFetch;
}

void ReplicaObject::SetDelayBind(const bool delay)
{
	mDelayBind = delay;
}

bool ReplicaObject::GetDelayBind(void)
{
	return mDelayBind;
}

void ReplicaObject::SetNumExpectedDataBlocks(const int expected)
{
}

int ReplicaObject::GetNumExpectedDataBlocks(void)
{
	return -1;
}
//From: RNReplicaNet/RO_RegistryBlock.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
//Skipping: #include "RNReplicaNet/Inc/RO_RegistryBlock.h"

using namespace RNReplicaNet;

s_RO_RegistryBlock::s_RO_RegistryBlock(int id,p_RO_Func *pfunc,p_RO_FuncDelete *pfunc_delete,const char *name)
{
	mID = id;
	mFunc = pfunc;
	mFuncDelete = pfunc_delete;
	mName = name;
}

int s_RO_RegistryBlock::GetClassID(void)
{
	return mID;
}

ReplicaObject *s_RO_RegistryBlock::CallBackAllocate(void)
{
	return (*mFunc)();
}

void s_RO_RegistryBlock::CallBackDelete(ReplicaObject *object)
{
	(*mFuncDelete)(object);
}

const char *s_RO_RegistryBlock::GetName(void) const
{
	return mName;
}

//From: RNReplicaNet/ReplicaNetPublic.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
//Skipping: #include "RNReplicaNet/Inc/ReplicaNet.h"
//Skipping: #include "RNReplicaNet/Inc/RO_RegistryBlock.h"
//Skipping: #include "RNReplicaNet/ReplicaNetPrivate.h"

using namespace RNReplicaNet;

ReplicaNet::ReplicaNet() : mPrivateReplicaNet(0)
{
	mPrivateReplicaNet = new ReplicaNetPrivate(this);
	mPrivateReplicaNet->PostCtorStageInit();
}

ReplicaNet::~ReplicaNet()
{
	delete mPrivateReplicaNet;
}

ReplicaNet *ReplicaNet::GetCurrentReplicaNet(void)
{
	return ReplicaNetPrivate::GetCurrentReplicaNet();
}

void ReplicaNet::SetCurrentReplicaNet(ReplicaNet *const replicanet)
{
	ReplicaNetPrivate::SetCurrentReplicaNet(replicanet);
}

ReplicaObject *ReplicaNet::AllocateReplicaObject(const int class_id,const int sessionid,const int uniqueid,const int reflect)
{
	return mPrivateReplicaNet->AllocateReplicaObject(class_id,sessionid,uniqueid,reflect);
}

bool ReplicaNet::GetMakeMaster(void)
{
	return mPrivateReplicaNet->GetMakeMaster();
}

int ReplicaNet::CallbackGetObjectUniqueID(ReplicaObject *object)
{
	return mPrivateReplicaNet->CallbackGetObjectUniqueID(object);
}

int ReplicaNet::GetSessionID(void)
{
	return mPrivateReplicaNet->GetSessionID();
}

void ReplicaNet::AddObject(ReplicaObject *const object)
{
	mPrivateReplicaNet->AddObject(object);
}

void ReplicaNet::RemoveObject(ReplicaObject *const object,const bool sendDelete)
{
	mPrivateReplicaNet->RemoveObject(object,sendDelete);
}

int ReplicaNet::GetGameChannel(void)
{
	return mPrivateReplicaNet->GetGameChannel();
}

void ReplicaNet::SetGameChannel(const int channel)
{
	mPrivateReplicaNet->SetGameChannel(channel);
}

void ReplicaNet::SessionCreate(const std::string name,const std::string protocols)
{
	mPrivateReplicaNet->SessionCreate(name,protocols);
}

void ReplicaNet::SessionCreate(const std::string name)
{
	mPrivateReplicaNet->SessionCreate(name);
}

std::string ReplicaNet::SessionExportURL(void)
{
	return mPrivateReplicaNet->SessionExportURL();
}

void ReplicaNet::SessionJoin(const std::string url)
{
	mPrivateReplicaNet->SessionJoin(url);
}

void ReplicaNet::Poll(void)
{
	mPrivateReplicaNet->Poll();
}

//void ReplicaNet::TakeOverObject(ReplicaObject *object)
//{
//	mPrivateReplicaNet->TakeOverObject(object);
//}

void ReplicaNet::SessionFind(void)
{
	mPrivateReplicaNet->SessionFind();
}

void ReplicaNet::SessionFind(const std::string protocols)
{
	mPrivateReplicaNet->SessionFind(protocols);
}

std::string ReplicaNet::SessionEnumerateFound(void)
{
	return mPrivateReplicaNet->SessionEnumerateFound();
}

int ReplicaNet::GetMakeUniqueID(void)
{
	return mPrivateReplicaNet->GetMakeUniqueID();
}

int ReplicaNet::GetMakeSessionID(void)
{
	return mPrivateReplicaNet->GetMakeSessionID();
}

void ReplicaNet::LockObjects(void)
{
	mPrivateReplicaNet->LockObjects();
}

void ReplicaNet::UnLockObjects(void)
{
	mPrivateReplicaNet->UnLockObjects();
}

float ReplicaNet::GetNetworkSendRate(void)
{
	return mPrivateReplicaNet->GetNetworkSendRate();
}

float ReplicaNet::GetNetworkReceiveRate(void)
{
	return mPrivateReplicaNet->GetNetworkReceiveRate();
}

int ReplicaNet::GetNetworkPacketsLost(void)
{
	return mPrivateReplicaNet->GetNetworkPacketsLost();
}

int ReplicaNet::GetNetworkPacketsRejected(void)
{
	return mPrivateReplicaNet->GetNetworkPacketsRejected();
}

SysTimeType ReplicaNet::GetTime(void)
{
	return mPrivateReplicaNet->GetTime();
}

SysTimeType ReplicaNet::GetLocalTime(void)
{
	return mPrivateReplicaNet->GetLocalTime();
}

void ReplicaNet::SetObserver(ReplicaObject *const object)
{
	mPrivateReplicaNet->SetObserver(object);
}

ReplicaObject *ReplicaNet::GetObserver(void)
{
	return mPrivateReplicaNet->GetObserver();
}

void ReplicaNet::GiveOwnership(ReplicaObject *const object,const int sessionID)
{
	mPrivateReplicaNet->GiveOwnership(object,sessionID);
}

void ReplicaNet::RequestOwnership(ReplicaObject *const object)
{
	mPrivateReplicaNet->RequestOwnership(object);
}

void ReplicaNet::SetCanSpider(const bool canSpider)
{
	mPrivateReplicaNet->SetCanSpider(canSpider);
}

bool ReplicaNet::GetCanSpider(void)
{
	return mPrivateReplicaNet->GetCanSpider();
}

float ReplicaNet::GetLatencyToMasterSession(void)
{
	return mPrivateReplicaNet->GetLatencyToMasterSession();
}

float ReplicaNet::GetLatencyToSessionID(const int sessionID)
{
	return mPrivateReplicaNet->GetLatencyToSessionID(sessionID);
}

void ReplicaNet::SetLatencyRecalculationDelay(const float seconds)
{
	mPrivateReplicaNet->SetLatencyRecalculationDelay(seconds);
}

bool ReplicaNet::IsMaster(void)
{
	return mPrivateReplicaNet->IsMaster();
}

bool ReplicaNet::IsStable(void)
{
	return mPrivateReplicaNet->IsStable();
}

void ReplicaNet::SetManualPoll(void)
{
	mPrivateReplicaNet->SetManualPoll();
}

void ReplicaNet::SetAutomaticPoll(void)
{
	mPrivateReplicaNet->SetAutomaticPoll();
}

void ReplicaNet::SetCanBecomeMaster(const bool canBeMaster)
{
	mPrivateReplicaNet->SetCanBecomeMaster(canBeMaster);
}

bool ReplicaNet::GetCanBecomeMaster(void)
{
	return mPrivateReplicaNet->GetCanBecomeMaster();
}

ReplicaNet::Error ReplicaNet::GetStatus(void)
{
	return mPrivateReplicaNet->GetStatus();
}

void ReplicaNet::SetOnSessionError(const OnError whatToDo)
{
	mPrivateReplicaNet->SetOnSessionError(whatToDo);
}

ReplicaNet::OnError ReplicaNet::GetOnSessionErrorMigrateObjects(void)
{
	return mPrivateReplicaNet->GetOnSessionErrorMigrateObjects();
}

void ReplicaNet::SetCanAcceptObjects(bool accept)
{
	mPrivateReplicaNet->SetCanAcceptObjects(accept);
}

bool ReplicaNet::GetCanAcceptObjects(void)
{
	return mPrivateReplicaNet->GetCanAcceptObjects();
}

void ReplicaNet::SetManualPollXPSession(void)
{
	mPrivateReplicaNet->SetManualPollXPSession();
}

void ReplicaNet::SetAutomaticPollXPSession(void)
{
	mPrivateReplicaNet->SetAutomaticPollXPSession();
}

void ReplicaNet::SetManualPollXPURL(void)
{
	mPrivateReplicaNet->SetManualPollXPURL();
}

void ReplicaNet::SetAutomaticPollXPURL(void)
{
	mPrivateReplicaNet->SetAutomaticPollXPURL();
}

void ReplicaNet::SetEncryption(const bool enable)
{
	mPrivateReplicaNet->SetEncryption(enable);
}

bool ReplicaNet::GetEncryption(void)
{
	return mPrivateReplicaNet->GetEncryption();
}

void ReplicaNet::SetLoadBalancing(const bool enable)
{
	mPrivateReplicaNet->SetLoadBalancing(enable);
}

bool ReplicaNet::GetLoadBalancing(void)
{
	return mPrivateReplicaNet->GetLoadBalancing();
}

void ReplicaNet::SetMaximumLoad(float load)
{
	mPrivateReplicaNet->SetMaximumLoad(load);
}

float ReplicaNet::GetMaximumLoad(int sessionID)
{
	return mPrivateReplicaNet->GetMaximumLoad(sessionID);
}

void ReplicaNet::LoadChangedForObject(ReplicaObject *object,float previousLoad,float newLoad)
{
	mPrivateReplicaNet->LoadChangedForObject(object,previousLoad,newLoad);
}

float ReplicaNet::GetTotalLoad(int sessionID)
{
	return mPrivateReplicaNet->GetTotalLoad(sessionID);
}

void ReplicaNet::ObjectListBeginIterate(void)
{
	mPrivateReplicaNet->ObjectListBeginIterate();
}

void ReplicaNet::ObjectListFinishIterate(void)
{
	mPrivateReplicaNet->ObjectListFinishIterate();
}

ReplicaObject *ReplicaNet::ObjectListIterate(void)
{
	return mPrivateReplicaNet->ObjectListIterate();
}

ReplicaObject *ReplicaNet::ObjectListFind(const int sessionID,const int uniqueID)
{
	return mPrivateReplicaNet->ObjectListFind(sessionID,uniqueID);
}

void ReplicaNet::SetPollLayerBelow(bool enable)
{
	mPrivateReplicaNet->SetPollLayerBelow(enable);
}

bool ReplicaNet::GetPollLayerBelow(void)
{
	return mPrivateReplicaNet->GetPollLayerBelow();
}

void ReplicaNet::SetPollLayerBelowForXPSession(bool enable)
{
	mPrivateReplicaNet->SetPollLayerBelowForXPSession(enable);
}

bool ReplicaNet::GetPollLayerBelowForXPSession(void)
{
	return mPrivateReplicaNet->GetPollLayerBelowForXPSession();
}


void ReplicaNet::AddItem(s_RO_RegistryBlock *block)
{
	assert(block);
	int value = block->GetClassID();
	mPrivateReplicaNet->AddItem(value,block);
}


void ReplicaNet::JoinerSessionIDPre(const int /*sessionID*/)
{
}

void ReplicaNet::JoinerSessionIDPost(const int /*sessionID*/)
{
}

void ReplicaNet::LeaverSessionIDPre(const int /*sessionID*/)
{
}

void ReplicaNet::LeaverSessionIDPost(const int /*sessionID*/)
{
}



void ReplicaNet::Disconnect(const int sessionID)
{
	mPrivateReplicaNet->Disconnect(sessionID);
}

bool ReplicaNet::GetPreConnectStatus(void)
{
	return mPrivateReplicaNet->GetPreConnectStatus();
}

void ReplicaNet::SetPreConnect(const bool enable)
{
	mPrivateReplicaNet->SetPreConnect(enable);
}

bool ReplicaNet::GetPreConnect(void)
{
	return mPrivateReplicaNet->GetPreConnect();
}

void ReplicaNet::PreConnectHasFinished(void)
{
	mPrivateReplicaNet->PreConnectHasFinished();
}

void ReplicaNet::DataSend(const int sessionid,const void *data,const int length,const PacketType type,const unsigned int band)
{
	mPrivateReplicaNet->DataSend(sessionid,data,length,type,band);
}

bool ReplicaNet::DataReceive(int *const fromsessionid,void *const data,int *const length,PacketType *const type)
{
	return mPrivateReplicaNet->DataReceive(fromsessionid,data,length,type);
}

bool ReplicaNet::DataReceivePeek(int *const fromsessionid,int *const length,PacketType *const type)
{
	return mPrivateReplicaNet->DataReceivePeek(fromsessionid,length,type);
}


void ReplicaNet::SetDataRetention(const bool enable)
{
	mPrivateReplicaNet->SetDataRetention(enable);
}

bool ReplicaNet::GetDataRetention(void) const
{
	return mPrivateReplicaNet->GetDataRetention();
}

void ReplicaNet::SetDataBlockUpdatePolicy(const bool automatic)
{
	mPrivateReplicaNet->SetDataBlockUpdatePolicy(automatic);
}

bool ReplicaNet::GetDataBlockUpdatePolicy(void) const
{
	return mPrivateReplicaNet->GetDataBlockUpdatePolicy();
}

void ReplicaNet::ProcessDataBlockUpdate(void)
{
	mPrivateReplicaNet->ProcessDataBlockUpdate();
}

void ReplicaNet::SetAutomaticPacketCompression(const bool enable)
{
	mPrivateReplicaNet->SetAutomaticPacketCompression(enable);
}

bool ReplicaNet::GetAutomaticPacketCompression(void)
{
	return mPrivateReplicaNet->GetAutomaticPacketCompression();
}


void ReplicaNet::GetCompressionStatistics(int *const before,int *const after,const bool reset)
{
	mPrivateReplicaNet->GetCompressionStatistics(before,after,reset);
}

void ReplicaNet::GetMergedStatistics(int *const sent,int *const received,const bool reset)
{
	mPrivateReplicaNet->GetMergedStatistics(sent,received,reset);
}

int ReplicaNet::GetMasterSessionID(void)
{
	return mPrivateReplicaNet->GetMasterSessionID();
}

std::string ReplicaNet::GetURLFromSessionID(const int sessionID)
{
	return mPrivateReplicaNet->GetURLFromSessionID(sessionID);
}

void ReplicaNet::SetClientOnly(const bool isClient)
{
	mPrivateReplicaNet->SetClientOnly(isClient);
}

bool ReplicaNet::GetClientOnly(void)
{
	return mPrivateReplicaNet->GetClientOnly();
}

bool ReplicaNet::GetBandwidthFromSessionID(const int sessionID,Transport::Bandwidth *const bandwidth,int *const output,int *const input)
{
	return mPrivateReplicaNet->GetBandwidthFromSessionID(sessionID,bandwidth,output,input);
}

ReplicaObject *ReplicaNet::CallBackAllocate(const int classID,const int sessionID,const int uniqueID)
{
	return 0;
}

ReplicaObject *ReplicaNet::CallBackDelete(ReplicaObject *object)
{
	return object;
}

bool ReplicaNet::BeginSessionRecord(void)
{
	return mPrivateReplicaNet->BeginSessionRecord();
}

void ReplicaNet::StopSessionRecord(void)
{
	mPrivateReplicaNet->StopSessionRecord();
}

bool ReplicaNet::GetSessionRecord(void) const
{
	return mPrivateReplicaNet->GetSessionRecord();
}

bool ReplicaNet::CallbackSessionRecord(const void *data,const int length)
{
	return false;
}

bool ReplicaNet::BeginSessionPlayback(void)
{
	return mPrivateReplicaNet->BeginSessionPlayback();
}

void ReplicaNet::SetPlaybackSpeed(const float speed)
{
	mPrivateReplicaNet->SetPlaybackSpeed(speed);
}

bool ReplicaNet::PlaybackAdvanceTo(const SysTimeType time)
{
	return mPrivateReplicaNet->PlaybackAdvanceTo(time);
}

void ReplicaNet::StopSessionPlayback(void)
{
	mPrivateReplicaNet->StopSessionPlayback();
}

bool ReplicaNet::CallbackSessionPlayback(void *data,const int length)
{
	return false;
}

void ReplicaNet::SetPlaybackAllowMasterReplicaObjects(const bool allow)
{
	mPrivateReplicaNet->SetPlaybackAllowMasterReplicaObjects(allow);
}

bool ReplicaNet::GetPlaybackAllowMasterReplicaObjects(void)
{
	return mPrivateReplicaNet->GetPlaybackAllowMasterReplicaObjects();
}

bool ReplicaNet::GetSessionPlayback(void) const
{
	return mPrivateReplicaNet->GetSessionPlayback();
}

ReplicaNet::Error ReplicaNet::GetSessionErrorReason(void)
{
	return mPrivateReplicaNet->GetSessionErrorReason();
}

void ReplicaNet::SetAllowConnections(const bool enable)
{
	mPrivateReplicaNet->SetAllowConnections(enable);
}

bool ReplicaNet::GetAllowConnections(void)
{
	return mPrivateReplicaNet->GetAllowConnections();
}

void ReplicaNet::SetNodeBuffers(const bool enable)
{
	mPrivateReplicaNet->SetNodeBuffers(enable);
}

bool ReplicaNet::GetNodeBuffers(void)
{
	return mPrivateReplicaNet->GetNodeBuffers();
}

void ReplicaNet::CallbackPlaybackAdvanceToFinished(void)
{
}

void ReplicaNet::ReplicaObjectDataSend(const int sessionid,const void *data,const int length,const ReplicaNet::PacketType type,ReplicaObject *object,const unsigned int band)
{
	mPrivateReplicaNet->ReplicaObjectDataSend(sessionid,data,length,type,object,band);
}

void ReplicaNet::CallbackMasterSessionIDChanged(const int previousSessionID)
{
}

void ReplicaNet::SetSessionIDCallback(const bool enable)
{
	mPrivateReplicaNet->SetSessionIDCallback(enable);
}

int ReplicaNet::CallbackGetSessionID(void)
{
	assert(!"ReplicaNet::SetSessionIDCallback() has been enabled but CallbackGetSessionID() has not been implemented by the user code.");
	return kReplicaNetUnknownUniqueID;
}

void ReplicaNet::SetMaximumDataSize(const int bytes)
{
	mPrivateReplicaNet->SetMaximumDataSize(bytes);
}

int ReplicaNet::GetMaximumDataSize(void) const
{
	return mPrivateReplicaNet->GetMaximumDataSize();
}

void ReplicaNet::SetPacketCompressionLevel(const int level)
{
	mPrivateReplicaNet->SetPacketCompressionLevel(level);
}
void ReplicaNet::SetLargePacketCompressionLevel(const int level)
{
	mPrivateReplicaNet->SetLargePacketCompressionLevel(level);
}

int ReplicaNet::GetPacketCompressionLevel(void)
{
	return mPrivateReplicaNet->GetPacketCompressionLevel();
}
int ReplicaNet::GetLargePacketCompressionLevel(void)
{
	return mPrivateReplicaNet->GetLargePacketCompressionLevel();
}

void ReplicaNet::SetTransparentPacketCompression(const int level)
{
	mPrivateReplicaNet->SetTransparentPacketCompression(level);
}

int ReplicaNet::GetTransparentPacketCompression(void)
{
	return mPrivateReplicaNet->GetTransparentPacketCompression();
}
//From: RNXPSession/XPSession.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
//Skipping: #include "RNXPSession/Inc/XPSession.h"
//Include inline: #include "RNPlatform/UtilityIter.h"
//From: RNPlatform/UtilityIter.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef __UTILITYITER_H__
#define __UTILITYITER_H__

// Iterator helper macros for std::vector and std::list.
// All std::vector helpers are prefixed with VECTOR_
// All std::list helpers are prefixed with LIST_

// First define the debug helper macros that include iterator checking at compilation time by using _isVector variables.
#ifdef _DEBUG

// std::vector helpers
#define VECTOR_ITER_BEGIN(iter,var,item)		\
{												\
	size_t _isVector = 0;						\
	std::vector<iter>::iterator st;				\
	bool iteratorSkipped = true;				\
	st = (var).begin();							\
	while (st != (var).end())					\
	{											\
		assert( iteratorSkipped );				\
		iteratorSkipped = false;				\
		_isVector++;							\
		iter item = *st;

#define VECTOR_ITER_ERASE(var)					\
		iteratorSkipped = true;					\
		_isVector++;							\
		{										\
		size_t offset;							\
		offset = st - (var).begin();			\
		(var).erase(st);						\
		st = (var).begin() + offset;			\
		}										\
		continue;

#define VECTOR_ITER_ERASENOCONT(var)			\
		iteratorSkipped = true;					\
		_isVector++;							\
		{										\
		size_t offset;							\
		offset = st - (var).begin();			\
		(var).erase(st);						\
		st = (var).begin() + offset;			\
		}

#define VECTOR_ITER_SKIP()						\
		iteratorSkipped = true;					\
		_isVector++;							\
		st++;

#define VECTOR_ITER_END()						\
		iteratorSkipped = true;					\
		_isVector++;							\
		st++;									\
	}											\
}

// std::list helpers
#define LIST_ITER_BEGIN(iter,var,item)			\
{												\
	std::list<iter>::iterator st;				\
	std::list<iter>::iterator tempst;			\
	bool iteratorSkipped = true;				\
	tempst = st = (var).begin();				\
	while (st != (var).end())					\
	{											\
		assert( iteratorSkipped );				\
		iteratorSkipped = false;				\
		iter item = *st;

#define LIST_ITER_END()							\
		iteratorSkipped = true;					\
		st++;									\
	}											\
}

#define LIST_ITER_ERASE(var)					\
		tempst = st;							\
		iteratorSkipped = true;					\
		st++;									\
		(var).erase(tempst);					\
		continue;

#define LIST_ITER_ERASENOCONT(var)				\
		tempst = st;							\
		iteratorSkipped = true;					\
		st++;									\
		(var).erase(tempst);

#define LIST_ITER_SKIP()						\
		iteratorSkipped = true;					\
		st++;

#else // ifdef _DEBUG

// std::vector helpers
#define VECTOR_ITER_BEGIN(iter,var,item)		\
{												\
	std::vector<iter>::iterator st;				\
	st = (var).begin();							\
	while (st != (var).end())					\
	{											\
		iter item = *st;

#define VECTOR_ITER_ERASE(var)					\
		{										\
		size_t offset;								\
		offset = st - (var).begin();			\
		(var).erase(st);						\
		st = (var).begin() + offset;			\
		}										\
		continue;

#define VECTOR_ITER_ERASENOCONT(var)			\
		{										\
		size_t offset;								\
		offset = st - (var).begin();			\
		(var).erase(st);						\
		st = (var).begin() + offset;			\
		}

#define VECTOR_ITER_SKIP()						\
		st++;

#define VECTOR_ITER_END()						\
		st++;									\
	}											\
}

// std::list helpers
#define LIST_ITER_BEGIN(iter,var,item)			\
{												\
	std::list<iter>::iterator st;				\
	std::list<iter>::iterator tempst;			\
	tempst = st = (var).begin();				\
	while (st != (var).end())					\
	{											\
		iter item = *st;

#define LIST_ITER_END()							\
		st++;									\
	}											\
}

#define LIST_ITER_ERASE(var)					\
		tempst = st;							\
		st++;									\
		(var).erase(tempst);					\
		continue;

#define LIST_ITER_ERASENOCONT(var)				\
		tempst = st;							\
		st++;									\
		(var).erase(tempst);

#define LIST_ITER_SKIP()						\
		st++;

#endif	// ifdef _DEBUG

#endif
#include "RNXPSockets/Inc/XPSockets.h"

//Skipping: #include "RNPlatform/Options.h"
//Skipping: #include "RNPlatform/Inc/SysTime.h"
//Skipping: #include "RNPlatform/Inc/Thread.h"
//Skipping: #include "RNPlatform/DebugSupport.h"
//Include inline: #include "RNXPURL/UDPReliableManager.h"
//From: RNXPURL/UDPReliableManager.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef __UDPRELIABLEMANAGER_H__
#define __UDPRELIABLEMANAGER_H__
#include <set>
#include <map>
//Include inline: #include "RNXPURL/TransportUDP.h"
//From: RNXPURL/TransportUDP.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef __TRANSPORTUDP_H__
#define __TRANSPORTUDP_H__
#include <stdlib.h>
#include <vector>
#include <set>
#include <map>
#include <string.h>
//Skipping: #include "RNXPURL/Inc/Transport.h"
//Skipping: #include "RNPlatform/Inc/Thread.h"
//Skipping: #include "RNPlatform/Inc/ThreadClass.h"
#include "RNPlatform/Inc/RegistryManager.h"
#include "RNPlatform/Inc/RegistryManagerList.h"
//Skipping: #include "RNPlatform/Inc/SysTime.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"

//Include inline: #include "RNXPURL/UDPDiscovery.h"
//From: RNXPURL/UDPDiscovery.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef __UDPDISCOVERY_H__
#define __UDPDISCOVERY_H__

#include <set>
#include <string>
#include <list>

//Skipping: #include "RNXPSockets/Inc/XPSocketUrgentClass.h"

namespace RNReplicaNet
{

/**
 * This class can handle broadcast discoveries using UDP packets. Add this class to a Transport type class to enable discovery
 */
class UDPDiscovery
{
public:
	/**
	 * The ctor performs some basic initialisation
	 */
	UDPDiscovery();

	/**
	 * The dtor makes sure everything is tidy
	 */
	virtual ~UDPDiscovery();

	/**
	 * This makes sure the discovery inbound socket is active
	 */
	void EnsureDiscoverySocketInboundIsAlive(void);

	/**
	 * This makes sure the discovery outbound socket is active
	 */
	void EnsureDiscoverySocketOutboundIsAlive(void);

	/**
	 * If a discovery is pending this will return the URL of the source machine that made a discovery request
	 * \return returns the URL of the machine attempting a discovery or a "" string
	 */
	std::string HandleDiscovery(void);

	/**
	 * This function handles the reply URL that is passed back to the previous calling machine of HandleDiscovery()
	 * This function can use the XPSocketUrgent hosting the discoverable connection to send the reply directly to the previous calling machine of HandleDiscovery() so the direct address can be discovered.
	 * \param reply the reply string to send
	 * \param sock The optional XPSocketUrgent hosting the discoverable connection. In this case the address can be used directly from the reply.
	 */
	void HandleDiscoveryReply(const std::string reply,XPSocketUrgent *sock = 0);

	/**
	 * This starts the discovery cycle to try to find other transports
	 */
	void BeginDiscovery(void);

	/**
	 * This is the function that can be used to discover other similar transports that can be connected to.
	 * \return Returns a URL, which is the URL passed in by HandleDiscoveryReply()
	 */
	std::string GetNextDiscovery(void);

	/**
	 * This is a virtual link to the parent class. Usually a Transport
	 * \return a std::string of the base type of the type that can be accepted
	 */
	virtual std::string CanAccept(void) = 0;

private:

	void Poll(void);

	XPSocketUrgent mDiscoverySocketOutbound;
	XPSocketUrgent mDiscoverySocketInbound;

	std::list<std::string> mDiscoveries;
	std::set<std::string> mUniqueDiscoveries;
	std::list<XPAddress> mDiscoveryProbes;

	XPAddress mDiscoveryReply;
};

} // namespace RNReplicaNet

#endif

namespace RNReplicaNet
{

class XPSocketUrgent;
class UDPReliableManager;
/**
 * A transport class for the UDP type of URL
 */
class TransportUDP : public Transport , public UDPDiscovery , private MessageHelper
{
public:
	/**
	 * The ctor performs some basic initialisation
	 */
	TransportUDP();

	/**
	 * The dtor makes sure everything is tidy
	 */
	virtual ~TransportUDP();

	virtual int GetPacketsSent(const bool reset);
	virtual int GetPacketsSentSize(const bool reset);
	virtual int GetPacketsReceived(const bool reset);
	virtual int GetPacketsReceivedSize(const bool reset);
	virtual int GetPacketsLost(const bool reset);

	virtual std::string CanAccept(void);
	virtual std::string CanRoute(void);

	virtual std::string ExportURL(void);

	virtual Transport *Allocate(void);

	virtual Transport::Error Listen(const int channel);
	virtual Transport::Error Listen(const std::string &address);
	virtual Transport::Error Connect(const std::string address);
	virtual Transport::Error ConnectStage1(void);
	virtual Transport::Error ConnectStage2(const std::string address);
	virtual Transport *Accept(void);

	virtual Transport::Error Send(const char *data,const int len);
	virtual Transport::Error SendOrdered(const char *data,const int len,const unsigned int band = 0);
	virtual Transport::Error SendReliable(const char *data,const int len,const unsigned int band = 0);
	virtual Transport::Error SendCertain(const char *data,const int len);
	virtual int Recv(char *const data,const int maxlen);
	virtual int GetMaxPacketSize(void);

	virtual std::string HandleDiscovery(void)
	{
		std::string temp = UDPDiscovery::HandleDiscovery();
		if (mLANDiscovery)
		{
			return temp;
		}
		return "";
	}

	virtual void HandleDiscoveryReply(const std::string reply)
	{
		if (mLANDiscovery)
		{
			UDPDiscovery::HandleDiscoveryReply(reply,GetPersistantSocket());
		}
	}

	virtual void BeginDiscovery(void)
	{
		if (mLANDiscovery)
		{
			UDPDiscovery::BeginDiscovery();
		}
	}

	virtual std::string GetNextDiscovery(void)
	{
		std::string temp = UDPDiscovery::GetNextDiscovery();
		if (mLANDiscovery)
		{
			return temp;
		}
		return "";
	}

	virtual Transport::Error GetStatus(void);

	/**
	 * A simple polling function that this transport needs to have called.
	 */
	virtual void Poll(void);

	virtual std::string GetPeerURL(void);

	virtual bool GetTransportClosed(void);

	virtual void SetEnableLANDiscovery(const bool enable);

	virtual bool GetEnableLANDiscovery(void);



	virtual int GetPacketsSentMerged(const bool reset = false);

	virtual int GetPacketsReceivedMerged(const bool reset = false);


	struct WaitingPacket
	{
		WaitingPacket()
		{
			mLen = 0;
			mData = 0;
			mAddr = XPAddress(0,0,0,0,0);
		}

		WaitingPacket(void *src,int size,XPAddress &addr)
		{
			mLen = size;
			if (size > 0)
			{
				mData = malloc(size);
				memcpy(mData,src,size);
			}
			else
			{
				mData = 0;
			}
			mAddr = addr;
		}

		virtual ~WaitingPacket()
		{
			if (mData)
			{
				free(mData);
			}
		}
		int mLen;
		void *mData;
		XPAddress mAddr;
	};

// Initialisers
	Transport::Error mError;
	bool mGotDisconnectPacket;
	bool mSocketIsMaster;
	XPSocketUrgent *mPersistantSocket;
	bool mOnlyReceiveFrom;
	TransportUDP *mBaseTransport;
	bool mIgnorePacket;
	bool mTransportHavingProblems;
	bool mFullConnectionDone;
	bool mAllowedToGetData;

// Others...
	// Receive and send data only to this other end point...
	// mOnlyReceiveFrom is set to be true
	XPAddress mReceiveFrom;

	/**
	 * The address to send packet to from this Transport. Set by Connect()
	 */
//	XPAddress mSendTo;

	int mPacketsSent;
	int mPacketsReceived;
	int mPacketsSentSize;
	int mPacketsReceivedSize;
	int mPacketsLost;

	int mCertainSequence;
	int mSequence[256];
	int mRecvSequence[256];

	int mProblemResendIndex;
	int mProblemResendIndexUsed;
	SysTimeType mProblemResendIndexReset;


	void AddWaitingPacket(WaitingPacket *packet);

	void SortPacketsToKnownTransports(void);

	TransportUDP *MatchKnownTransportFromAddress(const XPAddress &recvfrom);

	bool MatchNewAddressesToAddress(const XPAddress &recvfrom);

	struct NewAddress
	{
		XPAddress mAddress;
		Bandwidth mConfiguredBandwidth;
		int mMaximumOutputBandwidth;
		int mMaximumInputBandwidth;
		bool mUseChecksum;
	};

	struct ltNewAddress
	{
		bool operator()(const NewAddress &a,const NewAddress &b) const
		{
			return a.mAddress < b.mAddress;
		}
	};

	// Returns true if the address was added
	bool AddNewAddresses(const NewAddress &recvfrom);


	void SetBandwidthLimit(const Bandwidth enable = kBandwidth_Off);

	Bandwidth GetBandwidthLimit();

	void SetMaximumOutputBandwidth(const int bytesPerSecond = 0);

	int GetMaximumOutputBandwidth(void);

	void SetMaximumInputBandwidth(const int bytesPerSecond = 0);

	int GetMaximumInputBandwidth(void);

	void AddHistoryEntry(const int size);

	void KickPacketBuffer(const SysTimeType nowTime,const bool force);

	// For the packet buffer
	void DoInternalSend(const char *buffer,const int size);
	void DoInternalSendCompressionCheck(const char *data,const int len,const XPAddress &addr);

	const int GetLocalNonce(void) const
	{
		return mLocalNonce;
	}

	XPSocketUrgent *GetPersistantSocket(void)
	{
		return mPersistantSocket;
	}

	void AddSocketAutoPoll(void);
	void RemoveSocketAutoPoll(void);

	void ResetTransportHavingProblems(const int resendMax);

	virtual void SetTransparentPacketCompression(const int level = 0)
	{
		mCompressionLevel = level;
	}

	/**
	 * Allows the setting for SetTransparentPacketCompression() to be read.
	 * \return The setting for SetTransparentPacketCompression()
	 */
	virtual int GetTransparentPacketCompression(void)
	{
		return mCompressionLevel;
	}

protected:
//friend class UDPReliableManager;

//	std::list<XPAddress> mKnownAddresses;
//	std::list<TransportUDP *> mKnownTransports;
	// MPi: TODO: mKnownTransports and mKnownAddresses are always added to and removed from in sync so create a std::map for both...

	std::map<XPAddress,TransportUDP *> mKnownTransportsByAddress;

	std::list<WaitingPacket *> mWaitingPackets;
	std::set<NewAddress,ltNewAddress> mNewAddresses;	// MPi: This used to be a list. In theory the XPAddress sorted order of this new container shouldn't matter, but in very busy situations there may be a time when entries remain on the list if not all of them are parsed straight away and then more are added.

	Bandwidth mConfiguredBandwidth;
	int mMaximumOutputBandwidth;
	int mMaximumInputBandwidth;

	static Bandwidth mConfiguredBandwidthGlobal;
	static int mMaximumOutputBandwidthGlobal;
	static int mMaximumInputBandwidthGlobal;

	struct History
	{
		SysTimeType mTime;	// A common time
		int mSize;
	};

	// There is no input bandwidth history because the input comes from another transport which is told how much to send
	std::list<History> mHistoryOutput;
	int mHistoryTotal;
	float mCurrentBandwidthOutputPerSecond;
	void CalculateBandwidthOutputPerSecondAndRetireHistoryEntries(void);

	// Packet buffer stuff
	SysTimeType mEarliestBufferTime;
	char *mPacketBuffer;
	int mBufferSize;
	char *mPacketBufferCompressed;
	int mCompressionLevel;

public:
	void CommonDisconnectSend(void);	// Only for XboxUDP access
	static void AddChecksumToMessage(MessageHelper *message);
	int mPacketsSentMerged;
	int mPacketsReceivedMerged;
	bool mWrapHappened;

protected:
	MutexClass mUDPBuffer;
	MutexClass mUDPCompBuffer;

	bool mWasNewed;
	static bool mLANDiscovery;

private:
	int mLocalNonce;
	bool mUseChecksum;

public:
	// Atomic thread safe access only
	unsigned short mOrderedSendSequence[256];
	unsigned short mOrderedRecvSequence[256];
private:

};

} // namespace RNReplicaNet

#endif
//Skipping: #include "RNPlatform/Inc/SysTime.h"

#include "RNPlatform/Inc/RegistryManagerSet.h"

namespace RNReplicaNet
{

struct ReliablePacket
{
public:
	ReliablePacket(int len,void *data,TransportUDP *transport,XPAddress &sendto,XPAddress &recvfrom,const bool buffered);

	virtual ~ReliablePacket()
	{
		if (mData)
		{
			free(mData);
			mData = 0;
		}
	}

	int CopyOut(void *data)
	{
		int len = mLen - 5 - 2;
		if (len < 0)
		{
			len = 0;
		}
		if ( len > 0)
		{
			memcpy( ((char *)data)+5+2,mData,mLen-5-2);
		}
		return mLen-5-2;
	}

	bool mBuffered;
	int mLen;
	void *mData;
	TransportUDP *mTransport;
	XPAddress mSendTo;
	XPAddress mRecvFrom;
	int mSequence;
	SysTimeType mOriginalTime;
	int mResendIndex;
	SysTimeType mResendTime;
	bool mError;
	unsigned char mBand;
};

struct DuplicateCertainIDs;

struct ltDuplicateCertainIDs
{
	bool operator()(const DuplicateCertainIDs *a,const DuplicateCertainIDs *b) const;
};

struct DuplicateCertainIDs
{
	int mID;
	SysTimeType mTime;
	XPAddress mAddress;
	int mNonce;

	std::list<DuplicateCertainIDs *>::iterator mListIter;
	std::set<DuplicateCertainIDs *,ltDuplicateCertainIDs>::iterator mSetIter;
};

struct PendingBuildUpReply
{
	SysTimeType mTime;

	Transport::Bandwidth mConfiguredBandwidth;
	int mMaximumOutputBandwidth;
	int mMaximumInputBandwidth;

	std::list<PendingBuildUpReply *>::iterator mListIter;
	std::map<XPAddress,PendingBuildUpReply *>::iterator mMapIter;

	bool mUseChecksum;
};

class UDPReliableManagerPacketReceiveHook
{
public:
	static void SetUDPReliableManagerPacketReceiveHook(UDPReliableManagerPacketReceiveHook *hook = 0);

	virtual bool CallbackParsePacketData(t_XPSocket *socket,const XPAddress &addr,void *data,size_t length) = 0;
};

/**
 * This is a reliable socket manager for the TransportUDP class
 */
class UDPReliableManager : public ThreadClass , public Thread , public SysTime
{
public:
	/**
	 * The dtor starts the thread going to manage pending packets
	 */
	UDPReliableManager();

	/**
	 * The dtor cleans up and stops the thread running
	 */
	virtual ~UDPReliableManager();

	/**
	 * This adds a TransportUDP to the list of managed connections
	 * \param transport the transport
	 */
	void AddTransport(TransportUDP *transport);

	/**
	 * This removes a TransportUDP from the list of managed connections
	 * \param transport the transport
	 */
	void RemoveTransport(TransportUDP *transport);

	void AddTransportAutoPoll(TransportUDP *transport);

	void RemoveTransportAutoPoll(TransportUDP *transport);

	/**
	 * This Polls() the reliable UDP manager. Frequently this is called from a thread
	 */
	void Poll(void);

	enum PacketType
	{
		kDisconnect=4,	// This one remains constant
		// The rest can change
		kUnreliable=1,
		kReliable=2,
		kReliableACK=3,
		kCertain=5,
		kCertainACK=6,
		kBuildUp=8,
		kNAT=9,
		kOrdered=10,
		// Bit flags
		kUsingChecksum = (1<<7)
	};

	void SetManualPoll(void)
	{
		mManualPoll = true;
	}

	void SetAutomaticPoll(void)
	{
		mManualPoll = false;
	}

	void AddPendingPacket(ReliablePacket *packet);
	void AddPendingCertainPacket(ReliablePacket *packet);

	static float mPacketBufferTime;
	static bool mPacketBufferCapture;
	static bool mPacketBufferKickScheduled;
	static bool mDisableAllPacketBuffer;
	static char *mInfoString;
	static bool mEnableExtraPacketSecurity;
	static bool mEnablePacketSelect;

	void PerformKickTransports(const bool force);

private:
//friend class TransportUDP;

	int ThreadEntry(void);

	// MPi: TODO: Pending optimisation
	// Referenced by:
	// ReliablePacket::mSequence and ReliablePacket::mSendTo
	// ReliablePacket::mTransport (multi)
	// Potential optimisation for sorting (or resorting) by mResendTime whenever it changes
	RegistryManagerList<ReliablePacket> mPendingCertainACK;
	// Referenced by:
	// ReliablePacket::mSequence and ReliablePacket::mSendTo
	// ReliablePacket::mTransport (multi)
	// Potential optimisation for sorting (or resorting) by mResendTime whenever it changes
	RegistryManagerList<ReliablePacket> mPendingACK;

	// Referenced by:
	// ReliablePacket::mRecvFrom
	// ReliablePacket::mTransport (multi)
	// Sorted by ReliablePacket::mSequence
	RegistryManagerList<ReliablePacket> mACKedPackets;

	// Optimised
	RegistryManagerSet<TransportUDP> mTransportsAllowedToGetData;
	RegistryManagerSet<TransportUDP> mTransportsAllowedToGetDataNotOnlyReceiveFrom;
	RegistryManagerSet<TransportUDP> mTransportsBuffered;

	std::list<DuplicateCertainIDs *> mCertainIDsList;
	std::set<DuplicateCertainIDs *,ltDuplicateCertainIDs> mCertainIDs;

	std::list<PendingBuildUpReply *> mPendingBuildUpReplyList;
	std::map<XPAddress,PendingBuildUpReply *> mPendingBuildUpReply;

	volatile bool mManualPoll;

#ifdef _DEBUG
	int mNumCertIDsInDatabase;
#endif

	std::set<t_XPSocket *> mAutomaticPollSetBySocket;
};

extern UDPReliableManager *gUDPManager;
extern MutexClass gUDPManagerMutex;
extern UDPReliableManagerPacketReceiveHook *gUDPReliableManagerPacketReceiveHook;

} // namespace RNReplicaNet


#endif
//Skipping: #include "RNPlatform/Inc/CheckSum.h"
//Skipping: #include "RNPlatform/Inc/Encryption.h"
//Skipping: #include "RNPlatform/Inc/PlatformInfo.h"
//Skipping: #include "RNXPURL/Inc/XPURL.h"
//Skipping: #include "RNXPURL/Inc/DebugHandler.h"
//Skipping: #include "RNXPCompression/Inc/XPCompression.h"
//Skipping: #include "RNPlatform/Inc/MinMax.h"

using namespace RNReplicaNet;


#ifdef REPLICANET_TIME_DOUBLE
const static unsigned int sXPSessionVersion = _XPSESSION_VERSION | 0x80000000;
#else
const static unsigned int sXPSessionVersion = _XPSESSION_VERSION;
#endif


const unsigned char kXPSessionPacketType_SessionMessage	= 1<<2;
const unsigned char kXPSessionPacketType_CompressedMessage	= 1<<3;

typedef char SessMsgType;

// Session messages
const SessMsgType kSessionMessage_SessionVersion				= 0;	// This message always stays as zero.
const SessMsgType kSessionMessage_YouAreID						= 1;	// Master sends this to the connecting session node.
const SessMsgType kSessionMessage_IAmID							= 2;
const SessMsgType kSessionMessage_IsMaster						= 3;	// Sent by the master to signify it is the master.
const SessMsgType kSessionMessage_SessionJoined					= 4;
const SessMsgType kSessionMessage_SessionLeft					= 5;
const SessMsgType kSessionMessage_PingPong						= 6;
const SessMsgType kSessionMessage_TimeSet						= 7;
const SessMsgType kSessionMessage_HeartBeat						= 8;
const SessMsgType kSessionMessage_NULL_SpiderTo					= 9;	// Was last used in V5.00
const SessMsgType kSessionMessage_SessionName					= 10;
const SessMsgType kSessionMessage_SessionNowStable				= 11;	// This is sent by a joining session to the master once the kSessionMessage_YouAreID is received.
const SessMsgType kSessionMessage_SessionCompletelyStable		= 12;
const SessMsgType kSessionMessage_NULL							= 13;
const SessMsgType kSessionMessage_CanBeMaster					= 14;
const SessMsgType kSessionMessage_SendMeYourID					= 15;
const SessMsgType kSessionMessage_SendMeYourIDReply				= 16;
const SessMsgType kSessionMessage_BeginPreConnect				= 17;	// This is sent by the master in reply to a kSessionMessage_SessionNowStable to begin the pre-connect mechanism.
const SessMsgType kSessionMessage_SessionNowStableDoPingPong	= 18;	// This is sent by a joining session to the master when the pre-connect mechanism is done.
const SessMsgType kSessionMessage_SpiderTo						= 19;
const SessMsgType kSessionMessage_IsClientOnly					= 20;	// This is sent on join by a client if the node is client only, which means it doesn't get joiner/leaver messages.
const SessMsgType kSessionMessage_IDIsClientOnly				= 21;	// This is sent by the master to tell other can be masters about the session only being a client.
const SessMsgType kSessionMessage_FragmentedDataPacketStart		= 22;	// This is used when there is a large data packet being sent so we know to assemble it.
const SessMsgType kSessionMessage_FragmentedDataPacketContinue	= 23;	// This is used for all of the next fragments for the data packet.
const SessMsgType kSessionMessage_ProxyMaster					= 24;	// Sent by the first master after kSessionMessage_IsMaster if the master is a proxy master, i.e. it doesn't announce itself as a joiner/leaver and it doesn't accept any packets from the user API.

/**
	* The Route structure contains all sorts of useful information about the current transport and it's connection statistics
	* \todo Consider separating this out in to a class
	*/
struct XPSession::Route
{
public:
	Route();

	Route(Transport *transport);

	virtual ~Route();

	/**
		* Clears the route state
		*/
	void SetDefault(void);

	void AddRoundTripPingTime(float time);

	/**
		* The one way trip time from this route to the connection point
		*/
	float CalculateLatency(void);

	Transport *mTransport;

	// This is the sessionID of the target session for this route
	// The session that this is connected to programmed the session with this sessionID
	// with kSessionMessage_SendMeYourIDReply or kSessionMessage_IAmID
private:
	// Private to centralise access control to this variable
	int mTargetSessionID;
public:
	void SetTargetSessionID(const int targetSessionID,XPSession *session);
	int GetTargetSessionID(void) const;

	SysTimeType mLastHeartBeatSentTime;
	bool mCompletelyStable;
	bool mJoinerPosted;
	bool mCanBeMaster;
	bool mFatalError;
	bool mIsDoingPreConnect;

	float mPingHistoryRoundTripTime[kPingHistorySize];
	bool mFirstPingDone;
	SysTimeType mLastPingDoneAt;
	bool mReadyForNextPing;

	// This is the sessionID that we think might be outgoing from this new route
	// As set in response to kSessionMessage_SpiderTo
	// This outgoing ID should not be trusted however for packet sending
	// This is unset once the route is properly programmed
	int mOutgoingSpiderID;

	// If set to be true this means this session ID does not joiner/leaver messages from the master about other client only sessions
	bool mIsClientOnly;

	// Fragmented big packet combiner
	char *mFragmentedPacketCombiner;
	int mFragmentedPacketRealSize;
	int mFragmentedPacketGotSize;
	int mFragmentedPacketSentSize;
	XPSession *mInMapFor;	// Only set when added to mConnectionsBySessionID and mSetIter will be valid.
	std::multimap<int,Route *>::iterator mMapIter;	// The iterator into mConnectionsBySessionID. This is a multiset because we can have more than one route to the same sessionID due to there potentially being more than one Transport type used for this session.
};

XPSessionInternalBufferedPacket::XPSessionInternalBufferedPacket(const int sessionid,const char *data,const int length,const bool reliable,const bool certain,const bool ordered,const unsigned int band)
{
	mSessionID = sessionid;
	mData = (char *)malloc(length);
	assert(mData);
	memcpy(mData,data,(size_t) length);
	mLength = length;
	mReliable = reliable;
	mCertain = certain;
	mOrdered = ordered;
	mBand = band;
}

XPSessionInternalBufferedPacket::~XPSessionInternalBufferedPacket()
{
	free(mData);
}

XPSession::XPSession() : mGameChannel(TransportAnyGameChannel) , mSessionID(kXPSessionUnknownID) ,
	mStatus(kXPSession_EOK) , mIsMaster(false) , mMasterSessionID(kXPSessionUnknownID) , mThread(0) ,
	mBufferLen(0) , mMessageBufferIn(0) , mMessageBufferOut(0) , mCurrentSendRate(0) , mCurrentRecvRate(0) , mLastRateCalcTime(0) ,
	mCanSpider(true) , mCanBeMaster(true) , mCompletelyStable(false) , mTryingJoin(false) , startPollTime(0.0f) ,
	mPotentialMasterSessionID(kXPSessionUnknownID) , mNoticedHighestSessionID(kXPSessionUnknownID) ,
	mManualPoll(false) , mEncryptionOn(false) , mPollLayerBelow(true) , mEnablePreConnect(false) ,
	mCreateOrJoinDone(false) ,
	mEnableAutomaticCompression(false) , mCompressionBefore(0) , mCompressionAfter(0) ,
	mIsClientOnly(false) ,
	mTransportDisconnected(false) , mTransportError(false) ,
	mAllowConnections(true) , mNetworkPacketsLost(0) , mNetworkPacketsRejected(0) ,
	mEnableExtraBuffering(false) , mNumWaitingToSend(0) ,
	mGetSessionIDCallback(0) , mProxyMode(false) , mMasterIsProxyMode(false) ,
	mTransparentPacketCompression(0)
{
	THREADSAFELOCKCLASSNAMED(mMutexMiscValues);
	mZeroTime = FloatTime();
	mTargetZeroTime = mZeroTime;
	mLastTimeCorrectionTime = mZeroTime;
	mZeroTimeDelta = 0.0f;
	mBreakoutDone = false;
	mDontDoBreakOut = false;
	mLatencyRecalculationDelay = 1.0f;

	mNextSessionID = 1;
	mInPreConnect = false;
	mPreConnectSignalDone = false;

	SetMaximumDataSize();
	SetPacketCompressionLevel();
	SetLargePacketCompressionLevel();


#ifndef _FINAL
	if (XPURL::GetDebugHandler())
	{
		XPURL::GetDebugHandler()->Printf("::_Time\n%f\n::XPSession\nSession ID\n%d\n::_EndClass\n::_Flush\n",GetLocalTime(),GetSessionID());
	}
#endif
}

XPSession::~XPSession()
{
	if (mThread)
	{
		delete mThread;
		mThread = 0;
	}

	THREADSAFELOCK();

	THREADSAFELOCKCLASSNAMED(mMutexSentPackets);
	THREADSAFELOCKCLASSNAMED(mMutexRecvPackets);
	THREADSAFELOCKCLASSNAMED(mMutexJoinerList);
	THREADSAFELOCKCLASSNAMED(mMutexLeaverList);
	THREADSAFELOCKCLASSNAMED(mMutexMiscValues);

#ifndef _FINAL
	if (XPURL::GetDebugHandler())
	{
		XPURL::GetDebugHandler()->Printf("::_Time\n%f\n::~XPSession\nDeleted at\n%f\n::_EndClass\n::_Flush\n",GetLocalTime(),GetLocalTime());
	}
#endif

	LIST_ITER_BEGIN(XPSessionInternalBufferedPacket *,mWaitingToSend,packet);
	delete packet;
	LIST_ITER_END();
	mWaitingToSend.clear();

	LIST_ITER_BEGIN(WaitingPacket *,mWaitingPackets,packet);
	delete packet;
	LIST_ITER_END();
	mWaitingPackets.clear();

	LIST_ITER_BEGIN(Route *,mConnections,trans);
	delete trans;
	LIST_ITER_END();
	mConnections.clear();

	VECTOR_ITER_BEGIN(Transport *,mListens,trans);
	delete trans;
	VECTOR_ITER_END();
	mListens.clear();

	VECTOR_ITER_BEGIN(Transport *,mMasterListens,trans);
	delete trans;
	VECTOR_ITER_END();
	mMasterListens.clear();

	VECTOR_ITER_BEGIN(Transport *,mFindTransports,trans);
	delete trans;
	VECTOR_ITER_END();
	mFindTransports.clear();

	if (mMessageBufferIn)
	{
		free(mMessageBufferIn);
		mMessageBufferIn = 0;
	}

	if (mMessageBufferOut)
	{
		free(mMessageBufferOut);
		mMessageBufferOut = 0;
	}
}

bool XPSession::Initialise(void)
{
	RegisterDefaultTransports();

	// Make it quite large
	mBufferLen = TransportMinimumPacketSize;
	Transport *transport = 0;
	XPURL xpurl;
	xpurl.BeginEnumerateTransports();
	while( ( transport = xpurl.EnumerateTransports() ) != 0 )
	{
		mBufferLen = max(mBufferLen , transport->GetMaxPacketSize() );
	}
	
	mMessageBufferIn = (char *) malloc(mBufferLen);
	if (!mMessageBufferIn)
	{
		return false;
	}

	mMessageBufferOut = (char *) malloc(mBufferLen);
	if (!mMessageBufferOut)
	{
		return false;
	}

	mThread = new Thread();
	if (!mThread)
	{
		return false;
	}
	mThread->SetPreferredProcessor(PlatformInfo::GetProcessorXPSession());
	mThread->Begin(this);

	return true;
}

XPSession *XPSession::Allocate(void)
{
	XPSession *session = new XPSession();
	/* If init failed */
	if (!session->Initialise())
	{
		delete session;
		return 0;
	}
	return session;
}

void XPSession::Create(const std::string name)
{
	Create(name,"UDP@");
}

void XPSession::Create(const std::string cname,const std::string cprotocols)
{
	THREADSAFELOCK();
	std::string protocols = std::string(cprotocols);
	mSessionID = 0;
	mMasterSessionID = mSessionID;

	mCreateOrJoinDone = true;

#ifdef DEBUG_PRINTS1
	dprintf("Session $%p : Create session\n",this);
#endif

	mSessionName = std::string(cname);

#ifndef _FINAL
	if (XPURL::GetDebugHandler())
	{
		XPURL::GetDebugHandler()->Printf("::_Time\n%f\n::XPSession\nCreated at\n%f\nSession ID\n%d\nName\n%s\nProtocol\n%s\n::_EndClass\n::_Flush\n",GetLocalTime(),GetLocalTime(),GetSessionID(),mSessionName.c_str(),protocols.c_str());
	}
#endif
	
	std::string token;
	
	do
	{
		token = protocols;
		size_t pos = protocols.find_first_of(",");
		if (pos != std::string::npos)
		{
			protocols.erase(0,pos+1);
			token.erase(pos,token.size());
		}
		else
		{
			protocols.erase(0,protocols.size());
		}
		// Get the next transport in the list
	//	Transport *trans = EnumerateTransports();
		Transport *trans = FindTransport(token);

		if (trans)
		{
			Transport *newtrans = trans->Allocate();		// Creates an object of the relevant class type from the source object

//			dprintf("Session Allocate $%p\n",newtrans);

			assert(newtrans && "XPSession::Create() failed to find one of the Transport protocols. If using RNLobby has RNLobby::RegisterDefaultTransports() been called?");

			if (newtrans)
			{
				newtrans->SetTransparentPacketCompression(mTransparentPacketCompression);
				Transport::Error ret = newtrans->Listen(GetGameChannel());
				if (ret == Transport::kTransport_ECANTLISTENONCHANNEL)
				{
#ifdef DEBUG_PRINTS1
					dprintf("Session $%p : Can't setup a default channel\n",this);
#endif
					Transport::Error ret = newtrans->Listen();
					
					if (ret == Transport::kTransport_EERROR)
					{
						delete newtrans;
						newtrans = 0;
					}

				}
				else if (ret == Transport::kTransport_EERROR)
				{
					delete newtrans;
					newtrans = 0;
				}

				if (newtrans)
				{
					mMasterListens.push_back(newtrans);
				}
			}
		}

	} while (protocols != "");

#ifdef DEBUG_PRINTS1
	dprintf("I am session id %d\n",mSessionID);
#endif

	mIsMaster = true;
	mCompletelyStable = true;

	CreateBufferedURL();
}

std::string XPSession::GetSessionString(void)
{
	return std::string("SESSION://");
}

std::string XPSession::ExportURL(const bool shortAddress)
{
	if (mEnableExtraBuffering)
	{
		THREADSAFELOCKCLASSNAMED(mMutexMiscValues);
		if (shortAddress)
		{
			return mReturnExportURLTrue;
		}
		return mReturnExportURLFalse;
	}
	return BufferedExportURL(shortAddress);
}

std::string XPSession::BufferedExportURL(const bool shortAddress)
{
	THREADSAFELOCK();
	std::string bigurl = std::string(GetSessionString());

	bigurl += ExportURLInternal(shortAddress);

	if (mSessionName != "")
	{
		bigurl += std::string("{SESSIONNAME="+mSessionName+"}");
	}

	return bigurl;
}

std::string XPSession::ExportURLInternal(const bool shortAddress)
{
	THREADSAFELOCK();
	std::string bigurl;

	VECTOR_ITER_BEGIN(Transport *, mMasterListens, trans);
	std::string tempStr = trans->ExportURL();
	bigurl += tempStr;
	VECTOR_ITER_END();

	// If NO master listens and NOT only a short address then output the spider to listens addresses.
	if (!(mMasterListens.size() > 0 && shortAddress == true))
	{
		VECTOR_ITER_BEGIN(Transport *, mListens, trans);
		bigurl += trans->ExportURL();
		VECTOR_ITER_END();
	}

	return bigurl;
}


void XPSession::Join(const std::string url)
{
	if (url.size() < GetSessionString().size())
	{
		assert(!"XPSession::Join() was passed a URL that was shorter than expected. The URL is corrupt.");
		mStatus = kXPSession_EERROR;
		return;
	}

	if (url.find(GetSessionString()) != 0)
	{
		assert(!"XPSession::Join() was passed a URL that did not start with SESSION://. URLs are case sensitive. The URL is corrupt.");
		mStatus = kXPSession_EERROR;
		return;
	}

	THREADSAFELOCK();

	mCreateOrJoinDone = true;

	std::string copy = url;
	std::string justurls = std::string( copy.c_str()+GetSessionString().size() );

	std::string oneurl = ParseURLs(justurls);

	bool gotAtLeastOneTransport = false;

	while(oneurl != "")
	{
		Transport *newtrans = FindTransport(oneurl);

		if (newtrans != NULL)
		{
			newtrans = newtrans->Allocate();		// Creates an object of the relevant class type
			newtrans->SetTransparentPacketCompression(mTransparentPacketCompression);
			mConnections.push_back(new Route(newtrans));
#ifdef DEBUG_PRINTS1
			dprintf("Session $%p : Trying connection $%p via transport %s to address '%s'\n",this,newtrans,newtrans->CanAccept().c_str(),oneurl.c_str());
#endif
			// Do the connect
			newtrans->Connect(oneurl);
			gotAtLeastOneTransport = true;
		}

		oneurl = ParseURLs("");
	}

	if (!gotAtLeastOneTransport)
	{
		assert(!"XPSession::Join() : No registered transports were found to match the transports listed in the URL. The URL may be corrupt. If using RNLobby has RNLobby::RegisterDefaultTransports() been called?");
		mStatus = kXPSession_EERROR;
		return;
	}

	mTryingJoin = true;

//	// Only start up the listens if we can spider

// Maybe only if we can spider or become a master
	if (mCanSpider || mCanBeMaster)
	{
		// Because we are joining setup our own listen transports so we can do a web type of connection if possible
		justurls = std::string(&copy[GetSessionString().size()]);

		oneurl = ParseURLs(justurls);

		while(oneurl != "")
		{
			Transport *newtrans = FindTransport(oneurl);
			if (newtrans)
			{
				newtrans = newtrans->Allocate();		// Creates an object of the relevant class type

				if (newtrans)
				{
					newtrans->SetTransparentPacketCompression(mTransparentPacketCompression);
					Transport::Error ret = newtrans->Listen(GetGameChannel());
					if (ret == Transport::kTransport_ECANTLISTENONCHANNEL)
					{
						// Failed to get the game channel, so attempt to find any channel
						ret = newtrans->Listen();
					}
					
					if (ret == Transport::kTransport_EERROR || ret == Transport::kTransport_ECANTLISTENONCHANNEL)
					{
						delete newtrans;
					}
					else
					{
						mListens.push_back(newtrans);
					}
				}
			}
			oneurl = ParseURLs("");
		}
	}
}

void XPSession::Find(void)
{
	Find("UDP@");
}

void XPSession::Find(const std::string cprotocols)
{
	THREADSAFELOCK();
	std::string protocols = cprotocols;
	BeginEnumerateTransports();

	// Get the next transport in the list
	std::string token;
	
	do
	{
		token = protocols;
// Why oh why is npos different on different platforms?
		size_t pos = protocols.find_first_of(",");
		if (pos != std::string::npos)
		{
			protocols.erase(0,pos+1);
			token.erase(pos,token.size());
		}
		else
		{
			protocols.erase(0,protocols.size());
		}
		// Get the next transport in the list
		Transport *trans = FindTransport(token);

		if (trans)
		{
			Transport *newtrans = trans->Allocate();		// Creates an object of the relevant class type from the source object

			assert(newtrans);

			if (newtrans)
			{
				newtrans->SetTransparentPacketCompression(mTransparentPacketCompression);
				newtrans->BeginDiscovery();

				mFindTransports.push_back(newtrans);
			}
		}
	} while (protocols != "");
}

std::string XPSession::EnumerateFound(void)
{
	THREADSAFELOCK();
	std::string bigurl = std::string(GetSessionString());

	VECTOR_ITER_BEGIN(Transport *,mFindTransports,trans);

	std::string retstr = trans->GetNextDiscovery();
	if (retstr != "")
	{
		return retstr;
	}

	VECTOR_ITER_END();

	return "";
}

std::string XPSession::AppendSessionInfo(const std::string instr)
{
	THREADSAFELOCK();
	std::string retstr = instr;

	if (mSessionName != "")
	{
		retstr += std::string("{SESSIONNAME="+mSessionName+"}");
	}

	return retstr;
}

void XPSession::HandleTransportDiscovery(Transport * const trans)
{
	THREADSAFELOCK();
	std::string retstr;
	retstr = trans->HandleDiscovery();
	while (retstr != "")
	{
		if (mIsMaster)
		{
			trans->HandleDiscoveryReply(ExportURL());
		}
		retstr = trans->HandleDiscovery();
	}
}

void XPSession::Poll(void)
{
	if (mPollLayerBelow)
	{
		XPURL::Poll();
	}

	// Outside of the main class mutex because they are thread safe by using their own mutexes
	HandleWaitingToSendPackets();

	THREADSAFELOCK();

	CreateBufferedURL();

	// This is outside the mutex because the write is atomic
	mNetworkPacketsLost = BufferedGetNetworkPacketsLost();

	startPollTime = GetTime();
	mLocalTimeStartPollTime = GetLocalTime();

	mBreakoutDone = false;

	float time_delta = (float) (GetLocalTime() - mLastRateCalcTime);
	if (time_delta >= 1.0f)
	{
		int totalsent = 0;
		int totalrecv = 0;
		VECTOR_ITER_BEGIN(Transport *,mFindTransports,trans);
		totalsent += trans->GetPacketsSentSize(true);
		totalrecv += trans->GetPacketsReceivedSize(true);
		VECTOR_ITER_END();
		VECTOR_ITER_BEGIN(Transport *,mMasterListens,trans);
		totalsent += trans->GetPacketsSentSize(true);
		totalrecv += trans->GetPacketsReceivedSize(true);
		VECTOR_ITER_END();
		VECTOR_ITER_BEGIN(Transport *,mListens,trans);
		totalsent += trans->GetPacketsSentSize(true);
		totalrecv += trans->GetPacketsReceivedSize(true);
		VECTOR_ITER_END();
		LIST_ITER_BEGIN(Route *,mConnections,route);
		totalsent += route->mTransport->GetPacketsSentSize(true);
		totalrecv += route->mTransport->GetPacketsReceivedSize(true);
		LIST_ITER_END();

		mLastRateCalcTime = GetLocalTime();
		mCurrentSendRate = totalsent / time_delta;
		mCurrentRecvRate = totalrecv / time_delta;
	}

	// Add a paranoia check
	if (time_delta < 0.0f)
	{
		mLastRateCalcTime = GetLocalTime();
	}

	VECTOR_ITER_BEGIN(Transport *,mFindTransports,trans);
	HandleTransportDiscovery(trans);
	VECTOR_ITER_END();

	VECTOR_ITER_BEGIN(Transport *,mMasterListens,trans);
	HandleTransportDiscovery(trans);
	VECTOR_ITER_END();

	VECTOR_ITER_BEGIN(Transport *,mListens,trans);
	HandleTransportDiscovery(trans);
	VECTOR_ITER_END();

	bool continue_accept = false;

	do
	{
		continue_accept = false;

		VECTOR_ITER_BEGIN(Transport *,mListens,trans);
		Transport *newtrans;

		newtrans = trans->Accept();

		if (newtrans != NULL)
		{
			continue_accept = true;
#ifdef DEBUG_PRINTS1
			dprintf("XPSession mListens $%p : Noticed new spider connection $%p via transport %s at this address '%s'\n",this,newtrans,newtrans->CanAccept().c_str(),newtrans->ExportURL().c_str());
#endif
			Route *route = new Route(newtrans);

#ifdef DEBUG_PRINTS1
			dprintf("	New Route $%p for this transport $%p\n",route,newtrans);
#endif

			mConnections.push_back(route);

			SessionPacket_Header message;
			// Set to be broadcast so it gets through to the parse packet stage.
			// It is not really broadcast though...
			message.mDestinationSession = kXPSessionBroadcastID;
			message.mSourceSession = mSessionID;
			message.mPacketTypeAndChecksum = kXPSessionPacketType_SessionMessage | kXPSessionPacketType_Reliable;

//			int type;

			SetBuffer(mMessageBufferOut);
			MESSAGEHELPER_ADDVARIABLE(message.mDestinationSession);
			MESSAGEHELPER_ADDVARIABLE(message.mSourceSession);
			MESSAGEHELPER_ADDVARIABLE(message.mPacketTypeAndChecksum);

			SessMsgType sessmsgid = kSessionMessage_IAmID;
			MESSAGEHELPER_ADDVARIABLE(sessmsgid);

			sessmsgid = kSessionMessage_SendMeYourID;
			MESSAGEHELPER_ADDVARIABLE(sessmsgid);

			if (mCanBeMaster && mCanSpider)
			{
				sessmsgid = kSessionMessage_CanBeMaster;
				MESSAGEHELPER_ADDVARIABLE(sessmsgid);
			}

			newtrans->SendReliable(mMessageBufferOut,GetSize());
			route->mLastHeartBeatSentTime = startPollTime;
		}
		VECTOR_ITER_END();

		VECTOR_ITER_BEGIN(Transport *,mMasterListens,trans);
		Transport *newtrans;

		newtrans = trans->Accept();

		if (!mAllowConnections)
		{
			delete newtrans;
			newtrans = 0;
		}

		if (newtrans != NULL)
		{
			continue_accept = true;
#ifdef DEBUG_PRINTS1
			dprintf("XPSession : mMasterListens $%p : Noticed new connection $%p via transport %s for joining session id %d from address '%s'\n",this,newtrans,newtrans->CanAccept().c_str(),mNextSessionID,newtrans->ExportURL().c_str());
#endif

			Route *route = new Route(newtrans);
			if (mGetSessionIDCallback)
			{
				mNextSessionID = (*mGetSessionIDCallback)(mGetSessionIDCallbackContext);
			}
			route->SetTargetSessionID(mNextSessionID,this);
			// Now add the new route to the list of connections
			mConnections.push_back(route);

			// Stack context for the safe lock
			{
			THREADSAFELOCKCLASSNAMED(mMutexMiscValues);
			mBufferedURLsBySessionID.insert(std::pair<int,std::string>(route->GetTargetSessionID(),route->mTransport->GetPeerURL()));
			}

			// To hide the session until it is really joined we don't push the joining session id straight away

			SessionPacket_Header message;
			message.mDestinationSession = mNextSessionID;
			message.mSourceSession = mSessionID;
			message.mPacketTypeAndChecksum = kXPSessionPacketType_SessionMessage | kXPSessionPacketType_Reliable;

			int type;

			SetBuffer(mMessageBufferOut);
			MESSAGEHELPER_ADDVARIABLE(message.mDestinationSession);
			MESSAGEHELPER_ADDVARIABLE(message.mSourceSession);
			MESSAGEHELPER_ADDVARIABLE(message.mPacketTypeAndChecksum);
//			int headsize = GetSize();

			SessMsgType sessmsgid;

			sessmsgid = kSessionMessage_YouAreID;
			MESSAGEHELPER_ADDVARIABLE(sessmsgid);
			type = mNextSessionID;
			MESSAGEHELPER_ADDVARIABLE(type);

			sessmsgid = kSessionMessage_IsMaster;
			MESSAGEHELPER_ADDVARIABLE(sessmsgid);

			if (mProxyMode)
			{
				sessmsgid = kSessionMessage_ProxyMaster;
				MESSAGEHELPER_ADDVARIABLE(sessmsgid);
			}

			sessmsgid = kSessionMessage_IAmID;
			MESSAGEHELPER_ADDVARIABLE(sessmsgid);

			if (mCanBeMaster && mCanSpider)
			{
				sessmsgid = kSessionMessage_CanBeMaster;
				MESSAGEHELPER_ADDVARIABLE(sessmsgid);
			}

//			type = mSessionID;
//			MESSAGEHELPER_ADDVARIABLE(type);

			/* Set approximate time */
			sessmsgid = kSessionMessage_TimeSet;
			MESSAGEHELPER_ADDVARIABLE(sessmsgid);
			SysTimeType time = startPollTime;
			MESSAGEHELPER_ADDVARIABLE(time);
			float delta = 0.0f;
			MESSAGEHELPER_ADDVARIABLE(delta);

// Cannot encrypt this packet because this packet tells the session what ID it is
// and without the ID the key cannot be built... :)
			newtrans->SendReliable(mMessageBufferOut,GetSize());
			route->mLastHeartBeatSentTime = startPollTime;

			mNextSessionID++;
		}
		VECTOR_ITER_END();
	} while(continue_accept == true);

	if (!IsMaster() && GetSessionID() == kXPSessionUnknownID && mTryingJoin && mStatus != kXPSession_EERROR)
	{
//dprintf("\nStill trying join\n\n");
		if (mConnections.size() == 0)
		{
//dprintf("\nAll connections seem to be dead\n\n");
#ifdef DEBUG_PRINTS2
			dprintf("XPSession : Going to create instead as nothing responded\n");
#endif
			Create("<Default>");
			mSessionID = 0;
			if (mCanBeMaster)
			{
				MutateToMaster(mSessionID+1,0);
			}
			else
			{
				mStatus = kXPSession_EERROR;
			}
			return;
		}
	}

	// We we are a master then reset the zero time
	if (IsMaster())
	{
		mZeroTimeDelta = 0.0f;
	}


	/* Now go through all the connected routes to sessions that we know about */
	LIST_ITER_BEGIN(Route *,mConnections,route);

	// First of all, if we want to signal the pre-connect as being done then...
	if (mPreConnectSignalDone && route && ( route->GetTargetSessionID() == mPreConnectSendToID ) )
	{
		mInPreConnect = false;
		mPreConnectSignalDone = false;
		if (mStatus != kXPSession_EERROR)
		{
			mStatus = kXPSession_EOK;
		}
#ifdef DEBUG_PRINTS1
		dprintf("Session id %d : Send kSessionMessage_SessionNowStableDoPingPong\n",mSessionID);
#endif
		char buffer[32];
		SessionPacket_Header header;

		header.mDestinationSession = mPreConnectSendToID;
		header.mSourceSession = mSessionID;
		header.mPacketTypeAndChecksum = kXPSessionPacketType_Reliable | kXPSessionPacketType_SessionMessage;

		MessageHelper message;
		message.SetBuffer(buffer);

		MESSAGEHELPER_ADDVARIABLEp(message,header.mDestinationSession);
		MESSAGEHELPER_ADDVARIABLEp(message,header.mSourceSession);
		MESSAGEHELPER_ADDVARIABLEp(message,header.mPacketTypeAndChecksum);

		SessMsgType sessmsgid = kSessionMessage_SessionNowStableDoPingPong;
		MESSAGEHELPER_ADDVARIABLEp(message,sessmsgid);
		route->mTransport->SendReliable(buffer,message.GetSize());
		route->mLastHeartBeatSentTime = startPollTime;
	}

	// If we are the master and the route is ready of pinging then see if we want to send out a ping packet
	if (IsMaster() && route && route->mReadyForNextPing)
	{
		bool sendPing = false;
		// Have we sent one yet?
		if (route->mFirstPingDone == false)
		{
			// If no, then say yes send one
			sendPing = true;
		}
		else
		{
			// If yes, check the recalculation delay from a previous ping
			float delta = (float)(mLocalTimeStartPollTime - route->mLastPingDoneAt);
			if (delta > mLatencyRecalculationDelay)
			{
				sendPing = true;
			}
		}
		if (sendPing)
		{
#ifdef DEBUG_PRINTS2
			dprintf("XPSession : $%p : Sending kSessionMessage_PingPong to sessid %d\n",this,route->GetTargetSessionID());
#endif
			char buffer[20];
			SessionPacket_Header header;
			MessageHelper message;
			message.SetBuffer(buffer);

			header.mDestinationSession = route->GetTargetSessionID();
			header.mSourceSession = mSessionID;
			header.mPacketTypeAndChecksum = kXPSessionPacketType_Unreliable | kXPSessionPacketType_SessionMessage;

			MESSAGEHELPER_ADDVARIABLEp(message,header.mDestinationSession);
			MESSAGEHELPER_ADDVARIABLEp(message,header.mSourceSession);
			MESSAGEHELPER_ADDVARIABLEp(message,header.mPacketTypeAndChecksum);

			SessMsgType sessmsgid = kSessionMessage_PingPong;
			MESSAGEHELPER_ADDVARIABLEp(message,sessmsgid);

			SysTimeType mylocaltime = mLocalTimeStartPollTime;
			MESSAGEHELPER_ADDVARIABLEp(message,mylocaltime);

			route->mTransport->Send(buffer,message.GetSize());
			route->mLastPingDoneAt = mLocalTimeStartPollTime;
			route->mFirstPingDone = true;
		}
	}

	int ret;
	int breakout = false;

	// If no error on the route then receive and parse packets
	if (route && !route->mFatalError)
	{
		bool routeRecv = true;
		while ( routeRecv && !route->mFatalError && ((ret = route->mTransport->Recv(mMessageBufferIn,mBufferLen)) > 0))
		{
			assert( ret <= mBufferLen );
			// Reset the heartbeat time because we got a packet so we know the transport is OK.
			route->mLastHeartBeatSentTime = startPollTime;
			if (ParsePacket(route,ret))
			{
				breakout = true;
			}
			if (route->mTransport == 0)
			{
				routeRecv = false;
				delete route;
				LIST_ITER_ERASE(mConnections);
				// Implied continue in LIST_ITER_ERASE
				continue;
			}
		}
	}

	// breakout is set to be true if the ParsePacket function adds a 'spider to' connection
	// If true then we don't really want to continue going through the other transports connections list this time around
	if (breakout)
	{
		mBreakoutDone = true;
		break;
	}

	// For incoming routes only
	if ( route && ( ( startPollTime - route->mLastHeartBeatSentTime ) > 60.0f ) && ( route->GetTargetSessionID() == kXPSessionUnknownID ) )
	{
#ifdef DEBUG_PRINTS2
//		dprintf("***\n\n");
		dprintf("XPSession : Route $%p has been idle for too long\n",route);
//		dprintf("***\n\n");
#endif
//		route->mFatalError = true;
		route->mLastHeartBeatSentTime = startPollTime;

#ifdef DEBUG_PRINTS2
		dprintf("XPSession : $%p : Sending heart beat to sessid %d at this address '%s' via route $%p\n",this,route->GetTargetSessionID(),route->mTransport->ExportURL().c_str(),route);
#endif
		char buffer[16];
		SessionPacket_Header header;
		MessageHelper message;
		message.SetBuffer(buffer);

		header.mDestinationSession = route->GetTargetSessionID();
		header.mSourceSession = mSessionID;
//		header.mPacketTypeAndChecksum = kXPSessionPacketType_Reliable | kXPSessionPacketType_SessionMessage;
		header.mPacketTypeAndChecksum = kXPSessionPacketType_Certain | kXPSessionPacketType_SessionMessage;

		MESSAGEHELPER_ADDVARIABLEp(message,header.mDestinationSession);
		MESSAGEHELPER_ADDVARIABLEp(message,header.mSourceSession);
		MESSAGEHELPER_ADDVARIABLEp(message,header.mPacketTypeAndChecksum);

		SessMsgType sessmsgid = kSessionMessage_HeartBeat;
		MESSAGEHELPER_ADDVARIABLEp(message,sessmsgid);

		if ( route->mTransport )
		{
			route->mTransport->SendCertain(buffer,message.GetSize());
		}
		route->mLastHeartBeatSentTime = startPollTime;
	}

	// Some routes are only incoming and not outgoing.
//	if ( (startPollTime - route->mLastHeartBeatSentTime) > 10.0f && (IsMaster() || route->GetTargetSessionID() == mMasterSessionID || (mTryingJoin && GetSessionID() == kXPSessionUnknownID)))
//	if ( (startPollTime - route->mLastHeartBeatSentTime) > 10.0f && ((IsMaster() && route->GetTargetSessionID() != kXPSessionUnknownID) || route->GetTargetSessionID() == mMasterSessionID || (mTryingJoin && GetSessionID() == kXPSessionUnknownID)))
// Maybe all connections, if there is an idle time, need to send a heart beat...
	if ( route && ( ( startPollTime - route->mLastHeartBeatSentTime ) > 10.0f ) && ( ( route->GetTargetSessionID() != kXPSessionUnknownID ) || ( mTryingJoin && ( GetSessionID() == kXPSessionUnknownID ) ) ) )
	{
		if ( route->mTransport && ( route->mTransport->GetStatus() == Transport::kTransport_EOK ) )
		{
	#ifdef DEBUG_PRINTS2
			dprintf("XPSession : $%p : Sending heart beat to sessid %d at this address '%s' via route $%p\n",this,route->GetTargetSessionID(),route->mTransport->ExportURL().c_str(),route);
	#endif
			char buffer[16];
			SessionPacket_Header header;
			MessageHelper message;
			message.SetBuffer(buffer);

			header.mDestinationSession = route->GetTargetSessionID();
			header.mSourceSession = mSessionID;
	//		header.mPacketTypeAndChecksum = kXPSessionPacketType_Reliable | kXPSessionPacketType_SessionMessage;
			header.mPacketTypeAndChecksum = kXPSessionPacketType_Certain | kXPSessionPacketType_SessionMessage;

			MESSAGEHELPER_ADDVARIABLEp(message,header.mDestinationSession);
			MESSAGEHELPER_ADDVARIABLEp(message,header.mSourceSession);
			MESSAGEHELPER_ADDVARIABLEp(message,header.mPacketTypeAndChecksum);

			SessMsgType sessmsgid = kSessionMessage_HeartBeat;
			MESSAGEHELPER_ADDVARIABLEp(message,sessmsgid);

			route->mTransport->SendCertain(buffer,message.GetSize());
		}
		route->mLastHeartBeatSentTime = startPollTime;
	}

	if ( route && ( ( route->mTransport && ( route->mTransport->GetStatus() == Transport::kTransport_EERROR ) ) || route->mFatalError ) )
	{
		// If we are trying a join then flag for later reporting...
		if (mTryingJoin)
		{
			if (route->mTransport && route->mTransport->GetTransportClosed())
			{
				mTransportDisconnected = true;
			}
			else
			{
				mTransportError = true;
			}
		}

#ifdef DEBUG_PRINTS1
		dprintf("XPSession : Transport or Route ERROR\n");
#endif

		if (route->GetTargetSessionID() != kXPSessionUnknownID)
		{
#ifdef DEBUG_PRINTS1
			dprintf("Session $%p : Noticed session id %d left\n",this,route->GetTargetSessionID());
#endif
//			if (!IsMaster() && route->mCompletelyStable)
			if (!IsMaster() && !mTryingJoin)
			{
				// If we are currently able to become a master then remember potential leavers incase we become a master
				if (mCanBeMaster)
				{
#ifdef DEBUG_PRINTS1
					dprintf("	so adding mPotentialLeavers (%d)\n",route->GetTargetSessionID());
#endif
					mPotentialLeavers.push_back(route->GetTargetSessionID());
				}
			}

// Go through the other connections and see if we can flag any other duplicate routes for delete
			LIST_ITER_BEGIN(Route *,mConnections,route3);
			if (route3->GetTargetSessionID() == route->GetTargetSessionID() && route3 != route)
			{
#ifdef DEBUG_PRINTS1
				dprintf("	so now flagging duplicate primary routes as bad\n",route->GetTargetSessionID());
#endif
				route3->mFatalError = true;
				route3->SetTargetSessionID(kXPSessionUnknownID,this);
			}
			LIST_ITER_END();

			// If we are a master session...
			// Notify all other connected sessions that the session id was detected as leaving
			if (IsMaster())
			{
				if (route->mJoinerPosted)
				{
					AddLeaver(route->GetTargetSessionID());
// This was changed for V4.00 on 3 May 2004
// The change stopped non-joiner routes when they left from being told to other session nodes
					LIST_ITER_BEGIN(Route *,mConnections,route2);

					// If we are telling a client only node and the leaving route is not can be master
					// skip the route from being told to the client only node
					if (route2->mIsClientOnly && !route->mCanBeMaster)
					{
						LIST_ITER_SKIP();
						continue;
					}

					if (route2 != route)
					{
						char buffer[32];
						MessageHelper message;
						message.SetBuffer(buffer);
						SessionPacket_Header header;
						header.mDestinationSession = route2->GetTargetSessionID();
						header.mSourceSession = mSessionID;
	//					header.mPacketTypeAndChecksum = kXPSessionPacketType_Reliable | kXPSessionPacketType_SessionMessage;
						header.mPacketTypeAndChecksum = kXPSessionPacketType_Certain | kXPSessionPacketType_SessionMessage;

						MESSAGEHELPER_ADDVARIABLEp(message,header.mDestinationSession);
						MESSAGEHELPER_ADDVARIABLEp(message,header.mSourceSession);
						MESSAGEHELPER_ADDVARIABLEp(message,header.mPacketTypeAndChecksum);

						SessMsgType sessmsgid = kSessionMessage_SessionLeft;
						MESSAGEHELPER_ADDVARIABLEp(message,sessmsgid);

						int temp = route->GetTargetSessionID();
						MESSAGEHELPER_ADDVARIABLEp(message,temp);

	//					route2->mTransport->SendReliable(buffer,message.GetSize());
						route2->mTransport->SendCertain(buffer,message.GetSize());
						route2->mLastHeartBeatSentTime = startPollTime;
					}

					LIST_ITER_END();
				}
			}

			// If the master session left then add the ID to the potential leavers list
			if (route->GetTargetSessionID() == mMasterSessionID && !mCanBeMaster)
			{
				mPotentialLeavers.push_back(route->GetTargetSessionID());
			}

//			if (route->GetTargetSessionID() == mMasterSessionID)
			if (route->GetTargetSessionID() == mMasterSessionID || route->GetTargetSessionID() == mPotentialMasterSessionID)
			{
#ifdef DEBUG_PRINTS1
				dprintf("route->GetTargetSessionID() == mMasterSessionID || route->GetTargetSessionID() == mPotentialMasterSessionID\n");
#endif
				int told = 0;
				int highestsessionid = mNoticedHighestSessionID;
				if (mSessionID > highestsessionid)
				{
					highestsessionid = mSessionID;
				}
				if (route->GetTargetSessionID() > highestsessionid)
				{
					highestsessionid = route->GetTargetSessionID();
				}
				int highestcanbemastersessionid = kXPSessionUnknownID;
				if (mCanBeMaster)
				{
					highestcanbemastersessionid = mSessionID;
				}

				LIST_ITER_BEGIN(Route *,mConnections,route2);

				if (route2 != route && route2->GetTargetSessionID() != kXPSessionUnknownID)
				{
#ifdef DEBUG_PRINTS1
					dprintf("XPSession %d : Thinking about route2->GetTargetSessionID() %d can be (%d)\n",mSessionID,route2->GetTargetSessionID(),route2->mCanBeMaster);
#endif
					if (route2->GetTargetSessionID() > highestsessionid)
					{
						highestsessionid = route2->GetTargetSessionID();
					}
					if (route2->GetTargetSessionID() > highestcanbemastersessionid && route2->mCanBeMaster)
					{
						told++;
						highestcanbemastersessionid = route2->GetTargetSessionID();
					}
				}

#ifdef DEBUG_PRINTS1
				dprintf("XPSession %d : highestsessionid %d highestcanbemastersessionid %d told %d\n",mSessionID,highestsessionid,highestcanbemastersessionid,told);
#endif

				LIST_ITER_END();
				// If there are no spider connections to anyone else that can be a master then we are in real trouble
				// So assume the whole session left us and make the session report an error
#ifdef DEBUG_PRINTS1
				dprintf("XPSession %d : Thinks ID %d is going to be the master\n",mSessionID,highestcanbemastersessionid);
#endif
				mPotentialMasterSessionID = highestcanbemastersessionid;

				// If a spider connection can be a master then continue;
				if (told > 0)
				{
					delete route;
					LIST_ITER_ERASE(mConnections);
					// Implied continue in LIST_ITER_ERASE
					continue;
				}
				// If no spider connections can be a master then...
				if (told == 0)
				{
#ifdef DEBUG_PRINTS1
					dprintf("No connections told so...\n");
#endif
					// If we can become a master and we can spider and there isn't a session error then become a master
					if (mCanBeMaster && mCanSpider && mStatus != kXPSession_EERROR)
					{
#ifdef DEBUG_PRINTS1
						dprintf("   ... so I will MutateToMaster\n");
#endif
						MutateToMaster(highestsessionid+1,route);
					}
					else
					{
#ifdef DEBUG_PRINTS1
						dprintf("   ... I report an kXPSession_EERROR\n");
#endif
						if (route->mTransport)
						{
							if (route->mTransport->GetTransportClosed())
							{
								mTransportDisconnected = true;
							}
							else
							{
								mTransportError = true;
							}
						}
						AddLeaver(route->GetTargetSessionID());
						// Otherwise report an error
						mStatus = kXPSession_EERROR;
					}
					delete route;
					LIST_ITER_ERASE(mConnections);
					// Implied continue in LIST_ITER_ERASE
					continue;
				}
				// If we turn out to be the highest session ID that can master then do so
				// If we are the highest known session ID then we assume the role of master
				if (mSessionID == highestcanbemastersessionid)
				{
#ifdef DEBUG_PRINTS1
					dprintf("I will MutateToMaster\n");
#endif
					MutateToMaster(highestsessionid+1,route);

					delete route;
					LIST_ITER_ERASE(mConnections);
					// Implied continue in LIST_ITER_ERASE
					continue;
				}
			}
		}

// DEBUGING USE
		delete route;
		LIST_ITER_ERASE(mConnections);
		// Implied continue in LIST_ITER_ERASE
		continue;
	}

	LIST_ITER_END();


	// If we have empty connection list and create or join done and we are not a master then signal an error
	// something really bad happened to the session and we cannot continue
	if (mConnections.empty() && mCreateOrJoinDone && !IsMaster())
	{
		mStatus = kXPSession_EERROR;
	}
}

#ifdef DEBUG_PRINTS2
static int packetnum = 0;
#endif

void XPSession::InternalSendMessage(Route *routed, const SessionPacket_Header &message,const int length)
{
	unsigned char justPacketType = message.mPacketTypeAndChecksum & 0x03;
	if (justPacketType == kXPSessionPacketType_Certain)
	{
		routed->mTransport->SendCertain(mMessageBufferIn,length);
		routed->mLastHeartBeatSentTime = startPollTime;
	}
	else if (justPacketType == kXPSessionPacketType_Reliable)
	{
		routed->mTransport->SendReliable(mMessageBufferIn,length);
		routed->mLastHeartBeatSentTime = startPollTime;
	}
	else if (justPacketType == kXPSessionPacketType_Ordered)
	{
		routed->mTransport->SendOrdered(mMessageBufferIn,length);
	}
	else
	{
		routed->mTransport->Send(mMessageBufferIn,length);
	}
}

bool XPSession::ParsePacket(Route *const route,int length)
{
	THREADSAFELOCK();

#ifdef DEBUG_PRINTS2
	dprintf("XPSession : ParsePacket from route $%p (sessid %d transport $%p)\n",route,route->GetTargetSessionID(),route->mTransport);
#endif

#ifdef DEBUG_PRINTS2
	dprintf("XPSession : Whole quick dump of packet (len %d) is:",length);
	for (int i=0;i<length;i++)
	{
		dprintf("$%02x ",((int)mMessageBufferIn[i])&0xff);
	}
	dprintf("\n");
#endif

	// Only try to parse packets that have a normal message header
	if (length < (int) sizeof(SessionPacket_Header))
	{
#ifdef DEBUG_PRINTS2
		dprintf("XPSession : Ignoring invalid packet as it is too short\n");
#endif
		return false;
	}

	SessionPacket_Header message;

	SetBuffer(mMessageBufferIn);
	MESSAGEHELPER_GETVARIABLE(message.mDestinationSession);
	MESSAGEHELPER_GETVARIABLE(message.mSourceSession);
	MESSAGEHELPER_GETVARIABLE(message.mPacketTypeAndChecksum);

	// Now it must be a session or a user packet.
//	if ( (message.mPacketTypeAndChecksum & (kXPSessionPacketType_SessionMessage)) == 0)
//	{
//#ifdef DEBUG_PRINTS2
//		dprintf("XPSession : Ignoring invalid packet as it is not a user or session packet\n");
//#endif
//		return false;
//	}

	int headsize = GetSize();

#ifdef DEBUG_PRINTS2
	dprintf("XPsession Parsing packet number %d from %d to %d type %d\n",packetnum++,message.mSourceSession,message.mDestinationSession,message.mPacketTypeAndChecksum&15);
#endif

	// If we have a packet for someone else then forward it
	// i.e. We have a packet not for our session ID and
	// we are the master session and
	// the packet is not a broadcast packet
	if (message.mDestinationSession != mSessionID &&
		mIsMaster == true &&
		message.mDestinationSession != kXPSessionBroadcastID)
	{
		LIST_ITER_BEGIN(Route *,mConnections,routed);
		if (routed->GetTargetSessionID() == message.mDestinationSession)
		{
#ifdef DEBUG_PRINTS2
			dprintf("XPSession forwarding (routing) a packet from session id %d to %d\n",message.mSourceSession,message.mDestinationSession);
#endif
			InternalSendMessage(routed,message,length);
			return false;
		}
		LIST_ITER_END();
#ifdef DEBUG_PRINTS2
		dprintf("+++ Warning : Master session got a packet for session ID %d from session ID %d when ID wasn't in the routing table\n",message.mDestinationSession,message.mSourceSession);
#endif
		return false;
	}

	// Forward packets marked for broadcast that the master gets to everyone else except the sender
	if (message.mDestinationSession == kXPSessionBroadcastID &&
		mIsMaster == true &&
		message.mSourceSession != kXPSessionUnknownID)
	{
#ifdef DEBUG_PRINTS2
		dprintf("XPSession forwarding a broadcast packet from session id %d ",message.mSourceSession);
#endif
		LIST_ITER_BEGIN(Route *,mConnections,routed);
		// If the route is doing a pre-connect then don't send on broadcast messages to this route
		if (routed->mIsDoingPreConnect)
		{
			LIST_ITER_SKIP();
			continue;
		}

		if (routed->GetTargetSessionID() != message.mSourceSession && routed->GetTargetSessionID() != kXPSessionUnknownID)
		{
#ifdef DEBUG_PRINTS2
			dprintf("to id %d",routed->GetTargetSessionID());
#endif
			InternalSendMessage(routed,message,length);
		}
#ifdef DEBUG_PRINTS2
		dprintf("\n");
#endif
		LIST_ITER_END();
	}

	// The packet wasn't meant for us
	if (! (message.mDestinationSession == mSessionID ||
			mSessionID == kXPSessionUnknownID ||
			message.mDestinationSession == kXPSessionBroadcastID) )
	{
#ifdef DEBUG_PRINTS2
		dprintf("XPSession : Ignoring a packet from %d to %d as we are not that session ID\n",message.mSourceSession,message.mDestinationSession);
#endif
		return false;
	}

	// We ignore packets that don't have a source session id
	if (message.mSourceSession == kXPSessionUnknownID)
	{
#ifdef DEBUG_PRINTS2
		dprintf("XPSession : Ignoring a packet again from %d to %d\n",message.mSourceSession,message.mDestinationSession);
#endif
		return false;
	}

#ifdef DEBUG_PRINTS2
	dprintf("XPSession : Acting on packet as it was meant for us\n");
#endif

	int checksum = (message.mPacketTypeAndChecksum>>4) & 0x0f;
	/* Now try to decrypt the packet if the checksum is set */
	if (checksum != 0)
	{
#ifdef DEBUG_PRINTS2
		dprintf("XPSession : Decrypt the packet\n");
#endif
		Encryption::Key key;
		key.Create(mMessageBufferIn,sizeof(message.mSourceSession)+sizeof(message.mDestinationSession));
#ifdef DEBUG_PRINTS2
		dprintf("XPSession : Key = %x %x %x %x %x %x %x %x\n",key.mKey[0],key.mKey[1],key.mKey[2],key.mKey[3],key.mKey[4],key.mKey[5],key.mKey[6],key.mKey[7]);
#endif

		void *tempbuf = malloc(length-headsize);
		assert(tempbuf && "Failed to allocate temporary decrypt buffer");
		memcpy(tempbuf,((char *)mMessageBufferIn)+headsize,length-headsize);
//		Encryption::Decrypt(((char *)mMessageBufferIn)+headsize,length-headsize,&key);
		Encryption::Decrypt(tempbuf,length-headsize,&key);
		memcpy(((char *)mMessageBufferIn)+headsize,tempbuf,length-headsize);
		free(tempbuf);

		int calcuated_checksum = Checksum::ChecksumData(((char *)mMessageBufferIn)+headsize,length-headsize);
		calcuated_checksum = calcuated_checksum ^ (calcuated_checksum>>8) ^ (calcuated_checksum>>16) ^ (calcuated_checksum>>24);
		calcuated_checksum = calcuated_checksum ^ (calcuated_checksum>>4);
		calcuated_checksum &= 15;
		if (!calcuated_checksum)
		{
			calcuated_checksum = 1;
		}
#ifdef DEBUG_PRINTS2
		dprintf("XPSession : Calculated checksum = %x\n",calcuated_checksum);
#endif

		if (checksum != calcuated_checksum)
		{
#ifdef DEBUG_PRINTS2
			dprintf("XPSession : WARNING : Ignoring this decrypted packet as checksums are wrong\n");
#endif
			mNetworkPacketsRejected++;
			route->mFatalError = true;
			return false;
		}

		message.mPacketTypeAndChecksum &= 0x0f;

#ifdef DEBUG_PRINTS3
		dprintf("XPSession : Whole quick dump of decrypted packet (len %d) is:",length);
		for (int i=0;i<length;i++)
		{
			dprintf("$%02x ",((int)mMessageBufferIn[i])&0xff);
		}
		dprintf("\n");
#endif
	}

	// Check for compressed message
	if (message.mPacketTypeAndChecksum & kXPSessionPacketType_CompressedMessage)
	{
		XPCompression comp;

		void *tempbuf = malloc(mBufferLen);
		assert(tempbuf);
		if (!tempbuf)
		{
#ifdef DEBUG_PRINTS2
			dprintf("XPSession : WARNING : Ignoring this decompressed packet because there was no more memory\n");
#endif
			mNetworkPacketsRejected++;
			return false;
		}
		int decompLen;
		if (!comp.Decompress(mMessageBufferIn+headsize,length-headsize,tempbuf,&decompLen,mBufferLen))
		{
			free(tempbuf);
#ifdef DEBUG_PRINTS2
			dprintf("XPSession : WARNING : Ignoring this decompressed packet because there was an error\n");
#endif
			mNetworkPacketsRejected++;
			route->mFatalError = true;
			return false;
		}

		// Set the original size back again
		length = headsize + decompLen;
		// Copy the decompressed data
		memcpy(mMessageBufferIn+headsize,tempbuf,decompLen);

		// Remove the compressed message flag, since it is uncompressed now.
		message.mPacketTypeAndChecksum &= ~kXPSessionPacketType_CompressedMessage;

		// And free the memory
		free(tempbuf);
	}

	// Check for user message. ie. It is not a session message.
	if (!(message.mPacketTypeAndChecksum & kXPSessionPacketType_SessionMessage))
	{
#ifdef DEBUG_PRINTS2
		dprintf("XPSession : Was a user data packet so added to user data pool\n");
#endif
		WaitingPacket *packet = new WaitingPacket;
		packet->mSize = length - headsize;
		packet->mPacket = (char *) malloc(packet->mSize);
		packet->mFromSession = message.mSourceSession;
		packet->mPacketType = message.mPacketTypeAndChecksum & (kXPSessionPacketType_Unreliable | kXPSessionPacketType_Certain | kXPSessionPacketType_Reliable);
		memcpy(packet->mPacket,mMessageBufferIn+headsize,packet->mSize);
		// Quickly lock the relevant mutex
		THREADSAFELOCKCLASS(mMutexRecvPackets);
		mWaitingPackets.push_back(packet);
		return false;
	}

#ifdef DEBUG_PRINTS2
	dprintf("XPSession : Packet contains session data\n");
#endif

	int messageSourceSessionID = message.mSourceSession;

	SessMsgType sessmsgid;
	while (!route->mFatalError && ( GetSize() < length ) )
	{
#ifdef DEBUG_PRINTS2
		dprintf("Quick dump of packet is:");
		for (int i=GetSize();i<length;i++)
		{
			dprintf("$%02x ",((int)mMessageBufferIn[i])&0xff);
		}
		dprintf("\n");
#endif

		MESSAGEHELPER_GETVARIABLE(sessmsgid);

#ifdef DEBUG_PRINTS2
		dprintf("XPSession : sessmsgid = %d getsize = %d length %d\n",sessmsgid,GetSize(),length);
#endif

		switch(sessmsgid)
		{
			case kSessionMessage_CanBeMaster:
			{
#ifdef DEBUG_PRINTS1
				dprintf("Session id %d : Got kSessionMessage_CanBeMaster from %d\n",mSessionID,message.mSourceSession);
#endif
//				mKnownSessionInfo.push_back(SessionData(message.mSourceSession,true));

				route->mCanBeMaster = true;

				break;
			}
			case kSessionMessage_NULL:
			{
				break;
			}
			case kSessionMessage_SessionVersion:
			{
				unsigned int temp;
				MESSAGEHELPER_GETVARIABLE(temp);
#ifdef DEBUG_PRINTS1
				dprintf("Session id %d : Got kSessionMessage_SessionVersion of %d\n",mSessionID,temp);
#endif
				if (temp != sXPSessionVersion)
				{
					delete route->mTransport;
					route->mTransport = 0;
					route->SetTargetSessionID(kXPSessionUnknownID,this);
					return true;
				}
				break;
			}
			case kSessionMessage_SessionNowStable:
			{
#ifdef DEBUG_PRINTS1
				dprintf("Session id %d : Got kSessionMessage_SessionNowStable\n",mSessionID);
#endif
				char buffer[32];
				SessionPacket_Header header;

				header.mDestinationSession = message.mSourceSession;
				header.mSourceSession = mSessionID;
				header.mPacketTypeAndChecksum = kXPSessionPacketType_Reliable | kXPSessionPacketType_SessionMessage;

				MessageHelper message;
				message.SetBuffer(buffer);

				MESSAGEHELPER_ADDVARIABLEp(message,header.mDestinationSession);
				MESSAGEHELPER_ADDVARIABLEp(message,header.mSourceSession);
				MESSAGEHELPER_ADDVARIABLEp(message,header.mPacketTypeAndChecksum);

				SessMsgType sessmsgid = kSessionMessage_BeginPreConnect;
				MESSAGEHELPER_ADDVARIABLEp(message,sessmsgid);
				/**
				 * \todo This is slightly wrong as I should create a nice reliable session message sending function and not keep on creating message blocks
				 */
				route->mTransport->SendReliable(buffer,message.GetSize());
				route->mLastHeartBeatSentTime = startPollTime;

				// Flag this route as doing a pre-connect so it doesn't try to send on broadcast messages
				route->mIsDoingPreConnect = true;

				break;
			}
			case kSessionMessage_BeginPreConnect:
			{
#ifdef DEBUG_PRINTS1
				dprintf("Session id %d : Got kSessionMessage_BeginPreConnect from sessionID %d\n",mSessionID,message.mSourceSession);
#endif
				// If we have pre-connect enabled then wait for the signal from our application
				if (mEnablePreConnect)
				{
					mInPreConnect = true;
					mPreConnectSendToID = message.mSourceSession;
				}
				else
				{
					// Else just send back the kSessionMessage_SessionNowStableDoPingPong message
#ifdef DEBUG_PRINTS1
					dprintf("Session id %d : Send reply due to no pre-connect enabled kSessionMessage_SessionNowStableDoPingPong\n",mSessionID);
#endif
					char buffer[32];
					SessionPacket_Header header;

					header.mDestinationSession = message.mSourceSession;
					header.mSourceSession = mSessionID;
					header.mPacketTypeAndChecksum = kXPSessionPacketType_Reliable | kXPSessionPacketType_SessionMessage;

					MessageHelper message;
					message.SetBuffer(buffer);

					MESSAGEHELPER_ADDVARIABLEp(message,header.mDestinationSession);
					MESSAGEHELPER_ADDVARIABLEp(message,header.mSourceSession);
					MESSAGEHELPER_ADDVARIABLEp(message,header.mPacketTypeAndChecksum);

					SessMsgType sessmsgid = kSessionMessage_SessionNowStableDoPingPong;
					MESSAGEHELPER_ADDVARIABLEp(message,sessmsgid);
					route->mTransport->SendReliable(buffer,message.GetSize());
					route->mLastHeartBeatSentTime = startPollTime;
				}
				break;
			}

			case kSessionMessage_SessionNowStableDoPingPong:
			{
#ifdef DEBUG_PRINTS1
				dprintf("Session id %d : Got kSessionMessage_SessionNowStableDoPingPong\n",mSessionID);
#endif
				// Unflag the pre-connect for this route, we are now able to send on broadcast messages
				route->mIsDoingPreConnect = false;
				/* We've received a session stable packet from a session so check if we need to kick off the ping finding stuff */
				if (route->mFirstPingDone == false && IsMaster())
				{
					route->mReadyForNextPing = true;
				}
				break;
			}

			case kSessionMessage_IsMaster:
			{
#ifdef DEBUG_PRINTS1
				dprintf("Session id %d : Got kSessionMessage_IsMaster from %d\n",mSessionID,message.mSourceSession);
#endif

				assert("Am IsMater() but kSessionMessage_IsMaster got\n" && !IsMaster());

				mMasterSessionID = message.mSourceSession;
				mPotentialMasterSessionID = kXPSessionUnknownID;
				mPotentialLeavers.clear();
				break;
			}
			case kSessionMessage_YouAreID:
			{
				int temp;
				MESSAGEHELPER_GETVARIABLE(temp);

#ifdef DEBUG_PRINTS1
				dprintf("Session id %d : Just been told to become session id %d\n",mSessionID,temp);
#endif

				mSessionID = temp;

				/* Send back a welcome message once this session knows it's ID */
				char buffer[64];
				SessionPacket_Header header;

				header.mDestinationSession = message.mSourceSession;
				header.mSourceSession = mSessionID;
				header.mPacketTypeAndChecksum = kXPSessionPacketType_Reliable | kXPSessionPacketType_SessionMessage;

				MessageHelper message;
				message.SetBuffer(buffer);

				MESSAGEHELPER_ADDVARIABLEp(message,header.mDestinationSession);
				MESSAGEHELPER_ADDVARIABLEp(message,header.mSourceSession);
				MESSAGEHELPER_ADDVARIABLEp(message,header.mPacketTypeAndChecksum);

				SessMsgType sessmsgid = kSessionMessage_SessionVersion;
				MESSAGEHELPER_ADDVARIABLEp(message,sessmsgid);
				MESSAGEHELPER_ADDVARIABLEp(message,sXPSessionVersion);

				if (mIsClientOnly)
				{
					sessmsgid = kSessionMessage_IsClientOnly;
					MESSAGEHELPER_ADDVARIABLEp(message,sessmsgid);
				}

				if (mCanBeMaster && mCanSpider)
				{
					sessmsgid = kSessionMessage_CanBeMaster;
					MESSAGEHELPER_ADDVARIABLEp(message,sessmsgid);
				}

				sessmsgid = kSessionMessage_SessionNowStable;
				MESSAGEHELPER_ADDVARIABLEp(message,sessmsgid);

				/**
				 * TODO: This is slightly wrong as I should create a nice reliable session message sending function and not keep on creating message blocks
				 */
				route->mTransport->SendReliable(buffer,message.GetSize());
				route->mLastHeartBeatSentTime = startPollTime;

				break;
			}
			case kSessionMessage_SendMeYourIDReply:
			{
				assert("Route being re-programmed (bad)" && route->GetTargetSessionID() == kXPSessionUnknownID);

#ifdef DEBUG_PRINTS1
				dprintf("XPSession id %d got kSessionMessage_SendMeYourIDReply from %d\n",mSessionID,message.mSourceSession);
#endif

				route->SetTargetSessionID(message.mSourceSession,this);
				// We got programmed so we can unset the outgoing ID now
				route->mOutgoingSpiderID = kXPSessionUnknownID;
				// Stack context for the safe lock
				{
				THREADSAFELOCKCLASSNAMED(mMutexMiscValues);
				mBufferedURLsBySessionID.insert(std::pair<int,std::string>(route->GetTargetSessionID(),route->mTransport->GetPeerURL()));
				}
				break;
			}
			case kSessionMessage_IAmID:
			{
//				int temp;
//				MESSAGEHELPER_GETVARIABLE(temp);

				assert("Route being re-programmed (bad)" && route->GetTargetSessionID() == kXPSessionUnknownID);

#ifdef DEBUG_PRINTS1
				dprintf("XPSession id %d got kSessionMessage_IAmID from %d\n",mSessionID,message.mSourceSession);
#endif

				route->SetTargetSessionID(message.mSourceSession,this);
				// We got programmed so we can unset the outgoing ID now
				route->mOutgoingSpiderID = kXPSessionUnknownID;
				// Stack context for the safe lock
				{
				THREADSAFELOCKCLASSNAMED(mMutexMiscValues);
				mBufferedURLsBySessionID.insert(std::pair<int,std::string>(route->GetTargetSessionID(),route->mTransport->GetPeerURL()));
				}
				break;
			}
			case kSessionMessage_SessionJoined:
			{
				int temp;
				MESSAGEHELPER_GETVARIABLE(temp);
#ifdef DEBUG_PRINTS1
				dprintf("XPSession id %d was told by session (which noticed) %d that session id %d just joined\n",mSessionID,message.mSourceSession,temp);
#endif

				if (temp > mNoticedHighestSessionID)
				{
					mNoticedHighestSessionID = temp;
				}

				AddJoiner(temp);

				route->mJoinerPosted = true;

				// Only non-master sessions get this message so...
				/* Send back a welcome message once this session knows its ID */
				if (mListens.size() > 0 && temp != mMasterSessionID && mCanSpider)
				{
					char buffer[512];
					SessionPacket_Header header;

					header.mDestinationSession = temp;
					header.mSourceSession = mSessionID;
					header.mPacketTypeAndChecksum = kXPSessionPacketType_Reliable | kXPSessionPacketType_SessionMessage;

					MessageHelper message;
					message.SetBuffer(buffer);

					MESSAGEHELPER_ADDVARIABLEp(message,header.mDestinationSession);
					MESSAGEHELPER_ADDVARIABLEp(message,header.mSourceSession);
					MESSAGEHELPER_ADDVARIABLEp(message,header.mPacketTypeAndChecksum);

					sessmsgid = kSessionMessage_SpiderTo;
					MESSAGEHELPER_ADDVARIABLEp(message,sessmsgid);
					std::string url = ExportURLInternal();
					unsigned short urllen = (unsigned short) url.size();
					MESSAGEHELPER_ADDVARIABLEp(message,urllen);
					message.AddData(url.c_str(),(int)url.size());

					route->mTransport->SendReliable(buffer,message.GetSize());
					route->mLastHeartBeatSentTime = startPollTime;

#ifdef DEBUG_PRINTS1
					dprintf("   Sending kSessionMessage_SpiderTo with '%s' to %d\n",url.c_str(),header.mDestinationSession);
#endif
				}

				break;
			}
			case kSessionMessage_SessionLeft:
			{
				int temp;
				MESSAGEHELPER_GETVARIABLE(temp);
#ifdef DEBUG_PRINTS1
				dprintf("XPSession id %d was told by session (which noticed) %d that session id %d just left\n",mSessionID,message.mSourceSession,temp);
#endif

				AddLeaver(temp);

				// Go through the other connections and see if we can flag any other duplicate routes for delete
				LIST_ITER_BEGIN(Route *,mConnections,route3);
				if (route3->GetTargetSessionID() == temp)
				{
#ifdef DEBUG_PRINTS1
					dprintf("XPSession : Now flagging duplicate primary routes as bad for sessionid %d\n",temp);
#endif
					route3->mFatalError = true;
					route3->SetTargetSessionID(kXPSessionUnknownID,this);
				}
				LIST_ITER_END();

				if (mCanBeMaster)
				{
					LIST_ITER_BEGIN(int,mPotentialLeavers,theleftsessionid);
					if (theleftsessionid == temp)
					{
						LIST_ITER_ERASENOCONT(mPotentialLeavers);
						break;
					}
					LIST_ITER_END();
				}


				break;
			}
			case kSessionMessage_SendMeYourID:
			{
#ifdef DEBUG_PRINTS2
				dprintf("Got a kSessionMessage_SendMeYourID from session id %d\n",route->GetTargetSessionID());
#endif
				// If we cannot spider then send a reply so the spidered to session knows what this route is for
				if (!mCanSpider)
				{
#ifdef DEBUG_PRINTS2
					dprintf("   Cannot spider so we send a kSessionMessage_SendMeYourIDReply\n");
#endif
					char buffer[64];
					SessionPacket_Header header;

					header.mDestinationSession = message.mSourceSession;
					header.mSourceSession = mSessionID;
					header.mPacketTypeAndChecksum = kXPSessionPacketType_Certain | kXPSessionPacketType_SessionMessage;

					MessageHelper message;
					message.SetBuffer(buffer);

					MESSAGEHELPER_ADDVARIABLEp(message,header.mDestinationSession);
					MESSAGEHELPER_ADDVARIABLEp(message,header.mSourceSession);
					MESSAGEHELPER_ADDVARIABLEp(message,header.mPacketTypeAndChecksum);

					SessMsgType sessmsgid = kSessionMessage_SendMeYourIDReply;
					MESSAGEHELPER_ADDVARIABLEp(message,sessmsgid);

					if (mIsClientOnly)
					{
						sessmsgid = kSessionMessage_IsClientOnly;
						MESSAGEHELPER_ADDVARIABLEp(message,sessmsgid);
					}

					route->mTransport->SendCertain(buffer,message.GetSize());
					route->mLastHeartBeatSentTime = startPollTime;
				}
				break;
			}

			case kSessionMessage_PingPong:
			{
#ifdef DEBUG_PRINTS2
				dprintf("kSessionMessage_PingPong: Session id %d got a pingpong packet\n",mSessionID);
#endif
				// If we get a pingpong then it is a copy of the one we originally sent out to the route
				if (IsMaster())
				{
					SysTimeType mylocaltime;
					MESSAGEHELPER_GETVARIABLE(mylocaltime);

					float pingtime = (float)(mLocalTimeStartPollTime - mylocaltime);
					route->AddRoundTripPingTime(pingtime);
#ifdef DEBUG_PRINTS1
					dprintf("Route to %d = %f average ping time\n",route->GetTargetSessionID(),route->CalculateLatency());
#endif

					/* Send the session what we calculate as the time and delta when it will receive the packet, using the latency as the delta time */
					char buffer[20];
					SessionPacket_Header header;

					header.mDestinationSession = message.mSourceSession;
					header.mSourceSession = mSessionID;
					header.mPacketTypeAndChecksum = kXPSessionPacketType_Unreliable | kXPSessionPacketType_SessionMessage;

					MessageHelper message;
					message.SetBuffer(buffer);

					MESSAGEHELPER_ADDVARIABLEp(message,header.mDestinationSession);
					MESSAGEHELPER_ADDVARIABLEp(message,header.mSourceSession);
					MESSAGEHELPER_ADDVARIABLEp(message,header.mPacketTypeAndChecksum);

					sessmsgid = kSessionMessage_TimeSet;
					MESSAGEHELPER_ADDVARIABLEp(message,sessmsgid);
					float delta = route->CalculateLatency();
					SysTimeType time = startPollTime + delta;
					MESSAGEHELPER_ADDVARIABLEp(message,time);
					MESSAGEHELPER_ADDVARIABLEp(message,delta);

					// Stack context for the safe lock
					{
					THREADSAFELOCKCLASSNAMED(mMutexMiscValues);
					std::pair<std::map<int,float>::iterator,bool> ret = mBufferedLatencyBySessionID.insert(std::pair<int,float>(route->GetTargetSessionID(),delta));
					// If it didn't get inserted then we can update the value from the iterator
					if (!ret.second)
					{
						ret.first->second = delta;
					}
					}



					/**
					 * \todo This is slightly wrong as I should create a nice reliable session message sending function and not keep on creaitng message blocks
					 */
					route->mTransport->Send(buffer,message.GetSize());

					// If we have sent all the ping related packets and the route hasn't sent the completely stable message then send it
					if (!route->mCompletelyStable)
					{

						route->mCompletelyStable = true;
			// Now all the final connect stuff is moved here...
#ifdef DEBUG_PRINTS1
						dprintf("XPSession : Sending final connect stuff\n");
#endif

						std::vector<int> knownSessionIDs;
						std::vector<int> knownSessionIDsCanBeMaster;

						knownSessionIDs.clear();
						knownSessionIDs.push_back(mSessionID);

						// Notify all other connected sessions that the session id was detected as joining
						LIST_ITER_BEGIN(Route *,mConnections,route2);

						// Only if the output route is valid do we add it on the known session list
						if (route2->GetTargetSessionID() != messageSourceSessionID && route2->mCompletelyStable
								&& route2->GetTargetSessionID() != kXPSessionUnknownID)
						{
							// If the destination route is client only then and if the connecting route cannot be a master
							if (route2->mIsClientOnly && !route->mCanBeMaster)
							{
								// Don't add it to the known session list and don't send it on
								LIST_ITER_SKIP();
								continue;
							}

							knownSessionIDs.push_back(route2->GetTargetSessionID());

							SessionPacket_Header message;
							message.mDestinationSession = route2->GetTargetSessionID();
							message.mSourceSession = mSessionID;
							message.mPacketTypeAndChecksum = kXPSessionPacketType_Certain | kXPSessionPacketType_SessionMessage;

							SetBuffer(mMessageBufferOut);
							MESSAGEHELPER_ADDVARIABLE(message.mDestinationSession);
							MESSAGEHELPER_ADDVARIABLE(message.mSourceSession);
							MESSAGEHELPER_ADDVARIABLE(message.mPacketTypeAndChecksum);

							SessMsgType sessmsgid = kSessionMessage_SessionJoined;
							MESSAGEHELPER_ADDVARIABLE(sessmsgid);

							int temp = messageSourceSessionID;
							MESSAGEHELPER_ADDVARIABLE(temp);

#ifdef DEBUG_PRINTS1
							dprintf("Sending kSessionMessage_SessionJoined to sessid %d via direct transport\n",route2->GetTargetSessionID());
#endif

							route2->mTransport->SendCertain(mMessageBufferOut,GetSize());
							route2->mLastHeartBeatSentTime = startPollTime;
						}

						LIST_ITER_END();

						SessionPacket_Header message2;
						message2.mDestinationSession = messageSourceSessionID;
						message2.mSourceSession = mSessionID;
						message2.mPacketTypeAndChecksum = kXPSessionPacketType_SessionMessage | kXPSessionPacketType_Reliable;

						if (mSessionName != "")
						{
#ifdef DEBUG_PRINTS1
							dprintf("Sending kSessionMessage_SessionName to sessionid %d",message2.mDestinationSession);
#endif
							SetBuffer(mMessageBufferOut);
							MESSAGEHELPER_ADDVARIABLE(message2.mDestinationSession);
							MESSAGEHELPER_ADDVARIABLE(message2.mSourceSession);
							MESSAGEHELPER_ADDVARIABLE(message2.mPacketTypeAndChecksum);
							SessMsgType sessmsgid = kSessionMessage_SessionName;
							MESSAGEHELPER_ADDVARIABLE(sessmsgid);

							short namelen = (short) (mSessionName.size()+1);
							MESSAGEHELPER_ADDVARIABLE(namelen);

							AddData(mSessionName.c_str(),namelen);

							EncryptSessionPacket(message2);

							route->mTransport->SendReliable(mMessageBufferOut,GetSize());
							route->mLastHeartBeatSentTime = startPollTime;
						}


						// Now send all the session joined messages to the new session for all the known session ids so far
						// If it is client only then only send the can be masters
						int i;
						int sizeadjust = 100;
						int maxsize = (int)knownSessionIDs.size();

#ifdef DEBUG_PRINTS1
						dprintf("XPSession : Master knows about %d sessions...\n",maxsize);
						for (i=0;i<maxsize;i++)
						{
							dprintf("%d,",knownSessionIDs[i]);
						}
						dprintf("\n");
#endif

						for (i=0;i<maxsize;i+=sizeadjust)
						{
							message2.mDestinationSession = messageSourceSessionID;
							message2.mSourceSession = mSessionID;
//								message2.mPacketTypeAndChecksum = kXPSessionPacketType_SessionMessage | kXPSessionPacketType_Reliable;
							message2.mPacketTypeAndChecksum = kXPSessionPacketType_SessionMessage | kXPSessionPacketType_Certain;

							SetBuffer(mMessageBufferOut);
							MESSAGEHELPER_ADDVARIABLE(message2.mDestinationSession);
							MESSAGEHELPER_ADDVARIABLE(message2.mSourceSession);
							MESSAGEHELPER_ADDVARIABLE(message2.mPacketTypeAndChecksum);

#ifdef DEBUG_PRINTS1
							dprintf("Sending kSessionMessage_SessionJoined multiple (");
#endif

							// Now send all the session joined messages to the new session for all the known session ids so far
							int j;
							int end = maxsize - i;
							if (end > sizeadjust)
							{
								end = sizeadjust;
							}
							assert("end <= 0" && end > 0);
							for (j=0;j<end;j++)
							{
								SessMsgType sessmsgid = kSessionMessage_SessionJoined;
								MESSAGEHELPER_ADDVARIABLE(sessmsgid);
								int asessionid = knownSessionIDs[i+j];
								MESSAGEHELPER_ADDVARIABLE(asessionid);
#ifdef DEBUG_PRINTS1
								dprintf("%d ",knownSessionIDs[i+j]);
#endif
							}

#ifdef DEBUG_PRINTS1
							dprintf(") to sessid %d via direct transport\n",messageSourceSessionID);
#endif

//								route->mTransport->SendReliable(mMessageBufferOut,GetSize());
							route->mTransport->SendCertain(mMessageBufferOut,GetSize());
							route->mLastHeartBeatSentTime = startPollTime;
						}



						char buffer[20];
						SessionPacket_Header header;

#ifdef DEBUG_PRINTS1
						dprintf("Session id %d send kSessionMessage_SessionCompletelyStable to %d\n",mSessionID,messageSourceSessionID);
#endif

						header.mDestinationSession = messageSourceSessionID;
						header.mSourceSession = mSessionID;
						header.mPacketTypeAndChecksum = kXPSessionPacketType_Reliable | kXPSessionPacketType_SessionMessage;

						MessageHelper message;
						message.SetBuffer(buffer);

						MESSAGEHELPER_ADDVARIABLEp(message,header.mDestinationSession);
						MESSAGEHELPER_ADDVARIABLEp(message,header.mSourceSession);
						MESSAGEHELPER_ADDVARIABLEp(message,header.mPacketTypeAndChecksum);

						sessmsgid = kSessionMessage_SessionCompletelyStable;
						MESSAGEHELPER_ADDVARIABLEp(message,sessmsgid);

#ifdef DEBUG_PRINTS1
						dprintf("Session id %d Has pushed on new sessionid %d as joined\n",mSessionID,messageSourceSessionID);
#endif

						AddJoiner(messageSourceSessionID);

						route->mJoinerPosted = true;

						route->mTransport->SendReliable(buffer,message.GetSize());
						route->mLastHeartBeatSentTime = startPollTime;
					}
					length = 0;	// No following on messages
				}
				else
				{		// from if (IsMaster())
					SysTimeType mylocaltimereply;
					MESSAGEHELPER_GETVARIABLE(mylocaltimereply);

					char buffer[20];
					SessionPacket_Header header;

					header.mDestinationSession = message.mSourceSession;
					header.mSourceSession = mSessionID;
					header.mPacketTypeAndChecksum = kXPSessionPacketType_Unreliable | kXPSessionPacketType_SessionMessage;

					MessageHelper message;
					message.SetBuffer(buffer);

					MESSAGEHELPER_ADDVARIABLEp(message,header.mDestinationSession);
					MESSAGEHELPER_ADDVARIABLEp(message,header.mSourceSession);
					MESSAGEHELPER_ADDVARIABLEp(message,header.mPacketTypeAndChecksum);

					sessmsgid = kSessionMessage_PingPong;
					MESSAGEHELPER_ADDVARIABLEp(message,sessmsgid);

					MESSAGEHELPER_ADDVARIABLEp(message,mylocaltimereply);

					/**
					 * \todo This is slightly wrong as I should create a nice reliable session message sending function and not keep on creating message blocks
					 */
					route->mTransport->Send(buffer,message.GetSize());
				}
				break;
			}
			case kSessionMessage_TimeSet:
			{
#ifdef DEBUG_PRINTS2
				dprintf("Got a time correction packet\n");
#endif

				if (IsMaster())
				{
#ifdef DEBUG_PRINTS2
					dprintf("ERROR : Master got a time correction packet\n");
#endif
					assert(0 && "XPSession: Master got a time correction packet\n");
					break;
				}

				SysTimeType time;
				MESSAGEHELPER_GETVARIABLE(time);

				float delta;
				MESSAGEHELPER_GETVARIABLE(delta);

#ifdef DEBUG_PRINTS1
				dprintf("Calibrating time to be %f and got delta time hint %f\n",time,delta);
#endif

				THREADSAFELOCKCLASSNAMED(mMutexMiscValues);
				mZeroTime = FloatTime() - time;
				mZeroTimeDelta = delta;

				break;
			}
			case kSessionMessage_HeartBeat:
			{
#ifdef DEBUG_PRINTS2
				dprintf("Session id %d got a heart beat packet\n",mSessionID);
#endif
				break;
			}
			case kSessionMessage_SpiderTo:
			{
#ifdef DEBUG_PRINTS2
				dprintf("Session id %d got a kSessionMessage_SpiderTo packet\n",mSessionID);
#endif
				unsigned short urllen;
				char buffer[512];
				MESSAGEHELPER_GETVARIABLE(urllen);
				if ( urllen < ( sizeof(buffer) - 1) )
				{
					GetData(buffer,urllen);
					buffer[urllen] = 0;
					std::string url;
					url = std::string(buffer);

#ifdef DEBUG_PRINTS2
					dprintf("   SpiderTo url = '%s'\n",url.c_str());
#endif

					std::string justurls = url;

					std::string oneurl = ParseURLs(justurls);

					while(oneurl != "")
					{
						Transport *newtrans = FindTransport(oneurl);

						if (newtrans != NULL)
						{
							newtrans = newtrans->Allocate();		// Creates an object of the relevant class type
							newtrans->SetTransparentPacketCompression(mTransparentPacketCompression);
							Route *newRoute = new Route(newtrans);
							newRoute->mOutgoingSpiderID = message.mSourceSession;
							mConnections.push_back(newRoute);
							// Do the connect
							newtrans->Connect(oneurl);
#ifdef DEBUG_PRINTS1
							dprintf("Session $%p : SpiderTo Trying connection $%p via transport %s to session id %d to address '%s' from address'%s'\n",this, newtrans,newtrans->CanAccept().c_str(),message.mSourceSession,oneurl.c_str(),newtrans->ExportURL().c_str());
#endif
						}

						oneurl = ParseURLs("");
					}
				} //< if ( urllen < ( sizeof(buffer) - 1) )
				return true;

				break;
			}
			case kSessionMessage_SessionName:
			{
#ifdef DEBUG_PRINTS2
				dprintf("Session id %d got a kSessionMessage_SessionName packet\n",mSessionID);
#endif

				short namelen;

				MESSAGEHELPER_GETVARIABLE(namelen);

				char tempdatabuff[512];

				GetData(&tempdatabuff[0],namelen);
				mSessionName = std::string(tempdatabuff);

#ifdef DEBUG_PRINTS1
				dprintf("Session $%p : Sessionname being changed by network packet to '%s'\n", this,mSessionName.c_str());
#endif

				break;				
			}
			case kSessionMessage_SessionCompletelyStable:
			{
#ifdef DEBUG_PRINTS1
				dprintf("Session $%p : ID %d Got kSessionMessage_SessionCompletelyStable\n", this,mSessionID);
#endif
				mCompletelyStable = true;

//				dprintf("\nmTryingJoin = false\n\n");

				mTryingJoin = false;
				break;
			}


			case kSessionMessage_IsClientOnly:
			{
#ifdef DEBUG_PRINTS1
				dprintf("Session $%p : ID %d Got kSessionMessage_IsClientOnly from %d\n", this,mSessionID,route->GetTargetSessionID());
#endif
				route->mIsClientOnly = true;
				break;
			}

			case kSessionMessage_FragmentedDataPacketStart:
			{
#ifdef DEBUG_PRINTS1
				dprintf("Session $%p : ID %d Got kSessionMessage_FragmentedDataPacketStart from %d\n", this,mSessionID,route->GetTargetSessionID());
#endif
				assert(!route->mFragmentedPacketCombiner && "More than one concurrent fragmented packet from a route is bad\n");
				if (route->mFragmentedPacketCombiner)
				{
					free(route->mFragmentedPacketCombiner);
				}
				MESSAGEHELPER_GETVARIABLE(route->mFragmentedPacketSentSize);
				MESSAGEHELPER_GETVARIABLE(route->mFragmentedPacketRealSize);

				if ( ( route->mFragmentedPacketSentSize > 0 ) && ( route->mFragmentedPacketRealSize > 0 ) && ( ( route->mFragmentedPacketSentSize + route->mFragmentedPacketRealSize ) < mMaximumDataSize ) )
				{
					route->mFragmentedPacketCombiner = (char *) malloc(route->mFragmentedPacketSentSize);
					assert(route->mFragmentedPacketCombiner);
					route->mFragmentedPacketGotSize = 0;
				}
				else
				{
#ifdef DEBUG_PRINTS1
					dprintf("Session $%p : ID %d Got kSessionMessage_FragmentedDataPacketStart disconnect route\n", this,mSessionID);
#endif
					assert(!"XPSession: kSessionMessage_FragmentedDataPacketStart bad size disconnect route\n");
					route->mFatalError = true;
				}
				break;
			}

			case kSessionMessage_FragmentedDataPacketContinue:
			{
#ifdef DEBUG_PRINTS1
				dprintf("Session $%p : ID %d Got kSessionMessage_FragmentedDataPacketContinue from %d\n", this,mSessionID,route->GetTargetSessionID());
#endif
				unsigned short thisChunkSize;
				MESSAGEHELPER_GETVARIABLE(thisChunkSize);

				assert(route->mFragmentedPacketCombiner);
				if ( !route->mFragmentedPacketCombiner )
				{
					break;
				}

				if ( (route->mFragmentedPacketGotSize + thisChunkSize) > route->mFragmentedPacketSentSize )
				{
					assert(!"Bad fragmented packet received");
					break;
				}

				GetData((void *)(route->mFragmentedPacketCombiner + route->mFragmentedPacketGotSize),thisChunkSize);
				route->mFragmentedPacketGotSize += thisChunkSize;
				if (route->mFragmentedPacketGotSize >= route->mFragmentedPacketSentSize)
				{
					// We have a full packet, see if it was compressed or not
					if (route->mFragmentedPacketRealSize != route->mFragmentedPacketSentSize)
					{
						// Compressed
						XPCompression comp;
						char *decompBuff = (char *) malloc(route->mFragmentedPacketRealSize);
						assert(decompBuff);
						int decompLen;
						bool ret = comp.Decompress(route->mFragmentedPacketCombiner,route->mFragmentedPacketGotSize,decompBuff,&decompLen,route->mFragmentedPacketRealSize);
						assert(ret);
						assert(decompLen == route->mFragmentedPacketRealSize);
						if (ret && decompLen == route->mFragmentedPacketRealSize)
						{
							WaitingPacket *packet = new WaitingPacket;
							packet->mSize = route->mFragmentedPacketRealSize;
							packet->mPacket = decompBuff;
							packet->mFromSession = message.mSourceSession;
							packet->mPacketType = message.mPacketTypeAndChecksum & (kXPSessionPacketType_Unreliable | kXPSessionPacketType_Certain | kXPSessionPacketType_Reliable);

							// Free the compressed data and reset the pointer ready for the next one.
							free(route->mFragmentedPacketCombiner);
							route->mFragmentedPacketCombiner = 0;

							// Quickly lock the relevant mutex
							THREADSAFELOCKCLASS(mMutexRecvPackets);
							mWaitingPackets.push_back(packet);
						}
						else
						{
#ifdef DEBUG_PRINTS2
							dprintf("XPSession: mFragmentedPacketCombiner Decompression failed\n");
#endif
							assert(0 && "XPSession: mFragmentedPacketCombiner Decompression failed\n");
							route->mFatalError = true;
							break;
						}
					}
					else
					{
						// Not compressed
						WaitingPacket *packet = new WaitingPacket;
						packet->mSize = route->mFragmentedPacketRealSize;
						packet->mPacket = route->mFragmentedPacketCombiner;
						packet->mFromSession = message.mSourceSession;
						packet->mPacketType = message.mPacketTypeAndChecksum & (kXPSessionPacketType_Unreliable | kXPSessionPacketType_Certain | kXPSessionPacketType_Reliable);

						// No need to free, we reuse the buffer for the waiting packet. Clear the pointer ready for the next one.
						route->mFragmentedPacketCombiner = 0;

						// Quickly lock the relevant mutex
						THREADSAFELOCKCLASS(mMutexRecvPackets);
						mWaitingPackets.push_back(packet);
					}
				}
				break;
			}

			case kSessionMessage_ProxyMaster:
			{
#ifdef DEBUG_PRINTS1
				dprintf("Session $%p : ID %d Got kSessionMessage_ProxyMaster\n", this,mSessionID);
#endif
				mMasterIsProxyMode = true;
				break;
			}


			default:
			{
#ifdef DEBUG_PRINTS2
				dprintf("XPSession: Unknown packet type\n");
#endif
				assert(0 && "XPSession: Not allowed to leave unknown packets types in the queue\n");
				break;
			}
		}
	}

	return false;
}

void XPSession::DataSendToSession(const int sessionid,const char *data,const int length,const bool reliable,const bool certain,const bool ordered,const unsigned int band)
{
	// Don't waste time trying to send packets as we are an unknown session ID
	if (mSessionID == kXPSessionUnknownID)
	{
		return;
	}

	// Don't waste time trying to send packets to ourselves
	if (mSessionID == sessionid)
	{
		return;
	}

	// Don't waste time trying to send packets with zero length
	if (length <= 0)
	{
		return;
	}

	// Don't send packets if we are in an error state
	if (mStatus == kXPSession_EERROR)
	{
		return;
	}

	// Not allowed to send to a master session if it is proxying
	if (mMasterIsProxyMode && (sessionid == mMasterSessionID))
	{
		return;
	}


	if (!mEnableExtraBuffering)
	{
		DataSendToSessionPrivate(sessionid,data,length,reliable,certain,ordered,band);
		return;
	}

	XPSessionInternalBufferedPacket *packet = new XPSessionInternalBufferedPacket(sessionid,data,length,reliable,certain,ordered,band);

	THREADSAFELOCKCLASS(mMutexSentPackets);
	mNumWaitingToSend++;
	mWaitingToSend.push_back(packet);
}


void XPSession::DataPacketSendPrivate(const int finalDestID,const char *data,const int length,const bool reliable,const bool certain,const bool ordered,const unsigned int band,Route *route)
{
	if ( length > mMaximumDataSize )
	{
		assert( !"Data sent > XPSession::SetMaximumDataSize" );
		return;
	}

	THREADSAFELOCK();

	SessionPacket_Header message;
	int chunkSize = route->mTransport->GetMaxPacketSize();
	assert(chunkSize <= mBufferLen);

	if (chunkSize > 65535)
	{
		chunkSize = 65535;	// Unsigned short range used below
	}

	// Taking into account worst case packet overhead for this function, so when the receive part operates on the pack the packets can still get through.
	chunkSize = chunkSize - sizeof(message.mDestinationSession) - sizeof(message.mSourceSession) - sizeof(message.mPacketTypeAndChecksum) - sizeof(SessMsgType) - sizeof(int) - sizeof(int);


#ifdef DEBUG_PRINTS2
	dprintf( "XPSession : DataPacketSendPrivate finalDestID %d length %d reliable %d certain %d ordered %d band %d route $%x chunkSize %d\n", finalDestID , length , reliable , certain , ordered , band , (int) route , chunkSize );
#endif

	// Check for large data packets bigger than chunkSize.
	if (length > chunkSize)
	{
		char *sendData = (char *)data;
		int sendDataLength = length;
		bool isCompressed = false;
		if (mEnableAutomaticCompression)
		{
			XPCompression comp;
			int worstCase = comp.CalculateMaximumMemory(length);
			void *tempbuf = malloc(worstCase);
			assert(tempbuf && "Failed to allocate temporary compression buffer for fragmented packet");
			if (!tempbuf)
			{
				return;
			}

			int compLen;
			// Compression level 10, the default, is quite time consuming. Trying a lower level did help.
			// MPi: TODO: Make this configurable in a future release.
			comp.Compress((void *)data,length,tempbuf,&compLen,mLargePacketCompressionLevel);

			int diff = length - compLen;
			if (diff < 64)
			{
				// Compression didn't save enough bytes to make it worth while
				free(tempbuf);
			}
			else
			{
				isCompressed = true;
				sendData = (char *)tempbuf;
				sendDataLength = compLen;
			}
		}

		message.mDestinationSession = finalDestID;
		message.mSourceSession = mSessionID;
		message.mPacketTypeAndChecksum = kXPSessionPacketType_SessionMessage | kXPSessionPacketType_Reliable;

		SetBuffer(mMessageBufferOut);
		MESSAGEHELPER_ADDVARIABLE(message.mDestinationSession);
		MESSAGEHELPER_ADDVARIABLE(message.mSourceSession);
		MESSAGEHELPER_ADDVARIABLE(message.mPacketTypeAndChecksum);

		SessMsgType sessmsgid = kSessionMessage_FragmentedDataPacketStart;
		MESSAGEHELPER_ADDVARIABLE(sessmsgid);
		MESSAGEHELPER_ADDVARIABLE(sendDataLength);
		MESSAGEHELPER_ADDVARIABLE(length);

		if (mEncryptionOn)
		{
			EncryptSessionPacket(message);
		}

		route->mTransport->SendReliable(mMessageBufferOut,GetSize());
		route->mLastHeartBeatSentTime = startPollTime;

		int offset;
		for (offset=0;offset < sendDataLength;offset+=chunkSize)
		{
			int maxLen = sendDataLength - offset;
			if (maxLen > chunkSize)
			{
				maxLen = chunkSize;
			}
			message.mDestinationSession = finalDestID;
			message.mSourceSession = mSessionID;
			message.mPacketTypeAndChecksum = kXPSessionPacketType_SessionMessage | kXPSessionPacketType_Reliable;

			SetBuffer(mMessageBufferOut);
			MESSAGEHELPER_ADDVARIABLE(message.mDestinationSession);
			MESSAGEHELPER_ADDVARIABLE(message.mSourceSession);
			MESSAGEHELPER_ADDVARIABLE(message.mPacketTypeAndChecksum);

			SessMsgType sessmsgid = kSessionMessage_FragmentedDataPacketContinue;
			MESSAGEHELPER_ADDVARIABLE(sessmsgid);
			unsigned short thisChunkSize = (unsigned short) maxLen;
			MESSAGEHELPER_ADDVARIABLE(thisChunkSize);
			AddData((void *)(sendData + offset),maxLen);

			if (mEncryptionOn)
			{
				EncryptSessionPacket(message);
			}

			route->mTransport->SendReliable(mMessageBufferOut,GetSize());
			route->mLastHeartBeatSentTime = startPollTime;
		}

		// If it was compressed then free the temporary buffer
		if (isCompressed)
		{
			free(sendData);
		}

		return;
	}

	// Smaller packets are dealt with here
	message.mDestinationSession = finalDestID;
	message.mSourceSession = mSessionID;
	// User message. i.e. It is not a session message.
	message.mPacketTypeAndChecksum = 0; //kXPSessionPacketType_UserMessage;
	if (reliable)
	{
		message.mPacketTypeAndChecksum |= kXPSessionPacketType_Reliable;
	}
	else if (certain)
	{
		message.mPacketTypeAndChecksum |= kXPSessionPacketType_Certain;
	}
	else if (ordered)
	{
		message.mPacketTypeAndChecksum |= kXPSessionPacketType_Ordered;
	}

	SetBuffer(mMessageBufferOut);
	MESSAGEHELPER_ADDVARIABLE(message.mDestinationSession);
	MESSAGEHELPER_ADDVARIABLE(message.mSourceSession);
	MESSAGEHELPER_ADDVARIABLE(message.mPacketTypeAndChecksum);

	AddData((void *)data,length);

	if (mEnableAutomaticCompression)
	{
		CompressSessionPacket(message);
	}
	if (mEncryptionOn)
	{
		EncryptSessionPacket(message);
	}

	// Transport types that guarantee delivery mean the packet will get an ACK in reply, so no need for a heartbeat.
	if (reliable)
	{
		route->mTransport->SendReliable(mMessageBufferOut,GetSize(),band);
		route->mLastHeartBeatSentTime = startPollTime;
	}
	else if (certain)
	{
		route->mTransport->SendCertain(mMessageBufferOut,GetSize());
		route->mLastHeartBeatSentTime = startPollTime;
	}
	else if (ordered)
	{
		route->mTransport->SendOrdered(mMessageBufferOut,GetSize(),band);
	}
	else
	{
		route->mTransport->Send(mMessageBufferOut,GetSize());
	}
}

void XPSession::DataSendToSessionPrivate(const int sessionid,const char *data,const int length,const bool reliable,const bool certain,const bool ordered,const unsigned int band)
{
	// ** Do not lock this function with any mutex otherwise we may get a deadlock **
	if (reliable && certain)
	{
		assert(0 && "Should not have reliable and certain flags set for DataSendToSession");
	}

	// Don't waste time trying to send packets as we are an unknown session ID
	if (mSessionID == kXPSessionUnknownID)
	{
		return;
	}

	// Don't waste time trying to send packets to ourselves
	if (mSessionID == sessionid)
	{
		return;
	}

	// Don't waste time trying to send packets with zero length
	if (length <= 0)
	{
		return;
	}

	// Don't send packets if we are in an error state
	if (mStatus == kXPSession_EERROR)
	{
		return;
	}

	THREADSAFELOCK();

/*
	if (reliable && (band != 0))
	{
		printf("Sending with band %d\n",band);
	}
*/

	int finalDestID = sessionid;

	// If we are in a pre-connect stage then convert an kXPSessionUnknownID to be the masterID
	if (mInPreConnect && (finalDestID == kXPSessionUnknownID))
	{
		finalDestID = mMasterSessionID;
	}


#ifdef DEBUG_PRINTS2
	if (reliable)
	{
		dprintf("XPSession : Sending a reliable packet to sessid %d with band\n",finalDestID,band);
	}
	else if (certain)
	{
		dprintf("XPSession : Sending a certain packet to sessid %d\n",finalDestID);
	}
	else if (ordered)
	{
		dprintf("XPSession : Sending a normal ordered packet to sessid %d\n",finalDestID);
	}
	else
	{
		dprintf("XPSession : Sending a normal packet to sessid %d\n",finalDestID);
	}
#endif

	// First do the IsMaster() and broadcast packet
	if (IsMaster() && (finalDestID == kXPSessionBroadcastID))
	{
		LIST_ITER_BEGIN(Route *,mConnections,route);

		if (route->GetTargetSessionID() != kXPSessionUnknownID)
		{
			DataPacketSendPrivate(finalDestID,data,length,reliable,certain,ordered,band,route);
		}

#ifdef DEBUG_PRINTS2
		dprintf("XPSession : packet sent to sessID %d\n",route->GetTargetSessionID());
#endif

		LIST_ITER_END();
		return;
	}

	// Now do the non-broadcast message if possible
	if (finalDestID != kXPSessionBroadcastID)
	{
		// Not allowed to send to a master session if it is proxying
		if (mMasterIsProxyMode && (finalDestID == mMasterSessionID))
		{
			return;
		}

		Route *route = FindRouteForSessionIDFromMap(finalDestID);
		if (route)
		{
			DataPacketSendPrivate(finalDestID,data,length,reliable,certain,ordered,band,route);

#ifdef DEBUG_PRINTS2
			dprintf("XPSession : packet sent direct to sessID %d\n",route->GetTargetSessionID());
#endif
			return;
		}
	}

	// If I'm not the master then look for the master route and send the message
	if (!IsMaster())
	{
		 // Even if mMasterIsProxyMode is enabled we allow messages to be routed through the master

#ifdef DEBUG_PRINTS2
		dprintf("XPSession : packet being sent to the master for routing\n");
#endif
		Route *route = FindRouteForSessionIDFromMap(mMasterSessionID);
		if (route)
		{
			DataPacketSendPrivate(finalDestID,data,length,reliable,certain,ordered,band,route);
			return;
		}
#ifdef DEBUG_PRINTS2
		dprintf("+++ Warning : Send to a specific session ID %d failed from ID %d as there was no master session\n",finalDestID,mSessionID);
#endif
	}

#ifdef DEBUG_PRINTS2
	dprintf("+++ Warning : Send to a specific session ID %d failed from ID %d as there was no route to session\n",finalDestID,mSessionID);
#endif
}

void XPSession::DataSendToSessionUnreliable(const int sessionid,const char *data,const int length)
{
	DataSendToSession(sessionid,data,length,false,false);
}

void XPSession::DataSendToSessionCertain(const int sessionid,const char *data,const int length)
{
	DataSendToSession(sessionid,data,length,false,true);
}

void XPSession::DataSendToSessionReliable(const int sessionid,const char *data,const int length,const unsigned int band)
{
	DataSendToSession(sessionid,data,length,true,false,false,band);
}

void XPSession::DataSendToSessionOrdered(const int sessionid,const char *data,const int length,const unsigned int band)
{
	DataSendToSession(sessionid,data,length,false,false,true,band);
}

bool XPSession::DataReceivePeek(int *const fromsessionid,int *const length,unsigned char *const type)
{
	// Don't want the main class THREADSAFELOCK now.
//	THREADSAFELOCK();

	// Thread safe because it is a const read only operation
	if (mWaitingPackets.empty())
	{
		return false;
	}

	// Create stack frame for the safe lock
	// Very transient.
	WaitingPacket *packet;
	{
		THREADSAFELOCKCLASS(mMutexRecvPackets);
		// Now we have the lock, double check
		if (mWaitingPackets.empty())
		{
			return false;
		}

		packet = *mWaitingPackets.begin();

		if (fromsessionid)
		{
			*fromsessionid = packet->mFromSession;
		}
		if (length)
		{
			*length = packet->mSize;
		}

		if (type)
		{
			*type = packet->mPacketType & 0x03;
		}
	}

	return true;
}

bool XPSession::DataReceive(int *const fromsessionid,char *const data,int *const length,unsigned char *const type)
{
	// Don't want the main class THREADSAFELOCK now.
//	THREADSAFELOCK();

	// Thread safe because it is a const read only operation
	if (mWaitingPackets.empty())
	{
		return false;
	}

	// Don't receive packets if we are in an error state
	if (mStatus == kXPSession_EERROR)
	{
		return false;
	}

	// Create stack frame for the safe lock
	// Very transient.
	WaitingPacket *packet;
	{
		THREADSAFELOCKCLASS(mMutexRecvPackets);
		// Now we have the lock, double check
		if (mWaitingPackets.empty())
		{
			return false;
		}

		packet = *mWaitingPackets.begin();
		mWaitingPackets.pop_front();
	}

	if (fromsessionid)
	{
		*fromsessionid = packet->mFromSession;
	}
	if (length)
	{
		*length = packet->mSize;
	}

	memcpy( data , packet->mPacket , packet->mSize );

	if (type)
	{
		*type = packet->mPacketType & 0x03;
	}

	delete packet;

	return true;
}

int XPSession::BufferedGetNetworkPacketsLost(void)
{
	THREADSAFELOCK();

	int lost = 0;
	LIST_ITER_BEGIN(Route *,mConnections,route);

	if (route->mTransport)
	{
		lost += route->mTransport->GetPacketsLost();
	}

	LIST_ITER_END();

	return lost;
}

int XPSession::GetJoiner(void)
{
	// Thread safe since it is a const read only operation.
	if (mJoiners.empty())
	{
		return kXPSessionUnknownID;
	}

	THREADSAFELOCKCLASSNAMED(mMutexJoinerList);
	// Now double check
	if (mJoiners.empty())
	{
		return kXPSessionUnknownID;
	}

	int joiner = *mJoiners.begin();

	mJoiners.pop_front();

	// Filter out the master session ID
	if (mMasterIsProxyMode && (joiner == mMasterSessionID))
	{
		return kXPSessionUnknownID;
	}

	return joiner;
}

int XPSession::GetLeaver(void)
{
	// Thread safe const read only operation
	if (mLeavers.empty())
	{
		return kXPSessionUnknownID;
	}

	THREADSAFELOCKCLASSNAMED(mMutexLeaverList);
	if (mLeavers.empty())
	{
		return kXPSessionUnknownID;
	}

	int leaver = *mLeavers.begin();

	mLeavers.pop_front();

	// Filter out the master session ID
	if (mMasterIsProxyMode && (leaver == mMasterSessionID))
	{
		return kXPSessionUnknownID;
	}

	return leaver;
}

SysTimeType XPSession::GetTime(void)
{
	THREADSAFELOCKCLASSNAMED(mMutexMiscValues);

	return FloatTime() - mZeroTime;
}

SysTimeType XPSession::GetLocalTime(void)
{
	return FloatTime();
}

int XPSession::ThreadEntry(void)
{
	while (1)
	{
		Sleep(10);

		if (!mManualPoll)
		{
			Poll();

			if (mBreakoutDone)
			{
//				dprintf("mBreakoutDone RePoll()\n");
				Poll();
			}
		}
		else
		{
			Sleep(100);
		}
	}
	return 0;
}

void XPSession::CompressSessionPacket(SessionPacket_Header &message)
{
	int headsize = sizeof(message.mSourceSession)+sizeof(message.mDestinationSession)+sizeof(message.mPacketTypeAndChecksum);

	mCompressionBefore += GetSize();

	// Don't bother trying to compress anything that is so small
	if ( (GetSize() - headsize) <= 8)
	{
		mCompressionAfter += GetSize();
		return;
	}

	XPCompression comp;
	int worstCase = comp.CalculateMaximumMemory(GetSize()-headsize);
	void *tempbuf = malloc(worstCase);
	assert(tempbuf && "Failed to allocate temporary compression buffer");
	if (!tempbuf)
	{
		return;
	}

	int compLen;
	comp.Compress(((char *)mMessageBufferOut)+headsize,GetSize()-headsize,tempbuf,&compLen,mPacketCompressionLevel);

	int diff = (GetSize()-headsize) - compLen;
	// Compression didn't save enough bytes to make it worth while
	if (diff < 4)
	{
		mCompressionAfter += GetSize();
		free(tempbuf);
		return;
	}

#ifdef DEBUG_PRINTS2
	dprintf("XPSession : Compression saved = %d bytes\n",diff);
#endif

	// Copy over the compressed data and change the message length
	SetSize(headsize + compLen);
	mCompressionAfter += GetSize();
	memcpy(((char *)mMessageBufferOut)+headsize,tempbuf,compLen);
	free(tempbuf);

	// Update the header
	message.mPacketTypeAndChecksum |= kXPSessionPacketType_CompressedMessage;
	mMessageBufferOut[headsize-1] = message.mPacketTypeAndChecksum;

}

void XPSession::EncryptSessionPacket(SessionPacket_Header &message)
{
//	assert(message.mPacketTypeAndChecksum != 1 && "message.mPacketTypeAndChecksum != 1");
	Encryption::Key key;
	int headsize = sizeof(message.mSourceSession)+sizeof(message.mDestinationSession)+sizeof(message.mPacketTypeAndChecksum);
	key.Create(mMessageBufferOut,sizeof(message.mSourceSession)+sizeof(message.mDestinationSession));
#ifdef DEBUG_PRINTS2
	dprintf("XPSession : EncryptSessionPacket Key = %x %x %x %x %x %x %x %x\n",key.mKey[0],key.mKey[1],key.mKey[2],key.mKey[3],key.mKey[4],key.mKey[5],key.mKey[6],key.mKey[7]);
#endif
	int calcuated_checksum = Checksum::ChecksumData(((char *)mMessageBufferOut)+headsize,GetSize()-headsize);
	calcuated_checksum = calcuated_checksum ^ (calcuated_checksum>>8) ^ (calcuated_checksum>>16) ^ (calcuated_checksum>>24);
	calcuated_checksum = calcuated_checksum ^ (calcuated_checksum>>4);
	calcuated_checksum &= 15;
	if (!calcuated_checksum)
	{
		calcuated_checksum = 1;
	}
#ifdef DEBUG_PRINTS2
	dprintf("XPSession : Calculated checksum = %x\n",calcuated_checksum);
#endif

	void *tempbuf = malloc(GetSize()-headsize);
	assert(tempbuf && "Failed to allocate temporary encrypt buffer");
	if (!tempbuf)
	{
		return;
	}
	memcpy(tempbuf,((char *)mMessageBufferOut)+headsize,GetSize()-headsize);
//	Encryption::Encrypt(((char *)mMessageBufferOut)+headsize,GetSize()-headsize,&key);
	Encryption::Encrypt(tempbuf,GetSize()-headsize,&key);
	memcpy(((char *)mMessageBufferOut)+headsize,tempbuf,GetSize()-headsize);
	free(tempbuf);

	message.mPacketTypeAndChecksum |= (calcuated_checksum&15)<<4;
	mMessageBufferOut[headsize-1] = message.mPacketTypeAndChecksum;
}

void XPSession::MutateToMaster(const int nextsessionid,const Route *route)
{
#ifdef DEBUG_PRINTS1
	dprintf("MutateToMaster %d,%d\n",mSessionID,nextsessionid);
#endif
	mPotentialMasterSessionID = kXPSessionUnknownID;
	mMasterSessionID = mSessionID;
	mIsMaster = true;
	mNextSessionID = nextsessionid;
	if (mGetSessionIDCallback)
	{
		mNextSessionID = (*mGetSessionIDCallback)(mGetSessionIDCallbackContext);
	}
	mCompletelyStable = true;
	mTryingJoin = false;

	{
	THREADSAFELOCKCLASSNAMED(mMutexMiscValues);
	mBufferedLatencyBySessionID.erase(mSessionID);
	}

	// Here we build a list of really unconnected sessionIDs
	// These are session IDs that we might have started an outgoing connection to
	// then for some reason the one way spider got disconnected.
	// This means half connected spiders will then drop out of our session
	std::set<int> reallyUnconnected;
	LIST_ITER_BEGIN(Route *,mConnections,route2);
	if (route2->GetTargetSessionID() == kXPSessionUnknownID && route2->mOutgoingSpiderID != kXPSessionUnknownID)
	{
		reallyUnconnected.insert(route2->mOutgoingSpiderID);
	}
	LIST_ITER_END();

	// Remember to double check the mReallyUnconnected with the sessions we have been connected to
	// Also massage the connection so it looks like a master connection
	LIST_ITER_BEGIN(Route *,mConnections,route2);
	if (route2 != route && route2->GetTargetSessionID() != kXPSessionUnknownID)
	{
		char buffer[32];
		MessageHelper message;
		message.SetBuffer(buffer);
		SessionPacket_Header header;
		header.mDestinationSession = route2->GetTargetSessionID();
		header.mSourceSession = mSessionID;
		header.mPacketTypeAndChecksum = kXPSessionPacketType_Reliable | kXPSessionPacketType_SessionMessage;

		MESSAGEHELPER_ADDVARIABLEp(message,header.mDestinationSession);
		MESSAGEHELPER_ADDVARIABLEp(message,header.mSourceSession);
		MESSAGEHELPER_ADDVARIABLEp(message,header.mPacketTypeAndChecksum);

		SessMsgType sessmsgid = kSessionMessage_IsMaster;
		MESSAGEHELPER_ADDVARIABLEp(message,sessmsgid);

		route2->mTransport->SendReliable(buffer,message.GetSize());
		route2->mLastHeartBeatSentTime = startPollTime;
		route2->mJoinerPosted = true;
		route2->mCompletelyStable = true;		// So the master can access the list properly and doesn't try to send this person as joining since it is already joined according to other peers
		route2->mReadyForNextPing = true;
		route2->mIsDoingPreConnect = false;

		// Double check what sessionIDs are hanging around and remove if we can send to them
		reallyUnconnected.erase(route2->GetTargetSessionID());

	}
	LIST_ITER_END();


	// Add the really unconnected sessionIDs to the potential leavers list
	std::set<int>::iterator ist,ien;
	ist = reallyUnconnected.begin();
	ien = reallyUnconnected.end();
	while (ist != ien)
	{
		int sessid = *ist;
		mPotentialLeavers.push_back(sessid);
		ist++;
	}

	// Now notify everyone about leavers etc, since we are the new master
	LIST_ITER_BEGIN(int,mPotentialLeavers,theleftsessionid)
	AddLeaver(theleftsessionid);
		LIST_ITER_BEGIN(Route *,mConnections,route2);
		// If this pre-built outgoing route matches then we set it to error
		if (route2 != route && route2->mOutgoingSpiderID == theleftsessionid)
		{
			route2->mFatalError = true;
			LIST_ITER_SKIP();
			continue;
		}
		// Route is valid, for now, so we send it the information
		if (route2 != route && route2->GetTargetSessionID() != kXPSessionUnknownID)
		{
			char buffer[32];
			MessageHelper message;
			message.SetBuffer(buffer);
			SessionPacket_Header header;
			header.mDestinationSession = route2->GetTargetSessionID();
			header.mSourceSession = mSessionID;
			header.mPacketTypeAndChecksum = kXPSessionPacketType_Certain | kXPSessionPacketType_SessionMessage;

			MESSAGEHELPER_ADDVARIABLEp(message,header.mDestinationSession);
			MESSAGEHELPER_ADDVARIABLEp(message,header.mSourceSession);
			MESSAGEHELPER_ADDVARIABLEp(message,header.mPacketTypeAndChecksum);

			// TODO: Potential leavers that were not can become masters should not be told to client only nodes
			// This will need some extra data saved
			SessMsgType sessmsgid = kSessionMessage_SessionLeft;
			MESSAGEHELPER_ADDVARIABLEp(message,sessmsgid);

			int temp = theleftsessionid;
			MESSAGEHELPER_ADDVARIABLEp(message,temp);

			route2->mTransport->SendCertain(buffer,message.GetSize());
			route2->mLastHeartBeatSentTime = startPollTime;
		}
		LIST_ITER_END();
	LIST_ITER_END();
	mPotentialLeavers.clear();

	char tempStr[32];
	sprintf(tempStr,"%d",GetGameChannel());
// TODO: Make this match transports from the saved url that is parsed in Join()
	VECTOR_ITER_BEGIN(Transport *,mListens,trans);
	{
		std::string theURL = trans->ExportURL();
		// TODO: Make this more robust by having the transport report the channel it listens on as an int
		// If we have a listens channel match or we don't care what channel we end up being on...
		// We have a match, so change the listens to be a master listens
		if (theURL.find(tempStr) != std::string::npos || GetGameChannel() == TransportAnyGameChannel)
		{
			// It is already on the correct game channel
			mMasterListens.push_back(trans);
			VECTOR_ITER_ERASENOCONT(mListens);
			continue;
		}

		// Create a replica of the mListens transport types
		Transport *newtrans = trans->Allocate();

		assert(newtrans);
		if (newtrans)
		{
			newtrans->SetTransparentPacketCompression(mTransparentPacketCompression);
			Transport::Error ret = newtrans->Listen(GetGameChannel());
			if (ret == Transport::kTransport_ECANTLISTENONCHANNEL)
			{
				ret = newtrans->Listen();
			}
			if (ret == Transport::kTransport_EERROR || ret == Transport::kTransport_ECANTLISTENONCHANNEL)
			{
#ifdef DEBUG_PRINTS1
				dprintf("Session $%p : Can't setup a default channel for new master\n", this);
#endif
				delete newtrans;
			}
			else
			{
				mMasterListens.push_back(newtrans);
			}
		}
	}
	VECTOR_ITER_END();
}

void XPSession::AddJoiner(const int sessionid)
{
	assert(sessionid != kXPSessionUnknownID && "AddJoiner using kXPSessionUnknownID which is wrong");
	assert(sessionid != kXPSessionBroadcastID && "AddJoiner using kXPSessionBroadcastID which is wrong");

	THREADSAFELOCKCLASSNAMED(mMutexJoinerList);
	mJoiners.push_back(sessionid);
}

void XPSession::AddLeaver(const int sessionid)
{
	assert(sessionid != kXPSessionUnknownID && "AddLeaver using kXPSessionUnknownID which is wrong");
	assert(sessionid != kXPSessionBroadcastID && "AddLeaver using kXPSessionBroadcastID which is wrong");

	// Stack context for the safe lock
	{
	THREADSAFELOCKCLASSNAMED(mMutexMiscValues);
	mBufferedURLsBySessionID.erase(sessionid);
	mBufferedLatencyBySessionID.erase(sessionid);
	}

	THREADSAFELOCKCLASSNAMED(mMutexLeaverList);
	mLeavers.push_back(sessionid);
}

void XPSession::SetManualPoll(void)
{
	mManualPoll = true;
}

void XPSession::SetAutomaticPoll(void)
{
	mManualPoll = false;
}

void XPSession::SetPollLayerBelow(bool enable)
{
	if (PlatformInfo::IsThreaded())
	{
		mPollLayerBelow = enable;
	}
	else
	{
		mPollLayerBelow = true;
	}
}

bool XPSession::GetPollLayerBelow(void)
{
	return mPollLayerBelow;
}

void XPSession::Disconnect(const int sessionID)
{
	THREADSAFELOCK();

#ifdef DEBUG_PRINTS1
	dprintf("XPSession id %d was told to force a disconnect to %d\n",mSessionID,sessionID);
#endif

	// If we disconnect from all session nodes...
	if (sessionID == kXPSessionUnknownID)
	{
		// Flag all
		// Go through the other connections and see if we can flag any other duplicate routes for delete
		LIST_ITER_BEGIN(Route *,mConnections,route3);
		if (route3->GetTargetSessionID() != kXPSessionUnknownID)
		{
#ifdef DEBUG_PRINTS1
			dprintf("XPSession : Now flagging route $%p as bad for sessionid %d\n",route3,route3->GetTargetSessionID());
#endif
			route3->mFatalError = true;
		}
		LIST_ITER_END();

		// ...then signal a session error
 		mStatus = kXPSession_EERROR;
	}
	else
	{
		// Go through the other connections and see if we can flag any other duplicate routes for delete
		std::multimap<int,Route*>::iterator lb = mConnectionsBySessionID.lower_bound(sessionID);
		std::multimap<int,Route*>::iterator ub = mConnectionsBySessionID.upper_bound(sessionID);
		while (lb != ub)
		{
			Route *route = (*lb).second;
			assert(route->GetTargetSessionID() == sessionID);

#ifdef DEBUG_PRINTS1
			dprintf("XPSession : Now flagging route $%p as bad for sessionid %d\n",route,route->GetTargetSessionID());
#endif
			route->mFatalError = true;
			lb++;
		}
	}
}


XPSession::Route::Route()
{
	SetDefault();
	mTransport = NULL;
}

XPSession::Route::Route(Transport *transport)
{
	SetDefault();
	mTransport = transport;
}

XPSession::Route::~Route()
{
	// Detach from the set if we are registered with it
	if (mInMapFor)
	{
		mInMapFor->mConnectionsBySessionID.erase(mMapIter);
	}
	if (mTransport)
	{
		delete mTransport;
		mTransport = 0;
	}

	if (mFragmentedPacketCombiner)
	{
		free(mFragmentedPacketCombiner);
		mFragmentedPacketCombiner = 0;
	}
}

void XPSession::Route::SetDefault(void)
{
	mTargetSessionID = kXPSessionUnknownID;
	mCompletelyStable = false;
	mLastHeartBeatSentTime = 0;
	mJoinerPosted = false;
	mCanBeMaster = false;
	mFatalError = false;
	mIsDoingPreConnect = false;

	int i;
	for (i=0;i<kPingHistorySize;i++)
	{
		mPingHistoryRoundTripTime[i] = -1.0f;
	}

	mLastPingDoneAt = 0.0f;
	mFirstPingDone = false;
	mReadyForNextPing = false;

	mOutgoingSpiderID = kXPSessionUnknownID;

	mIsClientOnly = false;
	
	mFragmentedPacketCombiner = 0;
	mFragmentedPacketRealSize = 0;
	mFragmentedPacketGotSize = 0;
	mInMapFor = 0;
}

void XPSession::Route::AddRoundTripPingTime(float time)
{
	// Move the list of times down by one
	int i;
	for (i=0;i<kPingHistorySize-1;i++)
	{
		mPingHistoryRoundTripTime[i] = mPingHistoryRoundTripTime[i+1];
	}
	// Add in the ping time to the list
	mPingHistoryRoundTripTime[kPingHistorySize-1] = time;
}

// Calculates the one way trip time from the master to the client
// Latency is assumed to be symmetrical
float XPSession::Route::CalculateLatency(void)
{
	float accumulatedTime = 0.0f;
	int numEntries = 0;

	int i;
	for (i=0;i<kPingHistorySize;i++)
	{
		if (mPingHistoryRoundTripTime[i] > 0.0f)
		{
			accumulatedTime += mPingHistoryRoundTripTime[i];
			numEntries++;
		}
	}

	if (numEntries > 0)
	{
		return (accumulatedTime / float(numEntries)) / 2.0f;
	}

	return 0.0f;
}

void XPSession::Route::SetTargetSessionID(const int targetSessionID,XPSession *session)
{
	// Don't bother to change since it hasn't changed
	if (targetSessionID == mTargetSessionID)
	{
		return;
	}
	// Detach if it is already attached
	if (mInMapFor)
	{
		assert(session == mInMapFor);	// Check that we are not being moved from one session instance to another instance. Should never happen of course.
		mInMapFor = 0;
		session->mConnectionsBySessionID.erase(mMapIter);
	}
	// Set the target
	mTargetSessionID = targetSessionID;
	// Attach if required
	if (targetSessionID != kXPSessionUnknownID)
	{
		mMapIter = session->mConnectionsBySessionID.insert(std::pair<int,Route*>(targetSessionID,this));
		assert(mMapIter != session->mConnectionsBySessionID.end());
		mInMapFor = session;
	}
}

int XPSession::Route::GetTargetSessionID(void) const
{
	return mTargetSessionID;
}


std::string XPSession::GetURLFromSessionID(const int sessionID)
{
	if (sessionID == kXPSessionUnknownID || sessionID == kXPSessionBroadcastID)
	{
		return "";
	}

	THREADSAFELOCKCLASSNAMED(mMutexMiscValues);

	std::map<int,std::string>::iterator found = mBufferedURLsBySessionID.find(sessionID);
	if (found != mBufferedURLsBySessionID.end())
	{
		return (*found).second;
	}
	return "";
}

void XPSession::GetMergedStatistics(int *const sent,int *const received,const bool reset)
{
	THREADSAFELOCK();

	int totalsent = 0;
	int totalrecv = 0;
	VECTOR_ITER_BEGIN(Transport *,mFindTransports,trans);
	totalsent += trans->GetPacketsSentMerged(reset);
	totalrecv += trans->GetPacketsReceivedMerged(reset);
	VECTOR_ITER_END();
	VECTOR_ITER_BEGIN(Transport *,mMasterListens,trans);
	totalsent += trans->GetPacketsSentMerged(reset);
	totalrecv += trans->GetPacketsReceivedMerged(reset);
	VECTOR_ITER_END();
	VECTOR_ITER_BEGIN(Transport *,mListens,trans);
	totalsent += trans->GetPacketsSentMerged(reset);
	totalrecv += trans->GetPacketsReceivedMerged(reset);
	VECTOR_ITER_END();
	LIST_ITER_BEGIN(Route *,mConnections,route);
	totalsent += route->mTransport->GetPacketsSentMerged(reset);
	totalrecv += route->mTransport->GetPacketsReceivedMerged(reset);
	LIST_ITER_END();

	if (sent)
	{
		*sent = totalsent;
	}

	if (received)
	{
		*received = totalrecv;
	}
}

void XPSession::SetClientOnly(const bool isClient)
{
	mIsClientOnly = isClient;
	if (isClient)
	{
		SetCanBecomeMaster(false);
		SetCanSpider(false);
	}
}

bool XPSession::GetBandwidthFromSessionID(const int sessionID,Transport::Bandwidth *const bandwidth,int *const output,int *const input)
{
	if (sessionID == kXPSessionUnknownID || sessionID == kXPSessionBroadcastID)
	{
		return false;
	}

	THREADSAFELOCK();

	Route *route = FindRouteForSessionIDFromMap(sessionID);
	if (route)
	{
		if (bandwidth)
		{
			*bandwidth = route->mTransport->GetBandwidthLimit();
		}
		if (output)
		{
			*output = route->mTransport->GetMaximumOutputBandwidth();
		}
		if (input)
		{
			*input = route->mTransport->GetMaximumInputBandwidth();
		}
		return true;
	}

	return false;
}

void XPSession::HandleWaitingToSendPackets(void)
{
	// First backup the real mMutexSentPackets so that we don't get into the state of continuously trying to send packets that are sent by a different thread faster than we can send them.
	int numWaitingToSend = mNumWaitingToSend;

	while (numWaitingToSend > 0)
	{
		// Since we update a local copy we must guard the real mMutexSentPackets
		numWaitingToSend--;
		XPSessionInternalBufferedPacket *packet = 0;
		// Create stack frame for the safe lock
		// Very transient.
		{
			// Grab the next packet from the front of the list
			THREADSAFELOCKCLASS(mMutexSentPackets);
			// Now double check once we have the lock
			if (!mWaitingToSend.empty())
			{
				packet = *mWaitingToSend.begin();
				mWaitingToSend.pop_front();
				mNumWaitingToSend--;
				// Paranoia check for lower bound
				if (mNumWaitingToSend < 0)
				{
					mNumWaitingToSend = 0;
				}
			}
			else
			{
				// If it's empty then reset and return
				mNumWaitingToSend = 0;
				return;
			}
		}
		if (packet)
		{
			DataSendToSessionPrivate(packet->mSessionID,packet->mData,packet->mLength,packet->mReliable,packet->mCertain,packet->mOrdered,packet->mBand);
			delete packet;
		}
	}
}

XPSession::Route *XPSession::FindRouteForSessionIDFromMap(const int sessionID)
{
	std::multimap<int,Route*>::iterator found = mConnectionsBySessionID.find(sessionID);
	if (found == mConnectionsBySessionID.end())
	{
		return 0;
	}
	Route *route = (*found).second;
	assert(route->GetTargetSessionID() == sessionID);
	return route;
}

float XPSession::GetLatencyToSessionID(const int sessionID)
{
	if (sessionID == kXPSessionUnknownID || sessionID == kXPSessionBroadcastID)
	{
		return 0.0f;
	}

	THREADSAFELOCKCLASSNAMED(mMutexMiscValues);

	std::map<int,float>::iterator found = mBufferedLatencyBySessionID.find(sessionID);
	if (found != mBufferedLatencyBySessionID.end())
	{
		return (*found).second;
	}
	return 0.0f;
}

void XPSession::RegisterSessionIDCallback(XPSession::GetSessionIDCallback *callback,void *context)
{
	mGetSessionIDCallback = callback;
	mGetSessionIDCallbackContext = context;
}

void XPSession::SetProxyMode(const bool enable)
{
	mProxyMode = enable;
}

bool XPSession::GetProxyMode(void)
{
	return mProxyMode;
}

void XPSession::SetManualPollXPURL(void)
{
	XPURL::SetManualPoll();
}
void XPSession::SetAutomaticPollXPURL(void)
{
	XPURL::SetAutomaticPoll();
}

int XPSession::GetSessionID(void)
{
	if (mCompletelyStable)
	{
		return mSessionID;
	}

	return kXPSessionUnknownID;
}

bool XPSession::IsStable(void)
{
	if (mCompletelyStable)
	{
		return true;
	}
	return false;
}

XPSession::Error XPSession::GetStatus(void)
{
	return mStatus;
}

XPSession::Error XPSession::GetSessionErrorReason(void)
{
	if (mStatus == kXPSession_EOK)
	{
		return kXPSession_EOK;
	}
	if (mTransportDisconnected)
	{
		return kXPSession_ETRANSPORT_CLOSED;
	}
	if (mTransportError)
	{
		return kXPSession_ETRANSPORT_ERROR;
	}
	return kXPSession_EERROR;
}

bool XPSession::IsMaster(void)
{
	return mIsMaster;
}

float XPSession::GetNetworkSendRate(void)
{
	return mCurrentSendRate;
}

float XPSession::GetNetworkReceiveRate(void)
{
	return mCurrentRecvRate;
}

int XPSession::GetNetworkPacketsLost(void)
{
	return mNetworkPacketsLost;
}

int XPSession::GetNetworkPacketsRejected(void)
{
	return mNetworkPacketsRejected;
}

void XPSession::SetCanSpider(const bool canSpider)
{
	mCanSpider = canSpider;
}

bool XPSession::GetCanSpider(void)
{
	return mCanSpider;
}

void XPSession::SetCanBecomeMaster(const bool canBeMaster)
{
	mCanBeMaster = canBeMaster;
}

bool XPSession::GetCanBecomeMaster(void)
{
	return mCanBeMaster;
}

float XPSession::GetLatencyToMasterSession(void)
{
	return mZeroTimeDelta;
}

void XPSession::SetLatencyRecalculationDelay(const float seconds)
{
	mLatencyRecalculationDelay = seconds;
}

void XPSession::SetEncryption(const bool enable)
{
	mEncryptionOn = enable;
}

bool XPSession::GetEncryption(void)
{
	return mEncryptionOn;
}

void XPSession::SetPreConnect(const bool enable)
{
	mEnablePreConnect = enable;
}

bool XPSession::GetPreConnect(void)
{
	return mEnablePreConnect;
}

void XPSession::PreConnectHasFinished(void)
{
	if (mInPreConnect && mEnablePreConnect)
	{
		mInPreConnect = false;
		mPreConnectSignalDone = true;
	}
}

bool XPSession::GetPreConnectStatus(void)
{
	return mInPreConnect;
}

void XPSession::SetAutomaticPacketCompression(const bool enable)
{
	mEnableAutomaticCompression = true;
}

bool XPSession::GetAutomaticPacketCompression(void)
{
	return mEnableAutomaticCompression;
}

void XPSession::GetCompressionStatistics(int *const before,int *const after,const bool reset)
{
	if (before)
	{
		*before = mCompressionBefore;
	}
	if (after)
	{
		*after = mCompressionAfter;
	}
	if (reset)
	{
		mCompressionBefore = 0;
		mCompressionAfter = 0;
	}
}

int XPSession::GetMasterSessionID(void)
{
	return mMasterSessionID;
}

bool XPSession::GetClientOnly(void)
{
	return mIsClientOnly;
}

void XPSession::SetAllowConnections(const bool allow)
{
	mAllowConnections = allow;
}

bool XPSession::GetAllowConnections(void)
{
	return mAllowConnections;
}

void XPSession::SetNodeBuffers(const bool enable)
{
	mEnableExtraBuffering = enable;
}

bool XPSession::GetNodeBuffers(void)
{
	return mEnableExtraBuffering;
}

int XPSession::GetGameChannel(void)
{
	return mGameChannel;
}

void XPSession::SetGameChannel(const int channel)
{
	mGameChannel = channel;
}

void XPSession::CreateBufferedURL(void)
{
	std::string bfet = BufferedExportURL(true);
	std::string bfef = BufferedExportURL(false);

	// Stack context for the safe lock and for the local std:string storage
	{
	// Mutex lock for the write, since they are not atomic
	THREADSAFELOCKCLASSNAMED(mMutexMiscValues);
	mReturnExportURLTrue = bfet;
	mReturnExportURLFalse = bfef;
	}
}

void XPSession::SetMaximumDataSize(const int bytes)
{
	mMaximumDataSize = bytes;
}

int XPSession::GetMaximumDataSize(void) const
{
	return mMaximumDataSize;
}

void XPSession::SetPacketCompressionLevel(const int level)
{
	mPacketCompressionLevel = level;
}
void XPSession::SetLargePacketCompressionLevel(const int level)
{
	mLargePacketCompressionLevel = level;
}

int XPSession::GetPacketCompressionLevel(void) const
{
	return mPacketCompressionLevel;
}
int XPSession::GetLargePacketCompressionLevel(void) const
{
	return mLargePacketCompressionLevel;
}

void XPSession::SetTransparentPacketCompression(const int level)
{
	mTransparentPacketCompression = level;
}

int XPSession::GetTransparentPacketCompression(void)
{
	return mTransparentPacketCompression;
}
//From: RNXPSession/CXPSession.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#define __CXPSESSION_CPP__
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
//Skipping: #include "RNXPSession/Inc/XPSession.h"
#include "RNXPSession/Inc/CXPSession.h"

using namespace RNReplicaNet;

extern "C" hCXPSession CXPSession_Allocate(void)
{
	XPSession *newSession = XPSession::Allocate();

	return (hCXPSession) newSession;
}

extern "C" void CXPSession_Free(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	delete ((XPSession *)handle);
}

extern "C" void CXPSession_Create(const hCXPSession handle,const char *name)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->Create(name);
}

extern "C" void CXPSession_CreateWithProtocol(const hCXPSession handle,const char *name,const char *protocols)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->Create(name,protocols);
}

extern "C" void CXPSession_ExportURL(const hCXPSession handle,char *nameBuffer,const int length)
{
	assert(handle && "The CXPSession handle is null");

	std::string url = ((XPSession *)handle)->ExportURL();
	strncpy(nameBuffer,url.c_str(),length);
}

extern "C" void CXPSession_Join(const hCXPSession handle,const char *url)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->Join(url);
}

extern "C" void CXPSession_Find(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->Find();
}

extern "C" void CXPSession_FindWithProtocols(const hCXPSession handle,const char *protocols)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->Find(protocols);
}

extern "C" int CXPSession_EnumerateFound(const hCXPSession handle,char *nameBuffer,const int length)
{
	assert(handle && "The CXPSession handle is null");

	std::string found = ((XPSession *)handle)->EnumerateFound();
	if (found == "")
	{
		return 0;
	}

	strncpy(nameBuffer,found.c_str(),length);
	return 1;
}

extern "C" int CXPSession_GetGameChannel(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	return ((XPSession *)handle)->GetGameChannel();
}

extern "C" void CXPSession_SetGameChannel(const hCXPSession handle,const int channel)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->SetGameChannel(channel);
}

extern "C" int CXPSession_GetSessionID(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	return ((XPSession *)handle)->GetSessionID();
}

extern "C" int CXPSession_IsStable(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	if (((XPSession *)handle)->IsStable())
	{
		return 1;
	}
	return 0;
}

extern "C" int CXPSession_GetStatus(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	if (((XPSession *)handle)->GetStatus() == XPSession::kXPSession_EOK)
	{
		return 0;
	}
	return -1;
}

extern "C" void CXPSession_DataSendToSessionUnreliable(const hCXPSession handle,const int sessionid,const char *data,const int length)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->DataSendToSessionUnreliable(sessionid,data,length);
}

extern "C" void CXPSession_DataSendToSessionReliable(const hCXPSession handle,const int sessionid,const char *data,const int length)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->DataSendToSessionReliable(sessionid,data,length);
}

extern "C" void CXPSession_DataSendToSessionCertain(const hCXPSession handle,const int sessionid,const char *data,const int length)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->DataSendToSessionCertain(sessionid,data,length);
}

extern "C" int CXPSession_DataReceive(const hCXPSession handle,int *const fromsessionid,char *const data,int *const length,unsigned char *const type)
{
	assert(handle && "The CXPSession handle is null");

	bool ret = ((XPSession *)handle)->DataReceive(fromsessionid,data,length,type);
	if (ret)
	{
		return 1;
	}
	return 0;
}

extern "C" int CXPSession_IsMaster(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	if (((XPSession *)handle)->IsMaster())
	{
		return 1;
	}
	return 0;
}

extern "C" int CXPSession_GetJoiner(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	return ((XPSession *)handle)->GetJoiner();
}

extern "C" int CXPSession_GetLeaver(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	return ((XPSession *)handle)->GetLeaver();
}

extern "C" double CXPSession_GetTime(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	return ((XPSession *)handle)->GetTime();
}

extern "C" double CXPSession_GetLocalTime(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	return ((XPSession *)handle)->GetLocalTime();
}

extern "C" float CXPSession_GetNetworkSendRate(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	return ((XPSession *)handle)->GetNetworkSendRate();
}

extern "C" float CXPSession_GetNetworkReceiveRate(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	return ((XPSession *)handle)->GetNetworkReceiveRate();
}

extern "C" int CXPSession_GetNetworkPacketsLost(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	return ((XPSession *)handle)->GetNetworkPacketsLost();
}

extern "C" void CXPSession_Poll(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->Poll();
}

extern "C" void CXPSession_SetManualPoll(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->SetManualPoll();
}

extern "C" void CXPSession_SetAutomaticPoll(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->SetAutomaticPoll();
}

extern "C" void CXPSession_SetManualPollXPURL(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->SetManualPollXPURL();
}

extern "C" void CXPSession_SetAutomaticPollXPURL(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->SetAutomaticPollXPURL();
}

extern "C" void CXPSession_SetCanSpider(const hCXPSession handle,const int canSpider)
{
	assert(handle && "The CXPSession handle is null");

	if (canSpider == 1)
	{
		((XPSession *)handle)->SetCanSpider(true);
		return;
	}
	((XPSession *)handle)->SetCanSpider(false);
}

extern "C" int CXPSession_GetCanSpider(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	if (((XPSession *)handle)->GetCanSpider())
	{
		return 1;
	}
	return 0;
}

extern "C" void CXPSession_SetCanBecomeMaster(const hCXPSession handle,const int canBeMaster)
{
	assert(handle && "The CXPSession handle is null");

	if (canBeMaster == 1)
	{
		((XPSession *)handle)->SetCanBecomeMaster(true);
		return;
	}
	((XPSession *)handle)->SetCanBecomeMaster(false);
}

extern "C" int CXPSession_GetCanBecomeMaster(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	if (((XPSession *)handle)->GetCanBecomeMaster())
	{
		return true;
	}
	return false;
}

extern "C" float CXPSession_GetLatencyToMasterSession(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	return ((XPSession *)handle)->GetLatencyToMasterSession();
}

extern "C" void CXPSession_SetLatencyRecalculationDelay(const hCXPSession handle,const float seconds)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->SetLatencyRecalculationDelay(seconds);
}

extern "C" void CXPSession_SetEncryption(const hCXPSession handle,const int enable)
{
	assert(handle && "The CXPSession handle is null");

	if (enable == 1)
	{
		((XPSession *)handle)->SetEncryption(true);
		return;
	}

	((XPSession *)handle)->SetEncryption(false);
}

extern "C" int CXPSession_GetEncryption(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	if (((XPSession *)handle)->GetEncryption())
	{
		return 1;
	}
	return 0;
}

extern "C" void CXPSession_Disconnect(const hCXPSession handle,const int sessionID)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->Disconnect(sessionID);
}

extern "C" int CXPSession_GetPreConnectStatus(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	if (((XPSession *)handle)->GetPreConnectStatus())
	{
		return 1;
	}
	return 0;
}

extern "C" void CXPSession_SetPreConnect(const hCXPSession handle,const int enable)
{
	assert(handle && "The CXPSession handle is null");

	if (enable == 1)
	{
		((XPSession *)handle)->SetPreConnect(true);
		return;
	}

	((XPSession *)handle)->SetPreConnect(false);
}

extern "C" int CXPSession_GetPreConnect(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	if (((XPSession *)handle)->GetPreConnect())
	{
		return 1;
	}
	return 0;
}

extern "C" void CXPSession_PreConnectHasFinished(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->PreConnectHasFinished();
}

extern "C" void CXPSession_SetAutomaticPacketCompression(const hCXPSession handle,const int enable)
{
	assert(handle && "The CXPSession handle is null");

	if (enable == 1)
	{
		((XPSession *)handle)->SetAutomaticPacketCompression(true);
		return;
	}

	((XPSession *)handle)->SetAutomaticPacketCompression(false);
}

extern "C" int CXPSession_GetAutomaticPacketCompression(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	if(((XPSession *)handle)->GetAutomaticPacketCompression())
	{
		return 1;
	}
	return 0;
}

extern "C" void CXPSession_GetCompressionStatistics(const hCXPSession handle,int *const before,int *const after,const int reset)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->GetCompressionStatistics(before,after,reset==1?true:false);
}

extern "C" void CXPSession_GetMergedStatistics(const hCXPSession handle,int *const sent,int *const received,const int reset)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->GetMergedStatistics(sent,received,reset==1?true:false);
}

extern "C" int CXPSession_GetMasterSessionID(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	return ((XPSession *)handle)->GetMasterSessionID();
}

extern "C" int CXPSession_GetURLFromSessionID(const hCXPSession handle,const int sessionID,char *const url,const int urlLen)
{
	assert(handle && "The CXPSession handle is null");

	std::string temp = ((XPSession *)handle)->GetURLFromSessionID(sessionID);
	const char *ctemp = temp.c_str();
	int len = (int) strlen(ctemp)+1;
	if (len > urlLen)
	{
		return len;
	}

	if (url)
	{
		strcpy(url,ctemp);
		return len;
	}
	return len;
}

extern "C" void CXPSession_SetClientOnly(const hCXPSession handle,const int isClient)
{
	assert(handle && "The CXPSession handle is null");

	((XPSession *)handle)->SetClientOnly(isClient==1?true:false);
}

extern "C" int CXPSession_GetClientOnly(const hCXPSession handle)
{
	assert(handle && "The CXPSession handle is null");

	return ((XPSession *)handle)->GetClientOnly();
}

extern "C" int CXPSession_GetBandwidthFromSessionID(const hCXPSession handle,const int sessionID,int *const bandwidth,int *const output,int *const input)
{
	assert(handle && "The CXPSession handle is null");

	Transport::Bandwidth band;
	bool ret = ((XPSession *)handle)->GetBandwidthFromSessionID(sessionID,&band,output,input);
	*bandwidth = (int) band;
	return ret?1:0;
}
//From: RNXPURL/DoRegister.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
// This file holds various functions for ensuring things are registered as it is not nice to rely on
// self instantiation with some makes of compilers
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
//Include inline: #include "RNXPURL/DoRegister.h"
//From: RNXPURL/DoRegister.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef __DOREGISTER_H__
#define __DOREGISTER_H__

extern void RegisterDefaultTransports(void);

#endif
//Skipping: #include "RNXPURL/Inc/XPURL.h"
//Skipping: #include "RNXPSockets/Inc/XPSockets.h"

using namespace RNReplicaNet;

//Include inline: #include "RNXPURL/TransportTCPIP.h"
//From: RNXPURL/TransportTCPIP.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef __TRANSPORTTCPIP_H__
#define __TRANSPORTTCPIP_H__

#include <string>
#include <vector>

//Skipping: #include "RNXPURL/Inc/Transport.h"
//Skipping: #include "RNXPSockets/Inc/XPSockets.h"

//Skipping: #include "RNPlatform/Inc/MessageHelper.h"

//Skipping: #include "RNXPURL/UDPDiscovery.h"

namespace RNReplicaNet
{

/**
 * A transport class for the TCPIP type of URL
 */
class TransportTCPIP : public Transport , public UDPDiscovery , private XPSocket , private MessageHelper
{
public:
	/**
	 * The ctor performs some basic initialisation
	 */
	TransportTCPIP();

	/**
	 * The dtor makes sure everything is tidy
	 */
	virtual ~TransportTCPIP();

	int GetPacketsSent(const bool reset);
	int GetPacketsSentSize(const bool reset);
	int GetPacketsReceived(const bool reset);
	int GetPacketsReceivedSize(const bool reset);
	int GetPacketsLost(const bool reset);

	std::string CanAccept(void);
	std::string CanRoute(void);

	std::string ExportURL(void);

	Transport *Allocate(void);

	Transport::Error Listen(const int channel);
	Transport::Error Listen(const std::string &address);
	Transport::Error Connect(const std::string address);
	Transport *Accept(void);

	Transport::Error Send(const char *data,const int len);
	Transport::Error SendOrdered(const char *data,const int len,const unsigned int band = 0);
	Transport::Error SendReliable(const char *data,const int len,const unsigned int band = 0);
	Transport::Error SendCertain(const char *data,const int len);
	int Recv(char *const data,const int maxlen);
	int GetMaxPacketSize(void);

	std::string HandleDiscovery(void)
	{
		return UDPDiscovery::HandleDiscovery();
	}

	void HandleDiscoveryReply(const std::string reply)
	{
		UDPDiscovery::HandleDiscoveryReply(reply);
	}

	void BeginDiscovery(void)
	{
		UDPDiscovery::BeginDiscovery();
	}

	std::string GetNextDiscovery(void)
	{
		return UDPDiscovery::GetNextDiscovery();
	}

	Transport::Error GetStatus(void);

private:
	/**
	 * A simple polling function that this transport needs to have called.
	 * \todo change this to be some kind of event or thread or scheduled object or something :)
	 */
	void Poll(void);

	Transport::Error mError;

	int mPacketsSent;
	int mPacketsReceived;
	int mPacketsSentSize;
	int mPacketsReceivedSize;
	int mPacketsLost;
};

} // namespace RNReplicaNet

#endif
//Skipping: #include "RNXPURL/TransportUDP.h"
#ifdef _XBOX
//Include inline: #include "RNXPURL/TransportXBOXUDP.h"
//Force skipped: RNXPURL/TransportXBOXUDP.h
#endif
//Include inline: #include "RNXPURL/TransportStream.h"
//From: RNXPURL/TransportStream.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef __TRANSPORTSTREAM_H__
#define __TRANSPORTSTREAM_H__

//Skipping: #include "RNXPURL/Inc/Transport.h"

namespace RNReplicaNet
{

/**
 * A transport class for the Stream URL. This transport class is special as it shows how to create a generic type of transport that inherits from another transport
 * Using the Transport class as a base class you can add in things like encryption, compression.
 */
class TransportStream : public Transport
{
public:
	/**
	 * The ctor performs some basic initialisation
	 */
	TransportStream();

	/**
	 * The dtor makes sure everything is tidy
	 */
	virtual ~TransportStream();

	int GetPacketsSent(const bool reset);

	int GetPacketsSentSize(const bool reset);

	int GetPacketsReceived(const bool reset);

	int GetPacketsReceivedSize(const bool reset);

	int GetPacketsLost(const bool reset);


	std::string CanAccept(void);
	std::string CanRoute(void);

	std::string ExportURL(void);

	Transport *Allocate(void);

	Transport::Error Listen(const int channel);
	Transport::Error Listen(const std::string &address);
	Transport::Error Connect(const std::string address);
	Transport *Accept(void);

	Transport::Error Send(const char *data,const int len);
	Transport::Error SendOrdered(const char *data,const int len,const unsigned int band = 0);
	Transport::Error SendReliable(const char *data,const int len,const unsigned int band = 0);
	Transport::Error SendCertain(const char *data,const int len);
	int Recv(char *const data,const int maxlen);
	int GetMaxPacketSize(void);

	std::string HandleDiscovery(void);
	void HandleDiscoveryReply(const std::string reply);

	void BeginDiscovery(void);
	std::string GetNextDiscovery(void);

	Transport::Error GetStatus(void);

	/**
	 * This sets the base transport to use for this stream type and makes a new transport type
	 * \param transport the transport type to make streamed
	 */
	void SetBaseTransport(Transport &transport);

private:
	Transport *mBaseTransport;		/**< The base Transport class to inherit the abilities from */
	bool mAllocated;

	char *mBufferOut;				/**< A temporary buffer that is used to construct outbound or inbound packets and general data shuffling. Each buffer need one to be thread safe. */
	char *mBufferIn;					/**< A buffer that holds incoming packets and merges them until whole packets are available */
	int mPacketBlocks;				/**< The number of maximum size packets that are held in this buffer */
	int mBufferEndPoint;			/**< A counter for the used end point of the buffer */
	int mBufferSize;				/**< The size of the stream buffer */
};

} // namespace RNReplicaNet


#endif
//Include inline: #include "RNXPURL/TransportExample.h"
//From: RNXPURL/TransportExample.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#ifndef __TRANSPORTEXAMPLE_H__
#define __TRANSPORTEXAMPLE_H__

//Skipping: #include "RNXPURL/Inc/Transport.h"

namespace RNReplicaNet
{

/**
 * A transport class for the Example URL. This transport class is special as it shows how to create a generic type of transport that inherits from another transport
 * Using the Transport class as a base class you can add in things like encryption, compression.
 */
class TransportExample : public Transport
{
public:
	/**
	 * The ctor performs some basic initialisation
	 */
	TransportExample();

	/**
	 * The dtor makes sure everything is tidy
	 */
	virtual ~TransportExample();

	int GetPacketsSent(const bool reset);

	int GetPacketsSentSize(const bool reset);

	int GetPacketsReceived(const bool reset);

	int GetPacketsReceivedSize(const bool reset);

	int GetPacketsLost(const bool reset);


	std::string CanAccept(void);
	std::string CanRoute(void);

	std::string ExportURL(void);

	Transport *Allocate(void);

	Transport::Error Listen(const int channel);
	Transport::Error Listen(const std::string &address);

	Transport::Error Connect(const std::string address);
	Transport *Accept(void);

	Transport::Error Send(const char *data,const int len);
	Transport::Error SendOrdered(const char *data,const int len,const unsigned int band = 0);
	Transport::Error SendReliable(const char *data,const int len,const unsigned int band = 0);
	Transport::Error SendCertain(const char *data,const int len);
	int Recv(char *const data,const int maxlen);
	int GetMaxPacketSize(void);

	std::string HandleDiscovery(void);
	void HandleDiscoveryReply(const std::string reply);

	void BeginDiscovery(void);
	std::string GetNextDiscovery(void);

	Transport::Error GetStatus(void);

	/**
	 * This sets the base transport to use for this stream type and makes a new transport type
	 * \param transport the transport type to make streamed
	 */
	void SetBaseTransport(Transport &transport);

private:
	Transport *mBaseTransport;		/**< The base Transport class to inherit the abilities from */
	bool mAllocated;				/**< Set to be true if the base transport was allocated */
};

} // namespace RNReplicaNet

#endif
//Include inline: #include "RNXPURL/TransportCompression.h"
//From: RNXPURL/TransportCompression.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#ifndef __TRANSPORTCOMPRESSION_H__
#define __TRANSPORTCOMPRESSION_H__

//Skipping: #include "RNXPURL/Inc/Transport.h"

namespace RNReplicaNet
{

/**
 * A transport class for compression support
 */
class TransportCompression : public Transport
{
public:
	/**
	 * The ctor performs some basic initialisation
	 */
	TransportCompression();

	/**
	 * The dtor makes sure everything is tidy
	 */
	virtual ~TransportCompression();

	int GetPacketsSent(const bool reset);

	int GetPacketsSentSize(const bool reset);

	int GetPacketsReceived(const bool reset);

	int GetPacketsReceivedSize(const bool reset);

	int GetPacketsLost(const bool reset);


	std::string CanAccept(void);
	std::string CanRoute(void);

	std::string ExportURL(void);

	Transport *Allocate(void);

	Transport::Error Listen(const int channel);
	Transport::Error Listen(const std::string &address);

	Transport::Error Connect(const std::string address);
	Transport *Accept(void);

	Transport::Error Send(const char *data,const int len);
	Transport::Error SendOrdered(const char *data,const int len,const unsigned int band = 0);
	Transport::Error SendReliable(const char *data,const int len,const unsigned int band = 0);
	Transport::Error SendCertain(const char *data,const int len);
	int Recv(char *const data,const int maxlen);
	int GetMaxPacketSize(void);

	std::string HandleDiscovery(void);
	void HandleDiscoveryReply(const std::string reply);

	void BeginDiscovery(void);
	std::string GetNextDiscovery(void);

	Transport::Error GetStatus(void);

	/**
	 * This sets the base transport to use for this stream type and makes a new transport type
	 * \param transport the transport type to make streamed
	 */
	void SetBaseTransport(Transport &transport);

private:
	Transport *mBaseTransport;		/**< The base Transport class to inherit the abilities from */

	bool mAllocated;				/**< Set to be true if the base transport was allocated */

	void *mCompBuffer;				/**< The buffer used for compression */
};

} // namespace RNReplicaNet

#endif
//Include inline: #include "RNXPURL/TransportCrypto.h"
//From: RNXPURL/TransportCrypto.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#ifndef __TRANSPORTCRYPTO_H__
#define __TRANSPORTCRYPTO_H__

#include <list>
//Skipping: #include "RNXPURL/Inc/Transport.h"
//Skipping: #include "RNPlatform/Inc/Encryption.h"
//Skipping: #include "RNPlatform/Inc/ThreadClass.h"

namespace RNReplicaNet
{

/**
 * A transport class for the Crypto URL. This uses commutative encryption negotiation.
 */
class TransportCrypto : public Transport
{
public:
	/**
	 * The ctor performs some basic initialisation
	 */
	TransportCrypto();

	/**
	 * The dtor makes sure everything is tidy
	 */
	virtual ~TransportCrypto();

	int GetPacketsSent(const bool reset);

	int GetPacketsSentSize(const bool reset);

	int GetPacketsReceived(const bool reset);

	int GetPacketsReceivedSize(const bool reset);

	int GetPacketsLost(const bool reset);


	std::string CanAccept(void);
	std::string CanRoute(void);

	std::string ExportURL(void);

	Transport *Allocate(void);

	Transport::Error Listen(const int channel);
	Transport::Error Listen(const std::string &address);

	Transport::Error Connect(const std::string address);
	Transport *Accept(void);

	Transport::Error Send(const char *data,const int len);
	Transport::Error SendOrdered(const char *data,const int len,const unsigned int band = 0);
	Transport::Error SendReliable(const char *data,const int len,const unsigned int band = 0);
	Transport::Error SendCertain(const char *data,const int len);
	int Recv(char *const data,const int maxlen);
	int GetMaxPacketSize(void);

	std::string HandleDiscovery(void);
	void HandleDiscoveryReply(const std::string reply);

	void BeginDiscovery(void);
	std::string GetNextDiscovery(void);

	Transport::Error GetStatus(void);

	/**
	 * This sets the base transport to use for this stream type and makes a new transport type
	 * \param transport the transport type to make streamed
	 */
	void SetBaseTransport(Transport *transport);

private:
	void InitKeys(void);
	enum NegotiateStatus
	{
		kNegotiatePending = 0,
		kNegotiateSuccess,
		kNegotiateFailed
	};
	NegotiateStatus HandleNegotiate(void);	/// \return True when the negotiate 

	Transport *mBaseTransport;		/**< The base Transport class to inherit the abilities from */
	bool mAllocated;				/**< Set to be true if the base transport was allocated */

	MutexClass mPendingLock;
	std::list<TransportCrypto*> mPending;	/// Pending for the crypto negotiation
	int mCryptoNegotiateStage;

	bool mIsServer;
	bool mIsListen;
	Encryption::Key mSessionKey;
	Encryption::Key mMyPrivateKey;		/// Used to wrap mSessionKey

	int mTestData;
	bool mDoNegotiate;
};

} // namespace RNReplicaNet

#endif
//Skipping: #include "RNPlatform/Inc/PlatformHeap.h"

using namespace RNReplicaNet;

#ifdef _XBOX
static TransportXBOXUDP *trans_4 = 0;
static TransportUDP *trans_4b = 0;
#else
static TransportUDP *trans_1 = 0;
static TransportStream *trans_2 = 0;
static TransportTCPIP *trans_2b = 0;
static TransportCompression *trans_3 = 0;
static TransportUDP *trans_3b = 0;
static TransportCrypto *trans_4 = 0;
static TransportUDP *trans_4b = 0;
#endif
static bool doneRegister = false;

namespace RNReplicaNet
{
class RegisterDefaultTransportsHeap : public PlatformHeapBlock
{
public:
	virtual ~RegisterDefaultTransportsHeap()
	{
#ifdef _XBOX
		delete trans_4;
		trans_4 = 0;
		delete trans_4b;
		trans_4b = 0;
#else
		delete trans_4;
		trans_4 = 0;
		delete trans_4b;
		trans_4b = 0;
		delete trans_3;
		trans_3 = 0;
		delete trans_3b;
		trans_3b = 0;
		delete trans_2;
		trans_2 = 0;
		delete trans_2b;
		trans_2b = 0;
		delete trans_1;
		trans_1 = 0;
#endif
		doneRegister = false;
	}
};
}

void RegisterDefaultTransports(void)
{
	if (!doneRegister)
	{
		doneRegister = true;

#ifdef _XBOX
		// MPi: Xbox just supports this kind of transport protocol.
		trans_4 = new TransportXBOXUDP();
		trans_4b = new TransportUDP();

		trans_4->SetBaseTransport(trans_4b);
		XPURL::RegisterTransport(*trans_4);
#else
		trans_1 = new TransportUDP();
		XPURL::RegisterTransport(*trans_1);

		trans_2 = new TransportStream();
		trans_2b = new TransportTCPIP();
		trans_2->SetBaseTransport(*trans_2b);
		XPURL::RegisterTransport(*trans_2);

		trans_3 = new TransportCompression();
		trans_3b = new TransportUDP;
		trans_3->SetBaseTransport(*trans_3b);
		XPURL::RegisterTransport(*trans_3);

		trans_4 = new TransportCrypto();
		trans_4b = new TransportUDP;
		trans_4->SetBaseTransport(trans_4b);
		XPURL::RegisterTransport(*trans_4);
#endif

		(new RegisterDefaultTransportsHeap())->Register();
	}
}
//From: RNXPURL/NetworkEmulation.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include "RNXPURL/Inc/NetworkEmulation.h"

static bool mEnable = false;
static float mPacketLoss = 0.0f;
static int mBytesPerSecondOut = -1;
static int mBytesPerSecondIn = -1;
static float mAverageLatency = 0.0f;
static float mJitter = 0.0f;

using namespace RNReplicaNet;

void NetworkEmulation::SetEnabled(const bool enable)
{
	mEnable = enable;
}

bool NetworkEmulation::GetEnabled(void)
{
	return mEnable;
}

void NetworkEmulation::SetConnection(const ConnectionTypes type,const bool enable)
{
	switch (type)
	{
		case kPerfect:
		default:
			mPacketLoss = 0.0f;
			mBytesPerSecondOut = -1;
			mBytesPerSecondIn = -1;
			mAverageLatency = 0.0f;
			mJitter = 0.0f;
			break;
	}
	mEnable = enable;
}

void NetworkEmulation::SetPacketLoss(const float percent)
{
	if (mPacketLoss < 0.0f)
	{
		mPacketLoss = 0.0f;
	}
	if (mPacketLoss > 100.0f)
	{
		mPacketLoss = 100.0f;
	}

	mPacketLoss = percent;
}

float NetworkEmulation::GetPacketLoss(void)
{
	return mPacketLoss;
}

void NetworkEmulation::SetMaximumOutputBandwidth(const int bytesPerSecond)
{
	mBytesPerSecondOut = bytesPerSecond;
}

int NetworkEmulation::GetMaximumOutputBandwidth(void)
{
	return mBytesPerSecondOut;
}

void NetworkEmulation::SetMaximumInputBandwidth(const int bytesPerSecond)
{
	mBytesPerSecondIn = bytesPerSecond;
}

int NetworkEmulation::GetMaximumInputBandwidth(void)
{
	return mBytesPerSecondIn;
}

void NetworkEmulation::SetAverageLatency(const float seconds)
{
	mAverageLatency = seconds;
}

float NetworkEmulation::GetAverageLatency(void)
{
	return mAverageLatency;
}

void NetworkEmulation::SetJitter(const float seconds)
{
	mJitter = seconds;
}

float NetworkEmulation::GetJitter(void)
{
	return mJitter;
}

//From: RNXPURL/Transport.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
//Skipping: #include "RNXPURL/Inc/Transport.h"

using namespace RNReplicaNet;

static int sTransportInstance = 0;
Transport::Transport() : mTransportInstance(sTransportInstance++)
{
}

Transport::~Transport()
{
}

int Transport::GetPacketsSent(const bool reset)
{
	return 0;
}

int Transport::GetPacketsSentMerged(const bool reset)
{
	return 0;
}

int Transport::GetPacketsSentSize(const bool reset)
{
	return 0;
}

int Transport::GetPacketsReceived(const bool reset)
{
	return 0;
}

int Transport::GetPacketsReceivedMerged(const bool reset)
{
	return 0;
}

int Transport::GetPacketsReceivedSize(const bool reset)
{
	return 0;
}

int Transport::GetPacketsLost(const bool reset)
{
	return 0;
}

void Transport::SetBandwidthLimit(const Bandwidth enable)
{
}

Transport::Bandwidth Transport::GetBandwidthLimit()
{
	return kBandwidth_Off;
}

void Transport::SetMaximumOutputBandwidth(const int bytesPerSecond)
{
}

int Transport::GetMaximumOutputBandwidth(void)
{
	return 0;
}

void Transport::SetMaximumInputBandwidth(const int bytesPerSecond)
{
}

int Transport::GetMaximumInputBandwidth(void)
{
	return 0;
}

std::string Transport::GetPeerURL(void)
{
	return std::string("");
}

bool Transport::GetTransportClosed(void)
{
	return false;
}

void Transport::SetEnableLANDiscovery(const bool enable)
{
}

bool Transport::GetEnableLANDiscovery(void)
{
	return true;
}

int Transport::GetInstance(void)
{
	return mTransportInstance;
}
//From: RNXPURL/TransportCompression.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
//Skipping: #include "RNXPURL/TransportCompression.h"
//Skipping: #include "RNXPCompression/Inc/XPCompression.h"
//Skipping: #include "RNPlatform/DebugSupport.h"

using namespace RNReplicaNet;

static const char *sSuperName = "COMP";
static XPCompression comp;

static int before = 0;
static int after = 0;

TransportCompression::TransportCompression() : mBaseTransport(0) , mAllocated(false) , mCompBuffer(0)
{
}

TransportCompression::~TransportCompression()
{
	if (mAllocated && mBaseTransport)
	{
		delete mBaseTransport;
		mBaseTransport = 0;
		mAllocated = 0;
	}
	free(mCompBuffer);
}

int TransportCompression::GetPacketsSent(const bool reset)
{
	return mBaseTransport->GetPacketsSent(reset);
}

int TransportCompression::GetPacketsSentSize(const bool reset)
{
	return mBaseTransport->GetPacketsSentSize(reset);
}

int TransportCompression::GetPacketsReceived(const bool reset)
{
	return mBaseTransport->GetPacketsReceived(reset);
}

int TransportCompression::GetPacketsReceivedSize(const bool reset)
{
	return mBaseTransport->GetPacketsReceivedSize(reset);
}

int TransportCompression::GetPacketsLost(const bool reset)
{
	return mBaseTransport->GetPacketsLost(reset);
}

std::string TransportCompression::CanAccept()
{
	return sSuperName + mBaseTransport->CanAccept();
}

std::string TransportCompression::CanRoute()
{
	return sSuperName + mBaseTransport->CanRoute();
}

std::string TransportCompression::ExportURL(void)
{
	return sSuperName + mBaseTransport->ExportURL();
}

Transport *TransportCompression::Allocate(void)
{
	TransportCompression *stream = new TransportCompression();

	stream->SetBaseTransport(*mBaseTransport->Allocate());
	stream->mAllocated = true;

	return stream;
}

Transport::Error TransportCompression::Listen(int channel)
{
	return mBaseTransport->Listen(channel);
}

Transport::Error TransportCompression::Listen(const std::string &address)
{
	return mBaseTransport->Listen(address.substr(strlen(sSuperName)));
}

Transport::Error TransportCompression::Connect(const std::string address)
{
	std::string dupe = address;
	dupe.erase(0,std::string(sSuperName).size());
	return mBaseTransport->Connect(dupe);
}

Transport *TransportCompression::Accept(void)
{
	Transport *accepted = mBaseTransport->Accept();
	if (accepted == NULL)
	{
		return NULL;
	}

	TransportCompression *stream = new TransportCompression();
	stream->SetBaseTransport(*accepted);
	stream->mAllocated = true;
	return stream;
}

Transport::Error TransportCompression::Send(const char *datain,const int lenin)
{
	int complen,len = lenin;
	char *data = (char *) datain;
	if (comp.Compress(data,len,mCompBuffer,&complen,5))
	{
		len = complen;
		data = (char *) mCompBuffer;
	}

	before += lenin;
	after += len;

//	dprintf("Totals before %d after %d	  This %d to %d\n",before,after,lenin,len);

	return mBaseTransport->Send(data,len);
}

Transport::Error TransportCompression::SendOrdered(const char *datain,const int lenin,const unsigned int band)
{
	int complen,len = lenin;
	char *data = (char *) datain;
	if (comp.Compress(data,len,mCompBuffer,&complen,5))
	{
		len = complen;
		data = (char *) mCompBuffer;
	}

	before += lenin;
	after += len;

	//	dprintf("Totals before %d after %d	  This %d to %d\n",before,after,lenin,len);

	return mBaseTransport->SendOrdered(data,len,band);
}

Transport::Error TransportCompression::SendReliable(const char *datain,const int lenin,const unsigned int band)
{
	int complen,len = lenin;
	char *data = (char *) datain;
	if (comp.Compress(data,len,mCompBuffer,&complen,5))
	{
		len = complen;
		data = (char *) mCompBuffer;
	}

	before += lenin;
	after += len;

//	dprintf("Totals before %d after %d	  This %d to %d\n",before,after,lenin,len);

	return mBaseTransport->SendReliable(data,len,band);
}

Transport::Error TransportCompression::SendCertain(const char *datain,const int lenin)
{
	return SendReliable(datain,lenin);
}

int TransportCompression::Recv(char *const data,const int maxlen)
{
	int ret = mBaseTransport->Recv((char *) mCompBuffer,comp.CalculateMaximumMemory(mBaseTransport->GetMaxPacketSize()));
	if (ret > 0)
	{
		int decomplen;
		comp.Decompress(mCompBuffer,ret,data,&decomplen,maxlen);
		return decomplen;
	}
	return ret;
}

int TransportCompression::GetMaxPacketSize()
{
	return mBaseTransport->GetMaxPacketSize();
}

std::string TransportCompression::HandleDiscovery(void)
{
	std::string retstr;
	retstr = mBaseTransport->HandleDiscovery();
	if (retstr == "")
	{
		return "";
	}
	return sSuperName + retstr;
}

void TransportCompression::HandleDiscoveryReply(const std::string reply)
{
	mBaseTransport->HandleDiscoveryReply(reply);
}

void TransportCompression::BeginDiscovery(void)
{
	mBaseTransport->BeginDiscovery();
}

std::string TransportCompression::GetNextDiscovery(void)
{
	return mBaseTransport->GetNextDiscovery();
}

Transport::Error TransportCompression::GetStatus(void)
{
	return mBaseTransport->GetStatus();
}

void TransportCompression::SetBaseTransport(Transport &transport)
{
	if (mBaseTransport != NULL)
	{
		return;
	}

	mBaseTransport = &transport;
	mCompBuffer = malloc(comp.CalculateMaximumMemory(mBaseTransport->GetMaxPacketSize()));
}
//From: RNXPURL/TransportCrypto.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
//Skipping: #include "RNPlatform/Options.h"
//Skipping: #include "RNPlatform/DebugSupport.h"
//Skipping: #include "RNPlatform/Inc/Rand.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
//Skipping: #include "RNPlatform/UtilityIter.h"
//Skipping: #include "RNXPURL/TransportCrypto.h"
#include "RNXPURL/Inc/TransportConfig.h"

using namespace RNReplicaNet;

#define MSUPERNAME (std::string("CRYPTO"))

enum NegotiateCryptoStatus
{
	kNegotiateCryptoWrap = 0,
	kNegotiateCryptoUnWrap = 1,
	kNegotiateCryptoTest = 2,
	kNegotiateCryptoSuccess = 3,
	kNegotiateCryptoFailed = 4
};

TransportCrypto::TransportCrypto() : mBaseTransport(0) , mAllocated(false) , mCryptoNegotiateStage(0) , mIsServer(false) , mIsListen(false) , mDoNegotiate(false)
{
}

TransportCrypto::~TransportCrypto()
{
	{
		THREADSAFELOCKCLASS(mPendingLock);
		LIST_ITER_BEGIN( TransportCrypto * , mPending , trans );
			delete trans;
		LIST_ITER_END();
		mPending.clear();
	}


	if (mAllocated && mBaseTransport)
	{
		delete mBaseTransport;
		mBaseTransport = 0;
		mAllocated = 0;
	}
}

int TransportCrypto::GetPacketsSent(const bool reset)
{
	HandleNegotiate();
	return mBaseTransport->GetPacketsSent(reset);
}

int TransportCrypto::GetPacketsSentSize(const bool reset)
{
	HandleNegotiate();
	return mBaseTransport->GetPacketsSentSize(reset);
}

int TransportCrypto::GetPacketsReceived(const bool reset)
{
	HandleNegotiate();
	return mBaseTransport->GetPacketsReceived(reset);
}

int TransportCrypto::GetPacketsReceivedSize(const bool reset)
{
	HandleNegotiate();
	return mBaseTransport->GetPacketsReceivedSize(reset);
}

int TransportCrypto::GetPacketsLost(const bool reset)
{
	HandleNegotiate();
	return mBaseTransport->GetPacketsLost(reset);
}

std::string TransportCrypto::CanAccept()
{
	HandleNegotiate();
	return MSUPERNAME + mBaseTransport->CanAccept();
}

std::string TransportCrypto::CanRoute()
{
	HandleNegotiate();
	return MSUPERNAME + mBaseTransport->CanRoute();
}

std::string TransportCrypto::ExportURL(void)
{
	HandleNegotiate();
	return MSUPERNAME + mBaseTransport->ExportURL();
}

Transport *TransportCrypto::Allocate(void)
{
	TransportCrypto *crypto = new TransportCrypto();
	crypto->InitKeys();

	crypto->SetBaseTransport(mBaseTransport->Allocate());
	crypto->mAllocated = true;

	return crypto;
}

Transport::Error TransportCrypto::Listen(int channel)
{
	mIsListen = true;
	return mBaseTransport->Listen(channel);
}

Transport::Error TransportCrypto::Listen(const std::string &address)
{
	mIsListen = true;
	return mBaseTransport->Listen(address.substr(MSUPERNAME.length()));
}

Transport::Error TransportCrypto::Connect(const std::string address)
{
	mDoNegotiate = true;
	std::string dupe = address;
	dupe.erase(0,MSUPERNAME.size());
	return mBaseTransport->Connect(dupe);
}

Transport *TransportCrypto::Accept(void)
{
	if ( !mIsListen )
	{
		return 0;
	}
	Transport *accepted = mBaseTransport->Accept();
	if ( accepted )
	{
		TransportCrypto *crypto = new TransportCrypto();
		crypto->mIsServer = true;	// Server side accepted
		crypto->mDoNegotiate = true;
		crypto->InitKeys();
		crypto->SetBaseTransport(accepted);
		crypto->mAllocated = true;

		THREADSAFELOCKCLASS(mPendingLock);
		mPending.push_back( crypto );
	}

	THREADSAFELOCKCLASS(mPendingLock);

	// Now process any pending crypto stuff
	LIST_ITER_BEGIN( TransportCrypto * , mPending , trans );
		NegotiateStatus ret = trans->HandleNegotiate();
		if ( ret == kNegotiateSuccess )
		{
			LIST_ITER_ERASENOCONT( mPending );
			return trans;
		}
		else if ( ret == kNegotiateFailed )
		{
			// It failed, don't even return the failed pointer just delete it.
			delete trans;
			LIST_ITER_ERASE( mPending );
		}
	LIST_ITER_END();

	return 0;
}

Transport::Error TransportCrypto::Send(const char *data,const int len)
{
	if ( mIsListen )
	{
		return kTransport_EERROR;
	}

	if ( HandleNegotiate() != kNegotiateSuccess )
	{
		return kTransport_EWAITING;
	}
	DynamicMessageHelper message( data , len );
	Encryption::Encrypt( message.GetBuffer() , len , &mSessionKey );
	return mBaseTransport->Send((char*)message.GetBuffer(),len);
}

Transport::Error TransportCrypto::SendOrdered(const char *data,const int len,const unsigned int band)
{
	if ( mIsListen )
	{
		return kTransport_EERROR;
	}

	if ( HandleNegotiate() != kNegotiateSuccess )
	{
		return kTransport_EWAITING;
	}
	DynamicMessageHelper message( data , len );
	Encryption::Encrypt( message.GetBuffer() , len , &mSessionKey );
	return mBaseTransport->SendOrdered((char*)message.GetBuffer(),len,band);
}

Transport::Error TransportCrypto::SendReliable(const char *data,const int len,const unsigned int band)
{
	if ( mIsListen )
	{
		return kTransport_EERROR;
	}

	if ( HandleNegotiate() != kNegotiateSuccess )
	{
		return kTransport_EWAITING;
	}
	DynamicMessageHelper message( data , len );
	Encryption::Encrypt( message.GetBuffer() , len , &mSessionKey );
	return mBaseTransport->SendReliable((char*)message.GetBuffer(),len,band);
}

Transport::Error TransportCrypto::SendCertain(const char *data,const int len)
{
	if ( mIsListen )
	{
		return kTransport_EERROR;
	}

	if ( HandleNegotiate() != kNegotiateSuccess )
	{
		return kTransport_EWAITING;
	}
	DynamicMessageHelper message( data , len );
	Encryption::Encrypt( message.GetBuffer() , len , &mSessionKey );
	return mBaseTransport->SendCertain((char*)message.GetBuffer(),len);
}

int TransportCrypto::Recv(char *const data,const int maxlen)
{
	if ( mIsListen )
	{
		return kTransport_EERROR;
	}

	NegotiateStatus ret = HandleNegotiate();
	if ( ( ret == kNegotiatePending ) || ( ret == kNegotiateFailed ) )
	{
		return 0;
	}

	int got = mBaseTransport->Recv(data,maxlen);
	if ( got > 0 )
	{
		Encryption::Decrypt( data , got , &mSessionKey );
	}
	return got;
}

int TransportCrypto::GetMaxPacketSize()
{
	HandleNegotiate();
	return mBaseTransport->GetMaxPacketSize();
}

std::string TransportCrypto::HandleDiscovery(void)
{
	HandleNegotiate();
	std::string retstr;
	retstr = mBaseTransport->HandleDiscovery();
	if (retstr == "")
	{
		return "";
	}
	return MSUPERNAME + retstr;
}

void TransportCrypto::HandleDiscoveryReply(const std::string reply)
{
	HandleNegotiate();
	mBaseTransport->HandleDiscoveryReply(reply);
}

void TransportCrypto::BeginDiscovery(void)
{
	HandleNegotiate();
	mBaseTransport->BeginDiscovery();
}

std::string TransportCrypto::GetNextDiscovery(void)
{
	HandleNegotiate();
	return mBaseTransport->GetNextDiscovery();
}

Transport::Error TransportCrypto::GetStatus(void)
{
	if ( !mBaseTransport )
	{
		return kTransport_EERROR;
	}

	if ( mIsListen )
	{
		return mBaseTransport->GetStatus();
	}

	NegotiateStatus ret = HandleNegotiate();
	if ( ret == kNegotiateSuccess )
	{
		return mBaseTransport->GetStatus();
	}
	else if ( ret == kNegotiatePending )
	{
		return kTransport_EWAITING;
	}
	else if ( ret == kNegotiateFailed )
	{
		return kTransport_EERROR;
	}
	return mBaseTransport->GetStatus();
}

void TransportCrypto::SetBaseTransport(Transport *transport)
{
	if (mBaseTransport != NULL)
	{
		return;
	}

	mBaseTransport = transport;
}

void TransportCrypto::InitKeys(void)
{
	int i[2];
	i[0] = Rand::FastWeak();
	i[1] = Rand::FastWeak();
	mSessionKey.Create( i , sizeof(i) );

	i[0] = Rand::FastWeak();
	i[1] = Rand::FastWeak();
	mMyPrivateKey.Create( i , sizeof(i) );
}

TransportCrypto::NegotiateStatus TransportCrypto::HandleNegotiate(void)
{
	if ( !mDoNegotiate )
	{
		return kNegotiatePending;
	}

	if ( !mBaseTransport )
	{
		return kNegotiateFailed;
	}

	// If the base transport disconnects while negotiation is in progress then fail the negotiation
	if ( mBaseTransport->GetStatus() == Transport::kTransport_EERROR )
	{
		mCryptoNegotiateStage = kNegotiateCryptoFailed;
		return kNegotiateFailed;
	}

	if ( mIsServer )
	{
#ifdef DEBUG_PRINTS3
		dprintf( "TransportCrypto::HandleNegotiate $%p mIsServer stage %d\n" , this , mCryptoNegotiateStage );
#endif

		if ( mCryptoNegotiateStage == kNegotiateCryptoWrap )
		{
			// Send my wrapped key
			unsigned char key[ kEncryptionKeyLengthBytes ];
			memcpy( key , mSessionKey.mKey , kEncryptionKeyLengthBytes );

#ifdef DEBUG_PRINTS3
			dprintf( "TransportCrypto::HandleNegotiate $%p key %s\n" , this , MessageHelper::DumpAsHex( key , (int) sizeof( key ) ).c_str() );
#endif

			Encryption::CommutativeEncrypt( key , kEncryptionKeyLengthBytes , &mMyPrivateKey );

#ifdef DEBUG_PRINTS3
			dprintf( "TransportCrypto::HandleNegotiate $%p enc1 %s\n" , this , MessageHelper::DumpAsHex( key , (int) sizeof( key ) ).c_str() );
#endif
			mBaseTransport->SendReliable( (char*) key , sizeof( key ) );
			mCryptoNegotiateStage++;
		}

		if ( mCryptoNegotiateStage == kNegotiateCryptoUnWrap )
		{
			RNReplicaNet::DynamicMessageHelper message( RNReplicaNet::TransportConfig::GetPacketMTU() );
			int got = mBaseTransport->Recv( (char*) message.GetBuffer() , message.GetBufferSize() );
			if ( got >= kEncryptionKeyLengthBytes )
			{
#ifdef DEBUG_PRINTS3
				dprintf( "TransportCrypto::HandleNegotiate $%p dec %s\n" , this , MessageHelper::DumpAsHex( message.GetBuffer() , kEncryptionKeyLengthBytes ).c_str() );
#endif
				// Got the wrapped wrapped session key, unwrap it
				Encryption::CommutativeDecrypt( (char*) message.GetBuffer() , kEncryptionKeyLengthBytes , &mMyPrivateKey );

#ifdef DEBUG_PRINTS3
				dprintf( "TransportCrypto::HandleNegotiate $%p dec1 %s\n" , this , MessageHelper::DumpAsHex( message.GetBuffer() , kEncryptionKeyLengthBytes ).c_str() );
#endif
				mBaseTransport->SendReliable( (char*) (char*) message.GetBuffer() , kEncryptionKeyLengthBytes );

				// Send some known data as a test
				mTestData = RNReplicaNet::Rand::FastWeak();
				int temp = mTestData;

#ifdef DEBUG_PRINTS3
				dprintf( "TransportCrypto::HandleNegotiate $%p test %s\n" , this , MessageHelper::DumpAsHex( &temp , sizeof( temp ) ).c_str() );
#endif
				Encryption::Encrypt( &temp , sizeof( temp ) , &mSessionKey );

#ifdef DEBUG_PRINTS3
				dprintf( "TransportCrypto::HandleNegotiate $%p test enc %s\n" , this , MessageHelper::DumpAsHex( &temp , sizeof( temp ) ).c_str() );
#endif
				mBaseTransport->SendReliable( (char*) &temp , sizeof( temp ) );
				mCryptoNegotiateStage++;
			}
		}

		if ( mCryptoNegotiateStage == kNegotiateCryptoTest )
		{
			RNReplicaNet::DynamicMessageHelper message( RNReplicaNet::TransportConfig::GetPacketMTU() );
			int got = mBaseTransport->Recv( (char*) message.GetBuffer() , message.GetBufferSize() );
			int recvTestData;
			if ( got >= sizeof( recvTestData ) )
			{
				message.GetData( &recvTestData , sizeof( recvTestData ) );	// Deliberate use of GetData, endianess is not important
				if ( mTestData == recvTestData )
				{
#ifdef DEBUG_PRINTS3
					dprintf( "TransportCrypto::HandleNegotiate $%p kNegotiateCryptoSuccess\n" , this );
#endif
					mCryptoNegotiateStage = kNegotiateCryptoSuccess;
					return kNegotiateSuccess;
				}
				else
				{
#ifdef DEBUG_PRINTS3
					dprintf( "TransportCrypto::HandleNegotiate $%p kNegotiateCryptoFailed\n" , this );
#endif
					mCryptoNegotiateStage = kNegotiateCryptoFailed;
					return kNegotiateFailed;
				}
			}
		}
	}
	else //< if ( mIsServer )
	{
#ifdef DEBUG_PRINTS3
		dprintf( "TransportCrypto::HandleNegotiate $%p !mIsServer stage %d\n" , this , mCryptoNegotiateStage );
#endif
		if ( mCryptoNegotiateStage == kNegotiateCryptoWrap )
		{
			RNReplicaNet::DynamicMessageHelper message( RNReplicaNet::TransportConfig::GetPacketMTU() );
			int got = mBaseTransport->Recv( (char*) message.GetBuffer() , message.GetBufferSize() );
			if ( got >= kEncryptionKeyLengthBytes )
			{
#ifdef DEBUG_PRINTS3
				dprintf( "TransportCrypto::HandleNegotiate $%p enc %s\n" , this , MessageHelper::DumpAsHex( message.GetBuffer() , kEncryptionKeyLengthBytes ).c_str() );
#endif
				// Got the wrapped session key, wrap it
				Encryption::CommutativeEncrypt( message.GetBuffer() , kEncryptionKeyLengthBytes , &mMyPrivateKey );

#ifdef DEBUG_PRINTS3
				dprintf( "TransportCrypto::HandleNegotiate $%p enc1 %s\n" , this , MessageHelper::DumpAsHex( message.GetBuffer() , kEncryptionKeyLengthBytes ).c_str() );
#endif
				mBaseTransport->SendReliable( (char*) message.GetBuffer() , kEncryptionKeyLengthBytes );
				mCryptoNegotiateStage++;
			}
		}

		if ( mCryptoNegotiateStage == kNegotiateCryptoUnWrap )
		{
			RNReplicaNet::DynamicMessageHelper message( RNReplicaNet::TransportConfig::GetPacketMTU() );
			int got = mBaseTransport->Recv( (char*) message.GetBuffer() , message.GetBufferSize() );
			if ( got >= kEncryptionKeyLengthBytes )
			{
#ifdef DEBUG_PRINTS3
				dprintf( "TransportCrypto::HandleNegotiate $%p dec %s\n" , this , MessageHelper::DumpAsHex( message.GetBuffer() , kEncryptionKeyLengthBytes ).c_str() );
#endif
				// Got the wrapped session key, unwrap it
				Encryption::CommutativeDecrypt( message.GetBuffer() , kEncryptionKeyLengthBytes , &mMyPrivateKey );

#ifdef DEBUG_PRINTS3
				dprintf( "TransportCrypto::HandleNegotiate $%p dec1 %s\n" , this , MessageHelper::DumpAsHex( message.GetBuffer() , kEncryptionKeyLengthBytes ).c_str() );
#endif
				memcpy( mSessionKey.mKey , message.GetBuffer() , kEncryptionKeyLengthBytes );
				mCryptoNegotiateStage++;
			}
		}

		if ( mCryptoNegotiateStage == kNegotiateCryptoTest )
		{
			RNReplicaNet::DynamicMessageHelper message( RNReplicaNet::TransportConfig::GetPacketMTU() );
			int got = mBaseTransport->Recv( (char*) message.GetBuffer() , message.GetBufferSize() );
			int recvTestData;
			if ( got >= sizeof( recvTestData ) )
			{
				message.GetData( &recvTestData , sizeof( recvTestData ) );	// Deliberate use of GetData, endianess is not important

#ifdef DEBUG_PRINTS3
				dprintf( "TransportCrypto::HandleNegotiate $%p test got %s\n" , this , MessageHelper::DumpAsHex( &recvTestData , sizeof( recvTestData ) ).c_str() );
#endif
				Encryption::Decrypt( &recvTestData , sizeof( recvTestData ) , &mSessionKey );

#ifdef DEBUG_PRINTS3
				dprintf( "TransportCrypto::HandleNegotiate $%p test got dec %s\n" , this , MessageHelper::DumpAsHex( &recvTestData , sizeof( recvTestData ) ).c_str() );
#endif
				mBaseTransport->SendReliable( (char*) &recvTestData , sizeof( recvTestData ) );

				mCryptoNegotiateStage = kNegotiateCryptoSuccess;
			}
		}
	}

	// Special case stages to return the right status
	if ( mCryptoNegotiateStage == kNegotiateCryptoSuccess )
	{
		return kNegotiateSuccess;
	}
	else if ( mCryptoNegotiateStage == kNegotiateCryptoFailed )
	{
		return kNegotiateFailed;
	}

	return kNegotiatePending;
}

#undef MSUPERNAME
//From: RNXPURL/TransportExample.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
//Skipping: #include "RNXPURL/TransportExample.h"

using namespace RNReplicaNet;

#define MSUPERNAME (std::string("EXAMPLE"))

TransportExample::TransportExample() : mBaseTransport(0) , mAllocated(false)
{
}

TransportExample::~TransportExample()
{
	if (mAllocated && mBaseTransport)
	{
		delete mBaseTransport;
		mBaseTransport = 0;
		mAllocated = 0;
	}
}

int TransportExample::GetPacketsSent(const bool reset)
{
	return mBaseTransport->GetPacketsSent(reset);
}

int TransportExample::GetPacketsSentSize(const bool reset)
{
	return mBaseTransport->GetPacketsSentSize(reset);
}

int TransportExample::GetPacketsReceived(const bool reset)
{
	return mBaseTransport->GetPacketsReceived(reset);
}

int TransportExample::GetPacketsReceivedSize(const bool reset)
{
	return mBaseTransport->GetPacketsReceivedSize(reset);
}

int TransportExample::GetPacketsLost(const bool reset)
{
	return mBaseTransport->GetPacketsLost(reset);
}

std::string TransportExample::CanAccept()
{
	return MSUPERNAME + mBaseTransport->CanAccept();
}

std::string TransportExample::CanRoute()
{
	return MSUPERNAME + mBaseTransport->CanRoute();
}

std::string TransportExample::ExportURL(void)
{
	return MSUPERNAME + mBaseTransport->ExportURL();
}

Transport *TransportExample::Allocate(void)
{
	TransportExample *stream = new TransportExample();

	stream->SetBaseTransport(*mBaseTransport->Allocate());
	stream->mAllocated = true;

	return stream;
}

Transport::Error TransportExample::Listen(int channel)
{
	return mBaseTransport->Listen(channel);
}

Transport::Error TransportExample::Listen(const std::string &address)
{
	return mBaseTransport->Listen(address.substr(MSUPERNAME.length()));
}

Transport::Error TransportExample::Connect(const std::string address)
{
	std::string dupe = address;
	dupe.erase(0,MSUPERNAME.size());
	return mBaseTransport->Connect(dupe);
}

Transport *TransportExample::Accept(void)
{
	Transport *accepted = mBaseTransport->Accept();
	if (accepted == NULL)
	{
		return NULL;
	}

	TransportExample *stream = new TransportExample();
	stream->SetBaseTransport(*accepted);
	stream->mAllocated = true;
	return stream;
}

Transport::Error TransportExample::Send(const char *data,const int len)
{
	return mBaseTransport->Send(data,len);
}

Transport::Error TransportExample::SendOrdered(const char *data,const int len,const unsigned int band)
{
	return mBaseTransport->SendOrdered(data,len,band);
}

Transport::Error TransportExample::SendReliable(const char *data,const int len,const unsigned int band)
{
	return mBaseTransport->SendReliable(data,len,band);
}

Transport::Error TransportExample::SendCertain(const char *data,const int len)
{
	return mBaseTransport->SendCertain(data,len);
}

int TransportExample::Recv(char *const data,const int maxlen)
{
	return mBaseTransport->Recv(data,maxlen);
}

int TransportExample::GetMaxPacketSize()
{
	return mBaseTransport->GetMaxPacketSize();
}

std::string TransportExample::HandleDiscovery(void)
{
	std::string retstr;
	retstr = mBaseTransport->HandleDiscovery();
	if (retstr == "")
	{
		return "";
	}
	return MSUPERNAME + retstr;
}

void TransportExample::HandleDiscoveryReply(const std::string reply)
{
	mBaseTransport->HandleDiscoveryReply(reply);
}

void TransportExample::BeginDiscovery(void)
{
	mBaseTransport->BeginDiscovery();
}

std::string TransportExample::GetNextDiscovery(void)
{
	return mBaseTransport->GetNextDiscovery();
}

Transport::Error TransportExample::GetStatus(void)
{
	return mBaseTransport->GetStatus();
}

void TransportExample::SetBaseTransport(Transport &transport)
{
	if (mBaseTransport != NULL)
	{
		return;
	}

	mBaseTransport = &transport;
}

#undef MSUPERNAME
//From: RNXPURL/TransportStream.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
//Skipping: #include "RNXPURL/TransportStream.h"
//Skipping: #include "RNXPSockets/Inc/XPSockets.h"

using namespace RNReplicaNet;

TransportStream::TransportStream() : mBaseTransport(0) , mAllocated(false)
{
	mBufferIn = NULL;

	mBufferEndPoint = 0;
}

TransportStream::~TransportStream()
{
	if (mBufferIn)
	{
		free(mBufferIn);
		mBufferIn = 0;
	}

	if (mBufferOut)
	{
		free(mBufferOut);
		mBufferOut = 0;
	}

	if (mAllocated && mBaseTransport)
	{
		delete mBaseTransport;
		mBaseTransport = 0;
		mAllocated = 0;
	}
}

int TransportStream::GetPacketsSent(const bool reset)
{
	return mBaseTransport->GetPacketsSent(reset);
}

int TransportStream::GetPacketsSentSize(const bool reset)
{
	return mBaseTransport->GetPacketsSentSize(reset);
}

int TransportStream::GetPacketsReceived(const bool reset)
{
	return mBaseTransport->GetPacketsReceived(reset);
}

int TransportStream::GetPacketsReceivedSize(const bool reset)
{
	return mBaseTransport->GetPacketsReceivedSize(reset);
}

int TransportStream::GetPacketsLost(const bool reset)
{
	return mBaseTransport->GetPacketsLost(reset);
}

std::string TransportStream::CanAccept()
{
	return std::string("STREAM") + mBaseTransport->CanAccept();
}

std::string TransportStream::CanRoute()
{
	return std::string("STREAM") + mBaseTransport->CanRoute();
}

std::string TransportStream::ExportURL(void)
{
	return std::string("STREAM") + mBaseTransport->ExportURL();
}

Transport *TransportStream::Allocate(void)
{
	TransportStream *stream = new TransportStream();

	stream->SetBaseTransport(*mBaseTransport->Allocate());
	stream->mAllocated = true;

	return stream;
}

Transport::Error TransportStream::Listen(int channel)
{
	return mBaseTransport->Listen(channel);
}

Transport::Error TransportStream::Listen(const std::string &address)
{
	return mBaseTransport->Listen(address.substr(6));
}

Transport::Error TransportStream::Connect(const std::string address)
{
	std::string dupe = address;
	dupe.erase(0,6);
	return mBaseTransport->Connect(dupe);
}

Transport *TransportStream::Accept(void)
{
	Transport *accepted = mBaseTransport->Accept();
	if (accepted == NULL)
	{
		return NULL;
	}

	TransportStream *stream = new TransportStream();
	stream->SetBaseTransport(*accepted);
	stream->mAllocated = true;
	return stream;
}

Transport::Error TransportStream::Send(const char *data,const int len)
{
	assert( ( len > 0 ) && ( len <= (mBufferSize-2) ) );

	if ( ( len < 0 ) || ( len > (mBufferSize-2) ) )
	{
		return kTransport_EERROR;
	}
	MessageHelper::SetShort(mBufferOut,0,len+2);
	if (len > 0)
	{
		memcpy(mBufferOut+2,data,len);
	}

	return mBaseTransport->Send(mBufferOut,len+2);
}

Transport::Error TransportStream::SendOrdered(const char *data,const int len,const unsigned int band)
{
	assert( ( len > 0 ) && ( len <= (mBufferSize-2) ) );

	if ( ( len < 0 ) || ( len > (mBufferSize-2) ) )
	{
		return kTransport_EERROR;
	}
	MessageHelper::SetShort(mBufferOut,0,len+2);
	if (len > 0)
	{
		memcpy(mBufferOut+2,data,len);
	}

	return mBaseTransport->SendOrdered(mBufferOut,len+2,band);
}

Transport::Error TransportStream::SendReliable(const char *data,const int len,const unsigned int band)
{
	assert( ( len > 0 ) && ( len <= (mBufferSize-2) ) );

	if ( ( len < 0 ) || ( len > (mBufferSize-2) ) )
	{
		return kTransport_EERROR;
	}
	MessageHelper::SetShort(mBufferOut,0,len+2);
	if (len>0)
	{
		memcpy(mBufferOut+2,data,len);
	}

	return mBaseTransport->SendReliable(mBufferOut,len+2,band);
}

Transport::Error TransportStream::SendCertain(const char *data,const int len)
{
	assert( ( len > 0 ) && ( len <= (mBufferSize-2) ) );

	if ( ( len < 0 ) || ( len > (mBufferSize-2) ) )
	{
		return kTransport_EERROR;
	}
	MessageHelper::SetShort(mBufferOut,0,len+2);
	if (len>0)
	{
		memcpy(mBufferOut+2,data,len);
	}

	return mBaseTransport->SendCertain(mBufferOut,len+2);
}

int TransportStream::Recv(char *const data,const int maxlen)
{
	int ret;	

	// Loop around until we can fill the buffer with at least 2 bytes to get the length
	while( mBufferEndPoint < 2)
	{
		ret = mBaseTransport->Recv(mBufferIn+mBufferEndPoint, 2 - mBufferEndPoint);

		if (ret == 0 || ret == kTransport_EERROR)
		{
			return ret;
		}

		// Increment the counter for the end point of the buffer
		mBufferEndPoint += ret;
	}

	// Now loop around until we get at least one whole packet block in the buffer
	int length = MessageHelper::GetShort(mBufferIn,0);

	if ( ( length <= 1 ) || ( length > mBufferSize ) )
	{
		assert(!"Weird stream length, bad data received");
		return kTransport_EERROR;
	}

	// A zero length (-2 for the size header) packet
	if ( ( length - 2 ) == 0 )
	{
		return 0;
	}

	if ( (length-2) > maxlen )
	{
		return length-2;
	}

	while (mBufferEndPoint < length)
	{
		ret = mBaseTransport->Recv(mBufferIn+mBufferEndPoint,length - mBufferEndPoint);

		if (ret == 0 || ret == kTransport_EERROR)
		{
			return ret;
		}

		mBufferEndPoint += ret;
	}

	length -= 2;

	if ( ( length <= maxlen ) && ( length > 0 ) )
	{
		memcpy(data,mBufferIn+2,length);
		mBufferEndPoint = 0;
		return length;
	}

	assert(!"This should never happen");
	return kTransport_EERROR;
}

int TransportStream::GetMaxPacketSize()
{
	return mBaseTransport->GetMaxPacketSize() - 2;
}

std::string TransportStream::HandleDiscovery(void)
{
	std::string retstr;
	retstr = mBaseTransport->HandleDiscovery();
	if (retstr == "")
	{
		return "";
	}
	return std::string("STREAM") + retstr;
}

void TransportStream::HandleDiscoveryReply(const std::string reply)
{
	mBaseTransport->HandleDiscoveryReply(reply);
}

void TransportStream::BeginDiscovery(void)
{
	mBaseTransport->BeginDiscovery();
}

std::string TransportStream::GetNextDiscovery(void)
{
	return mBaseTransport->GetNextDiscovery();
}

Transport::Error TransportStream::GetStatus(void)
{
	return mBaseTransport->GetStatus();
}

void TransportStream::SetBaseTransport(Transport &transport)
{
	if (mBaseTransport != NULL)
	{
		return;
	}

	mBaseTransport = &transport;

	mBufferSize = mBaseTransport->GetMaxPacketSize();
	mBufferIn = (char *) malloc(mBufferSize);
	mBufferOut = (char *) malloc(mBufferSize);
}
//From: RNXPURL/TransportTCPIP.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>

//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
using namespace RNReplicaNet;
//Skipping: #include "RNXPSockets/Inc/XPSockets.h"
//Skipping: #include "RNXPURL/TransportTCPIP.h"


TransportTCPIP::TransportTCPIP() : mError(kTransport_EOK)
{
	mPacketsSent = 0;
	mPacketsReceived = 0;

	mPacketsSentSize = 0;
	mPacketsReceivedSize = 0;

	mPacketsLost = 0;
}

TransportTCPIP::~TransportTCPIP()
{
}

int TransportTCPIP::GetPacketsSent(const bool reset)
{
	int temp = mPacketsSent;
	if (reset)
	{
		mPacketsSent = 0;
	}
	return temp;
}
int TransportTCPIP::GetPacketsSentSize(const bool reset)
{
	int temp = mPacketsSentSize;
	if (reset)
	{
		mPacketsSentSize = 0;
	}
	return temp;
}
int TransportTCPIP::GetPacketsReceived(const bool reset)
{
	int temp = mPacketsReceived;
	if (reset)
	{
		mPacketsReceived = 0;
	}
	return temp;
}
int TransportTCPIP::GetPacketsReceivedSize(const bool reset)
{
	int temp = mPacketsReceivedSize;
	if (reset)
	{
		mPacketsReceivedSize = 0;
	}
	return temp;
}
int TransportTCPIP::GetPacketsLost(const bool reset)
{
	int temp = mPacketsLost;
	if (reset)
	{
		mPacketsLost = 0;
	}
	return temp;
}

std::string TransportTCPIP::CanAccept()
{
	return std::string("TCPIP@");
}

std::string TransportTCPIP::CanRoute()
{
	return std::string("TCPIP@");
}

std::string TransportTCPIP::ExportURL(void)
{
	XPAddress addr;
	XPSocket::GetAddress(&addr);

	return std::string(CanAccept() + addr.Export() + std::string("/"));
}


Transport *TransportTCPIP::Allocate(void)
{
	return new TransportTCPIP();
}

Transport::Error TransportTCPIP::Listen(int channel)
{
	int ret;
	// Create a socket of type TCP to use for this transport
	XPSocket::Create();

	if (channel == TransportAnyGameChannel)
	{
		ret = XPSocket::Listen(XPSOCK_PORT_ANY);
	}
	else
	{
		ret = XPSocket::Listen(channel);
		if (ret == XPSOCK_EERROR)
		{
			XPSocket::Close();
			return kTransport_ECANTLISTENONCHANNEL;
		}
	}

	// Start the discovery UDP socket once the main socket is started
	EnsureDiscoverySocketInboundIsAlive();

	return kTransport_EOK;
}

Transport::Error TransportTCPIP::Listen(const std::string &address)
{
	std::string work = address.substr(CanAccept().length());
	XPAddress addr(work);

	int ret;
	// Create a socket of type TCP to use for this transport
	XPSocket::Create();

	ret = XPSocket::Listen(addr);
	if (ret == XPSOCK_EERROR)
	{
		XPSocket::Close();
		return kTransport_ECANTLISTENONCHANNEL;
	}

	// Start the discovery UDP socket once the main socket is started
	EnsureDiscoverySocketInboundIsAlive();

	return kTransport_EOK;
}

Transport::Error TransportTCPIP::Connect(const std::string address)
{
	if (address.size() < CanAccept().size())
	{
		return kTransport_EERROR;
	}

	std::string justaddr;
	size_t len = CanAccept().size();
	std::string copy = address;
	justaddr = std::string(copy.c_str()+len);
	XPAddress addr(justaddr);

	XPSocket::Create();
	XPSocket::Connect(addr);

	return kTransport_EOK;
}

Transport *TransportTCPIP::Accept(void)
{
	Poll();

	XPSocket *socket = XPSocket::Accept();
	if (socket == NULL || socket == pcXPSOCK_EERROR)
	{
		return NULL;
	}

	TransportTCPIP *newtrans = new TransportTCPIP;

	newtrans->Create();

	newtrans->MutateSocket(socket);

	delete socket;

	return newtrans;
}

Transport::Error TransportTCPIP::Send(const char *data,const int len)
{
	return SendReliable(data,len);
}

Transport::Error TransportTCPIP::SendOrdered(const char *data,const int len,const unsigned int band)
{
	return SendReliable(data,len);
}

Transport::Error TransportTCPIP::SendReliable(const char *data,const int len,const unsigned int band)
{
	Poll();

	mPacketsSent++;
	mPacketsSentSize+=len;

	int ret = XPSocket::Send(data,len);

	if (ret < 0 && XPSocket::GetLastError() != XPSOCK_EWOULDBLOCK)
	{
		mError = kTransport_EERROR;
	}

	return kTransport_EOK;
}

Transport::Error TransportTCPIP::SendCertain(const char *data,const int len)
{
	return SendReliable(data,len);
}

int TransportTCPIP::Recv(char *const data,const int maxlen)
{
	Poll();

	int ret = XPSocket::Recv(data,maxlen);

	if (ret < 0)
	{
		mError = kTransport_EERROR;
		return 0;
	}

	mPacketsReceived++;
	mPacketsReceivedSize+=ret;

	return ret;
}

int TransportTCPIP::GetMaxPacketSize()
{
	return XPSocket::GetMaxPacketSize();
}

void TransportTCPIP::Poll(void)
{
}

Transport::Error TransportTCPIP::GetStatus(void)
{
	return mError;
}
//From: RNXPURL/TransportUDP.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <vector>
#include <time.h>
//Skipping: #include "RNPlatform/Inc/ThreadClass.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
using namespace RNReplicaNet;
//Skipping: #include "RNXPSockets/Inc/XPSockets.h"
//Skipping: #include "RNXPURL/TransportUDP.h"
//Skipping: #include "RNPlatform/UtilityIter.h"
//Skipping: #include "RNPlatform/Options.h"
//Skipping: #include "RNPlatform/Inc/Thread.h"
//Skipping: #include "RNPlatform/Inc/ThreadClass.h"
//Skipping: #include "RNPlatform/Inc/RegistryManager.h"
//Skipping: #include "RNPlatform/Inc/SysTime.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
//Skipping: #include "RNPlatform/DebugSupport.h"
//Skipping: #include "RNXPURL/UDPReliableManager.h"
//Skipping: #include "RNXPURL/Inc/TransportConfig.h"
//Skipping: #include "RNPlatform/Inc/CheckSum.h"
//Skipping: #include "RNXPCompression/Inc/XPCompression.h"

// Used with THREADSAFELOCKCLASS() to lock various aspects of transports
static MutexClass gUDPWaitingPackets;
static MutexClass gUDPNewAddresses;
static MutexClass gUDPKnownTransportsByAddress;
static MutexClass gUDPHistory;

SysTime gUDPTimer;
static bool sIsforcedExternalAddress;
static RNReplicaNet::XPAddress sForcedExternalAddress;

Transport::Bandwidth TransportUDP::mConfiguredBandwidthGlobal = Transport::kBandwidth_Off;
int TransportUDP::mMaximumOutputBandwidthGlobal = 0;
int TransportUDP::mMaximumInputBandwidthGlobal = 0;

bool TransportUDP::mLANDiscovery = true;

static bool sLocalNonceInit = true;
static int sLocalNonce = 0;

// MPi: Implementation notes.
// The standard format for a packet is:
// 0/1		Low/Hi size of entire packet. (short)
// 2		RNReplicaNet::UDPReliableManager::PacketType. (char)
// 3+		Data length (n)
// n		One byte CRC
//
// Searching XDK for "Outbound Datagrams" results in:
// For Xbox the maximum UDP payload is 1304.
// For Xbox 360 the maximum UDP payload is 1264 bytes.
// PS2 doesn't seem to care that much as long as the whole packet doesn't go over the Ethernet frame size of 1500 bytes.
// PC Win32 and Linux also don't care that much.
// Given that on the wire UDP IP header information is 42 bytes in total, allow sensible values for packet sizes.
static int sUDPMaximumBufferedDataSize = 1264;	// If this value is changed the comments relating to SetPacketMTU in TransportConfig.h must also be changed.

static volatile size_t sCompressedBytesSaved = 0;
size_t TransportConfig::GetTransparentPacketCompressionBytesSaved(const bool reset)
{
	size_t toRet = sCompressedBytesSaved;
	if (reset)
	{
		sCompressedBytesSaved = 0;
	}
	return toRet;
}

void TransportConfig::SetPacketMTU(const int bytes)
{
	sUDPMaximumBufferedDataSize = bytes - kUDPIPHeaderBytes;
	if (sUDPMaximumBufferedDataSize < TransportMinimumPacketSize)
	{
		sUDPMaximumBufferedDataSize = TransportMinimumPacketSize;
	}
}

int TransportConfig::GetPacketMTU(void)
{
	return (sUDPMaximumBufferedDataSize + kUDPIPHeaderBytes);
}

void TransportConfig::SetExternalIP(const std::string address)
{
	if (address == "")
	{
		sIsforcedExternalAddress = false;
		return;
	}
	std::string real = address;
	if (real.find_first_of(':') == std::string::npos)
	{
		real = real + ":0";
	}
	sForcedExternalAddress.Import(real);
	sIsforcedExternalAddress = true;
}

std::string TransportConfig::GetExternalIP(void)
{
	if (!sIsforcedExternalAddress)
	{
		return std::string("");
	}
	std::string ret = sForcedExternalAddress.Export();
	ret = ret.substr(0,ret.find_first_of(':'));
	return ret;
}

TransportUDP::TransportUDP() : mError(kTransport_EOK) , mGotDisconnectPacket(false) , mSocketIsMaster(false) , mPersistantSocket(0) , mOnlyReceiveFrom(false) ,
				mBaseTransport(0) , mIgnorePacket(true) , mTransportHavingProblems(false) , mFullConnectionDone(false) ,
				mAllowedToGetData(false) , mConfiguredBandwidth(kBandwidth_Off) , mMaximumOutputBandwidth(0) ,
				mMaximumInputBandwidth(0) , mHistoryTotal(0), mCurrentBandwidthOutputPerSecond(0.0f) , mEarliestBufferTime(0.0f) ,
				mPacketBuffer(0) , mBufferSize(0) , mPacketBufferCompressed(0) , mCompressionLevel(0) , mPacketsSentMerged(0) , mPacketsReceivedMerged(0) , mWasNewed(true)
{
#ifdef DEBUG_PRINTS3
	dprintf("TransportUDP $%p : Construct\n",this);
#endif
	if (sLocalNonceInit)
	{
		sLocalNonceInit = false;
		sLocalNonce = (int) time(0);	// Seed the local nonce with something that is likely to change regularly.
	}
	mLocalNonce = sLocalNonce++;

	if (!gUDPManager)
	{
		gUDPManagerMutex.Lock();
		if (!gUDPManager)
		{
			gUDPManager = new UDPReliableManager;
		}
		gUDPManagerMutex.UnLock();
	}
//	THREADSAFELOCKCLASSp(gUDPManager);

	mPacketsSent = 0;
	mPacketsReceived = 0;

	mPacketsSentSize = 0;
	mPacketsReceivedSize = 0;

	mPacketsLost = 0;

	mCertainSequence = 0;
	memset(&mSequence,0,sizeof(mSequence));
	memset(&mRecvSequence,0,sizeof(mRecvSequence));
	mProblemResendIndex = 0;
	mProblemResendIndexUsed = 0;
	mProblemResendIndexReset = (SysTimeType) 0;
	memset(&mOrderedSendSequence,0,sizeof(mOrderedSendSequence));
	memset(&mOrderedRecvSequence,0,sizeof(mOrderedRecvSequence));

	// TODO: Do properly
	// Global settings override local settings in the ctor
	if (mConfiguredBandwidthGlobal != Transport::kBandwidth_Off)
	{
		mConfiguredBandwidth = mConfiguredBandwidthGlobal;
		mMaximumInputBandwidth = mMaximumInputBandwidthGlobal;
		mMaximumOutputBandwidth = mMaximumOutputBandwidthGlobal;
	}
	mWrapHappened = false;

	// By default turn on checksums
	// MPi: TODO: Maybe make this configurable so new versions of RN can still talk to old versions?
	mUseChecksum = TransportConfig::GetExtraPacketSecurity();
}

TransportUDP::~TransportUDP()
{
	if (gUDPManager)
	{
		gUDPManager->RemoveTransport(this);
	}
//	THREADSAFELOCKCLASSp(gUDPManager);
#ifdef DEBUG_PRINTS3
	dprintf("TransportUDP $%p : Free\n",this);
#endif

	CommonDisconnectSend();

	if (mSocketIsMaster && mPersistantSocket)
	{
		THREADSAFELOCKCLASS(gUDPKnownTransportsByAddress);
		if (mWasNewed)
		{
			if (!mKnownTransportsByAddress.empty())
			{
				assert(false && "TransportUDP: Error! Master persistant socket was deleted with attached transports\n");
				exit(-1);
			}
		}

		mPersistantSocket->Close();
		if (mWasNewed)
		{
			delete mPersistantSocket;
		}
		mPersistantSocket = 0;
	}

	// i.e. This transport is allocated as part of an Accept() call
	if (mBaseTransport)
	{
#ifdef DEBUG_PRINTS3
		dprintf("Is part of base trans $%p\n",mBaseTransport);
#endif
		THREADSAFELOCKCLASS(gUDPKnownTransportsByAddress);

#ifdef _DEBUG
		// Debug check to make sure we are removing ourself.
		std::map<XPAddress,TransportUDP *>::iterator found = mBaseTransport->mKnownTransportsByAddress.find(mReceiveFrom);
		assert(found != mBaseTransport->mKnownTransportsByAddress.end());
		assert((*found).second == this);
#endif
#ifdef DEBUG_PRINTS3
		dprintf("Delete ref to transport $%p on mBaseTransport\n",this);
#endif
		mBaseTransport->mKnownTransportsByAddress.erase(mReceiveFrom);
	}

	// Delete the waiting packets because they might be left
	THREADSAFELOCKCLASS(gUDPWaitingPackets);
	while (!mWaitingPackets.empty())
	{
		WaitingPacket *packet = *mWaitingPackets.begin();
		mWaitingPackets.erase(mWaitingPackets.begin());

		delete packet;
	}

	free(mPacketBuffer);
	free(mPacketBufferCompressed);
}

void TransportUDP::CommonDisconnectSend(void)
{
	if (mPersistantSocket && mOnlyReceiveFrom)
	{
		// Are we disconnecting due to a disconnect packet being received?
		// If not then send our own disconnect packets
		if (!mGotDisconnectPacket)
		{
#ifdef DEBUG_PRINTS3
			dprintf("Sending death packets to %s\n",mReceiveFrom.Export().c_str());
#endif
			// When freeing send deaths packet if we can
			char buffer[8];
			MessageHelper message;
			message.SetBuffer(buffer);
			char reply = UDPReliableManager::kDisconnect;
			short size = 3;
			message.AddVariable(&size,sizeof(size));
			message.AddVariable(&reply,sizeof(reply));
			if (mUseChecksum)
			{
				AddChecksumToMessage(&message);
			}
			mPersistantSocket->Send(buffer,message.GetSize(),mReceiveFrom);
			mPersistantSocket->Send(buffer,message.GetSize(),mReceiveFrom);
			mPersistantSocket->Send(buffer,message.GetSize(),mReceiveFrom);
			mPersistantSocket->Send(buffer,message.GetSize(),mReceiveFrom);
			mPersistantSocket->Send(buffer,message.GetSize(),mReceiveFrom);
			mGotDisconnectPacket = true;	// Stop it from sending this more than once.
		}
	}
}

int TransportUDP::GetPacketsSent(const bool reset)
{
	int temp = mPacketsSent;
	if (reset)
	{
		mPacketsSent = 0;
	}
	return temp;
}
int TransportUDP::GetPacketsSentSize(const bool reset)
{
	int temp = mPacketsSentSize;
	if (reset)
	{
		mPacketsSentSize = 0;
	}
	return temp;
}
int TransportUDP::GetPacketsReceived(const bool reset)
{
	int temp = mPacketsReceived;
	if (reset)
	{
		mPacketsReceived = 0;
	}
	return temp;
}
int TransportUDP::GetPacketsReceivedSize(const bool reset)
{
	int temp = mPacketsReceivedSize;
	if (reset)
	{
		mPacketsReceivedSize = 0;
	}
	return temp;
}
int TransportUDP::GetPacketsLost(const bool reset)
{
	int temp = mPacketsLost;
	if (reset)
	{
		mPacketsLost = 0;
	}
	return temp;
}

std::string TransportUDP::CanAccept()
{
	return std::string("UDP@");
}

std::string TransportUDP::CanRoute()
{
	return std::string("UDP@");
}

std::string TransportUDP::ExportURL(void)
{
	XPAddress addr;

	if (!mPersistantSocket)
	{
		return std::string("");
	}

	mPersistantSocket->GetAddress(&addr);

	// If we are forcing an external IP address then use that instead
	if (sIsforcedExternalAddress)
	{
		addr.addr[0] = sForcedExternalAddress.addr[0];
		addr.addr[1] = sForcedExternalAddress.addr[1];
		addr.addr[2] = sForcedExternalAddress.addr[2];
		addr.addr[3] = sForcedExternalAddress.addr[3];
	}

	return std::string(CanAccept() + addr.Export() + std::string("/"));
}


Transport *TransportUDP::Allocate(void)
{
	return new TransportUDP();
}

Transport::Error TransportUDP::Listen(const int channel)
{
	XPAddress addr;
	addr.MakeAny(channel);
	if (channel == TransportAnyGameChannel)
	{
		addr.MakeAny();
	}

	// If we are forcing an external IP address then use that instead
	if (sIsforcedExternalAddress)
	{
		addr.addr[0] = sForcedExternalAddress.addr[0];
		addr.addr[1] = sForcedExternalAddress.addr[1];
		addr.addr[2] = sForcedExternalAddress.addr[2];
		addr.addr[3] = sForcedExternalAddress.addr[3];
	}

	return Listen(CanAccept() + addr.Export());
}

Transport::Error TransportUDP::Listen(const std::string &address)
{
	std::string work = address.substr(CanAccept().length());
	XPAddress addr(work);
//	THREADSAFELOCKCLASSp(gUDPManager);

#ifdef DEBUG_PRINTS3
	dprintf("TransportUDP $%p : Listen\n",this);
#endif

	if (mPersistantSocket)
	{
//		assert(false);
		return kTransport_EERROR;
	}

	mSocketIsMaster = true;
	mPersistantSocket = new XPSocketUrgent();

	if (!mPersistantSocket)
	{
//		assert(false);
		return kTransport_EERROR;
	}

	mIgnorePacket = false;

	int ret;
	ret = mPersistantSocket->Create(addr);
	if (ret == XPSOCK_EERROR)
	{
		mPersistantSocket->Close();
		delete mPersistantSocket;
		mPersistantSocket = 0;
//		assert(false);
		return kTransport_ECANTLISTENONCHANNEL;
	}

	int bufsize = 128*1024; // 128Kb
	if (mPersistantSocket->SetSendBuffer(-1) < bufsize)
	{
		mPersistantSocket->SetSendBuffer(bufsize);
	}
	if (mPersistantSocket->SetRecvBuffer(-1) < bufsize)
	{
		mPersistantSocket->SetRecvBuffer(bufsize);
	}

	// Start the discovery UDP socket once the main socket is started
	EnsureDiscoverySocketInboundIsAlive();

	mCertainSequence = -1;
	mSequence[0] = -1;
	mRecvSequence[0] = -1;

	mFullConnectionDone = true;

	mOnlyReceiveFrom = false;
	mAllowedToGetData = true;

//	printf("ListenAdd $%p\n",this);
	if (gUDPManager)
	{
		gUDPManager->AddTransport(this);
	}

	return kTransport_EOK;
}

Transport::Error TransportUDP::Connect(const std::string address)
{
	Error ret = ConnectStage1();
	if (ret != kTransport_EOK)
	{
		return ret;
	}
	return ConnectStage2(address);
}

Transport::Error TransportUDP::ConnectStage1(void)
{
//	THREADSAFELOCKCLASSp(gUDPManager);

	if (mPersistantSocket)
	{
		return kTransport_EERROR;
	}

	mSocketIsMaster = true;
	mPersistantSocket = new XPSocketUrgent();

	if (!mPersistantSocket)
	{
//		assert(false);
		return kTransport_EERROR;
	}

	mIgnorePacket = false;

	XPAddress addr(0);
	// Decide what sockets to create based on what has been detected.
	addr.mIPv4 = TransportConfig::GetIPv4Detected();
	addr.mIPv6 = TransportConfig::GetIPv6Detected();

	int ret;
	ret = mPersistantSocket->Create(addr);
	if (ret == XPSOCK_EERROR)
	{
		delete mPersistantSocket;
		mPersistantSocket = 0;
		return kTransport_EERROR;
	}

	int bufsize = 128*1024; // 128Kb
	if (mPersistantSocket->SetSendBuffer(-1) < bufsize)
	{
		mPersistantSocket->SetSendBuffer(bufsize);
	}
	if (mPersistantSocket->SetRecvBuffer(-1) < bufsize)
	{
		mPersistantSocket->SetRecvBuffer(bufsize);
	}

	return kTransport_EOK;
}

Transport::Error TransportUDP::ConnectStage2(const std::string address)
{
	if (address.size() < CanAccept().size())
	{
		delete mPersistantSocket;
		mPersistantSocket = 0;
		return kTransport_EERROR;
	}

	std::string justaddr;
	std::string copy = address;
	size_t len = CanAccept().size();
	justaddr = std::string(copy.c_str()+len);
	XPAddress addr(justaddr);

	// Decide what to connect to based on what has been detected.
	// Prefer IPv6 connections if the address has an IPv6 section
	if (TransportConfig::GetIPv6Detected() && addr.mIPv6)
	{
		addr.mIPv4 = false;
	}
	if (!TransportConfig::GetIPv4Detected())
	{
		addr.mIPv4 = false;
	}
	if (!TransportConfig::GetIPv6Detected())
	{
		addr.mIPv6 = false;
	}

	if (!addr.mIPv4 && !addr.mIPv6)
	{
		mError = kTransport_EERROR;
		return kTransport_EERROR;
	}

	mOnlyReceiveFrom = true;
	mReceiveFrom = addr;

#ifdef DEBUG_PRINTS3
	dprintf("TransportUDP::ConnectStage2 to addr %s\n",addr.Export().c_str());
#endif

	mAllowedToGetData = true;

	if (/*UDPReliableManager::mPacketBufferTime > 0.0f*/ !UDPReliableManager::mDisableAllPacketBuffer)
	{
		mPacketBuffer = (char *)malloc(sUDPMaximumBufferedDataSize);
	}

	if ((mCompressionLevel > 0) && (mCompressionLevel <= 10))
	{
		XPCompression comp;
		mPacketBufferCompressed = (char *)malloc(comp.CalculateMaximumMemory(sUDPMaximumBufferedDataSize) + sizeof(short));
	}

	// Because we want to skip the first two sequences since they are special
	mRecvSequence[0] = 2;

//	printf("ConnectAdd $%p\n",this);
	gUDPManager->AddTransport(this);

	// This transport sends two initial ping packets when it connects to help the master do the accept()
	char buffer[64];
	char reliablebit;
	short origsize = sizeof(origsize)+sizeof(reliablebit)+sizeof(mSequence[0])+sizeof(mConfiguredBandwidth)+sizeof(mMaximumOutputBandwidth)+sizeof(mMaximumInputBandwidth);
	MessageHelper message;
	ReliablePacket *relb;
	XPAddress tempa = XPAddress(0,0,0,0,0);


	message.SetBuffer(buffer);
	reliablebit = UDPReliableManager::kBuildUp;
	message.AddVariable(&origsize,sizeof(origsize));
	message.AddVariable(&reliablebit,sizeof(reliablebit));
	message.AddVariable(&mSequence[0],sizeof(mSequence[0]));
// TODO: This does need to use global and local choices depending on the option...
//	message.AddVariable(&mConfiguredBandwidth,sizeof(mConfiguredBandwidth));
//	message.AddVariable(&mMaximumOutputBandwidth,sizeof(mMaximumOutputBandwidth));
//	message.AddVariable(&mMaximumInputBandwidth,sizeof(mMaximumInputBandwidth));
	message.AddVariable(&mConfiguredBandwidthGlobal,sizeof(mConfiguredBandwidthGlobal));
	message.AddVariable(&mMaximumOutputBandwidthGlobal,sizeof(mMaximumOutputBandwidthGlobal));
	message.AddVariable(&mMaximumInputBandwidthGlobal,sizeof(mMaximumInputBandwidthGlobal));
	if (mUseChecksum)
	{
		AddChecksumToMessage(&message);
	}

	relb = new ReliablePacket(message.GetSize(),buffer,this,mReceiveFrom,tempa,false);
	gUDPManager->AddPendingPacket(relb);
	mPacketsSent++;
	mPacketsSentSize+=message.GetSize();
	mPersistantSocket->Send(buffer,message.GetSize(),mReceiveFrom);
	AddHistoryEntry(message.GetSize());
	mSequence[0]++;

	// Now the zero length packet with sequence id of 1
	char data[1];
	SendReliable(data,0);

#ifdef DEBUG_PRINTS3
	dprintf("TransportUDP : ConnectStage2 Send of connect bytes to %d.%d.%d.%d:%d\n",mReceiveFrom.addr[0],mReceiveFrom.addr[1],mReceiveFrom.addr[2],mReceiveFrom.addr[3],mReceiveFrom.port);
#endif

	return kTransport_EOK;
}

Transport *TransportUDP::Accept(void)
{
//	THREADSAFELOCKCLASSp(gUDPManager);

	// Read only, thread safe
	if (mNewAddresses.empty())
	{
		return NULL;
	}

	TransportUDP *newtrans = 0;

	{
		THREADSAFELOCKCLASS(gUDPNewAddresses);

		// Now double check once we have the lock
		if (mNewAddresses.empty())
		{
			return 0;
		}

		newtrans = new TransportUDP;

		assert(mPersistantSocket);
		newtrans->mPersistantSocket = mPersistantSocket;

		newtrans->mOnlyReceiveFrom = true;
		newtrans->mReceiveFrom = (*mNewAddresses.begin()).mAddress;

		newtrans->mBaseTransport = this;

	//	newtrans->mReceiveFrom = (*mNewAddresses.begin()).mAddress;
		newtrans->mConfiguredBandwidth = (*mNewAddresses.begin()).mConfiguredBandwidth;
		// Swap over the send and receive since we want to use the mirror of what the other end says
		newtrans->mMaximumOutputBandwidth = (*mNewAddresses.begin()).mMaximumInputBandwidth;
		newtrans->mMaximumInputBandwidth = (*mNewAddresses.begin()).mMaximumOutputBandwidth;

		newtrans->mUseChecksum = (*mNewAddresses.begin()).mUseChecksum;

		// Because we have received two packets, which are reliable ones
		newtrans->mRecvSequence[0] = 2;
		// We want to start out real packets off at sequence 2
		newtrans->mSequence[0] = 2;

		newtrans->mFullConnectionDone = true;

		if (/*UDPReliableManager::mPacketBufferTime > 0.0f*/ !UDPReliableManager::mDisableAllPacketBuffer)
		{
			newtrans->mPacketBuffer = (char *)malloc(sUDPMaximumBufferedDataSize);
		}

		if ((mCompressionLevel > 0) && (mCompressionLevel <= 10))
		{
			XPCompression comp;
			newtrans->mCompressionLevel = mCompressionLevel;
			newtrans->mPacketBufferCompressed = (char *)malloc(comp.CalculateMaximumMemory(sUDPMaximumBufferedDataSize) + sizeof(short));
		}

	//	mNewAddresses.erase(&(*mNewAddresses.begin()));
	/// GCC Fix
		mNewAddresses.erase(mNewAddresses.begin());
	}

	gUDPManager->AddTransport(newtrans);

/*
	// MPi: commented out to see if it breaks anything.
	// After testing seems to be OK...

	// MPi: TODO: Is this really needed since the waiting packets will parse the list anyway?
	// Grab any other pending packets waiting for us in the queue
	{
		THREADSAFELOCKCLASS(gUDPWaitingPackets);
		LIST_ITER_BEGIN(WaitingPacket *,mWaitingPackets,packet);
		if (packet->mAddr == newtrans->mReceiveFrom)
		{
			newtrans->mWaitingPackets.push_back(packet);
			LIST_ITER_ERASE(mWaitingPackets);
		}
		LIST_ITER_END();
	}
*/

	{
	THREADSAFELOCKCLASS(gUDPKnownTransportsByAddress);
	mKnownTransportsByAddress.insert(std::pair<XPAddress,TransportUDP *>(newtrans->mReceiveFrom,newtrans));
	}

	// Send back a zero length packet as the wakeup packet that completes the connection for the remote machine
	// This is sent as sequence id 2 so the client knows
	char data[1];
	newtrans->SendReliable(data,0);

	return newtrans;
}

Transport::Error TransportUDP::Send(const char *data,const int len)
{
	if (mSequence[0] == -1)
	{
#ifdef DEBUG_PRINTS3
		dprintf("TransportUDP: Trying to send from a listen transport\n");
#endif
		mError = kTransport_EERROR;
		return kTransport_EERROR;
	}

	if (mError == kTransport_EERROR)
	{
		return kTransport_EERROR;
	}

	if (GetStatus() != kTransport_EOK)
	{
// MPi: TODO: Might be internally used prior to a valid connect. Find and replace these occurrences.
//		return GetStatus();
	}

	CalculateBandwidthOutputPerSecondAndRetireHistoryEntries();
	if (mConfiguredBandwidth == kBandwidth_Connection && mMaximumOutputBandwidth > 0)
	{
		if(mCurrentBandwidthOutputPerSecond > mMaximumOutputBandwidth)
		{
			return kTransport_EOK;
		}
	}

#ifdef DEBUG_PRINTS3
	dprintf("TransportUDP : Send of %d normal bytes to %d.%d.%d.%d:%d\n",len,mReceiveFrom.addr[0],mReceiveFrom.addr[1],mReceiveFrom.addr[2],mReceiveFrom.addr[3],mReceiveFrom.port);
#endif

	// Prepend a null flag for unreliable packet
	char buffer[4096];
	MessageHelper message;
	message.SetBuffer(buffer);
	short origsize = len + 3;
	char nullbit = UDPReliableManager::kUnreliable;
	message.AddVariable(&origsize,sizeof(origsize));
	message.AddVariable(&nullbit,sizeof(nullbit));

	if (len > 0)
	{
		message.AddData(data,len);
	}

	if (mUseChecksum)
	{
		AddChecksumToMessage(&message);
	}

	DoInternalSend(buffer,message.GetSize());

#ifdef DEBUG_PRINTS3
	dprintf("   Really %d bytes long\n",message.GetSize());
#endif

	return kTransport_EOK;
}

Transport::Error TransportUDP::SendOrdered(const char *data,const int len,const unsigned int band)
{
	if (mSequence[0] == -1)
	{
#ifdef DEBUG_PRINTS3
		dprintf("TransportUDP: Trying to send from a listen transport\n");
#endif
		mError = kTransport_EERROR;
		return kTransport_EERROR;
	}

	if (mError == kTransport_EERROR)
	{
		return kTransport_EERROR;
	}

	if (GetStatus() != kTransport_EOK)
	{
		// MPi: TODO: Might be internally used prior to a valid connect. Find and replace these occurrences.
		//		return GetStatus();
	}

	CalculateBandwidthOutputPerSecondAndRetireHistoryEntries();
	if (mConfiguredBandwidth == kBandwidth_Connection && mMaximumOutputBandwidth > 0)
	{
		if(mCurrentBandwidthOutputPerSecond > mMaximumOutputBandwidth)
		{
			return kTransport_EOK;
		}
	}

#ifdef DEBUG_PRINTS3
	dprintf("TransportUDP : Send of %d normal ordered bytes to %d.%d.%d.%d:%d\n",len,mReceiveFrom.addr[0],mReceiveFrom.addr[1],mReceiveFrom.addr[2],mReceiveFrom.addr[3],mReceiveFrom.port);
#endif

	// Prepend a null flag for unreliable packet
	char buffer[4096];
	MessageHelper message;
	message.SetBuffer(buffer);
	short origsize = len + 6;
	unsigned char realBand = (unsigned char) band;
	char nullbit = UDPReliableManager::kOrdered;
	// Basically the first sent unreliable ordered packet sequence is 1
	unsigned short sequence = ++mOrderedSendSequence[realBand];
	message.AddVariable(&origsize,sizeof(origsize));
	message.AddVariable(&nullbit,sizeof(nullbit));
	message.AddVariable(&sequence,sizeof(sequence));
	message.AddVariable(&realBand,sizeof(realBand));

	if (len > 0)
	{
		message.AddData(data,len);
	}

	if (mUseChecksum)
	{
		AddChecksumToMessage(&message);
	}

	DoInternalSend(buffer,message.GetSize());

#ifdef DEBUG_PRINTS3
	dprintf("   Really %d bytes long\n",message.GetSize());
#endif

	return kTransport_EOK;
}

Transport::Error TransportUDP::SendReliable(const char *data,const int len,const unsigned int band)
{
	if (mSequence[0] == -1)
	{
#ifdef DEBUG_PRINTS3
		dprintf("TransportUDP: Trying to send from a listen transport\n");
#endif
		mError = kTransport_EERROR;
		return kTransport_EERROR;
	}

//	THREADSAFELOCKCLASSp(gUDPManager);

	if (mError == kTransport_EERROR)
	{
		return kTransport_EERROR;
	}

	if (GetStatus() != kTransport_EOK)
	{
// MPi: TODO: Might be internally used prior to a valid connect. Find and replace these occurrences.
//		return GetStatus();
	}

	CalculateBandwidthOutputPerSecondAndRetireHistoryEntries();

#ifdef DEBUG_PRINTS3
	dprintf("TransportUDP : Send of %d reliable bytes to %d.%d.%d.%d:%d seqid %d\n",len,mReceiveFrom.addr[0],mReceiveFrom.addr[1],mReceiveFrom.addr[2],mReceiveFrom.addr[3],mReceiveFrom.port,mSequence);
#endif


	char buffer[4096];
	MessageHelper message;
	message.SetBuffer(buffer);
	short origsize = len + 7;
	char reliablebit = UDPReliableManager::kReliable;		// The packet type in the reliable manager

	message.AddVariable(&origsize,sizeof(origsize));
	message.AddVariable(&reliablebit,sizeof(reliablebit));
	unsigned int bandSeq = (band << 24) | mSequence[band];
	message.AddVariable(&bandSeq,sizeof(bandSeq));

	if (len > 0)
	{
		message.AddData(data,len);
	}

	if (mUseChecksum)
	{
		AddChecksumToMessage(&message);
	}

	ReliablePacket *relb;
	XPAddress tempa = XPAddress(0,0,0,0,0);
	if (len > 0)
	{
		relb = new ReliablePacket(message.GetSize(),buffer,this,mReceiveFrom,tempa,true);
	}
	else
	{
		relb = new ReliablePacket(message.GetSize(),buffer,this,mReceiveFrom,tempa,false);
	}
	gUDPManager->AddPendingPacket(relb);

	if (len > 0)
	{
		DoInternalSend(buffer,message.GetSize());
	}
	else
	{
		mPacketsSent++;
		mPacketsSentSize+=message.GetSize();
		DoInternalSendCompressionCheck(buffer,message.GetSize(),mReceiveFrom);
		AddHistoryEntry(message.GetSize());
	}

#ifdef DEBUG_PRINTS3
	dprintf("   Really %d bytes long\n",message.GetSize());
#endif

	mSequence[band]++;

	// To avoid the situation where we loop around the sequence numbers we reset it to be 2 (after the build up and initial zero length packet)
	if (mSequence[band] == (1<<24))
	{
		mSequence[band] = 2;
	}

	return kTransport_EOK;
}

Transport::Error TransportUDP::SendCertain(const char *data,const int len)
{
	if (mCertainSequence == -1)
	{
#ifdef DEBUG_PRINTS3
		dprintf("TransportUDP: Trying to send from a listen transport\n");
#endif
		mError = kTransport_EERROR;
		return kTransport_EERROR;
	}

//	THREADSAFELOCKCLASSp(gUDPManager);

	if (mError == kTransport_EERROR)
	{
		return kTransport_EERROR;
	}

	if (GetStatus() != kTransport_EOK)
	{
// MPi: TODO: Might be internally used prior to a valid connect. Find and replace these occurences.
//		return GetStatus();
	}

	CalculateBandwidthOutputPerSecondAndRetireHistoryEntries();

#ifdef DEBUG_PRINTS3
	dprintf("TransportUDP : Send of %d certain bytes to %d.%d.%d.%d:%d seqid %d\n",len,mReceiveFrom.addr[0],mReceiveFrom.addr[1],mReceiveFrom.addr[2],mReceiveFrom.addr[3],mReceiveFrom.port,mSequence);
#endif


	char buffer[4096];
	MessageHelper message;
	message.SetBuffer(buffer);
	short origsize = len + 7;
	char reliablebit = UDPReliableManager::kCertain;		// The packet type in the reliable manager
	message.AddVariable(&origsize,sizeof(origsize));
	message.AddVariable(&reliablebit,sizeof(reliablebit));
	message.AddVariable(&mCertainSequence,sizeof(mCertainSequence));

	if (len > 0)
	{
		message.AddData(data,len);
	}

	if (mUseChecksum)
	{
		AddChecksumToMessage(&message);
	}

	ReliablePacket *relb;
	XPAddress tempa = XPAddress(0,0,0,0,0);
/// GCC Fix
	relb = new ReliablePacket(message.GetSize(),buffer,this,mReceiveFrom,tempa,true);
	gUDPManager->AddPendingCertainPacket(relb);

	DoInternalSend(buffer,message.GetSize());

#ifdef DEBUG_PRINTS3
	dprintf("   Really %d bytes long\n",message.GetSize());
#endif

	mCertainSequence++;

	return kTransport_EOK;
}

int TransportUDP::Recv(char *const data,const int maxlen)
{
//	THREADSAFELOCKCLASSp(gUDPManager);

	if (mError == kTransport_EERROR)
	{
		return 0;
	}

	// Thread safe since it is read only
	if (mWaitingPackets.empty())
	{
		return 0;
	}

	// Exhaust the waiting packets
	THREADSAFELOCKCLASS(gUDPWaitingPackets);
	// Now double check once we have the lock
	if (!mWaitingPackets.empty())
	{
		WaitingPacket *packet = *mWaitingPackets.begin();
		mWaitingPackets.erase(mWaitingPackets.begin());

		if (packet->mLen > 0)
		{
			memcpy(data,packet->mData,packet->mLen);
		}

		int len = packet->mLen;

		delete packet;

		return len;
	}

	return 0;
}

int TransportUDP::GetMaxPacketSize()
{
//	return mPersistantSocket->GetMaxPacketSize();
	return sUDPMaximumBufferedDataSize;
}

void TransportUDP::Poll(void)
{
//	THREADSAFELOCKCLASSp(gUDPManager);
}

Transport::Error TransportUDP::GetStatus(void)
{
	if (mError == kTransport_EOK)
	{
		if (!mFullConnectionDone)
		{
			return kTransport_EWAITING;
		}
	}

	return mError;
}

void TransportUDP::AddWaitingPacket(WaitingPacket *packet)
{
//	THREADSAFELOCKCLASSp(gUDPManager);
//	printf("AddWaitingPacket $%p\n",this);
	THREADSAFELOCKCLASS(gUDPWaitingPackets);
	mWaitingPackets.push_back(packet);
}

void TransportUDP::SortPacketsToKnownTransports(void)
{
	// Thread safe read only tests
	if (mKnownTransportsByAddress.empty())
	{
		return;
	}
	if (mKnownTransportsByAddress.empty())
	{
		return;
	}
//	THREADSAFELOCKCLASSp(gUDPManager);
	THREADSAFELOCKCLASS(gUDPWaitingPackets);
	{
	THREADSAFELOCKCLASS(gUDPKnownTransportsByAddress);

	// Only if the packet was allowed to get data
	assert(mAllowedToGetData && "TransportUDP: Transport that is not allowed to get data being told to sort packets");
	// If this was the result of a Connect() (since this is the only other mAllowedToGetData type)
	// then we have the packet already so skip
	assert(!mOnlyReceiveFrom && "TransportUDP: Transport that is mOnlyReceiveFrom to get data being told to sort packets");

	LIST_ITER_BEGIN(TransportUDP::WaitingPacket *,mWaitingPackets,packet);

	std::map<XPAddress,TransportUDP *>::iterator found = mKnownTransportsByAddress.find(packet->mAddr);

	if (found != mKnownTransportsByAddress.end())
	{
		TransportUDP *trans = (*found).second;
		trans->mWaitingPackets.push_back(packet);
		trans->mPacketsReceived++;
		trans->mPacketsReceivedSize+=packet->mLen+1;
		mPacketsReceived--;
		mPacketsReceivedSize-=packet->mLen+1;
		LIST_ITER_ERASE(mWaitingPackets);
	}

	LIST_ITER_END();
	}
}

TransportUDP *TransportUDP::MatchKnownTransportFromAddress(const XPAddress &recvfrom)
{
//	THREADSAFELOCKCLASSp(gUDPManager);
	// Thread safe read only
	if (mKnownTransportsByAddress.empty())
	{
		return 0;
	}
	THREADSAFELOCKCLASS(gUDPKnownTransportsByAddress);

	std::map<XPAddress,TransportUDP *>::iterator found = mKnownTransportsByAddress.find(recvfrom);

	if (found != mKnownTransportsByAddress.end())
	{
		TransportUDP *trans = (*found).second;
		return trans;
	}
	return 0;
}

bool TransportUDP::MatchNewAddressesToAddress(const XPAddress &recvfrom)
{
//	THREADSAFELOCKCLASSp(gUDPManager);
	// Thread safe read only
	if (mNewAddresses.empty())
	{
		return false;
	}
	NewAddress temp;
	temp.mAddress = recvfrom;
	THREADSAFELOCKCLASS(gUDPNewAddresses);
	if (mNewAddresses.find(temp) != mNewAddresses.end())
	{
		return true;
	}
	return false;
}

bool TransportUDP::AddNewAddresses(const NewAddress &recvfrom)
{
//	THREADSAFELOCKCLASSp(gUDPManager);
	THREADSAFELOCKCLASS(gUDPNewAddresses);

#ifdef DEBUG_PRINTS3
	printf("TransportUDP::AddNewAddresses %s\n",recvfrom.mAddress.Export().c_str());
#endif

	std::pair<std::set<NewAddress,ltNewAddress>::iterator , bool> inserted = mNewAddresses.insert(recvfrom);

	return inserted.second;
}

void TransportUDP::SetBandwidthLimit(const Bandwidth enable)
{
	mConfiguredBandwidth = enable;

	if (mConfiguredBandwidth == kBandwidth_Off)
	{
//		THREADSAFELOCKCLASSp(gUDPManager);
		THREADSAFELOCKCLASS(gUDPHistory);
		mHistoryOutput.clear();
		mHistoryTotal = 0;
	}
	mConfiguredBandwidthGlobal = enable;
}

Transport::Bandwidth TransportUDP::GetBandwidthLimit()
{
	return mConfiguredBandwidth;
}

void TransportUDP::SetMaximumOutputBandwidth(const int bytesPerSecond)
{
	mMaximumOutputBandwidth = bytesPerSecond;
	mMaximumOutputBandwidthGlobal = bytesPerSecond;
}

int TransportUDP::GetMaximumOutputBandwidth(void)
{
	return mMaximumOutputBandwidth;
}

void TransportUDP::SetMaximumInputBandwidth(const int bytesPerSecond)
{
	mMaximumInputBandwidth = bytesPerSecond;
	mMaximumInputBandwidthGlobal = bytesPerSecond;
}

int TransportUDP::GetMaximumInputBandwidth(void)
{
	return mMaximumInputBandwidth;
}

void TransportUDP::CalculateBandwidthOutputPerSecondAndRetireHistoryEntries(void)
{
	if (mConfiguredBandwidth == kBandwidth_Off || !gUDPManager)
	{
		mCurrentBandwidthOutputPerSecond = 0;
		return;
	}

//	THREADSAFELOCKCLASSp(gUDPManager);
	THREADSAFELOCKCLASS(gUDPHistory);

	std::list<History>::iterator st,en;

#ifdef _DEBUG
	int localTotal = 0;
	st = mHistoryOutput.begin();
	en = mHistoryOutput.end();
	while (st != en)
	{
		History entry = *st++;
		localTotal += entry.mSize;
	}
	assert(mHistoryTotal == localTotal && "The Transport history totals do not pass the sanity check");
#endif

	// Nothing in the history automatically means nothing in the output bandwidth
	if (mHistoryOutput.empty())
	{
		mCurrentBandwidthOutputPerSecond = 0.0f;
		return;
	}
	
	// Now retire the history entries if they are older than deltaTime
	float deltaTime = 1.0f;
	st = mHistoryOutput.begin();
	en = mHistoryOutput.end();

	SysTimeType timeThen = gUDPTimer.FloatTime() - deltaTime;

	while (st != en)
	{
		std::list<History>::iterator next = st;
		next++;
		
		History entry = *st;
		if (entry.mTime <= timeThen)
		{
			mHistoryTotal -= entry.mSize;
			mHistoryOutput.erase(st);

			assert(mHistoryTotal >= 0 && "The history total is negative!");
		}
		else
		{
			// We have started finding newer entries so break out of the retire loop
			break;
		}
		st = next;
	}

	// Now the history total is only using the total packet size from the deltaTime period
	mCurrentBandwidthOutputPerSecond = float(mHistoryTotal) / deltaTime;
}

void TransportUDP::AddHistoryEntry(const int size)
{
	if (mConfiguredBandwidth == kBandwidth_Off || !gUDPManager)
	{
		return;
	}

	SysTimeType time = gUDPTimer.FloatTime();
	History entry;
	entry.mTime = time;
	entry.mSize = size + kUDPIPHeaderBytes;

//	THREADSAFELOCKCLASSp(gUDPManager);
	THREADSAFELOCKCLASS(gUDPHistory);

	mHistoryTotal += entry.mSize;
	mHistoryOutput.push_back(entry);
}

std::string TransportUDP::GetPeerURL(void)
{
	XPAddress addr;

	// Not connected either by connect or by an accepted listen transport? Return a null string
	if (!mOnlyReceiveFrom)
	{
		return std::string("");
	}

	// This is now valid
	addr = mReceiveFrom;

	// Assume we are only connected to other transport of our type and build the URL
	return std::string(CanAccept() + addr.Export() + std::string("/"));
}

bool TransportUDP::GetTransportClosed(void)
{
	return mGotDisconnectPacket;
}

void TransportUDP::SetEnableLANDiscovery(const bool enable)
{
	mLANDiscovery = enable;
}

bool TransportUDP::GetEnableLANDiscovery(void)
{
	return mLANDiscovery;
}

void TransportUDP::KickPacketBuffer(const SysTimeType nowTime,const bool force)
{
	SysTimeType theTime = mEarliestBufferTime + UDPReliableManager::mPacketBufferTime;
	if ((nowTime >= theTime || force) && mBufferSize > 0 && mPacketBuffer)
	{
//		THREADSAFELOCKCLASSp(gUDPManager);
		THREADSAFELOCKCLASS(mUDPBuffer);
		// Yes, so send it and clear the buffer
		mPacketsSent++;
		mPacketsSentSize+=mBufferSize;
		DoInternalSendCompressionCheck(mPacketBuffer,mBufferSize,mReceiveFrom);
		AddHistoryEntry(mBufferSize);
		mBufferSize = 0;
	}
}

void TransportUDP::DoInternalSend(const char *buffer,const int size)
{
	assert(mOnlyReceiveFrom);
	// If we have a packet buffer and (there is time for buffer or we are force capturing) then do it
	// We only have a mPacketBuffer is there is no mDisableAllPacketBuffer
	if ((UDPReliableManager::mPacketBufferTime > 0.0f || UDPReliableManager::mPacketBufferCapture) && mPacketBuffer)
	{
//		THREADSAFELOCKCLASSp(gUDPManager);
		THREADSAFELOCKCLASS(mUDPBuffer);
		if (mBufferSize == 0)
		{
			mEarliestBufferTime = gUDPManager->FloatTime();
		}
		// Space in the buffer?
		if ( (mBufferSize + size) <= sUDPMaximumBufferedDataSize)
		{
			memcpy(mPacketBuffer + mBufferSize,buffer,size);
			// Do we add a packet to one already in the buffer?
			if (mBufferSize > 0)
			{
				// Yes, we are merging!!!
				mPacketsSentMerged++;
			}
			mBufferSize += size;
			return;
		}
		
		// Stuff to send in the buffer?
		if (mBufferSize > 0)
		{
			// Yes, so send it and clear the buffer
			mPacketsSent++;
			mPacketsSentSize+=mBufferSize;
			DoInternalSendCompressionCheck(mPacketBuffer,mBufferSize,mReceiveFrom);
			AddHistoryEntry(mBufferSize);
			mBufferSize = 0;
		}

		// Now the buffer is empty
		// Packet small enough for the buffer now?
		if (size <= sUDPMaximumBufferedDataSize)
		{
			// Store in the buffer
			memcpy(mPacketBuffer,buffer,size);
			mBufferSize = size;
			return;
		}
		else
		{
			// Send it now anyway
			mPacketsSent++;
			mPacketsSentSize+=size;
			DoInternalSendCompressionCheck(buffer,size,mReceiveFrom);
			AddHistoryEntry(size);
		}
	}
	else
	{
		mPacketsSent++;
		mPacketsSentSize+=size;
		DoInternalSendCompressionCheck(buffer,size,mReceiveFrom);
		AddHistoryEntry(size);
	}
}

// This function tries to compress a packet that is being sent. It can be called from this class or the UDPReliableManager.
void TransportUDP::DoInternalSendCompressionCheck(const char *data,const int len,const XPAddress &addr)
{
	assert(len <= 0x7fff && "The length MSB must not be set");
	// Since the MSB is used to signal a compressed packet then the MSB must not be set after compression
	// Don't bother trying to compress packets that are too short, there is so worst case trade-off
	if (mPacketBufferCompressed && (len > 24))
	{
		short compLenS;
		MessageHelper::GetVariable(data , &compLenS , sizeof(compLenS));
		assert(compLenS >= 0 && "The internal packet length short MSB must not be set");

		XPCompression comp;
		int compLen;
		THREADSAFELOCKCLASS(mUDPCompBuffer);
		// Also only send the compressed packet if it is shorter, obviously
		if (comp.Compress((void*)data , len , mPacketBufferCompressed + sizeof(short) , &compLen , mCompressionLevel) && (compLen <= 0x7fff) && ((compLen + (int)sizeof(short)) < len))
		{
			// Negative length, i.e. MSB is set, signals a compressed packet
			compLenS = -compLen;
			MessageHelper::AddVariable(mPacketBufferCompressed , &compLenS , sizeof(compLenS));

			compLen += sizeof(short);
			mPersistantSocket->Send(mPacketBufferCompressed , compLen , addr);

			sCompressedBytesSaved += (size_t) (len - compLen);
			return;
		}
	}

	// Default to just sending
	mPersistantSocket->Send(data , len , addr);
}

int TransportUDP::GetPacketsSentMerged(const bool reset)
{
	int ret = mPacketsSentMerged;

	if (reset)
	{
		mPacketsSentMerged = 0;
	}

	return ret;
}

int TransportUDP::GetPacketsReceivedMerged(const bool reset)
{
	int ret = mPacketsReceivedMerged;

	if (reset)
	{
		mPacketsReceivedMerged = 0;
	}

	return ret;
}

void TransportUDP::AddSocketAutoPoll(void)
{
	if (gUDPManager)
	{
		gUDPManager->AddTransportAutoPoll(this);
	}
}

void TransportUDP::RemoveSocketAutoPoll(void)
{
	if (gUDPManager)
	{
		gUDPManager->RemoveTransportAutoPoll(this);
	}
}

void TransportUDP::AddChecksumToMessage(MessageHelper *message)
{
	int largeSum = Checksum::ChecksumData(message->GetBuffer(),message->GetSize());
	unsigned char checksum = (unsigned char) (largeSum ^ (largeSum >> 8) ^ (largeSum >> 16) ^ (largeSum >> 24));
	*message << checksum;

	unsigned char *buffer = (unsigned char *) message->GetBuffer();
	// Update the type to flag it as using a checksum
	buffer[2] |= UDPReliableManager::kUsingChecksum;
}

void TransportUDP::ResetTransportHavingProblems(const int resendMax)
{
	if (mTransportHavingProblems)
	{
		// Limit the amount this gets increased up to the maximum number of retries for the connection.
		if (mProblemResendIndex < mProblemResendIndexUsed)
		{
			// Don't allow rapid increases in mProblemResendIndex, limit to every second
			if ( ( gUDPTimer.FloatTime() - mProblemResendIndexReset ) >= 1.0f )
			{
				mProblemResendIndexReset = gUDPTimer.FloatTime();
				// This makes any pending ACK packets for the connection able to use a longer recovery if the connection starts to receive ACKs again.
				mProblemResendIndex += ( resendMax / 4 ) + 1;
				if ( mProblemResendIndex < 0 )
				{
					mProblemResendIndex = 0;
					mProblemResendIndexUsed = 0;
				}
				else if ( mProblemResendIndex > mProblemResendIndexUsed )
				{
					mProblemResendIndex = mProblemResendIndexUsed;
				}
#ifdef DEBUG_PRINTS3
				dprintf("TransportUDP $%p : mProblemResendIndex %d mProblemResendIndexUsed %d\n",(int)this , mProblemResendIndex , mProblemResendIndexUsed);
#endif
			}
		}
	}
	mTransportHavingProblems = false;
}
//From: RNXPURL/UDPDiscovery.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
//Skipping: #include "RNXPURL/UDPDiscovery.h"
//Skipping: #include "RNPlatform/Inc/ThreadClass.h"
//Skipping: #include "RNPlatform/UtilityIter.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
//Skipping: #include "RNPlatform/Options.h"
//Skipping: #include "RNPlatform/DebugSupport.h"
//Skipping: #include "RNPlatform/Inc/StrDup.h"
#include <assert.h>
#include <string.h>

using namespace RNReplicaNet;

static int kUDPDiscovery_MagicDiscoveryProbe[2] = {static_cast<int>(0xdeadbeaf),static_cast<int>(0xdeadc0de)};
static int kUDPDiscovery_MagicDiscoveryReply[2] = {static_cast<int>(0xdeadd00d),static_cast<int>(0xbeafface)};
static int kUDPDiscovery_MagicDiscoverySocketReply[2] = {static_cast<int>(0xdeadb01d),static_cast<int>(0xb01df00d)};

UDPDiscovery::UDPDiscovery()
{
#ifdef DEBUG_PRINTS3
	dprintf("UDPDiscovery $%p : Construct\n",this);
#endif

	mDiscoveryReply = XPAddress(0,0,0,0,0);
}

UDPDiscovery::~UDPDiscovery()
{
#ifdef DEBUG_PRINTS3
	dprintf("UDPDiscovery $%p : Free\n",this);
#endif
}

static const int kDiscoveryPort = 4445;
static const int kkDiscoveryPortStep = 10;

void UDPDiscovery::BeginDiscovery(void)
{
#ifdef DEBUG_PRINTS3
	dprintf("UDPDiscovery $%p : BeginDiscovery\n",this);
#endif

	char buffer[512];
	MessageHelper message;

	EnsureDiscoverySocketOutboundIsAlive();

	mDiscoveries.clear();
	mUniqueDiscoveries.clear();

	// Setup various broadcast addresses to cope with stacks that don't like some format of broadcasts
	XPAddress other1,other2,other3,other4;
	other1 = XPAddress(0,255,255,255,255);
	mDiscoverySocketOutbound.GetAddress(&other2);
	other2.addr[3] = 255;
	other3 = other2;
	other3.addr[2] = 255;
	other4 = other3;
	other4.addr[1] = 255;

	message.SetBuffer(buffer);
	MESSAGEHELPER_ADDVARIABLEp(message,kUDPDiscovery_MagicDiscoveryProbe[0]);
	MESSAGEHELPER_ADDVARIABLEp(message,kUDPDiscovery_MagicDiscoveryProbe[1]);
	int size = message.GetSize();
	for (int i=0;i<kkDiscoveryPortStep;i++)
	{
		other1.port = kDiscoveryPort + i;
		other2.port = kDiscoveryPort + i;
		other3.port = kDiscoveryPort + i;
		other4.port = kDiscoveryPort + i;
		// Broadcast one packet to each address
		mDiscoverySocketOutbound.Send(buffer,size,other1);
		mDiscoverySocketOutbound.Send(buffer,size,other2);
		mDiscoverySocketOutbound.Send(buffer,size,other3);
		mDiscoverySocketOutbound.Send(buffer,size,other4);
		// Send a packet to ourselves to get around some stacks that have local host routing problems from broadcast
		mDiscoverySocketOutbound.Send(buffer,size,XPAddress(kDiscoveryPort + i,127,0,0,1));
	}
}

std::string UDPDiscovery::HandleDiscovery(void)
{
#ifdef DEBUG_PRINTS3
//	dprintf("UDPDiscovery $%p : HandleDiscovery\n",this);
#endif

	Poll();

	if (!mDiscoverySocketInbound.IsAlive())
	{
		return "";
	}

	if (!mDiscoveryProbes.empty())
	{
		mDiscoveryReply = mDiscoveryProbes.front();
		mDiscoveryProbes.pop_front();
		return std::string(CanAccept() + mDiscoveryReply.Export() + std::string("/"));
	}

	return "";
}

void UDPDiscovery::HandleDiscoveryReply(const std::string reply,XPSocketUrgent *sock)
{
#ifdef DEBUG_PRINTS3
	dprintf("UDPDiscovery $%p : HandleDiscoveryReply\n",this);
#endif

	Poll();
	MessageHelper message;

	if (mDiscoveryReply.port == 0)
	{
		return;
	}

	char buffer2[512];
	message.SetBuffer(buffer2);
	if (sock && sock->IsAlive())
	{
		MESSAGEHELPER_ADDVARIABLEp(message,kUDPDiscovery_MagicDiscoverySocketReply[0]);
		MESSAGEHELPER_ADDVARIABLEp(message,kUDPDiscovery_MagicDiscoverySocketReply[1]);
	}
	else
	{
		MESSAGEHELPER_ADDVARIABLEp(message,kUDPDiscovery_MagicDiscoveryReply[0]);
		MESSAGEHELPER_ADDVARIABLEp(message,kUDPDiscovery_MagicDiscoveryReply[1]);
	}
	std::string copy = reply;
	strcpy(buffer2+8,copy.c_str());
	if (sock && sock->IsAlive())
	{
		sock->Send(buffer2,message.GetSize() + (int)(reply.size()+1),mDiscoveryReply);
	}
	else
	{
		mDiscoverySocketInbound.Send(buffer2,message.GetSize() + (int)(reply.size()+1),mDiscoveryReply);
	}
	mDiscoveryReply.port = 0;
}

std::string UDPDiscovery::GetNextDiscovery(void)
{
#ifdef DEBUG_PRINTS3
	dprintf("UDPDiscovery $%p : GetNextDiscovery\n",this);
#endif

	Poll();

	if (!mDiscoveries.empty())
	{
		std::string nextstr;
		nextstr = mDiscoveries.front();
		mDiscoveries.pop_front();
		return nextstr;
	}
	return std::string("");
}

void UDPDiscovery::Poll(void)
{
	int ret;
	MessageHelper message;
	char buffer[512];
	XPAddress addr;
	ret = 0;

	if (mDiscoverySocketInbound.IsAlive())
	{
		while ( (ret=mDiscoverySocketInbound.Recv(buffer,sizeof(buffer),&addr)) >= 8)
		{
			int test[2];

			message.SetBuffer(buffer);
			MESSAGEHELPER_GETVARIABLEp(message,test[0]);
			MESSAGEHELPER_GETVARIABLEp(message,test[1]);

			// If we get a probe, then add the address to the potential probe list
			if (test[0] == kUDPDiscovery_MagicDiscoveryProbe[0] && test[1] == kUDPDiscovery_MagicDiscoveryProbe[1])
			{
				mDiscoveryProbes.push_back(addr);
			}
		}
	}

	if (mDiscoverySocketOutbound.IsAlive())
	{
		while ( (ret=mDiscoverySocketOutbound.Recv(buffer,sizeof(buffer),&addr)) >= 8)
		{
			int test[2];

			message.SetBuffer(buffer);
			MESSAGEHELPER_GETVARIABLEp(message,test[0]);
			MESSAGEHELPER_GETVARIABLEp(message,test[1]);

			// We have a discovery reply so we add the reply to the queue
			if (test[0] == kUDPDiscovery_MagicDiscoveryReply[0] && test[1] == kUDPDiscovery_MagicDiscoveryReply[1])
			{
				std::string reply = std::string((const char *)message.GetCurrentPosition());
				if (mUniqueDiscoveries.find(reply) == mUniqueDiscoveries.end())
				{
					mDiscoveries.push_back(reply);
					mUniqueDiscoveries.insert(reply);

//					printf("disc reply '%s'\n" , reply.c_str() );
				}
			}
			else if (test[0] == kUDPDiscovery_MagicDiscoverySocketReply[0] && test[1] == kUDPDiscovery_MagicDiscoverySocketReply[1])
			{
				std::string reply = std::string((const char *)message.GetCurrentPosition());
				if (mUniqueDiscoveries.find(reply) == mUniqueDiscoveries.end())
				{
					std::string reply = std::string((const char *)message.GetCurrentPosition());
					std::string realReply = reply;
					size_t pos = reply.find(CanAccept());
					// Look for only our CanAccept() URL and replace it if needed
					if ((pos != std::string::npos) && ((pos == 0) || ((pos > 0) && (reply[pos-1] == '/'))))
					{
						size_t pos2 = reply.find('/',pos);
						if (pos2 != std::string::npos)
						{
							std::string source = CanAccept() + addr.Export() +"/";
							realReply = reply.substr(0,pos) + source + reply.substr(pos2+1);
						}
					}

					mDiscoveries.push_back(realReply);
					mUniqueDiscoveries.insert(reply);

//					printf("disc reply '%s'\n" , reply.c_str() );
//					printf("disc reply2 '%s'\n" , realReply.c_str() );
				}
			}
		}
	}
}

void UDPDiscovery::EnsureDiscoverySocketInboundIsAlive(void)
{
	if (!mDiscoverySocketInbound.IsAlive())
	{
#ifdef DEBUG_PRINTS3
		dprintf("UDPDiscovery $%p : In bound make alive\n",this);
#endif

		int ret;

		for (int i=0;i<kkDiscoveryPortStep;i++)
		{
			ret = mDiscoverySocketInbound.Create(kDiscoveryPort+i);
			if (ret != XPSOCK_EERROR)
			{
				mDiscoverySocketInbound.MakeBroadcast();
				return;
			}
		}

#ifdef DEBUG_PRINTS3
		dprintf("UDPDiscovery $%p : Problems making the in bound socket\n",this);
#endif

		ret = mDiscoverySocketInbound.Create(XPSOCK_PORT_ANY);
		if (ret == XPSOCK_EERROR)
		{
			mDiscoverySocketInbound.Close();
#ifdef DEBUG_PRINTS3
			dprintf("UDPDiscovery $%p : Error making the in bound socket\n",this);
#endif
			return;
		}
		mDiscoverySocketInbound.MakeBroadcast();
	}
}

void UDPDiscovery::EnsureDiscoverySocketOutboundIsAlive(void)
{
	if (!mDiscoverySocketOutbound.IsAlive())
	{
#ifdef DEBUG_PRINTS3
		dprintf("UDPDiscovery $%p : Out bound make alive\n",this);
#endif

		int ret;

		ret = mDiscoverySocketOutbound.Create(XPSOCK_PORT_ANY);
		if (ret == XPSOCK_EERROR)
		{
#ifdef DEBUG_PRINTS3
			dprintf("UDPDiscovery $%p : Error making the out bound socket\n",this);
#endif
			mDiscoverySocketOutbound.Close();
			return;
		}
		mDiscoverySocketOutbound.MakeBroadcast();
	}
}
//From: RNXPURL/UDPReliableManager.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <vector>
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
using namespace RNReplicaNet;
//Skipping: #include "RNXPSockets/Inc/XPSockets.h"
//Skipping: #include "RNXPURL/TransportUDP.h"
//Skipping: #include "RNPlatform/Options.h"
//Skipping: #include "RNPlatform/Inc/Thread.h"
//Skipping: #include "RNPlatform/Inc/ThreadClass.h"
//Skipping: #include "RNPlatform/Inc/RegistryManager.h"
//Skipping: #include "RNPlatform/Inc/SysTime.h"
//Skipping: #include "RNPlatform/DebugSupport.h"
//Skipping: #include "RNPlatform/Inc/PlatformInfo.h"
//Skipping: #include "RNXPURL/UDPReliableManager.h"
//Skipping: #include "RNXPURL/Inc/NetworkEmulation.h"
//Skipping: #include "RNXPURL/Inc/TransportConfig.h"
//Skipping: #include "RNPlatform/Inc/StrDup.h"
//Skipping: #include "RNPlatform/Inc/CheckSum.h"
//Skipping: #include "RNXPCompression/Inc/XPCompression.h"

//static fd_set socks;		/* Socket file descriptors we want to wake up for */

//static fd_set realsocks;		/* Socket file descriptors we want to wake up for */

// Only used for setting or deleting gUDPManager.
MutexClass RNReplicaNet::gUDPManagerMutex;
UDPReliableManager *RNReplicaNet::gUDPManager = 0;

// Only used during TransportConfig::SetInfoString and TransportConfig::GetInfoString
static MutexClass sInfoString;


static MutexClass gManagerTransportLists;
static MutexClass gManagerTransportListsBuffered;
static MutexClass gManagerListPendingACK;
static MutexClass gManagerListPendingCertainACK;

UDPReliableManagerPacketReceiveHook *RNReplicaNet::gUDPReliableManagerPacketReceiveHook = 0;	// Protected by gManagerTransportLists

void UDPReliableManagerPacketReceiveHook::SetUDPReliableManagerPacketReceiveHook(UDPReliableManagerPacketReceiveHook *hook)
{
	THREADSAFELOCKCLASS(gManagerTransportLists);
	gUDPReliableManagerPacketReceiveHook = hook;
}

bool RNReplicaNet::ltDuplicateCertainIDs::operator()(const DuplicateCertainIDs *a,const DuplicateCertainIDs *b) const
{
	// Order by ID first since it is less expensive
	if  (a->mID < b->mID)
	{
		return true;
	}
	else if (a->mID == b->mID)
	{
		return (a->mAddress < b->mAddress);
	}
	return false;
}


float UDPReliableManager::mPacketBufferTime = 0.01f;
bool UDPReliableManager::mPacketBufferCapture = false;
bool UDPReliableManager::mPacketBufferKickScheduled = false;
bool UDPReliableManager::mDisableAllPacketBuffer = false;
char *UDPReliableManager::mInfoString = 0;
bool UDPReliableManager::mEnableExtraPacketSecurity = true;
bool UDPReliableManager::mEnablePacketSelect = false;

// In seconds (NOT milliseconds)
//static float sResendTimes[] = {0.3f , 0.5f , 1.1f , 2.3f , 4.7f , 10.6f};
// Better resend times are here!
// Short list to let me test disconnects quickly ;)
//static float sResendTimes[] = {1.0f , 2.0f , 3.0f};

// The maximum time a packet will be alive for before reporting an error, usually the sum of the resend times plus 5 seconds.
static float sMaximumTime = 36.0f;
// The actual resend times
static const int kMaxResendTimes = 60;
static float sResendTimes[kMaxResendTimes] = {	0.5f , 0.5f , 1.0f , 2.0f , 2.0f , 2.0f , 3.0f , 4.0f , 4.0f , 4.0f ,
									4.0f , 1.0f , 1.0f , 1.0f , 1.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f ,
									0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f ,
									0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f ,
									0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f ,
									0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f
									};
// The number of resend times
static int sResendMax = 15;
// Usually sMaximumTime * 3
static float sLastGaspDataBaseTimeout = 108.0f;
// After sNoBufferAfterRetries number of retries the packets are not going to use buffering in an attempt to get through.
// Usually sResendMax / 2
static int sNoBufferAfterRetries = 7;

namespace RNReplicaNet
{
void XPURLInternalPollFromUDPReliableManagerPoll(void);
}

void TransportConfig::SetResendTimes(const int numberOfTimes,const float *retryTimes)
{
	if (numberOfTimes < 0 || numberOfTimes > kMaxResendTimes || retryTimes == 0)
	{
		return;
	}
	sMaximumTime = 0;
	sResendMax = numberOfTimes;
	int i;
	for (i=0;i<numberOfTimes;i++)
	{
		sResendTimes[i] = retryTimes[i];
		sMaximumTime += retryTimes[i];
	}
	sMaximumTime += 5;
	sLastGaspDataBaseTimeout = sMaximumTime * 3;
	sNoBufferAfterRetries = numberOfTimes / 2;
}

void TransportConfig::GetResendTimes(int *numberOfTimes,float *retryTimes)
{
	if (numberOfTimes)
	{
		*numberOfTimes = sResendMax;
	}
	if (retryTimes)
	{
		int i;
		for (i=0;i<sResendMax;i++)
		{
			retryTimes[i] = sResendTimes[i];
		}		
	}
}

void TransportConfig::SetPacketBufferTime(const float maxTime)
{
	UDPReliableManager::mPacketBufferTime = maxTime;
}

float TransportConfig::GetPacketBufferTime(void)
{
	return UDPReliableManager::mPacketBufferTime;
}

void TransportConfig::PacketBufferBeginCaptureWindow(void)
{
	UDPReliableManager::mPacketBufferCapture = true;
}

void TransportConfig::PacketBufferEndCaptureWindow(const bool kickBuffer)
{
	UDPReliableManager::mPacketBufferCapture = false;
	if (kickBuffer)
	{
		gUDPManagerMutex.Lock();
		if (gUDPManager)
		{
			gUDPManager->PerformKickTransports(true);
		}
		gUDPManagerMutex.UnLock();
	}
	else
	{
		UDPReliableManager::mPacketBufferKickScheduled = true;
	}
}

void TransportConfig::SetPacketBufferEnable(const bool enable)
{
	UDPReliableManager::mDisableAllPacketBuffer = !enable;
}

bool TransportConfig::GetPacketBufferEnable(void)
{
	return !UDPReliableManager::mDisableAllPacketBuffer;
}

void TransportConfig::SetInfoString(const std::string info)
{
	THREADSAFELOCKCLASS(sInfoString);
	free(UDPReliableManager::mInfoString);
	UDPReliableManager::mInfoString = 0;
	// Make sure the string is no longer than 512 bytes
	std::string toSet = info.substr(0,512);
	if (!toSet.empty())
	{
		UDPReliableManager::mInfoString = RNReplicaNet::StrDup(toSet.c_str());
	}
}

std::string TransportConfig::GetInfoString(void)
{
	// First read only without a lock
	if (UDPReliableManager::mInfoString)
	{
		// Now do a lock and really get the info string
		THREADSAFELOCKCLASS(sInfoString);
		if (UDPReliableManager::mInfoString)
		{
			return std::string(UDPReliableManager::mInfoString);
		}
	}
	return std::string("");
}

void TransportConfig::SetExtraPacketSecurity(const bool enable)
{
	UDPReliableManager::mEnableExtraPacketSecurity = enable;
}

bool TransportConfig::GetExtraPacketSecurity(void)
{
	return UDPReliableManager::mEnableExtraPacketSecurity;
}

static bool sIPv4Detection = true;
void TransportConfig::SetIPv4Detection(const bool enable)
{
	sIPv4Detection = enable;
}

bool TransportConfig::GetIPv4Detection(void)
{
	return sIPv4Detection;
}

static bool sIPv6Detection = false;
void TransportConfig::SetIPv6Detection(const bool enable)
{
	sIPv6Detection = enable;
}

bool TransportConfig::GetIPv6Detection(void)
{
	return sIPv6Detection;
}

static bool sIPv4Detected = true;
void TransportConfig::SetIPv4Detected(const bool enable)
{
	sIPv4Detected = enable;
}

bool TransportConfig::GetIPv4Detected(void)
{
	return sIPv4Detected;
}

static bool sIPv6Detected = false;
void TransportConfig::SetIPv6Detected(const bool enable)
{
	sIPv6Detected = enable;
}

bool TransportConfig::GetIPv6Detected(void)
{
	return sIPv6Detected;
}

void TransportConfig::SetEnablePacketSelect(const bool enable)
{
	UDPReliableManager::mEnablePacketSelect = enable;
}

bool TransportConfig::GetEnablePacketSelect(void)
{
	return UDPReliableManager::mEnablePacketSelect;
}




UDPReliableManager::UDPReliableManager()
{
#ifdef DEBUG_PRINTS3
	dprintf("UDPReliableManager() construct\n");
#endif

	mManualPoll = false;

//	FD_ZERO(&socks);

#ifdef _DEBUG
	mNumCertIDsInDatabase = 0;
#endif
	SetPreferredProcessor(PlatformInfo::GetProcessorXPURL());

	Begin(this);
}

UDPReliableManager::~UDPReliableManager()
{
	// Stop the thread
	Terminate();

	// Before the class lock, of course since it also locks on a different mutex inside the below function.
	TransportConfig::SetInfoString();

	THREADSAFELOCK();

	TransportUDP *transport;
//	RegistryManagerList<TransportUDP> mTransportsAllowedToGetData;
	{
		THREADSAFELOCKCLASS(gManagerTransportLists);
		mTransportsAllowedToGetData.BeginIterate();
		while ( (transport = mTransportsAllowedToGetData.Iterate()) != 0)
		{
			// This causes a remove from this list, so start iterating again...
			delete transport;
			mTransportsAllowedToGetData.BeginIterate();
		}
	}

//	RegistryManagerList<TransportUDP> mTransportsAllowedToGetDataNotOnlyReceiveFrom;
	{
		THREADSAFELOCKCLASS(gManagerTransportLists);
		mTransportsAllowedToGetDataNotOnlyReceiveFrom.BeginIterate();
		while ( (transport = mTransportsAllowedToGetDataNotOnlyReceiveFrom.Iterate()) != 0)
		{
			// This causes a remove from this list, so start iterating again...
			delete transport;
			mTransportsAllowedToGetDataNotOnlyReceiveFrom.BeginIterate();
		}
	}

	{
		THREADSAFELOCKCLASS(gManagerTransportListsBuffered);
		mTransportsBuffered.BeginIterate();
		while ( (transport = mTransportsBuffered.Iterate()) != 0)
		{
			// This causes a remove from this list, so start iterating again...
			delete transport;
			mTransportsBuffered.BeginIterate();
		}
	}

// Now tidy the packet lists
	ReliablePacket *packet;
//	RegistryManagerList<ReliablePacket> mPendingCertainACK;
	{
	THREADSAFELOCKCLASS(gManagerListPendingCertainACK);
	mPendingCertainACK.BeginIterate();
	while ( (packet = mPendingCertainACK.Iterate()) != 0 )
	{
		mPendingCertainACK.RemoveItem();
		delete packet;
	}
	}

//	RegistryManagerList<ReliablePacket> mPendingACK;
	{
	THREADSAFELOCKCLASS(gManagerListPendingACK);
	mPendingACK.BeginIterate();
	while ( (packet = mPendingACK.Iterate()) != 0 )
	{
		mPendingACK.RemoveItem();
		delete packet;
	}
	}


//	RegistryManagerList<ReliablePacket> mACKedPackets;
	mACKedPackets.BeginIterate();
	while ( (packet = mACKedPackets.Iterate()) != 0 )
	{
		mACKedPackets.RemoveItem();
		delete packet;
	}

//	std::set<DuplicateCertainIDs*,ltDuplicateCertainIDs> mCertainIDs;
	std::set<DuplicateCertainIDs*,ltDuplicateCertainIDs>::iterator st = mCertainIDs.begin();
	while (st != mCertainIDs.end())
	{
		DuplicateCertainIDs *dupes = *st++;
		assert(dupes);
		delete dupes;
#ifdef _DEBUG
		mNumCertIDsInDatabase--;
#endif
	}
#ifdef _DEBUG
	assert(mNumCertIDsInDatabase == 0);
#endif


//	std::map<XPAddress,PendingBuildUpReply *> mPendingBuildUpReply;
	std::map<XPAddress,PendingBuildUpReply *>::iterator st2 = mPendingBuildUpReply.begin();
	while ( st2 != mPendingBuildUpReply.end() )
	{
		PendingBuildUpReply *checkAddresses = (*(st2++)).second;
		assert(checkAddresses);
		delete checkAddresses;
	}
}

int UDPReliableManager::ThreadEntry(void)
{
	while(true)
	{
		if (!mManualPoll)
		{
			// Do the poll, we are automatic
			Poll();
		}
		else
		{
			// Sleep for a bit longer, we are on manual but might change back to automatic later on
			Sleep(100);
		}

		Sleep(0);	// For the thread context switch and also the cancel point. We also don't want to be very busy in this thread if we are packet flooded.

		if (mEnablePacketSelect)
		{
#define MAX_WAITING_SOCKETS 32
			// Don't bother building a select list if it will be more than what the stack supports
			if ((MAX_WAITING_SOCKETS < XPSock_GetSocketSelectMaxSize()) && (!mTransportsAllowedToGetData.IsEmpty()) && (mTransportsAllowedToGetData.GetNumItems() < MAX_WAITING_SOCKETS))
			{
				Sleep(5);	// We also don't want to be very busy in this thread if we are packet flooded.
				t_XPSocket *sockets[MAX_WAITING_SOCKETS];
				int numWaiting = 0;
				// If this machine is not managing many connection then build a list and select them, saves processing time.
				THREADSAFELOCKCLASS(gManagerTransportLists);
				mTransportsAllowedToGetData.BeginIterate();
				TransportUDP *transport;
				// Now distribute the unreliable received packets among the known transports etc
				// This includes certain packets as these are able to be put in the unreliable waiting packets list
				while ( (numWaiting < MAX_WAITING_SOCKETS) && ( (transport = mTransportsAllowedToGetData.Iterate()) != 0) )
				{
					XPSocketUrgent *socket = transport->GetPersistantSocket();
					if (socket)
					{
						sockets[numWaiting] = socket->GetSocketPointer();
						if (sockets[numWaiting])
						{
							numWaiting++;
						}
					}
				}

				int ret = XPSock_SocketSelect(sockets,numWaiting,50);
			}
			else
			{
				// Assume it will always be busy receiving something, use a sleep then just process.
				Sleep(10);
			}
		}
		else
		{
			Sleep(10);
		}
	};
	return 0;
}

void UDPReliableManager::AddTransport(TransportUDP *transport)
{
	THREADSAFELOCK();

	if (transport->mAllowedToGetData)
	{
		assert(transport->mPersistantSocket);
		THREADSAFELOCKCLASS(gManagerTransportLists);
		if (!transport->mOnlyReceiveFrom)
		{
			mTransportsAllowedToGetDataNotOnlyReceiveFrom.AddItem(transport);
		}
//		dprintf("AddTransport $%p\n",transport);
		mTransportsAllowedToGetData.AddItem(transport);
	}

	if (/*mPacketBufferTime > 0.0f && */transport->mOnlyReceiveFrom && !mDisableAllPacketBuffer)
	{
		THREADSAFELOCKCLASS(gManagerTransportListsBuffered);
		mTransportsBuffered.AddItem(transport);
	}

//	mTransports.AddItem(transport);
}

void UDPReliableManager::RemoveTransport(TransportUDP *transport)
{
	THREADSAFELOCK();

	ReliablePacket *packet;

	{
	THREADSAFELOCKCLASS(gManagerListPendingACK);
	mPendingACK.BeginIterate();
	while ( (packet = mPendingACK.Iterate()) != 0 )
	{
		if (packet->mTransport == transport)
		{
			mPendingACK.RemoveItem();
			delete packet;
			continue;
		}
	}
	}

	mACKedPackets.BeginIterate();
	while ( (packet = mACKedPackets.Iterate()) != 0 )
	{
		if (packet->mTransport == transport)
		{
			mACKedPackets.RemoveItem();
			delete packet;
			continue;
		}
	}

	{
	THREADSAFELOCKCLASS(gManagerListPendingCertainACK);
	mPendingCertainACK.BeginIterate();
	while ( (packet = mPendingCertainACK.Iterate()) != 0 )
	{
		if (packet->mTransport == transport)
		{
			mPendingCertainACK.RemoveItem();
			delete packet;
			continue;
		}
	}
	}

	if (transport->mAllowedToGetData)
	{
		THREADSAFELOCKCLASS(gManagerTransportLists);
		if (!transport->mOnlyReceiveFrom)
		{
			mTransportsAllowedToGetDataNotOnlyReceiveFrom.RemoveItem(transport);
		}
		mTransportsAllowedToGetData.RemoveItem(transport);
	}

	if (/*mPacketBufferTime > 0.0f && */transport->mOnlyReceiveFrom && !mDisableAllPacketBuffer)
	{
		THREADSAFELOCKCLASS(gManagerTransportListsBuffered);
		mTransportsBuffered.RemoveItem(transport);
	}
}

void UDPReliableManager::AddTransportAutoPoll(TransportUDP *transport)
{
	THREADSAFELOCK();
	assert(transport->GetPersistantSocket());
	assert(transport->GetPersistantSocket()->GetSocketPointer());
	mAutomaticPollSetBySocket.insert(transport->GetPersistantSocket()->GetSocketPointer());
}

void UDPReliableManager::RemoveTransportAutoPoll(TransportUDP *transport)
{
	THREADSAFELOCK();
	if (transport->GetPersistantSocket())
	{
		assert(transport->GetPersistantSocket()->GetSocketPointer());
		mAutomaticPollSetBySocket.erase(transport->GetPersistantSocket()->GetSocketPointer());
	}
}

void UDPReliableManager::Poll(void)
{
	XPURLInternalPollFromUDPReliableManagerPoll();

	// Once at the start because this doesn't need to read it for every single packet received this poll
	std::string infoString = TransportConfig::GetInfoString();
	if (!infoString.empty())
	{
		infoString = "\xff\xff\xff\xffinfo" + infoString;
	}

	THREADSAFELOCK();

	gXPSock_PacketLossEmulationPercent = NetworkEmulation::GetPacketLoss();
	gXPSock_PacketLossEmulation = NetworkEmulation::GetEnabled();

	gXPSock_PacketLatencyEmulationBase = NetworkEmulation::GetAverageLatency();
	gXPSock_PacketLatencyEmulationJitter = NetworkEmulation::GetJitter();
	gXPSock_PacketLatencyEmulation = NetworkEmulation::GetEnabled();

	if (NetworkEmulation::GetEnabled())
	{
		XPSock_Poll();
	}
	XPSock_UpdatePerSecondMetrics();
	
	SysTimeType ttime = FloatTime();

	TransportUDP *transport;

	if (mPacketBufferTime > 0.0f || mPacketBufferKickScheduled)
	{
		PerformKickTransports(false);
	}

	ttime = FloatTime();
	{
	THREADSAFELOCKCLASS(gManagerTransportLists);

	if (gUDPReliableManagerPacketReceiveHook && !mAutomaticPollSetBySocket.empty())
	{
		RNReplicaNet::DynamicMessageHelper message( RNReplicaNet::TransportConfig::GetPacketMTU() );

		std::set<t_XPSocket *>::iterator st = mAutomaticPollSetBySocket.begin();
		while (st != mAutomaticPollSetBySocket.end())
		{
			t_XPSocket *socket = *st++;

			int times = 10;
			int ret;
			do
			{
				RNReplicaNet::XPAddress addr;
				ret = XPSock_UrgentRecv(socket,(char *) message.GetBuffer(),message.GetBufferSize(),XPSOCK_FNULL,&addr);
				if (ret > 0)
				{
					gUDPReliableManagerPacketReceiveHook->CallbackParsePacketData(socket,addr,message.GetBuffer(),ret);
				}
				if (ret == XPSOCK_EERROR)
				{
					// Expire errors and count them as packets with data
					int real = asocket_lasterror;
					ret = 1;
				}
			} while ( (times-- > 0) && (ret > 0) );

		}
	}

	mTransportsAllowedToGetData.BeginIterate();
#ifdef DEBUG_PRINTS3
	static int loopCounter = 0;
	loopCounter++;
	dprintf("UDPReliableManager : Processing mTransportsAllowedToGetData loopCounter = %d\n",loopCounter);
#endif
	while ( (transport = mTransportsAllowedToGetData.Iterate()) != 0)
	{
		char bufferrealStack[8192];
		char bufferrealCompStack[8192];
		char *bufferreal = bufferrealStack;

#ifdef DEBUG_PRINTS3
		dprintf("TransportUDP : Processing transport $%p\n",transport);
#endif

//#define MAXACKS (16)
//		int acksfortrans[MAXACKS];
//		int ackstotal = 0;

		// We only let the primary listen transport receive data through the socket
		assert(transport->mAllowedToGetData && "UDPReliableManager: Transport that is not allowed to get data in the wrong list");

		XPAddress recvfrom;
		int retreal;
#ifdef _DEBUG
		if (!transport->mPersistantSocket)
		{
			dprintf("Transport $%p dodgy\n",transport);
		}
#endif
		assert(transport->mPersistantSocket);
		while ( (retreal = transport->mPersistantSocket->Recv(bufferrealStack,sizeof(bufferrealStack),&recvfrom)) > 0)
		{
			bufferreal = bufferrealStack;

#ifdef DEBUG_PRINTS3
			dprintf("TransportUDP : Got packet of size %d from %s\n",retreal,recvfrom.Export().c_str());
			dprintf("TransportUDP : %s\n",MessageHelper::DumpAsHex(bufferreal,retreal).c_str());
#endif

			if (retreal < 3)
			{
#ifdef DEBUG_PRINTS3
				dprintf("TransportUDP : Ignoring packet as size is less than 3\n");
#endif
				continue;
			}

			// Check for an info string and receiving the "getinfo" packet
			// The "getinfo" packet is eleven bytes.
			if (retreal >= 11)
			{
				if (!infoString.empty())
				{
					if (!memcmp(bufferreal,"\xff\xff\xff\xffgetinfo",11))
					{
						transport->mPersistantSocket->Send(infoString.c_str(),recvfrom);
						continue;
					}
				}
			}

			// We have a packet processing hook installed, so use it.
			if (gUDPReliableManagerPacketReceiveHook)
			{
				// Call the hook, if it returns true then continue since it is not a packet we are interested in.
				if (gUDPReliableManagerPacketReceiveHook->CallbackParsePacketData(transport->mPersistantSocket->GetSocketPointer(),recvfrom,bufferreal,(size_t) retreal))
				{
#ifdef DEBUG_PRINTS3
					dprintf("TransportUDP : CallbackParsePacketData was NAT data\n");
#endif
					continue;
				}
			}

			if ( transport && transport->mOnlyReceiveFrom )
			{
				if ( transport->mReceiveFrom != recvfrom )
				{
#ifdef DEBUG_PRINTS3
					dprintf("TransportUDP : Discard packet type %d from %s (size %d) transport mOnlyReceiveFrom mReceiveFrom not matched\n",buffer[2],recvfrom.Export().c_str(),ret);
#endif
					continue;
				}
			}
			
			// Check for compressed data
			short compCheck;
			MessageHelper::GetVariable(bufferreal , &compCheck , sizeof(compCheck));
			// It's negated, for the compressed signal
			if (compCheck < 0)
			{
				compCheck = -compCheck;
				// It's compressed, so decompress
				XPCompression comp;
				int destLen;
				if (comp.Decompress(bufferreal + sizeof(short), compCheck , bufferrealCompStack , &destLen , sizeof(bufferrealCompStack)) && (destLen > 0))
				{
					retreal = destLen;
					bufferreal = bufferrealCompStack;
				}
				else
				{
#ifdef DEBUG_PRINTS3
					dprintf("TransportUDP : XPCompression::Decompress ERROR\n");
#endif
					continue;
				}
			}

			unsigned int offset = 0;

			bool datatoprocess = true;
			int numPackets = 0;		// The number of real packets dealt with so far this iteration

			while (datatoprocess)
			{
				int ret = retreal;
				char *buffer = bufferreal + offset;
				char *data = buffer;

#ifdef DEBUG_PRINTS3
				dprintf("TransportUDP : datatoprocess ret = %d offset = %d\n",ret,offset);
#endif

				MessageHelper message;
				message.SetBuffer(buffer);
				unsigned short origsize;
				message.GetVariable(&origsize,sizeof(origsize));
				// Stupid packet length check
				if (origsize > ret)
				{
					break;
				}

				unsigned short tweakedSize = origsize;

				// Adjust the size for the next check if the packet is using a checksum
				bool isUsingChecksum = false;
				if (buffer[2] & UDPReliableManager::kUsingChecksum)
				{
					tweakedSize++;
					// Update the message so it strips the checksum flag
					buffer[2] &= ~UDPReliableManager::kUsingChecksum;
					isUsingChecksum = true;
				}

				// Remembering to take into account the one byte checksum that is not included in the packet size
				if (tweakedSize > ret)
				{
#ifdef DEBUG_PRINTS3
					dprintf("TransportUDP : Ignoring packet as size (%d) is smaller recorded size (%d)\n   First 7 bytes are %d,%d,%d,%d,%d,%d,%d\n",ret,origsize,
						buffer[0],
						buffer[1],
						buffer[2],
						buffer[3],
						buffer[4],
						buffer[5],
						buffer[6]
						);
#endif
					datatoprocess = false;
					continue;
				}

				ret = origsize;

				if (isUsingChecksum)
				{
					// Check the checksum of the fragment received
					int largeSum = Checksum::ChecksumData(buffer,origsize);
					unsigned char calculatedChecksum = (unsigned char) (largeSum ^ (largeSum >> 8) ^ (largeSum >> 16) ^ (largeSum >> 24));

					unsigned char checksum = ((unsigned char *)buffer)[origsize];
					if (calculatedChecksum != checksum)
					{
#ifdef DEBUG_PRINTS3
						dprintf("+++WARNING : Packet fragment from network failed the checksum check\n");
#endif
						datatoprocess = false;
						continue;
					}
				}

				// Calculate what the next packet might be before we do the larger processing code for the current packet data
				retreal -= origsize;
				offset += origsize;

				// Adjust for the checksum data which isn't included in the original size
				if (isUsingChecksum)
				{
					offset++;
					retreal--;
				}


				if (retreal < 3)
				{
					datatoprocess = false;
				}
				if (origsize <= 0)
				{
					datatoprocess = false;
				}
				if (retreal >= 3)
				{
#ifdef DEBUG_PRINTS3
					dprintf("+++WARNING : Packet from network potentially had more than one transport packet\n");
#endif
				}

				if ((buffer[2] == UDPReliableManager::kUnreliable) && (ret >= 3))
				{
					numPackets++;
#ifdef DEBUG_PRINTS3
					dprintf("TransportUDP : Got unreliable packet %s (size %d)\n",recvfrom.Export().c_str(),ret);
#endif
					// Non-reliable packet so push it on to the stack
					TransportUDP::WaitingPacket *packet;

					transport->mPacketsReceived++;
					transport->mPacketsReceivedSize+=ret;

					data+=2;
					ret-=2;
					
					data++;
					ret--;
					if ( ret > 0 )
					{
						packet = new TransportUDP::WaitingPacket(data,ret,recvfrom);
						transport->AddWaitingPacket(packet);
					}
					if (numPackets > 1)
					{
						transport->mPacketsReceivedMerged++;
					}
				}
				else if ((buffer[2] == UDPReliableManager::kOrdered) && (ret >= 6))
				{
					numPackets++;
#ifdef DEBUG_PRINTS3
					dprintf("TransportUDP : Got unreliable ordered packet %s (size %d)\n",recvfrom.Export().c_str(),ret);
#endif
					// Non-reliable packet so push it on to the stack
					TransportUDP::WaitingPacket *packet;

					transport->mPacketsReceived++;
					transport->mPacketsReceivedSize+=ret;

					data+=2;
					ret-=2;

					data++;
					ret--;

					TransportUDP *trans2 = 0;
					if (transport->mOnlyReceiveFrom)
					{
						// If this assert triggers then the other machine has multi-homed connections that are incorrectly configured or someone is sending spoofed packets.
						// Or there is a bug in this code. In any of these cases in debug mode we want to know about it.
						assert(transport->mReceiveFrom == recvfrom);
						// In release mode we ignore spoofed packets.
						if (transport->mReceiveFrom == recvfrom)
						{
							trans2 = transport;
						}
					}
					else
					{
						trans2 = transport->MatchKnownTransportFromAddress(recvfrom);
						if (trans2)
						{
							assert(trans2->mOnlyReceiveFrom);
							assert(trans2->mReceiveFrom == recvfrom);
						}
					}
					// Get the sequence
					MessageHelper message;
					message.SetBuffer(data);
					data+=2;
					ret-=2;
					unsigned short sequence;
					message >> sequence;
					// Get the band
					data++;
					ret--;
					unsigned char band;
					message >> band;

#ifdef DEBUG_PRINTS3
					dprintf("TransportUDP : Unreliable ordered packet seq %d band %d\n",sequence,band);
#endif

					if (trans2)
					{
#ifdef DEBUG_PRINTS3
						dprintf("TransportUDP : Unreliable ordered packet matched transport $%p\n",trans2);
#endif
						// Wrap around sequence tests
						if (
							// First the in sequence check discarding really old packet sequences
							( (sequence > trans2->mOrderedRecvSequence[band]) && ((sequence - trans2->mOrderedRecvSequence[band]) < 32768) ) ||
							// Next if there has been a wrap around then the sequence will be less but the gap will be really large
							( (sequence < trans2->mOrderedRecvSequence[band]) && ((trans2->mOrderedRecvSequence[band] - sequence) >= 32768) )
							)
						{
							// Either way we add the packet to the correct transport
							trans2->mOrderedRecvSequence[band] = sequence;
							if ( ret > 0 )
							{
								packet = new TransportUDP::WaitingPacket(data,ret,recvfrom);
								trans2->AddWaitingPacket(packet);
							}
						}
						else
						{
							// Debug assignment
							sequence = sequence;
#ifdef DEBUG_PRINTS3
							dprintf("TransportUDP : Unreliable ordered packet out of order, dropped\n");
#endif
						}
					}

					if (numPackets > 1)
					{
						transport->mPacketsReceivedMerged++;
					}
				}
				else if (((buffer[2] == UDPReliableManager::kReliable) || (buffer[2] == UDPReliableManager::kBuildUp)) && (ret >= 7))
				{
					numPackets++;

					// Reliable packet so store it and send an ACK
					XPAddress tempa = XPAddress(0,0,0,0,0);
					ReliablePacket *relb = new ReliablePacket(ret,buffer,transport,tempa,recvfrom,false);
					int thisSeq = relb->mSequence;
					int thisBand =  relb->mBand;

#ifdef DEBUG_PRINTS3
					dprintf("TransportUDP : Got reliable packet type %d for seqid %d from %s (size %d)\n",buffer[2],thisSeq,recvfrom.Export().c_str(),ret);
#endif

					if ((buffer[2] == UDPReliableManager::kBuildUp) && (relb->mBand == 0))
					{
#ifdef DEBUG_PRINTS3
						dprintf("TransportUDP : This packet is a build up packet\n");
#endif
						// First, check with the local transport because it's quicker
						bool found = transport->MatchNewAddressesToAddress(recvfrom);
						if ( found )
						{
#ifdef DEBUG_PRINTS3
							dprintf("TransportUDP :	 With a dupe in the transport pending new address list\n");
#endif
						}
						else // !found
						{
							// Check the global list next, potentially slower.
							std::map<XPAddress,PendingBuildUpReply *>::iterator foundIter = mPendingBuildUpReply.find(recvfrom);

							if (foundIter != mPendingBuildUpReply.end())
							{
								found = true;
#ifdef DEBUG_PRINTS3
								dprintf("TransportUDP :	 With a dupe in the pending list\n");
#endif
							}
						}
						if ( !found )
						{
							// If it's still not found then check it's not already connected.
							if (!transport->mOnlyReceiveFrom)
							{
								TransportUDP *trans2 = transport->MatchKnownTransportFromAddress(recvfrom);
								if (trans2)
								{
#ifdef DEBUG_PRINTS3
									dprintf("TransportUDP :	 With a dupe in the transport known list\n");
#endif
									found = true;
								}
							}
						}

						if (!found)
						{
#ifdef DEBUG_PRINTS3
							dprintf("TransportUDP :	 mPendingBuildUpReply added\n");
#endif
							PendingBuildUpReply *newAddress = new PendingBuildUpReply;
							assert(newAddress);
							newAddress[0].mTime = ttime;
							newAddress[0].mUseChecksum = isUsingChecksum;
							char tempc;
							message.GetVariable(&tempc,sizeof(tempc));
							assert(tempc == UDPReliableManager::kBuildUp);
							int tempi;
							message.GetVariable(&tempi,sizeof(tempi));
							assert(tempi == 0);
							message.GetVariable(&newAddress[0].mConfiguredBandwidth,sizeof(newAddress[0].mConfiguredBandwidth));
							message.GetVariable(&newAddress[0].mMaximumOutputBandwidth,sizeof(newAddress[0].mMaximumOutputBandwidth));
							message.GetVariable(&newAddress[0].mMaximumInputBandwidth,sizeof(newAddress[0].mMaximumInputBandwidth));
							std::pair<std::map<XPAddress,PendingBuildUpReply *>::iterator,bool> result = mPendingBuildUpReply.insert(std::pair<XPAddress,PendingBuildUpReply *>(recvfrom,newAddress));
							assert(result.second);
							newAddress->mMapIter = result.first;
							mPendingBuildUpReplyList.push_back(newAddress);
							newAddress->mListIter = --mPendingBuildUpReplyList.end();
						}
						delete relb;
					}
					else
					{
#ifdef DEBUG_PRINTS3
						dprintf("TransportUDP : Added reliable packet to mACKedPackets\n");
#endif
						mACKedPackets.AddItem(relb);
					}

					bool sendACK = true;

#ifdef DEBUG_PRINTS3
					dprintf("TransportUDP : Sending ACK for seqid %d to %s\n",thisSeq,recvfrom.Export().c_str());
#endif
					char buffer[8];
					MessageHelper message;
					message.SetBuffer(buffer);
					char reply = UDPReliableManager::kReliableACK;
					int seq = thisSeq | (thisBand << 24);
					short size = 7;

					message.AddVariable(&size,sizeof(size));
					message.AddVariable(&reply,sizeof(reply));
					message.AddVariable(&seq,sizeof(seq));
					assert(message.GetSize() == 7);

					if (isUsingChecksum)
					{
						TransportUDP::AddChecksumToMessage(&message);
					}

					// If we have buffers on...
					if (mPacketBufferTime > 0.0f)
					{
						if (transport->mOnlyReceiveFrom)
						{
							// If this assert triggers then the other machine has multi-homed connections that are incorrectly configured or someone is sending spoofed packets.
							// Or there is a bug in this code. In any of these cases in debug mode we want to know about it.
							assert(transport->mReceiveFrom == recvfrom);
							// In release mode we ignore spoofed packets.
							if (transport->mReceiveFrom == recvfrom)
							{
								// Prefer to send using the known end point and buffer
								transport->DoInternalSend(buffer,message.GetSize());
							}
							sendACK = false;
							if (numPackets > 1)
							{
								transport->mPacketsReceivedMerged++;
							}
						}
						else
						{
							// ... And if we match with a known transport end point
							TransportUDP *trans2 = transport->MatchKnownTransportFromAddress(recvfrom);
							if (trans2)
							{
								assert(trans2->mOnlyReceiveFrom);
								assert(trans2->mReceiveFrom == recvfrom);
								// Prefer to send using the known end point and buffer
								trans2->DoInternalSend(buffer,message.GetSize());
								sendACK = false;
								if (numPackets > 1)
								{
									trans2->mPacketsReceivedMerged++;
								}
							}
						}
					}
					// If the ack still isn't handled yet, then handle it now on the transport that received it
					if (sendACK)
					{
						transport->mPersistantSocket->Send(buffer,message.GetSize(),recvfrom);
						transport->AddHistoryEntry(message.GetSize());
						transport->mPacketsSent++;
						transport->mPacketsSentSize+=7;
						if (numPackets > 1)
						{
							transport->mPacketsReceivedMerged++;
						}
					}
				}
				else if ((buffer[2] == UDPReliableManager::kReliableACK) && (ret >= 7))
				{
					numPackets++;
					// Got an ACK for a reliable packet
					ReliablePacket *packet;
					MessageHelper message;
					message.SetBuffer(buffer+3);
					int seq;
					message.GetVariable(&seq,sizeof(seq));

#ifdef DEBUG_PRINTS3
					dprintf("TransportUDP : Got ack for seqid %d(seq %d band %d) from %s (size %d)\n" , seq , seq & 0xffffff, (seq >> 24) & 0xff , recvfrom.Export().c_str(),ret);
#endif

					{
					THREADSAFELOCKCLASS(gManagerListPendingACK);
					mPendingACK.BeginIterate();
					while ( (packet = mPendingACK.Iterate()) != 0)
					{
						if (transport->mOnlyReceiveFrom && (packet->mTransport != transport))
						{
							// Not the one we want obviously
							continue;
						}
						if ((((unsigned int)packet->mSequence | (((unsigned int)packet->mBand)<<24)) == (unsigned int)seq) && (recvfrom == packet->mSendTo))
						{
#ifdef DEBUG_PRINTS3
							dprintf("   Matched to $%p\n",packet->mTransport);
#endif
							packet->mTransport->ResetTransportHavingProblems(sResendMax);
							if (numPackets > 1)
							{
								packet->mTransport->mPacketsReceivedMerged++;
							}
							mPendingACK.RemoveItem();
							delete packet;
							break;
						}
					}
					}
				}
				else if ((buffer[2] == UDPReliableManager::kDisconnect) && (ret >= 3))
				{
					numPackets++;
#ifdef DEBUG_PRINTS3
					dprintf("TransportUDP : Got disconnect packet via UDP from %s\n (size %d)\n",recvfrom.Export().c_str(),ret);
#endif

					if (transport->mOnlyReceiveFrom)
					{
						if (numPackets > 1)
						{
							transport->mPacketsReceivedMerged++;
						}
						if (transport->mReceiveFrom == recvfrom)
						{
							transport->mGotDisconnectPacket = true;
							transport->mError = Transport::kTransport_EERROR;
#ifdef DEBUG_PRINTS3
							dprintf("TransportUDP : mOnlyReceiveFrom Disconnect packet used\n");
#endif
						}
						else
						{
#ifdef DEBUG_PRINTS3
							dprintf("TransportUDP : mOnlyReceiveFrom Disconnect packet ignored\n");
#endif
						}
					}
					else
					{
						TransportUDP *trans2 = transport->MatchKnownTransportFromAddress(recvfrom);
						if (trans2)
						{
							trans2->mGotDisconnectPacket = true;
							trans2->mError = Transport::kTransport_EERROR;
							if (numPackets > 1)
							{
								trans2->mPacketsReceivedMerged++;
							}
#ifdef DEBUG_PRINTS3
							dprintf("TransportUDP : Disconnect packet used\n");
#endif
						}
						else
						{
#ifdef DEBUG_PRINTS3
							dprintf("TransportUDP : Disconnect packet ignored\n");
#endif
						}
					}
				}
				else if ((buffer[2] == UDPReliableManager::kCertain) && (ret >= 7))
				{
					numPackets++;
					// Certain packet type got
					char flag;
					short size;
					int seq;
					MessageHelper message;
					message.SetBuffer(buffer);
					message.GetVariable(&size,sizeof(size));
					message.GetVariable(&flag,sizeof(flag));
					message.GetVariable(&seq,sizeof(seq));

					// Certain packet so store it and send an ACK
					char buffer[8];
					message.SetBuffer(buffer);
					char reply = UDPReliableManager::kCertainACK;
					size = 7;
#ifdef DEBUG_PRINTS3
					dprintf("TransportUDP : Got certain packet for seqid %d from %s\n (size %d)\n",seq,recvfrom.Export().c_str(),ret);
#endif

					message.AddVariable(&size,sizeof(size));
					message.AddVariable(&reply,sizeof(reply));
					message.AddVariable(&seq,sizeof(seq));
					assert(message.GetSize() == 7);

					if (isUsingChecksum)
					{
						TransportUDP::AddChecksumToMessage(&message);
					}

					bool sendAck = true;
					// If we have buffers on...
					TransportUDP *trans2 = 0;
					if (mPacketBufferTime > 0.0f)
					{
						if (transport->mOnlyReceiveFrom)
						{
							// If this assert triggers then the other machine has multi-homed connections that are incorrectly configured or someone is sending spoofed packets.
							// Or there is a bug in this code. In any of these cases in debug mode we want to know about it.
							assert(transport->mReceiveFrom == recvfrom);
							// In release mode we ignore spoofed packets.
							if (transport->mReceiveFrom == recvfrom)
							{
								transport->DoInternalSend(buffer,message.GetSize());
							}
							sendAck = false;
							if (numPackets > 1)
							{
								transport->mPacketsReceivedMerged++;
							}
							trans2 = transport;
						}
						else
						{
							// ... And if we match with a known transport end point
							trans2 = transport->MatchKnownTransportFromAddress(recvfrom);
							if (trans2)
							{
								assert(trans2->mOnlyReceiveFrom);
								assert(trans2->mReceiveFrom == recvfrom);
								trans2->DoInternalSend(buffer,message.GetSize());
								sendAck = false;
								if (numPackets > 1)
								{
									trans2->mPacketsReceivedMerged++;
								}
							}
						}
					}
					// If it is not handled yet then send using the old method
					if (sendAck)
					{
						transport->mPersistantSocket->Send(buffer,message.GetSize(),recvfrom);
						transport->AddHistoryEntry(message.GetSize());
						transport->mPacketsSent++;
						transport->mPacketsSentSize+=7;
						if (numPackets > 1)
						{
							transport->mPacketsReceivedMerged++;
						}

						if (transport->mOnlyReceiveFrom)
						{
							trans2 = transport;
						}
					}
					bool isDupe = false;

					DuplicateCertainIDs dupeTest;
					dupeTest.mAddress = recvfrom;
					dupeTest.mID = seq;
					std::set<DuplicateCertainIDs*,ltDuplicateCertainIDs>::iterator found = mCertainIDs.find(&dupeTest);
					if (found != mCertainIDs.end())
					{
						DuplicateCertainIDs *result = *found;

						if (!trans2)
						{
							if (transport->mOnlyReceiveFrom)
							{
								trans2 = transport;
							}
							else
							{
								trans2 = transport->MatchKnownTransportFromAddress(recvfrom);
							}
						}
						if (trans2 && result->mNonce != trans2->GetLocalNonce())
						{
							// It belonged to a previous instance (from the same address) so remove it since we can ignore this one.
#ifdef DEBUG_PRINTS3
							dprintf("TransportUDP : Ignoring dupe since it is from an old nonce and hence expired\n");
#endif
							mCertainIDs.erase(result->mSetIter);
							mCertainIDsList.erase(result->mListIter);
							delete result;
#ifdef _DEBUG
							mNumCertIDsInDatabase--;
#endif
						}
						else
						{
#ifdef DEBUG_PRINTS3
							dprintf("TransportUDP : Discard duplicate certain packet\n");
#endif
							isDupe = true;
						}
					}

					if (!isDupe)
					{
						DuplicateCertainIDs *newEntry = new DuplicateCertainIDs;
						newEntry->mAddress = recvfrom;
						newEntry->mID = seq;
						newEntry->mTime = ttime;
						if (!trans2)
						{
							if (transport->mOnlyReceiveFrom)
							{
								trans2 = transport;
							}
							else
							{
								trans2 = transport->MatchKnownTransportFromAddress(recvfrom);
							}
						}
						if (trans2)
						{
							newEntry->mNonce = trans2->GetLocalNonce();
						}
						else
						{
							newEntry->mNonce = -1;
						}
						std::pair<std::set<DuplicateCertainIDs*,ltDuplicateCertainIDs>::iterator,bool> result = mCertainIDs.insert(newEntry);
						assert(result.second);	// Each XPAddress and ID pair should always be unique
						newEntry->mSetIter = result.first;
						mCertainIDsList.push_back(newEntry);
						newEntry->mListIter = --mCertainIDsList.end();
#ifdef _DEBUG
						mNumCertIDsInDatabase++;
#endif

					}
					// Certain packet so push it on to the stack
					TransportUDP::WaitingPacket *packet;

					transport->mPacketsReceived++;
					transport->mPacketsReceivedSize+=ret;

					// size
					data+=2;
					ret-=2;
					
					// flag
					data++;
					ret--;

					// seq id
					data+=4;
					ret-=4;

					if (!isDupe)
					{
						if ( ret > 0 )
						{
							packet = new TransportUDP::WaitingPacket(data,ret,recvfrom);
							transport->AddWaitingPacket(packet);
						}
					}
				}
				else if ((buffer[2] == UDPReliableManager::kCertainACK) && (ret >= 7))
				{
					numPackets++;
					// Got an ACK for a certain packet
					ReliablePacket *packet;
					MessageHelper message;
					message.SetBuffer(buffer+3);
					int seq;
					message.GetVariable(&seq,sizeof(seq));

#ifdef DEBUG_PRINTS3
					dprintf("TransportUDP : Got a certain ack for seqid %d from %s\n (size %d)\n",seq,recvfrom.Export().c_str(),ret);
#endif

					{
					THREADSAFELOCKCLASS(gManagerListPendingCertainACK);
					mPendingCertainACK.BeginIterate();
					while ( (packet = mPendingCertainACK.Iterate()) != 0)
					{
						if (transport->mOnlyReceiveFrom && (packet->mTransport != transport))
						{
							// Not the one we want obviously
							continue;
						}
						if ((packet->mSequence == seq) && (recvfrom == packet->mSendTo))
						{
#ifdef DEBUG_PRINTS3
							dprintf("   Matched to $%p\n",packet->mTransport);
#endif
							packet->mTransport->ResetTransportHavingProblems(sResendMax);
							if (numPackets > 1)
							{
								packet->mTransport->mPacketsReceivedMerged++;
							}
							mPendingCertainACK.RemoveItem();
							delete packet;
							break;
						}
					}
					}
				}
			} // while(datatoprocess)
		} // while ( (retreal = transport->mPersistantSocket->Recv(...
	} // while ( (transport = mTransportsAllowedToGetData....
	} //	THREADSAFELOCKCLASS(gManagerTransportLists);


#ifdef _DEBUG
	int numretired = 0;
#endif
	// Now retire the dupe list for certain packets
	std::list<DuplicateCertainIDs *>::iterator st = mCertainIDsList.begin();
	while ( st != mCertainIDsList.end() )
	{
		DuplicateCertainIDs *dupes = *st++;
		if ( (ttime-dupes->mTime) > sMaximumTime )
		{
#ifdef DEBUG_PRINTS3
			dprintf("TransportUDP : Retire certain packet entry, this is normal nothing to worry about\n");
#endif
			mCertainIDs.erase(dupes->mSetIter);
			mCertainIDsList.erase(dupes->mListIter);
			delete dupes;
#ifdef _DEBUG
			mNumCertIDsInDatabase--;
#endif
#ifdef _DEBUG
			numretired++;
#endif
		}
		else
		{
			// The times we are now starting to get in the list are too new so just break out as they do not need checking
			break;
		}
	}

#ifdef _DEBUG
	assert(mCertainIDs.size() == mCertainIDsList.size());
	assert(mCertainIDs.size() == (size_t)mNumCertIDsInDatabase);
//	dprintf("\n*** counter = %d numretired = %d ***\n",mCertainIDs.size(),numretired);
#endif


	// Now retire the timed out build up requests
	std::list<PendingBuildUpReply *>::iterator st2 = mPendingBuildUpReplyList.begin();
	while ( st2 != mPendingBuildUpReplyList.end() )
	{
		PendingBuildUpReply *checkAddresses = *st2++;
		assert(checkAddresses);
		if ( (ttime-checkAddresses->mTime) > sMaximumTime )
		{
#ifdef DEBUG_PRINTS3
			dprintf("TransportUDP : WARNING: Retire mPendingBuildUpReply entry due to incomplete or duped build up request time %f address %s\n",checkAddresses->mTime,(*checkAddresses->mMapIter).first.Export().c_str());
#endif
			mPendingBuildUpReply.erase(checkAddresses->mMapIter);
			mPendingBuildUpReplyList.erase(checkAddresses->mListIter);
			delete checkAddresses;
		}
		else
		{
			// The times we are now starting to get in the list are too new so just break out as they do not need checking
			break;
		}
	}


	// The mKnownTransports are the transports that have come from the result of an Accept() on a listen type of transport
	// The packets sitting on the master listen socket are distributed among the known transports

	{
	THREADSAFELOCKCLASS(gManagerTransportLists);
	mTransportsAllowedToGetDataNotOnlyReceiveFrom.BeginIterate();
	// Now distribute the unreliable received packets among the known transports etc
	// This includes certain packets as these are able to be put in the unreliable waiting packets list
	while ( (transport = mTransportsAllowedToGetDataNotOnlyReceiveFrom.Iterate()) != 0)
	{
		// Only if the packet was allowed to get data
		assert(transport->mAllowedToGetData && "UDPReliableManager: Transport that is not allowed to get data in the wrong list");
		// If this was the result of a Connect() (since this is the only other mAllowedToGetData type)
		// then we have the packet already so skip
		assert(!transport->mOnlyReceiveFrom && "UDPReliableManager: Transport that is mOnlyReceiveFrom to get data in the wrong list");

		transport->SortPacketsToKnownTransports();
	}
	}

	ReliablePacket *acklist;

	// Now distribute the reliable ACKed packets among the known transports etc
	SysTimeType startacktime = FloatTime();

#ifdef DEBUG_PRINTS3
	mACKedPackets.BeginIterate();
	acklist = mACKedPackets.Iterate();
	if (acklist)
	{
		dprintf("TransportUDP : Processing acked packets into their transports at time %f\n" , startacktime);
	}
#endif


	{
	THREADSAFELOCKCLASS(gManagerTransportLists);
	mACKedPackets.BeginIterate();
	while ( (acklist = mACKedPackets.Iterate()) != 0)
	{
		if ( (startacktime - acklist->mOriginalTime) > sLastGaspDataBaseTimeout)
		{
#ifdef DEBUG_PRINTS3
			dprintf("TransportUDP : ACKed packet seqid %d deleted as it timed out\n",acklist->mSequence);
#endif
			mACKedPackets.RemoveItem();
			delete acklist;
			acklist = 0;
			continue;
		}

		transport = acklist->mTransport;

		if (transport->mOnlyReceiveFrom)
		{
// A transport that only wants packets from one address
// i.e. A transport that came ONLY from a Connect() call
#ifdef DEBUG_PRINTS3
			dprintf("TransportUDP : mOnlyReceiveFrom is true\n");
#endif
			if (transport->mReceiveFrom == acklist->mRecvFrom)
			{
				// MPi: TODO: Need 24 bit wrap around check for the sequence
				bool possibleWrapAround = false;
				// If we get a large swing then possibly the packet comes from the wrap around event, so we flag it.
				if ( (transport->mRecvSequence[acklist->mBand] - acklist->mSequence) > (1<<22) )
				{
					possibleWrapAround = true;
				}
				if ((transport->mRecvSequence[acklist->mBand] > acklist->mSequence) && !possibleWrapAround)
				{
#ifdef DEBUG_PRINTS3
					dprintf("TransportUDP : mOnlyReceiveFrom ACKed packet seqid %d deleted as it is already processed\n",acklist->mSequence);
#endif
					mACKedPackets.RemoveItem();
					delete acklist;
					acklist = 0;
					continue;
				}
				if (transport->mRecvSequence[acklist->mBand] == acklist->mSequence)
				{
					// This check finds the zero length wakeup packet that is sent back once the other end accepts this connection attempt.
					if (acklist->mSequence == 2 && acklist->mLen >= 7 && acklist->mBand == 0 && !transport->mWrapHappened)
					{
						transport->mFullConnectionDone = true;

#ifdef DEBUG_PRINTS3
						dprintf("TransportUDP : mFullConnectionDone = true and discard zero length packet\n");
#endif
					}
					if ( acklist->mLen > 7 )
					{
#ifdef DEBUG_PRINTS3
						dprintf("TransportUDP : mOnlyReceiveFrom ACKed packet seqid %d added to waiting packets queue\n",acklist->mSequence);
#endif
						TransportUDP::WaitingPacket *packet = new TransportUDP::WaitingPacket(((char *)acklist->mData)+7,acklist->mLen-7,acklist->mRecvFrom);
						transport->AddWaitingPacket(packet);
					}
					transport->mRecvSequence[acklist->mBand]++;
					if (transport->mRecvSequence[acklist->mBand] == (1<<24))
					{
						transport->mRecvSequence[acklist->mBand] = 2;
						transport->mWrapHappened = true;
					}
					transport->mPacketsReceived++;
					transport->mPacketsReceivedSize+=acklist->mLen;
					mACKedPackets.RemoveItem();
					delete acklist;
					acklist = 0;
					continue;
				}
#ifdef DEBUG_PRINTS3
				dprintf("TransportUDP : mOnlyReceiveFrom ACKed packet seqid %d left in queue\n",acklist->mSequence);
#endif
				continue;
			}
#ifdef DEBUG_PRINTS3
			dprintf("TransportUDP : mOnlyReceiveFrom ACKed packet seqid %d deleted as address and port not valid (%s)\n",acklist->mSequence,acklist->mRecvFrom.Export().c_str());
#endif
			mACKedPackets.RemoveItem();
			delete acklist;
			acklist = 0;
			continue;
		}
		else
		{
// This transport is a listen transport and so needs the packets that are intended for them the transports that were the result of the accept
#ifdef DEBUG_PRINTS3
			dprintf("TransportUDP : mOnlyReceiveFrom is false\n");
#endif
			TransportUDP *trans2 = transport->MatchKnownTransportFromAddress(acklist->mRecvFrom);

			if (trans2)
			{
#ifdef DEBUG_PRINTS3
				dprintf("TransportUDP : band %d trans_is_seqid %d packet seqid %d\n" , acklist->mBand , trans2->mRecvSequence[acklist->mBand] , acklist->mSequence);
#endif
				bool possibleWrapAround = false;
				// If we get a large swing then possibly the packet comes from the wrap around event, so we flag it.
				if ( (trans2->mRecvSequence[acklist->mBand] - acklist->mSequence) > (1<<22) )
				{
					possibleWrapAround = true;
				}
				if ((trans2->mRecvSequence[acklist->mBand] > acklist->mSequence) && !possibleWrapAround)
				{
#ifdef DEBUG_PRINTS3
					dprintf("TransportUDP : listen ACKed packet seqid %d deleted as it is already processed\n",acklist->mSequence);
#endif
					mACKedPackets.RemoveItem();
					delete acklist;
					acklist = 0;
// We do not need the break since now we are not iterating the transport list
//						break;
				}
				else if (trans2->mRecvSequence[acklist->mBand] == acklist->mSequence)
				{
					if ( acklist->mLen > 7 )
					{
#ifdef DEBUG_PRINTS3
						dprintf("TransportUDP : listen ACKed packet seqid %d added to waiting packets queue\n",acklist->mSequence);
#endif
						TransportUDP::WaitingPacket *packet = new TransportUDP::WaitingPacket(((char *)acklist->mData)+7,acklist->mLen-7,acklist->mRecvFrom);
						trans2->AddWaitingPacket(packet);
					}
					trans2->mRecvSequence[acklist->mBand]++;
					if (trans2->mRecvSequence[acklist->mBand] == (1<<24))
					{
						trans2->mRecvSequence[acklist->mBand] = 2;
						trans2->mWrapHappened = true;
					}
					trans2->mPacketsReceived++;
					trans2->mPacketsReceivedSize+=acklist->mLen;
					mACKedPackets.RemoveItem();
					delete acklist;
					acklist = 0;
// We do not need the break since now we are not iterating the transport list
//						break;
				}
				else
				{
#ifdef DEBUG_PRINTS3
					dprintf("TransportUDP : listen ACKed packet seqid %d left in queue\n",acklist->mSequence);
#endif
					acklist = 0;
				}
// We do not need the break since now we are not iterating the transport list
//					break;
			} //< if (trans2)

			if (!acklist)
			{
				continue;
			}


			// Only do this if it is a zero length packet and this zero length packet is sent as reliable
			if (acklist->mSequence == 1 && acklist->mBand == 0 && acklist->mLen == 7)
			{
#ifdef DEBUG_PRINTS3
				dprintf("TransportUDP : Process potential listen ACKed packet\n");
#endif
				// First check to see if the address is in the build up list...
				std::map<XPAddress,PendingBuildUpReply *>::iterator foundIter = mPendingBuildUpReply.find(acklist->mRecvFrom);
				TransportUDP::NewAddress newAddr;
				if ( foundIter != mPendingBuildUpReply.end() )
				{
					PendingBuildUpReply *checkAddress = (*foundIter).second;
					assert(checkAddress);

#ifdef DEBUG_PRINTS3
					dprintf("TransportUDP : Address found in build up list so remove address from list\n");
#endif
					newAddr.mAddress = acklist->mRecvFrom;
					newAddr.mConfiguredBandwidth = checkAddress->mConfiguredBandwidth;
					newAddr.mMaximumOutputBandwidth = checkAddress->mMaximumOutputBandwidth;
					newAddr.mMaximumInputBandwidth = checkAddress->mMaximumInputBandwidth;
					newAddr.mUseChecksum = checkAddress->mUseChecksum;
					mPendingBuildUpReply.erase(checkAddress->mMapIter);
					mPendingBuildUpReplyList.erase(checkAddress->mListIter);
					delete checkAddress;

					if ( transport->AddNewAddresses(newAddr) )
					{
#ifdef DEBUG_PRINTS3
						dprintf("TransportUDP : Build up and zero length received and was inserted to mNewAddresses\n");
#endif
					}
					else
					{
#ifdef DEBUG_PRINTS3
						dprintf("TransportUDP : Build up and zero length received but was already in mNewAddresses\n");
#endif
					}

#ifdef DEBUG_PRINTS3
					dprintf("TransportUDP : listen ACKed packet seqid %d removed as it was the mNewAddresses packet for a potential new connection\n",acklist->mSequence);
#endif
					mACKedPackets.RemoveItem();
					delete acklist;
					acklist = 0;
					continue;
				}
				else
				{
#ifdef DEBUG_PRINTS3
					dprintf("TransportUDP : Address not found in build up list so leave it pending for a while\n");
#endif
				}
			}


			// It's a potential building up connection, but it will get timed out if it isn't in the pending list
			if ( ( (startacktime - acklist->mOriginalTime) > sMaximumTime ) && !transport->MatchNewAddressesToAddress(acklist->mRecvFrom))
			{
#ifdef DEBUG_PRINTS3
				dprintf("TransportUDP : ACKed packet seqid %d deleted as it timed out due to no build up\n",acklist->mSequence);
#endif
				mACKedPackets.RemoveItem();
				delete acklist;
				acklist = 0;
				continue;
			}

		}
	}
	}//	THREADSAFELOCKCLASS(gManagerTransportLists);


	bool problem = false;
	SysTimeType time = FloatTime();

	{
	THREADSAFELOCKCLASS(gManagerListPendingACK);

#ifdef DEBUG_PRINTS3
	mPendingACK.BeginIterate();
	acklist = mPendingACK.Iterate();
	if (acklist)
	{
		dprintf("TransportUDP : Processing pending ack packets at time %f\n" , time);
	}
#endif

	mPendingACK.BeginIterate();

	while ( (acklist = mPendingACK.Iterate()) != 0)
	{
		// Now check the packets that still need ACKs
		if (time > acklist->mResendTime)
		{
//DEBUGING USE:  Any packet loss or lag and it gets disconnected straight away
//	acklist->mTransport->mError = Transport::kTransport_EERROR;

			if (acklist->mTransport->mError == Transport::kTransport_EERROR)
			{
#ifdef DEBUG_PRINTS3
				dprintf("TransportUDP $%p: Error Seqid %d failed to get through. ERROR.\n",acklist->mTransport,acklist->mSequence);
#endif
				mPendingACK.RemoveItem();
				delete acklist;
				acklist = 0;
				problem = true;
				continue;
			}

#ifdef DEBUG_PRINTS3
			dprintf("TransportUDP $%p: Process acklist seqid %d band %d mResendIndex %d trans mProblemResendIndex %d\n",acklist->mTransport, acklist->mSequence, acklist->mBand , acklist->mResendIndex , acklist->mTransport->mProblemResendIndex);
#endif

			// Underflow check
			if (acklist->mResendIndex < acklist->mTransport->mProblemResendIndex)
			{
				acklist->mResendIndex = acklist->mTransport->mProblemResendIndex;
			}

			int realIndex = acklist->mResendIndex - acklist->mTransport->mProblemResendIndex;

			if (realIndex >= (sResendMax-1))
			{
				// Debugging point: Potentially going to fail
				int a = 0;
			}

			if (realIndex >= sResendMax)
			{
#ifdef DEBUG_PRINTS3
				dprintf("TransportUDP $%p: Timeout seqid %d failed to get through. ERROR.\n",acklist->mTransport,acklist->mSequence);
#endif
				acklist->mTransport->mError = Transport::kTransport_EERROR;
				mPendingACK.RemoveItem();
				delete acklist;
				acklist = 0;
				problem = true;
				continue;
			}
			problem = true;
			acklist->mResendIndex++;
			float waittime = sResendTimes[realIndex];
			assert(acklist->mTransport->mOnlyReceiveFrom);
			assert(acklist->mTransport->mReceiveFrom == acklist->mSendTo);
			// If we have buffering and we have not resent too many times already
#ifdef DEBUG_PRINTS3
			std::string baddr = acklist->mSendTo.Export();
			char *taddr = (char *) baddr.c_str();
			dprintf("TransportUDP $%p: Resend seqid %d to %s and wait %f realIndex %d until time %f\n",acklist->mTransport, acklist->mSequence,taddr,waittime , realIndex , acklist->mResendTime);
#endif
			if (acklist->mBuffered && (realIndex < sNoBufferAfterRetries) )
			{
#ifdef DEBUG_PRINTS3
				dprintf("TransportUDP $%p: DoInternalSend to %s\n",acklist->mTransport , acklist->mTransport->mReceiveFrom.Export().c_str());
#endif
				acklist->mTransport->DoInternalSend((char *) acklist->mData,acklist->mLen);
			}
			else
			{
#ifdef DEBUG_PRINTS3
				dprintf("TransportUDP $%p: DoInternalSendCompressionCheck to %s\n",acklist->mTransport , acklist->mSendTo.Export().c_str());
#endif
				// Otherwise we will try sending the individual packet since we don't want to buffer it this time.
				acklist->mTransport->DoInternalSendCompressionCheck((char *) acklist->mData,acklist->mLen,acklist->mSendTo);
				acklist->mTransport->AddHistoryEntry(acklist->mLen);
			}
			acklist->mResendTime = time+waittime;
			acklist->mTransport->mPacketsLost++;
			acklist->mTransport->mTransportHavingProblems = true;
		}
	}
	} //	THREADSAFELOCKCLASS(gManagerListPendingACK);

	{
	THREADSAFELOCKCLASS(gManagerListPendingCertainACK);
	mPendingCertainACK.BeginIterate();
	problem = false;
	time = FloatTime();

	while ( (acklist = mPendingCertainACK.Iterate()) != 0)
	{
		// Now check the packets that still need ACKs
		if (time > acklist->mResendTime)
		{
//DEBUGING USE:  Any packet loss or lag and it gets disconnected straight away
//	acklist->mTransport->mError = Transport::kTransport_EERROR;

			if (acklist->mTransport->mError == Transport::kTransport_EERROR)
			{
#ifdef DEBUG_PRINTS3
				dprintf("TransportUDP $%p: Error Certain Seqid %d failed to get through. ERROR.\n",acklist->mTransport,acklist->mSequence);
#endif
				mPendingCertainACK.RemoveItem();
				delete acklist;
				acklist = 0;
				problem = true;
				continue;
			}

			// Underflow check
			if (acklist->mResendIndex < acklist->mTransport->mProblemResendIndex)
			{
				acklist->mResendIndex = acklist->mTransport->mProblemResendIndex;
			}

			int realIndex = acklist->mResendIndex - acklist->mTransport->mProblemResendIndex;
			if (realIndex >= sResendMax)
			{
#ifdef DEBUG_PRINTS3
				dprintf("TransportUDP $%p: Timeout certain seqid %d failed to get through. ERROR.\n",acklist->mTransport,acklist->mSequence);
#endif
				acklist->mTransport->mError = Transport::kTransport_EERROR;
				mPendingCertainACK.RemoveItem();
				delete acklist;
				acklist = 0;
				problem = true;
				continue;
			}
			problem = true;
			acklist->mResendIndex++;
			float waittime = sResendTimes[realIndex];
			assert(acklist->mTransport->mOnlyReceiveFrom);
			assert(acklist->mTransport->mReceiveFrom == acklist->mSendTo);
			// If we have buffering and we have not resent too many times already
			if (acklist->mBuffered && (realIndex < sNoBufferAfterRetries) )
			{
				acklist->mTransport->DoInternalSend((char *) acklist->mData,acklist->mLen);
			}
			else
			{
				// Otherwise we will try sending the individual packet since we don't want to buffer it this time.
				acklist->mTransport->DoInternalSendCompressionCheck((char *) acklist->mData,acklist->mLen,acklist->mSendTo);
				acklist->mTransport->AddHistoryEntry(acklist->mLen);
			}
			acklist->mResendTime = time+waittime;
			acklist->mTransport->mPacketsLost++;
			acklist->mTransport->mTransportHavingProblems = true;
#ifdef DEBUG_PRINTS3
			std::string baddr = acklist->mSendTo.Export();
			char *taddr = (char *) baddr.c_str();
			dprintf("TransportUDP $%p: Resend certain seqid %d to %s and wait %f\n",this, acklist->mSequence,taddr,waittime);
#endif
		}
	}
	} //	THREADSAFELOCKCLASS(gManagerListPendingCertainACK);



	// Now poll all of our known transports
//CalculateBandwidthOutputPerSecondAndRetireHistoryEntries

	ttime = FloatTime() - ttime;
	if (problem)
	{
#ifdef DEBUG_PRINTS3
		dprintf("Last problem UDP resend took %f ms\n",ttime*1000.0f);
#endif
	}

}

void UDPReliableManager::AddPendingPacket(ReliablePacket *packet)
{
	THREADSAFELOCKCLASS(gManagerListPendingACK);

	mPendingACK.AddItem(packet);
}

void UDPReliableManager::AddPendingCertainPacket(ReliablePacket *packet)
{
	THREADSAFELOCKCLASS(gManagerListPendingCertainACK);

	mPendingCertainACK.AddItem(packet);
}



ReliablePacket::ReliablePacket(int len,void *data,TransportUDP *transport,XPAddress &sendto,XPAddress &recvfrom,const bool buffered)
{
	assert(len);
	assert(data);

	mBuffered = buffered;
	mLen = len;
	mData = malloc(len);
	memcpy(mData,data,len);
	mTransport = transport;
	mSendTo = sendto;
	mRecvFrom = recvfrom;
	MessageHelper message;
	message.SetBuffer(data);
	char flag;
	short size;
	message.GetVariable(&size,sizeof(size));
	message.GetVariable(&flag,sizeof(flag));
	flag &= ~UDPReliableManager::kUsingChecksum;
	mBand = 0;
	message.GetVariable(&mSequence,sizeof(mSequence));
	if ((flag == UDPReliableManager::kBuildUp) || (flag == UDPReliableManager::kReliable))
	{
		// Otherwise the sequence is defined as band%8 and seq%24
		mBand = (unsigned char) (mSequence >> 24);
		mSequence = mSequence & 0xffffff;
	}

	mOriginalTime = gUDPManager->FloatTime();
	mResendIndex = transport->mProblemResendIndex + 1;
	transport->mProblemResendIndexUsed = transport->mProblemResendIndex + sResendMax;
	mResendTime = mOriginalTime+sResendTimes[0];
	mError = false;

#ifdef DEBUG_PRINTS3
	dprintf("TransportUDP $%p: Create ReliablePacket seqid %d band %d mResendIndex %d trans mProblemResendIndex %d\n",mTransport, mSequence, mBand , mResendIndex , mTransport->mProblemResendIndex);
#endif
}


void UDPReliableManager::PerformKickTransports(const bool force)
{
	if (mDisableAllPacketBuffer)
	{
		return;
	}
	THREADSAFELOCKCLASS(gManagerTransportListsBuffered);
	SysTimeType ttime = FloatTime();
	mPacketBufferKickScheduled = false;
	TransportUDP *transport;
	mTransportsBuffered.BeginIterate();
#ifdef DEBUG_PRINTS3
	dprintf("UDPReliableManager : Processing KickPacketBuffer\n");
#endif
	while ( (transport = mTransportsBuffered.Iterate()) != 0)
	{
		transport->KickPacketBuffer(ttime,force);
	}
}
//From: RNXPURL/XPURL.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
//Skipping: #include "RNXPURL/Inc/XPURL.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
using namespace RNReplicaNet;
//Skipping: #include "RNXPSockets/Inc/XPSockets.h"
//Include inline: #include "RNXPURL/XPURLPrivate.h"
//From: RNXPURL/XPURLPrivate.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef __XPURLPRIVATE_H__
#define __XPURLPRIVATE_H__

//Skipping: #include "RNXPURL/Inc/XPURL.h"

#endif
//Skipping: #include "RNXPURL/Inc/Transport.h"
//Skipping: #include "RNXPURL/DoRegister.h"
//Skipping: #include "RNPlatform/Inc/CheckSum.h"
//Skipping: #include "RNXPURL/UDPReliableManager.h"
//Skipping: #include "RNPlatform/Inc/PlatformInfo.h"
//Skipping: #include "RNPlatform/Inc/PlatformHeap.h"
//Skipping: #include "RNXPURL/Inc/DebugHandler.h"


struct RNReplicaNet::URLBlock
{
	URLBlock();
	URLBlock(Transport *transport);

	Transport *mTransport;
	std::string mAccept;
	std::string mRoute;
	int mQuickMatchAccept;
	int mQuickMatchRoute;
};

static std::vector<URLBlock *> *sTransportTypesList = 0;

static DebugHandler *theDebugHandler = 0;

namespace RNReplicaNet
{
class XPURLHeapBlock : public RNReplicaNet::PlatformHeapBlock
{
public:
	virtual ~XPURLHeapBlock()
	{
		std::vector<URLBlock *>::iterator st,en;
		st = sTransportTypesList->begin();
		en = sTransportTypesList->end();
		while(st != en)
		{
			URLBlock *block = *st;
			delete block;
			st++;
		}

		delete sTransportTypesList;
		sTransportTypesList = 0;

		delete theDebugHandler;
		theDebugHandler = 0;

		// Finally shut down the network
		XPURL::ShutdownNetwork(true);
	}
};
}

static void EnsureTransportTypesListAllocated(void)
{
	if (!sTransportTypesList)
	{
		sTransportTypesList = new std::vector<URLBlock *>;
		assert(sTransportTypesList);
		(new XPURLHeapBlock())->Register();
	}
}


XPURL::XPURL()
{
}

XPURL::~XPURL()
{
}

//void XPURL_RegisterTransport(Transport *transport)
//{
//	XPURL::RegisterTransport(*transport);
//}


void XPURL::RegisterTransport(Transport &transport)
{
	EnsureTransportTypesListAllocated();

	XPURL aurl;
	aurl.BeginEnumerateTransports();

	// Check for a duplicate first
	Transport *found = aurl.FindTransport(transport.CanAccept());

	if (found)
	{
		return;
	}

#ifdef DEBUG_PRINTS1
	printf("Registered transport %s\n",transport.CanAccept().c_str());
#endif

	sTransportTypesList->push_back(new URLBlock(&transport));
}

void XPURL::BeginEnumerateTransports(void)
{
	EnsureTransportTypesListAllocated();

	mst = sTransportTypesList->begin();
	men = sTransportTypesList->end();
}

Transport *XPURL::EnumerateTransports(void)
{
	EnsureTransportTypesListAllocated();

	if (mst != men)
	{
		URLBlock *mBlock = mst[0];
		mst++;
		return mBlock->mTransport;
	}

	return 0;
}

std::string XPURL::ParseURLs(const std::string urls)
{
	EnsureTransportTypesListAllocated();

	if (urls.size() > 0)
	{
		mParseState = urls;
	}

	if (mParseState.size() == 0)
	{
		return "";
	}


	size_t i = mParseState.find_first_of("/");

	if (i==std::string::npos)
	{
		return std::string("");
	}

	std::string	oneurl = mParseState;
	oneurl.erase(i,oneurl.size());

	mParseState.erase(0,i+1);

	return oneurl;
}

Transport *XPURL::FindTransport(const std::string url)
{
	EnsureTransportTypesListAllocated();

	XPURL aurl;
	aurl.BeginEnumerateTransports();

	Transport *trans = aurl.EnumerateTransports();
	while (trans)
	{
		std::string transurl = trans->CanAccept();

		if (url.substr(0,transurl.size()) == transurl)
		{
			return trans;
		}

		trans = aurl.EnumerateTransports();
	}

	return 0;
}

bool XPURL::FreeTransport(Transport *transport)
{
	if (!transport)
	{
		return false;
	}
	delete transport;
	return true;
}

void XPURL::RegisterDefaultTransports(void)
{
	::RegisterDefaultTransports();
}

URLBlock::URLBlock()
{
}

URLBlock::URLBlock(Transport *transport)
{
	mTransport = transport;
	mAccept = transport->CanAccept();
	mRoute = transport->CanRoute();
	mQuickMatchAccept = Checksum::ChecksumData(mAccept.c_str(),mAccept.size());
	mQuickMatchRoute = Checksum::ChecksumData(mRoute.c_str(),mRoute.size());
}

void XPURL::Poll(void)
{
	gUDPManagerMutex.Lock();
	if (gUDPManager)
	{
		gUDPManager->Poll();
	}
	gUDPManagerMutex.UnLock();
}

void XPURL::SetAutomaticPoll(void)
{
	InitialiseNetwork();

	gUDPManagerMutex.Lock();
	assert(gUDPManager);

	gUDPManager->SetAutomaticPoll();
	gUDPManagerMutex.UnLock();
}

void XPURL::SetManualPoll(void)
{
	InitialiseNetwork();

	gUDPManagerMutex.Lock();
	assert(gUDPManager);

	gUDPManager->SetManualPoll();
	gUDPManagerMutex.UnLock();
}

void XPURL::InitialiseNetwork(const bool hardware)
{
	if (!gUDPManager)
	{
		gUDPManagerMutex.Lock();
		gUDPManager = new UDPReliableManager;
		gUDPManagerMutex.UnLock();
	}

	if (hardware)
	{
		XPSock_Init();
	}
}

void XPURL::ShutdownNetwork(const bool hardware)
{
	gUDPManagerMutex.Lock();
	delete gUDPManager;
	gUDPManager = 0;
	gUDPManagerMutex.UnLock();
	
	if (hardware)
	{
		XPSock_Quit();
	}
}

DebugHandler *XPURL::RegisterDebugHandler(DebugHandler *debugHandler)
{
	DebugHandler *theOldDebugHandler = theDebugHandler;

	theDebugHandler = debugHandler;

	return theOldDebugHandler;
}

DebugHandler *XPURL::GetDebugHandler(void)
{
	return theDebugHandler;
}

namespace RNReplicaNet
{
// This is here because XPURL doesn't actually have its own thread, but the UDP reliable manager does
void XPURLInternalPollFromUDPReliableManagerPoll(void)
{
	if (XPURL::GetDebugHandler())
	{
		XPURL::GetDebugHandler()->Poll();
	}

	if (!PlatformInfo::IsThreaded())
	{
	}
}
}
//From: RNXPURL/XPURLDoc.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
/** \page XPURL XPURL
 *
 * \section intro Introduction
 *
 * RNReplicaNet::XPURL decodes and encodes URLs and acts as a common method for interfacing various networking protocols.<br>
 * A Transport is a high level network connection that can be found or registered by RNReplicaNet::XPURL.<br>
 * For testing purposes the network performance, even of local host tests, can be emulated by the RNReplicaNet::NetworkEmulation class.
 *
 * \section usingxpurl Using XPURL
 *
 * Include files are in the Includes directory.<br>
 * Use "RNXPURL/Inc/XPURL.h" to access all the C++ interface to XPURL<br>
 * <br>
 * To link follow the instructions at \ref usingreplicanet <br>
 *
 */

//From: RNXPURL/DebugHandler.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
//Skipping: #include "RNXPSockets/Inc/XPSocketClass.h"
//Skipping: #include "RNXPURL/Inc/DebugHandler.h"
//Skipping: #include "RNPlatform/Inc/ThreadClass.h"
//Skipping: #include "RNPlatform/Inc/PlatformHeap.h"

using namespace RNReplicaNet;

static MutexClass theDebugMutex;
static XPSocket *theSocketListen = 0;
static XPSocket *theSocket = 0;
static bool heapBlock = false;

namespace RNReplicaNet
{
class XPURLDebugHanderHeapBlock : public RNReplicaNet::PlatformHeapBlock
{
public:
	XPURLDebugHanderHeapBlock()
	{
		heapBlock = true;
	}
	virtual ~XPURLDebugHanderHeapBlock()
	{
		THREADSAFELOCKCLASS(theDebugMutex);
		delete theSocket;
		theSocket = 0;
		delete theSocketListen;
		theSocketListen = 0;
		heapBlock = false;
	}
};
}

DebugHandler::DebugHandler()
{
}

DebugHandler::~DebugHandler()
{
	DisableVisualDebuggerSocket();
}

bool DebugHandler::OutputToSocket(const char *text)
{
	THREADSAFELOCKCLASS(theDebugMutex);

	if (theSocket)
	{
		int length = (int)strlen(text);
		int sent = 0;
		int ret;
		while (sent < length)
		{
			int toSend = length-sent;
			// Cap the maximum sent each time to avoid problems with killing some network stacks on consoles...
			if (toSend > 1024)
			{
				toSend = 1024;
			}
			ret = theSocket->Send(text+sent,toSend);
			if (ret > 0)
			{
				if (ret != toSend)
				{
					CallbackConnectionError(ret);
				}
				sent += ret;
			}
			// If it totally failed to send anything then sleep for a tiny bit
			if (ret == 0)
			{
				CallbackConnectionError(0);
				CurrentThread::Sleep(1);
			}
			if (ret == XPSOCK_EERROR)
			{
				int realError = theSocket->GetLastError();
				delete theSocket;
				theSocket = 0;
				CallbackConnectionError(realError);
				return true;
			}
		}
	}

	return false;
}

bool DebugHandler::EnableVisualDebuggerSocket(const int port)
{
	THREADSAFELOCKCLASS(theDebugMutex);

	if (!heapBlock)
	{
		(new XPURLDebugHanderHeapBlock())->Register();
	}

	DisableVisualDebuggerSocket();

	theSocketListen = new XPSocket();
	theSocketListen->Create();
	if (theSocketListen->Listen(port) != XPSOCK_EOK)
	{
		// Fall back to using any port number
		theSocketListen->Listen();
	}

	return false;
}

void DebugHandler::DisableVisualDebuggerSocket(void)
{
	THREADSAFELOCKCLASS(theDebugMutex);
	delete theSocket;
	theSocket = 0;
	delete theSocketListen;
	theSocketListen = 0;
}

#ifdef _MSC_VER
#pragma warning (disable : 4793)
#endif

#ifdef _WIN32
// VC6 uses _vsnprintf
#define vsnprintf _vsnprintf
#endif

void DebugHandler::Printf(const char *format, ...)
{
	THREADSAFELOCKCLASS(theDebugMutex);

	char buffer[8192];
	va_list	ap;
	va_start(ap, format);
	int len = vsnprintf(buffer, sizeof(buffer)-1, format, ap);
	buffer[sizeof(buffer)-1] = '\0';
	if (len > 0)
	{
		buffer[len] = '\0';
	}
	va_end(ap);

	DebugPrint(buffer);
}

void DebugHandler::Poll(void)
{
	THREADSAFELOCKCLASS(theDebugMutex);

	if (!theSocketListen)
	{
		return;
	}

	XPSocket *theAccepted = theSocketListen->Accept();

	if (theAccepted && theAccepted != pcXPSOCK_EERROR)
	{
		delete theSocket;
		theSocket = theAccepted;

		// Try to set a larger send buffer
		int buffSize = 128*1024;
		if (theSocket->SetSendBuffer(-1) < buffSize)
		{
			theSocket->SetSendBuffer(buffSize);
		}

		OutputToSocket("#Welcome to the debug channel\n");

		OutputToSocket("::_Time\n0.0\n::VisualDebugger.RemoteAddress\n");
		OutputToSocket("Address\n");
		XPAddress addr;
		theAccepted->GetPeerAddress(&addr);
		std::string temp = addr.Export() + "\n";
		OutputToSocket(temp.c_str());

		OutputToSocket("::_EndClass\n::_Flush\n");
	}
}

void DebugHandler::DebugPrint(const char *text)
{
	OutputToSocket(text);
}

bool DebugHandler::GotConnection(void) const
{
	if (theSocket)
	{
		return true;
	}
	return false;
}

void DebugHandler::CallbackConnectionError(const int error)
{
}
//From: RNXPCompression/XPCompression.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
//Skipping: #include "RNXPCompression/Inc/XPCompression.h"
//Include inline: #include "RNXPCompression/Compress.h"
//From: RNXPCompression/Compress.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef __GBACOMPRESS_H__
#define __GBACOMPRESS_H__

//Include inline: #include "RNXPCompression/common.h"
//From: RNXPCompression/common.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef __AGB_H__
#define __AGB_H__

typedef unsigned int u32;
typedef unsigned short u16;
typedef unsigned char u8;

typedef signed int s32;
typedef signed short s16;
typedef signed char s8;

#define LONG_OFFSET_THRESHOLD			 0xd00

#define GBA_E_OK					0
#define GBA_E_ERROR					(-1)
#define GBA_E_INVALID_ARGUMENT		(-2)
#define GBA_E_OUT_OF_MEMORY			(-3)

#endif
#include <map>
#include <list>
#include <set>

namespace RNReplicaNet
{

namespace RNXPCompression
{

//const int kMatchHistorySize = 16;
/**
 * Implements the LZMPi compression algorithm. The algorithm inserts previous data that did not match into a std::multimap of value pairs and scans these pairs for future matches.
 * The longest matching runs are then encoded with offset and length which are themselves encoded using packed values.
 */
class Compression
{
public:
	Compression();
	virtual ~Compression();

	/**
	 * Compress a part of memory to a destination buffer
	 * \param src the source memory pointer
	 * \param src_len the length of the source in bytes
	 * \param dst the destination memory pointer. This should be at least sourcesize + (sourcesize/8) + 256 in size
	 * \param dst_len the pointer for the length of the destination buffer. 
	 * \param level the compression level from 1 to 10 where 10 is the best compression
	 * \return An error code or 0 for no error
	 */
	int Compress( const u8*src, u32 src_len,u8 *dst, u32 *dst_len,int level);

private:
	// Bit buffering
	void BitBufferWriteBits(void);

	void BitBufferPutBit(unsigned char bit);

	void BitBufferPutByte(unsigned char b);

	void BitBufferFlushBits(unsigned char filler_bit);

	// Uses a bit per bit
	void PackValue(u32 i);
	// Uses power of two scheme
	void PackValue2(u32 i);

	void EncodeMatch(u32 len, const u32 offset);

	void EncodeLiteralRun(const u8 *litRun, u32 currentLitNum);

	// Calculates the proposed match length in bits
	int CodedMatchLength(u32 len, u32 offset);

	u32 mLastOffset;
	u32 mInLen;
	const u8 *mCurBuf;
	const u8 *mBufEnd;

	u32 mBitBufferValue;
	unsigned char mBitBufferCount;
	u8 *mBitBufferCurrentOut;
	u8 *mBitBufferNextOut;


	// Dictionary
	struct Bytes
	{
		Bytes(u8 a, u8 b)
		{
			mBytes[0] = a;
			mBytes[1] = b;
		}
		u8 mBytes[2];

		u16 GetHash(void) const
		{
			return ((u16)mBytes[0]) | (((u16)mBytes[1])<<8);
		}
	};
	struct ByBytes
	{
		bool operator()(const Bytes &a, const Bytes &b) const
		{
			if (a.mBytes[0] < b.mBytes[0])
			{
				return true;
			}
			else if (a.mBytes[0] == b.mBytes[0])
			{
				return a.mBytes[1] < b.mBytes[1];
			}
			return false;
		}
	};
	struct Value
	{
		u32 mPos;

		// Iterators
		std::multimap<Bytes,Value*,ByBytes>::iterator mByBytes;
		std::list<Value *>::iterator mByAge;
		std::set<u32>::iterator mByPos;

		std::set<u32>::iterator mHashPosAdded;
		std::list<Value*>::iterator mHashValues;

		u16 mHashedValue;
	};
	struct HashNode
	{
		std::set<u32> mPosAdded;
		std::list<Value*> mValues;
	};
	std::multimap<Bytes,Value*,ByBytes> mValueByBytes;
	std::list<Value*> mByAge;
	std::set<u32> mByPos;
	HashNode *mHashTable;

	u32 mLastMatchPos;
	u32 mLastMatchLen;
	u32 mLastMatchOffset;
	Value *mLastMatchValue;
	bool mLastMatchReturn;
	u32 mUpperLimitForwardMatchLen;
	u32 mMaximumRangeCheck;
	bool mUseDictionary;
	bool mDoForwardCheck;
	bool mDoExtendedDictionaryAdd;
	u32 mMaximumDictionaryBlocks;

	void DictionaryFree(void);
	void DictionaryAdd(const u32 fromStartPos);
	bool DictionaryFindMatch(const u32 fromStartPos,u32 &len,u32 &matchOffset,Value **pValue);
	void DictionaryFreeValue(Value *value);
	bool CommonValueChecks(Value *value,const u32 fromStartPos, u32 &bestMatchPos, u32 &bestMatchLen, int &bestBitLength, const u32 maxNumBytesAhead);

	u32 mTotalBits;
};

} // namespace RNXPCompression

} // namespace RNReplicaNet

#endif
//Include inline: #include "RNXPCompression/Decompress.h"
//From: RNXPCompression/Decompress.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef __GBADECOMPRESS_H__
#define __GBADECOMPRESS_H__
//Skipping: #include "RNXPCompression/common.h"

namespace RNReplicaNet
{

namespace RNXPCompression
{

/**
 * Decompresses memory compressed with Compress
 * \param source the source memory pointer
 * \param sourceLen the size of the source memory buffer
 * \param dest the destination memory buffer
 * \param destLen the pointer that will the length of the decompressed data
 * \param max_buffer_size the maximum size of the destination memory buffer to use while decompressing
 * \return An error code or 0 for no error
 */
extern int Decompress( const u8 * source, u32  sourceLen,u8 * dest, u32 * destLen, u32 max_buffer_size);

} // namespace RNXPCompression

} // namespace RNReplicaNet

#endif
#if defined(_WIN32) && !defined(__MINGW32__)
#include <crtdbg.h>
#endif
#include <assert.h>

using namespace RNReplicaNet;

XPCompression::XPCompression()
{
}


XPCompression::~XPCompression()
{
}

int XPCompression::CalculateMaximumMemory(int length)
{
	return length + (length / 8) + 256;
}

bool XPCompression::Compress(void *source_data,int source_length,void *destination_data,int *destination_length,int level)
{
	assert(source_data);
	assert(destination_data);
	assert(destination_length);
#if defined(_WIN32) && !defined(__MINGW32__)
	// Compression with heap checking on is very expensive, so we turn it off temporarily
	int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
	int tmpFlag2 = tmpFlag & ~_CRTDBG_CHECK_ALWAYS_DF;
	_CrtSetDbgFlag( tmpFlag2 );
#endif
	if (source_length == 0)
	{
		*destination_length = 0;
		return true;
	}
	RNXPCompression::Compression comp;
	bool ret = comp.Compress((const u8 *) source_data,(u32) source_length,(u8 *) destination_data,(u32 *) destination_length,level) == GBA_E_OK;
#if defined(_WIN32) && !defined(__MINGW32__)
	if ( tmpFlag != tmpFlag2 )
	{
		// Force a memory check because we turned it off above
		_CrtCheckMemory();
		// Restore the old debug state if it was changed
		_CrtSetDbgFlag( tmpFlag );
	}
#endif
	return ret;
}

bool XPCompression::Decompress(void *source_data,int source_length,void *destination_data,int *destination_length,int max_buffer_size)
{
	assert(source_data);
	assert(destination_data);
	assert(destination_length);
	*destination_length = 0;
	if (source_length == 0)
	{
		return true;
	}
	return RNXPCompression::Decompress((const u8 *) source_data,(u32) source_length,(u8 *) destination_data,(u32 *) destination_length,(u32) max_buffer_size) == GBA_E_OK;
}
//From: RNXPCompression/Compress.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <assert.h>

//Skipping: #include "RNXPCompression/Compress.h"

namespace RNReplicaNet
{

namespace RNXPCompression
{

// Define this to print out the total bits written during compression
//#define TOTAL_BITS_DEBUG

// Tweak values
const int gXPCompressionTweak1 = 5;
const int gXPCompressionTweak2 = 5;
const int gXPCompressionTweak3 = 5;
const int gXPCompressionTweak4 = 9;

#define FORCE_BYTE(x)						((unsigned char) (x))
#define FORCE_UNSIGNED(c)					c ## U

Compression::Compression()
{
}

Compression::~Compression()
{
}

void Compression::BitBufferWriteBits(void)
{
	u8 *p = mBitBufferCurrentOut;
	u32 b = mBitBufferValue;

	p[0] = FORCE_BYTE(b);
}


void Compression::BitBufferPutBit(unsigned char bit)
{
#ifdef TOTAL_BITS_DEBUG
	mTotalBits++;
#endif
	// Paranoia checking to ensure only the bottom bit is passed in
	if (bit)
	{
		bit = 1;
	}
	if (mBitBufferCount < 8)
	{
		// Fetch new output pointer
		if (mBitBufferCount == 0)
		{
			mBitBufferCurrentOut = mBitBufferNextOut;
			mBitBufferNextOut++;
		}

		mBitBufferValue = (mBitBufferValue << 1) + bit;
		mBitBufferCount++;
	}
	else
	{
		BitBufferWriteBits();
		mBitBufferCurrentOut = mBitBufferNextOut;
		mBitBufferNextOut++;
		mBitBufferValue = bit;
		mBitBufferCount = 1;
	}
}


void Compression::BitBufferPutByte(unsigned char b)
{
#ifdef TOTAL_BITS_DEBUG
	mTotalBits += 8;
#endif

	*mBitBufferNextOut++ = FORCE_BYTE(b);
}


void Compression::BitBufferFlushBits(unsigned char filler_bit)
{
#ifdef TOTAL_BITS_DEBUG
	printf("\n//mTotalBits before flush = %d\n",mTotalBits);
#endif

	if (mBitBufferCount > 0)
	{
		while (mBitBufferCount != 8)
		{
			BitBufferPutBit(filler_bit);
		}
		BitBufferWriteBits();
		mBitBufferCount = 0;
	}
	mBitBufferCurrentOut = NULL;
}


void Compression::PackValue(u32 i)
{
	if (i >= 2)
	{
		u32 t = 4;
		i += 2;
		do
		{
			t = t << 1;
		} while (i >= t);
		t = t >> 1;
		do
		{
			t = t >> 1;
			BitBufferPutBit((i & t) ? 1 : 0);
			BitBufferPutBit(0);
		} while (t > 2);
	}
	BitBufferPutBit((unsigned)i & 1);
	BitBufferPutBit(1);
}

void Compression::EncodeMatch(u32 len, const u32 offset)
{
#ifdef TOTAL_BITS_DEBUG
	printf("//EM%d,%d   ",len,offset);
#endif

	BitBufferPutBit(0);

	if (offset == mLastOffset)
	{
		BitBufferPutBit(0);
		BitBufferPutBit(1);
	}
	else
	{
		PackValue(1 + ((offset - 1) >> 8));
		BitBufferPutByte((unsigned)offset - 1);
	}

	// Here len can be 2,3,4... if offset <= LONG_OFFSET_THRESHOLD
	u32 workLen = len - 1;
	if (offset > LONG_OFFSET_THRESHOLD)
	{
		workLen--;
	}

	if (workLen >= 4)
	{
		// Effectively output 0
		BitBufferPutBit(0);
		BitBufferPutBit(0);
		// Followed by a packed bit representation
		PackValue(workLen - 4);
	}
	else
	{
		BitBufferPutBit(workLen > 1);
		BitBufferPutBit((unsigned)workLen & 1);
	}

	mLastOffset = offset;
}


int Compression::CodedMatchLength(u32 len, u32 offset)
{
	int b;
	if (len < 2 || (len == 2 && (offset > LONG_OFFSET_THRESHOLD)))
		return -1;

	u32 workLen = len - 2;
	if (offset > LONG_OFFSET_THRESHOLD)
	{
		workLen--;
	}

	if (offset == mLastOffset)
	{
		b = 1 + 2;
	}
	else
	{
		b = 1 + 10;
		offset = (offset - 1) >> 8;
		while (offset > 0)
		{
			b += 2;
			offset >>= 1;
		}
	}

	b += 2;
	if (workLen < 3)
	{
		return b;
	}

	// MPi: TODO: Research why tweaking this number slightly to 2 produces a 4 bytes saving on the small (53KB) test C64 file.
	workLen -= 3;

	do
	{
		b += 2;
		workLen >>= 1;
	} while (workLen > 0);

	return b;
}

//static FILE *fp = 0;

void Compression::EncodeLiteralRun(const u8 *litRun, u32 currentLitNum)
{
#ifdef TOTAL_BITS_DEBUG
	printf("//EL%d   ",currentLitNum);
#endif

	if (currentLitNum == 0)
	{
		return;
	}

	do
	{
		BitBufferPutBit(1);
#ifdef TOTAL_BITS_DEBUG
//		printf("$%x ",*litRun);
#endif

		BitBufferPutByte(*litRun++);
		currentLitNum--;

	} while (currentLitNum > 0);
}


int Compression::Compress( const u8 *in, u32 inLen,u8 *out, u32 *outLen,int compLevel)
{
	if ((compLevel < 1) || (compLevel > 10))
	{
		return GBA_E_INVALID_ARGUMENT;
	}

	mHashTable = 0;

	mTotalBits = 0;
	mLastOffset = 1;
	mInLen = inLen;
	mCurBuf = in;
	mBufEnd = in + inLen;

	mBitBufferValue = 0;
	mBitBufferCount = 0;
	mBitBufferCurrentOut = 0;
	mBitBufferNextOut = out;

	// Now the parts which decide compression speed and level
	mUpperLimitForwardMatchLen = compLevel * 1024;
	mMaximumRangeCheck = (compLevel * 32) / 11;
	mMaximumDictionaryBlocks = (compLevel * 131072) / 11;
	mDoExtendedDictionaryAdd = false;
	mDoForwardCheck = false;
	mUseDictionary = false;
	// MPi: TODO: For now we will always have the dictionary on even on the lowest compression.
	// It will be using only a small dictionary though.
//	if (compLevel > 1)		// Hence this "if" is commented out.
	{
		mUseDictionary = true;
	}
	if (compLevel > 6)
	{
		// Makes compression ~3 times slower than level 6
		mDoForwardCheck = true;
	}
	if (compLevel > 8)
	{
		// Makes compression ~2 times slower than level 8
		mDoExtendedDictionaryAdd = true;
	}
	// Special case for turning everything on to a sensible maximum
	if (compLevel == 10)
	{
		mUpperLimitForwardMatchLen = 0x7fffffff;
		mMaximumRangeCheck = 96;
		mMaximumDictionaryBlocks = 131072;
	}

	// If the input length is larger than this then switch to using the hash table.
	// The idea being that even though it uses more memory and constructs (clears) the table it is actually quicker for larger input blocks.
	if ((inLen >= (512*1024)) && (mMaximumDictionaryBlocks > 50000))
	{
// mHashTable is slower, even for large blocks. It has been removed. Bah.
//		mHashTable = new HashNode[65536];
	}

	const u8 *litRun = mCurBuf;			// Pointer to the start of the literal run
	u32 currentLitNum = 0;			// Number of literals to encode

	u32 curPos = 0;

	mLastMatchPos = 0x7fffffff;

	while (curPos < inLen)
	{
		// Now try a dictionary match
		int dictionaryBits = -1;
		u32 matchLen,matchOffset;
		Value *pValue = 0;
		if (DictionaryFindMatch(curPos,matchLen,matchOffset,&pValue))
		{
			dictionaryBits = CodedMatchLength(matchLen,matchOffset);
		}

		// Is length of the proposed match smaller than the number of bits needed for a literal version of the match length?
		if ((dictionaryBits != -1) && (dictionaryBits < (int)(matchLen * 9)))
		{
			// Yes, so the match results in a smaller size so we use it.

			// Now do a forward match test
			u32 curPos2 = curPos+1;
			int dictionaryBits2 = -1;
			u32 matchLen2,matchOffset2;
			bool firstMatchIsBetter = true;
			Value *pValue2 = 0;
			// This forward match test takes some extra time
			if ((curPos2 < inLen) && mDoForwardCheck)
			{
				if (DictionaryFindMatch(curPos2,matchLen2,matchOffset2,&pValue2))
				{
					dictionaryBits2 = CodedMatchLength(matchLen2,matchOffset2);

					if ((dictionaryBits2 != -1) && (dictionaryBits2 < (int)(matchLen2 * 9)))
					{
						// Figure out if it is shorter (in terms of bits saved to the file) to skip the first match and encode using this second try instead
						if ( (dictionaryBits + (int) gXPCompressionTweak1 + (int(matchLen2) * gXPCompressionTweak2) - (int(matchLen) * gXPCompressionTweak3) ) > (dictionaryBits2 + gXPCompressionTweak4))
						{
							firstMatchIsBetter = false;
						}
					}
				}
			}

			if (firstMatchIsBetter)
			{
				// Store any literals we have not already output
				EncodeLiteralRun(litRun,currentLitNum);
				// Store the match
				EncodeMatch(matchLen,matchOffset);
				curPos += matchLen;
				litRun = in + curPos;
				currentLitNum = 0;
//				printf("left = %d\n",inLen - curPos);
				continue;
			}
		}

		currentLitNum++;
		curPos++;
	}

	// Store any remaining literals
	EncodeLiteralRun(litRun,currentLitNum);

	// EOF
	BitBufferPutBit(0);
	PackValue(FORCE_UNSIGNED(0x1000000));
	BitBufferPutByte(0xff);
	BitBufferFlushBits(0);

	*outLen = (u32) (mBitBufferNextOut - out);

	// Makes sure the dictionary is freed
	DictionaryFree();

	delete []mHashTable;
	return GBA_E_OK;
}

void Compression::DictionaryFree(void)
{
//	printf("mValueByBytes = %d\n",mValueByBytes.size());
	std::list<Value*>::iterator st,en;
	st = mByAge.begin();
	en = mByAge.end();
	while (st != en)
	{
		Value *value = *st++;
		// No need to unlink this value because we are clearing the containers anyway
		delete value;
	}
	mValueByBytes.clear();
	mByAge.clear();
	mByPos.clear();
}

void Compression::DictionaryAdd(const u32 fromStartPos)
{
	if ((fromStartPos+1) >= mInLen)
	{
		return;
	}

	Bytes bytes(mCurBuf[fromStartPos],mCurBuf[fromStartPos+1]);
	u16 theHash = bytes.GetHash();
	if (mHashTable)
	{
		if (mHashTable[theHash].mPosAdded.find(fromStartPos) != mHashTable[theHash].mPosAdded.end())
		{
			return;
		}
	}
	else
	{
		// Quicker to do a find rather than allocating the Value block then failing on the first add
		if (mByPos.find(fromStartPos) != mByPos.end())
		{
			return;
		}
	}

#if 1
	Value *value = new Value;
	value->mPos = fromStartPos;
	value->mHashedValue = theHash;
	// Fill in the iterators
	if (mHashTable)
	{
		mHashTable[theHash].mValues.push_back(value);
		value->mHashValues = --mHashTable[theHash].mValues.end();

		std::pair<std::set<u32>::iterator,bool> ret = mHashTable[theHash].mPosAdded.insert(fromStartPos);
		assert(ret.second && "XPCompression couldn't add the pair");
		value->mHashPosAdded = ret.first;
	}
	else
	{
		value->mByBytes = mValueByBytes.insert(std::pair<Bytes,Value *>(bytes,value));
		std::pair<std::set<u32>::iterator,bool> ret = mByPos.insert(fromStartPos);
		assert(ret.second && "XPCompression couldn't add the pair");
		value->mByPos = ret.first;
	}
	mByAge.push_back(value);
	value->mByAge = --mByAge.end();

	// Expire old entries if we get too many
	// Saves memory at the expense of potential compression block matches
	// In most optimised STL implementation x.size() uses a counter variable so it isn't slow.
	if (mByAge.size() > mMaximumDictionaryBlocks)
	{
		// Get the oldest used block from the head of the list
		Value *value = mByAge.front();
		DictionaryFreeValue(value);
	}
#endif
}

void Compression::DictionaryFreeValue(Value *value)
{
	if (mHashTable)
	{
		mHashTable[value->mHashedValue].mValues.erase(value->mHashValues);
		mHashTable[value->mHashedValue].mPosAdded.erase(value->mHashPosAdded);
	}
	else
	{
		mValueByBytes.erase(value->mByBytes);
		mByPos.erase(value->mByPos);
	}
	mByAge.erase(value->mByAge);
	delete value;
}

bool Compression::DictionaryFindMatch(const u32 fromStartPos,u32 &len,u32 &matchOffset,Value **pValue)
{
	*pValue = 0;
	u32 bestMatchPos = fromStartPos,bestMatchLen = 0;
	u32 maxNumBytesAhead = mInLen - fromStartPos;
	int bestBitLength = 0;

	// Have we searched for this already? If yes, early out.
	if (mLastMatchPos == fromStartPos)
	{
		len = mLastMatchLen;
		matchOffset = mLastMatchOffset;
		*pValue = mLastMatchValue;
		return mLastMatchReturn;
	}

	mLastMatchPos = fromStartPos;
	mLastMatchLen = 0;
	mLastMatchOffset = 0;
	mLastMatchValue = 0;
	mLastMatchReturn = false;

	DictionaryAdd(fromStartPos);

	if (fromStartPos == 0)
	{
		return false;
	}

	// Try a simple backward search, slow but sure
	int pos;
	for (pos = fromStartPos - 1; (pos >= 0) && ((fromStartPos - pos) < mMaximumRangeCheck); pos--)
	{
		const u8 *start = mCurBuf + fromStartPos;
		const u8 *test = mCurBuf + pos;
		u32 i;
		u32 proposedMatchLen = 0;
		for (i=0; (i<mUpperLimitForwardMatchLen) && (i < maxNumBytesAhead);i++)
		{
			if (start[i] != test[i])
			{
				// This DictionaryAdd uses a bit more time and memory but improves the compression
				if (mDoExtendedDictionaryAdd)
				{
					DictionaryAdd(pos + i);
				}
				break;
			}
			proposedMatchLen = i+1;
		}
		if (proposedMatchLen == 0)
		{
			continue;
		}

		int proposedBits = CodedMatchLength(proposedMatchLen,fromStartPos - pos);
		// If we have a daft number of bits then don't use the match at all
		if (proposedBits == -1)
		{
			continue;
		}
		int proposedBitLength = (proposedMatchLen * 9) - proposedBits;

		if (proposedBitLength > bestBitLength)
		{
			bestMatchLen = proposedMatchLen;
			bestMatchPos = pos;
			bestBitLength = proposedBitLength;
		}
		// Logic end begins here
	}

	if (mUseDictionary && (maxNumBytesAhead >= 2) && (bestMatchLen < maxNumBytesAhead))
	{
		// Search the current dictionary for byte sequences that might match what we want
		Bytes bytes(mCurBuf[fromStartPos],mCurBuf[fromStartPos+1]);
		u16 theHash = bytes.GetHash();

		// MPi: TODO: With or without hash table there is quite a lot of common code. Make it common.
		if (mHashTable)
		{
			std::list<Value *>::iterator st = mHashTable[theHash].mValues.begin();
			std::list<Value *>::iterator en = mHashTable[theHash].mValues.end();
			//		printf(".\n");
			while (st != en)
			{
				Value *value = *st++;
				assert(value->mHashedValue == theHash);
				if (CommonValueChecks(value, fromStartPos, bestMatchPos, bestMatchLen, bestBitLength, maxNumBytesAhead))
				{
					*pValue = value;
				}
			}
		}
		else
		{
			std::multimap<Bytes,Value *,ByBytes>::iterator st = mValueByBytes.lower_bound(bytes);
			std::multimap<Bytes,Value *,ByBytes>::iterator en = mValueByBytes.upper_bound(bytes);
			//		printf(".\n");
			while (st != en)
			{
				Value *value = (*st++).second;
				assert(value->mHashedValue == theHash);
				if (CommonValueChecks(value, fromStartPos, bestMatchPos, bestMatchLen, bestBitLength, maxNumBytesAhead))
				{
					*pValue = value;
				}
			}
		}
	}

	if (bestMatchLen == 0)
	{
		return false;
	}

	// Do the forward match test with whatever the match is and calculate a new length based on how many times the sequence repeats
	const u8 *start = mCurBuf + fromStartPos + bestMatchLen;
	const u8 *test = mCurBuf + bestMatchPos + bestMatchLen;
	while ((start < mBufEnd) /*&& (bestMatchLen < mUpperLimitForwardMatchLen)*/)
	{
		if (*start != *test)
		{
			break;
		}
		start++;
		test++;
		bestMatchLen++;
	}

	// Now finally return the best match
	matchOffset = fromStartPos - bestMatchPos;
	len = bestMatchLen;

	mLastMatchLen = len;
	mLastMatchOffset = matchOffset;
	mLastMatchValue = *pValue;
	mLastMatchReturn = true;

	return true;
}



bool Compression::CommonValueChecks(Value *value,const u32 fromStartPos, u32 &bestMatchPos, u32 &bestMatchLen, int &bestBitLength, const u32 maxNumBytesAhead)
{
//	printf(".");
	// Check the byte sequences that are found
	u32 pos = value->mPos;
	// Stops us from comparing with the already completed backwards check
	if ((fromStartPos - pos) < mMaximumRangeCheck)
	{
		return false;
	}

	// Logic begins here
	const u8 *start = mCurBuf + fromStartPos;
	const u8 *test = mCurBuf + pos;
	u32 i;
	u32 proposedMatchLen = 0;
	for (i=0; (i<mUpperLimitForwardMatchLen) && (i < maxNumBytesAhead);i++)
	{
		if (start[i] != test[i])
		{
			break;
		}
		proposedMatchLen = i+1;
	}
	if (proposedMatchLen == 0)
	{
		return false;
	}

	int proposedBits = CodedMatchLength(proposedMatchLen,fromStartPos - pos);
	// If we have a daft number of bits then don't use the match at all
	if (proposedBits == -1)
	{
		return false;
	}
	int proposedBitLength = (proposedMatchLen * 9) - proposedBits;

	if (proposedBitLength > bestBitLength)
	{
		bestMatchLen = proposedMatchLen;
		bestMatchPos = pos;
		bestBitLength = proposedBitLength;

		// Because this entry is used it is put back at the end of the list again
		mByAge.erase(value->mByAge);
		mByAge.push_back(value);
		value->mByAge = --mByAge.end();
		return true;

	}

	return false;
}


} // namespace RNXPCompression

} // namespace RNReplicaNet
//From: RNXPCompression/Decompress.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
//Skipping: #include "RNXPCompression/Decompress.h"
#include <assert.h>

namespace RNReplicaNet
{

namespace RNXPCompression
{


static inline u32 GetNextBit(u8 &currentBits, u8 &bitCnt, const u8 * source, u32 &curLen)
{
	if (bitCnt)
	{
		// If there are bits left then shift up by one
		currentBits = currentBits << 1;
		bitCnt--;
	}
	else
	{
		currentBits = (u32)source[curLen];
		curLen++;
		bitCnt=7;
	}

	return (u32) ((currentBits >> 7) & 1);
}

int Decompress( const u8 * source, u32  sourceLen,u8 * dest, u32 * destLen, u32 max_buffer_size )
{
	u8 currentBits = 0;
	u32 curLen = 0, outLen = 0, lastworkOffset = 1;
	u8 bitCnt = 0;

	// First bit (source[0] & 0x80) encoded should always be 1 to indicate a literal byte because obviously we have no previous literals to copy from since we have no uncompressed data.
	// Future expansion could encode a 0 bit and use that as a flag for something.

	for (;;)
	{
		while (GetNextBit(currentBits,bitCnt,source,curLen))
		{
			if ( outLen >= max_buffer_size )
			{
				assert( !"Out of range offset detected" );
				return GBA_E_ERROR;
			}
			if ( curLen >= sourceLen )
			{
				assert( !"Read ahead offset detected" );
				return GBA_E_ERROR;
			}
			dest[outLen] = source[curLen];
			outLen++;
			curLen++;
		}

		u32 workOffset = 1;

		int maxBitFetchCount = 32;
		do
		{
			workOffset = (workOffset<<1) + GetNextBit(currentBits,bitCnt,source,curLen);
			maxBitFetchCount--;
			if ( maxBitFetchCount < 0 )
			{
				assert( !"Corrupt data detected" );
				return GBA_E_ERROR;
			}
		} while (!GetNextBit(currentBits,bitCnt,source,curLen));

		if (workOffset == 2)
		{
			workOffset = lastworkOffset;
		}
		else
		{
			workOffset = ((workOffset-3)<<8) + source[curLen];
			curLen++;
			if (workOffset == 0xffffffffU)
			{
				break;
			}
			workOffset++;
			lastworkOffset = workOffset;
		}

		u32 workLen = GetNextBit(currentBits,bitCnt,source,curLen);
		workLen = (workLen<<1) + GetNextBit(currentBits,bitCnt,source,curLen);

		if (workLen == 0)
		{
			maxBitFetchCount = 32;
			workLen++;
			do
			{
				workLen = (workLen<<1) + GetNextBit(currentBits,bitCnt,source,curLen);
				maxBitFetchCount--;
				if ( maxBitFetchCount < 0 )
				{
					assert( !"Corrupt data detected2" );
					return GBA_E_ERROR;
				}
			} while (!GetNextBit(currentBits,bitCnt,source,curLen));
			workLen += 2;
		}

		if (workOffset > LONG_OFFSET_THRESHOLD)
		{
			workLen++;
		}

		const u8 *workPos = dest + outLen - workOffset;
		if ( workOffset > outLen )
		{
			assert( !"Corrupt offset detected" );
			return GBA_E_ERROR;
		}

		if ( outLen >= max_buffer_size )
		{
			assert( !"Out of range offset detected1" );
			return GBA_E_ERROR;
		}
		dest[outLen] = *workPos;
		outLen++;
		workPos++;
		do
		{
			if ( outLen >= max_buffer_size )
			{
				assert( !"Out of range offset detected2" );
				return GBA_E_ERROR;
			}
			dest[outLen] = *workPos;
			outLen++;
			workPos++;
			workLen--;
		} while (workLen > 0);
	}
	*destLen = outLen;
	assert( curLen == sourceLen );
	return curLen == sourceLen ? (GBA_E_OK) : (GBA_E_ERROR);
}

} // namespace RNXPCompression

} // namespace RNReplicaNet
#ifndef REPLICANET_REMOVE_RNLOBBY
//From: RNLobby/AdvertiseClient.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <assert.h>
#include "RNLobby/Inc/AdvertiseClient.h"
//Include inline: #include "RNLobby/AdvertiseServerPrivate.h"
//From: RNLobby/AdvertiseServerPrivate.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef _ADVERTISESERVERPRIVATE_H_
#define _ADVERTISESERVERPRIVATE_H_

namespace RNReplicaNet
{

namespace RNLobby
{

namespace AdvertiseServerPrivate
{

enum kPacket
{
	kServerProbeFromConnect = 0,
	kClientAdvertise,
	kServerIndex,
	kClientStopAdvertise,
	kClientGetListings,
	kClientStopGetListings,
	kServerListingsStart,
	kServerListingsEntry,
	kServerListingsEnd,
	kClientStartRules,
	kClientAddRule,
	kClientEndRules,
	kClientStartPlayers,
	kClientAddPlayer,
	kClientEndPlayers,
	kClientRequestRules,
	kServerStartRules,
	kServerAddRule,
	kServerEndRules,
	kClientRequestPlayers,
	kServerStartPlayers,
	kServerAddPlayer,
	kServerEndPlayers,
	kClientMessage
};

} // namespace AdvertiseServerPrivate

} // namespace RNLobby

} // namespace RNReplicaNet

#endif
//Include inline: #include "RNLobby/BackendPrivate.h"
//From: RNLobby/BackendPrivate.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef _BACKENDPRIVATE_H_
#define _BACKENDPRIVATE_H_
//Skipping: #include "RNXPSockets/Inc/XPSocket.h"
#include "RNLobby/Inc/UserClient.h"

namespace RNReplicaNet
{

namespace RNLobby
{

namespace Backend
{

static const size_t kMaxServerCryptoLength = 8;

extern volatile bool gAnyServiceRequestedTitleID;
extern volatile bool gAuthenticateDone;

extern int GetTitleID(void);
extern void SetTitleID(const int titleID = 0);
extern bool GetIsAdvertised(void);
extern int GetAdvertisedID(void);
extern void SetAdvertised(const bool isAdvertised = false,const int advertisedID = 0);
extern int GetLoginID(void);
extern void SetLoginID(const int loginID = UserInfo::kAnyLoginID);
extern int GetSessionID(void);
// Set by the BackendClient when it verifies the titleID. This is a nonce from the BackendServer.
// SQL doesn't use 0 as the index for auto inserted rows
extern void SetSessionID(const int sessionID = 0);
extern XPAddress GetCodeServerAddress(void);
extern XPAddress GetNATServerAddress(void);
extern void GetNATDetectServerAddress(XPAddress &address1,XPAddress &address2);
extern XPAddress GetAdvertiseServerAddress(void);
extern XPAddress GetUserServerAddress(void);
extern XPAddress GetStatServerAddress(void);

extern const char *GetCodeServerCrypto(void);
extern const char *GetNATServerCrypto(void);
extern const char *GetNATDetectServerCrypto(void);
extern const char *GetAdvertiseServerCrypto(void);
extern const char *GetUserServerCrypto(void);
extern const char *GetStatServerCrypto(void);

// Support older compilers like VC6
#ifndef strnlen
static size_t strnlen(const char *s, size_t max) {
	register const char *p;
	for(p = s; *p && max--; ++p);
	return(p - s);
}
#endif

template<class ServerType> class ServerCryptoHelper
{
public:
	static void SetEncryption(ServerType *server,const char *crypto)
	{
		size_t maxLen = strnlen(crypto,kMaxServerCryptoLength);
		if (maxLen)
		{
			server->SetEncryptionKey(crypto,(int)maxLen);
		}
	}
};

extern bool SetAdvertiseServerInformation(const std::string &address, const int port, const std::string &crypto);
extern bool SetCodeServerInformation(const std::string &address, const int port, const std::string &crypto);
extern bool SetNATServerInformation(const std::string &address, const int port, const std::string &crypto);
extern bool SetNATDetectServerInformation(const std::string &address1, const int port1, const std::string &address2, const int port2, const std::string &crypto);
extern bool SetStatServerInformation(const std::string &address, const int port, const std::string &crypto);
extern bool SetUserServerInformation(const std::string &address, const int port, const std::string &crypto);
extern bool SetCloudServerInformation(const std::string &address, const int port, const std::string &crypto);

} // namespace Backend

} // namespace RNLobby

} // namespace RNReplicaNet

#endif
//Skipping: #include "RNXPURL/TransportUDP.h"
//Skipping: #include "RNXPURL/Inc/XPURL.h"
//Skipping: #include "RNXPURL/Inc/TransportConfig.h"

using namespace RNReplicaNet;
using namespace RNLobby;

static const int kMaxPingTries = 10;

AdvertiseClient::AdvertiseClient() : mBroadcast(0) , mBroadcastServerID(0) , mServerAddressSet(false)
{
//	mSerial = 0;	// This can always count up for as long as we want and doesn't need to be reset.
	CallbackTidy();
}

AdvertiseClient::~AdvertiseClient()
{
	Stop();
	Backend::SetAdvertised();
}

bool AdvertiseClient::Start(void)
{
	Stop();
	Backend::ServerCryptoHelper<AdvertiseClient>::SetEncryption(this,Backend::GetAdvertiseServerCrypto());
	XPURL::RegisterDefaultTransports();
	THREADSAFELOCK();
	if (!mServerAddressSet)
	{
		mServerAddress = Backend::GetAdvertiseServerAddress();
	}
	mPingServer.Begin(&mPingServer);
	XPURL xpurl;
	Transport *transport = xpurl.FindTransport("UDP@");
	assert(transport && "Unable to find UDP@ Transport");
	TransportUDP *transport2 = (TransportUDP *) transport->Allocate();
	assert(transport2);
	transport2->Connect("UDP@"+mServerAddress.Export());
	return BaseTransportServer::StartWithTransport(transport2,true,false);
}

static const int kAdvertisePort = 4400;
static const int kAdvertisePortStep = 10;

bool AdvertiseClient::StartLAN(void)
{
	THREADSAFELOCK();
	if (!mServerAddressSet)
	{
		mServerAddress = Backend::GetAdvertiseServerAddress();
	}
	mPingServer.Begin(&mPingServer);
	mBroadcast = new XPSocketUrgent();
	assert(mBroadcast);
	for (int i=0;i<kAdvertisePortStep;i++)
	{
		if (mBroadcast->Create(kAdvertisePort) == XPSOCK_EOK)
		{
			break;
		}
	}
	// Last gasp attempt
	if (!mBroadcast->IsAlive())
	{
		mBroadcast->Create();
	}
	mBroadcast->MakeBroadcast();
	return BaseTransportServer::StartWithTransport(0,true,false);
}

void AdvertiseClient::SetServer(const RNReplicaNet::XPAddress &address)
{
	mServerAddressSet = true;
	mServerAddress = address;
}

void AdvertiseClient::CallbackTidy(void)
{
	mPingServer.Terminate();
	Backend::SetAdvertised();
	mIsAdvertising = false;
	mDoingListing = false;
	mWantRules = false;
	mDoingRules = false;
	mWantPlayers = false;
	mDoingPlayers = false;
	delete mBroadcast;
	mBroadcast = 0;
	mBroadcastServerID = 0;

	mBroadcastURL.erase();
	mBroadcastData.erase();
	mGotReplyFrom.clear();
	mPingServer.mLocalServerInfo.clear();
	mPingServer.mServerIndexByAddress.clear();
	mPingServer.mServerIDsPingFinished.clear();
	mPingServer.mAnyActivePings = false;
	mRequestListingTime = 0.0f;
	mRequestRulesTimes.clear();
	mRequestPlayersTimes.clear();
	TransportConfig::SetInfoString();
}

bool AdvertiseClient::CallbackPoll(void)
{
	// First read OK due to it being read only
	if (!mPingServer.mServerIDsPingFinished.empty())
	{
		int gotIndex = 0;
		float gotLatency = 0.0f;
		float gotLoss = 0.0f;
		// Stack context for the lock
		{
			THREADSAFELOCKCLASS(mPingServer);
			// Second read now we have the lock
			if (!mPingServer.mServerIDsPingFinished.empty())
			{
				int index = *mPingServer.mServerIDsPingFinished.begin();
				mPingServer.mServerIDsPingFinished.pop_front();
				std::map<int,ServerInfo>::iterator found = mPingServer.mLocalServerInfo.find(index);
				if (found != mPingServer.mLocalServerInfo.end())
				{
					ServerInfo &info = (*found).second;
					gotIndex = index;
					gotLatency = info.GetLatency();
					gotLoss = info.GetPacketLoss();
				}
			}
		}
		if (gotIndex)
		{
			CallbackLatencyTo(gotIndex,gotLatency,gotLoss);
		}
	}
	if (mBroadcast && mBroadcast->IsAlive())
	{
		THREADSAFELOCK();

		// Trigger the LAN listings complete callback
		if (mRequestListingTime > 0.0f)
		{
			if ( FloatTime() > mRequestListingTime )
			{
				CallbackListingsComplete();
				mRequestListingTime = 0.0f;
			}
		}

		// Trigger the LAN rules complete callback
		std::list<std::pair<SysTimeType,int> >::iterator st1 = mRequestRulesTimes.begin();
		if (st1 != mRequestRulesTimes.end())
		{
			SysTimeType time = (*st1).first;
			if ( FloatTime() > time )
			{
				CallbackRulesComplete( (*st1).second );
				mRequestRulesTimes.erase(st1);
			}
		}

		// Trigger the LAN players complete callback
		std::list<std::pair<SysTimeType,int> >::iterator st2 = mRequestPlayersTimes.begin();
		if (st2 != mRequestPlayersTimes.end())
		{
			SysTimeType time = (*st2).first;
			if ( FloatTime() > time )
			{
				CallbackPlayersComplete( (*st2).second );
				mRequestPlayersTimes.erase(st2);
			}
		}

		DynamicMessageHelper message( 0 ,4096 );
		XPAddress addr;
		int ret;
		do
		{
			message.SetSize(0);
			ret = mBroadcast->Recv((char *)message.GetBuffer(),message.GetBufferSize(),&addr);
			if (ret < 8)
			{
				continue;
			}
			int NOnce;
			message >> NOnce;
			AdvertiseServerPrivate::kPacket packet;
			message >> packet;
			switch (packet)
			{
				default:
					break;

				case AdvertiseServerPrivate::kClientGetListings:
				{
					// MPi: Filtering isn't used for LAN queries.
					if (!mIsAdvertising)
					{
						break;
					}
					message.SetSize(0);
					message << NOnce;
					message << AdvertiseServerPrivate::kServerListingsEntry;
					message << mBroadcastServerID;
					int loginID = Backend::GetLoginID();
					message << loginID;
					message << mBroadcastURL;
					message << mBroadcastData;
					mBroadcast->Send((char *)message.GetBuffer(),message.GetSize(),addr);
					break;
				}

				case AdvertiseServerPrivate::kServerListingsEntry:
				{
					if (NOnce != mNOnce)
					{
						break;
					}
					int broadcastID;
					message >> broadcastID;
					std::pair<std::map<int,XPAddress>::iterator,bool> ret = mGotReplyFrom.insert(std::pair<int,XPAddress>(broadcastID,addr));
					if (!ret.second)
					{
						break;
					}
					int loginID;
					message >> loginID;
					ServerInfo serverInfo;
					std::string url;
					message >> url;
					std::string userData;
					message >> userData;
					serverInfo.mURL = url;
					serverInfo.mData = userData;
					serverInfo.mLoginID = loginID;
					serverInfo.mExternalIP = addr;
					THREADSAFELOCKCLASSNAMED(mPingServer);
					mPingServer.mLocalServerInfo.insert(std::pair<int,ServerInfo>(broadcastID,serverInfo));
					CallbackListingsEntry(broadcastID,UserInfo::kAnyLoginID,url.c_str(),userData.c_str(),0.0f,addr);
					break;
				}

				case AdvertiseServerPrivate::kClientRequestRules:
				{
					if (!mIsAdvertising)
					{
						break;
					}
					int serverIndex;
					message >> serverIndex;
					if (serverIndex != mBroadcastServerID)
					{
						break;
					}
					mCurrentReply = addr;
					mCurrentNOnce = NOnce;
					mDoingRules = true;
					CallbackWantRules();
					mDoingRules = false;
					break;
				}

				case AdvertiseServerPrivate::kServerAddRule:
				{
					if (NOnce != mNOnce)
					{
						break;
					}

					int broadcastID;
					message >> broadcastID;

					std::map<int,XPAddress>::iterator found = mGotReplyFrom.find(broadcastID);
					if (found == mGotReplyFrom.end())
					{
						break;
					}

					std::string rule;
					message >> rule;
					std::string userData;
					message >> userData;

					CallbackRule(broadcastID,rule.c_str(),userData.c_str());

					break;
				}

				case AdvertiseServerPrivate::kClientRequestPlayers:
				{
					if (!mIsAdvertising)
					{
						break;
					}
					int serverIndex;
					message >> serverIndex;
					if (serverIndex != mBroadcastServerID)
					{
						break;
					}
					mCurrentReply = addr;
					mCurrentNOnce = NOnce;
					mDoingPlayers = true;
					CallbackWantPlayers();
					mDoingPlayers = false;
					break;
				}

				case AdvertiseServerPrivate::kServerAddPlayer:
				{
					if (NOnce != mNOnce)
					{
						break;
					}

					int broadcastID;
					message >> broadcastID;

					std::map<int,XPAddress>::iterator found = mGotReplyFrom.find(broadcastID);
					if (found == mGotReplyFrom.end())
					{
						break;
					}

					std::string name;
					message >> name;
					std::string userData;
					message >> userData;
					int loginID;
					message >> loginID;

					CallbackPlayer(broadcastID,name.c_str(),userData.c_str(),loginID);

					break;
				}

				case AdvertiseServerPrivate::kClientMessage:
				{
					if (!mIsAdvertising)
					{
						break;
					}
					int serverIndex;
					message >> serverIndex;
					if (serverIndex != mBroadcastServerID)
					{
						break;
					}
					int length;
					message >> length;

					if ((length > 512) || (length <= 0))
					{
						break;
					}

					CallbackMessageReceived(0,message.GetCurrentPosition(),length);
					break;
				}
			}
		} while (ret > 0);
		return true;
	}
	if (mWantRules && mTransport)
	{
		mWantRules = false;

		DynamicMessageHelper message;
		message << mNOnce;
		message << AdvertiseServerPrivate::kClientStartRules;
		PackageAndSendData(mTransport,message);

		mDoingRules = true;
		CallbackWantRules();
		mDoingRules = false;

		message.SetSize(0);
		message << mNOnce;
		message << AdvertiseServerPrivate::kClientEndRules;
		PackageAndSendData(mTransport,message);
	}

	if (mWantPlayers && mTransport)
	{
		mWantPlayers = false;

		DynamicMessageHelper message;
		message << mNOnce;
		message << AdvertiseServerPrivate::kClientStartPlayers;
		PackageAndSendData(mTransport,message);

		mDoingPlayers = true;
		CallbackWantPlayers();
		mDoingPlayers = false;

		message.SetSize(0);
		message << mNOnce;
		message << AdvertiseServerPrivate::kClientEndPlayers;
		PackageAndSendData(mTransport,message);
	}
	return true;
}

bool AdvertiseClient::CallbackParseValidMessage(Transport *transport,DynamicMessageHelper &message,const size_t length)
{
	int NOnce;
	message >> NOnce;
	AdvertiseServerPrivate::kPacket packet;
	message >> packet;

	switch(packet)
	{
		default:
			break;

		case AdvertiseServerPrivate::kServerProbeFromConnect:
		{
			CallbackConnectionEstablished(mTransport);
			break;
		}

		case AdvertiseServerPrivate::kServerIndex:
		{
			if (NOnce == mNOnce)
			{
				int advertisedID;
				message >> advertisedID;
				Backend::SetAdvertised(true,advertisedID);
				CallbackGotServerIndex(advertisedID);
				mWantRules = true;
				mWantPlayers = true;
			}
			else
			{
				return false;
			}
			break;
		}

		case AdvertiseServerPrivate::kServerListingsStart:
		{
			if (NOnce == mNOnce)
			{
				unsigned int numResults;
				message >> numResults;
				CallbackListingsBegin();
			}
			else
			{
				return false;
			}
			break;
		}

		case AdvertiseServerPrivate::kServerListingsEntry:
		{
			if (NOnce == mNOnce)
			{
				int Id;
				int loginID;
				std::string url;
				std::string userData;
				XPAddress addr;
				float age;

				ServerInfo serverInfo;
				message >> Id;
				message >> loginID;
				message >> url;
				message >> userData;
				serverInfo.mURL = url;
				serverInfo.mData = userData;
				serverInfo.mLoginID = loginID;
				message >> addr;
				serverInfo.mExternalIP = addr;
				message >> age;
				THREADSAFELOCKCLASSNAMED(mPingServer);
				mPingServer.mLocalServerInfo.insert(std::pair<int,ServerInfo>(Id,serverInfo));
				CallbackListingsEntry(Id,loginID,url.c_str(),userData.c_str(),age,addr);
			}
			else
			{
				return false;
			}
			break;
		}

		case AdvertiseServerPrivate::kServerListingsEnd:
		{
			if (NOnce == mNOnce)
			{
				CallbackListingsComplete();
			}
			else
			{
				return false;
			}
			break;
		}

		case AdvertiseServerPrivate::kServerStartRules:
		{
			if (NOnce == mNOnce)
			{
				int Id;
				message >> Id;
				CallbackRulesBegin(Id);
			}
			else
			{
				return false;
			}
			break;
		}

		case AdvertiseServerPrivate::kServerAddRule:
		{
			if (NOnce == mNOnce)
			{
				int Id;
				message >> Id;
				std::string rule;
				message >> rule;
				std::string data;
				message >> data;
				CallbackRule(Id,rule.c_str(),data.c_str());
			}
			else
			{
				return false;
			}
			break;
		}

		case AdvertiseServerPrivate::kServerEndRules:
		{
			if (NOnce == mNOnce)
			{
				int Id;
				message >> Id;
				CallbackRulesComplete(Id);
			}
			else
			{
				return false;
			}
			break;
		}

		case AdvertiseServerPrivate::kServerStartPlayers:
		{
			if (NOnce == mNOnce)
			{
				int Id;
				message >> Id;
				CallbackPlayersBegin(Id);
			}
			else
			{
				return false;
			}
			break;
		}

		case AdvertiseServerPrivate::kServerAddPlayer:
		{
			if (NOnce == mNOnce)
			{
				int Id;
				message >> Id;
				std::string name;
				message >> name;
				std::string data;
				message >> data;
				int loginID;
				message >> loginID;
				CallbackPlayer(Id,name.c_str(),data.c_str(),loginID);
			}
			else
			{
				return false;
			}
			break;
		}

		case AdvertiseServerPrivate::kServerEndPlayers:
		{
			if (NOnce == mNOnce)
			{
				int Id;
				message >> Id;
				CallbackPlayersComplete(Id);
			}
			else
			{
				return false;
			}
			break;
		}

		case AdvertiseServerPrivate::kClientMessage:
		{
			if (NOnce == mNOnce)
			{
				int sourceLoginID;
				message >> sourceLoginID;
				int length;
				message >> length;

				if ((length > 512) || (length <= 0))
				{
					return false;
				}

				CallbackMessageReceived(sourceLoginID,message.GetCurrentPosition(),length);
			}
			else
			{
				return false;
			}
			break;
		}


	}
	return true;
}

bool AdvertiseClient::AdvertiseSession(const char *url,const char *userData)
{
	assert(url);
	assert(userData);
	if (mIsAdvertising && (url == mCurrentURL) && (userData == mCurrentUserData))
	{
		return true;
	}
	mIsAdvertising = true;

	mCurrentURL = url;
	mCurrentUserData = userData;

	TransportConfig::SetInfoString(mCurrentURL + mCurrentUserData);

	if (mBroadcast)
	{
		THREADSAFELOCK();
		mBroadcastURL = mCurrentURL;
		mBroadcastData = mCurrentUserData;
		mBroadcastServerID = mNOnce;
		CallbackGotServerIndex(mBroadcastServerID);
		return true;
	}
	THREADSAFELOCK();
	if (!mTransport)
	{
		return false;
	}
	DynamicMessageHelper message;
	message << mNOnce;
	message << AdvertiseServerPrivate::kClientAdvertise;
	message << Backend::GetTitleID();
	message << Backend::GetLoginID();
	message << url;
	message << userData;
	XPAddress IPAddr;
	std::string addr = std::string(mTransport->ExportURL().c_str() + mTransport->CanAccept().length());
	IPAddr.Import(addr);
	message << IPAddr;
	PackageAndSendData(mTransport,message);

	return true;
}

bool AdvertiseClient::RulesChanged(void)
{
	if (!mTransport)
	{
		return false;
	}
	// MPi: TODO: Put some client and server side throttling check here
	mWantRules = true;
	return true;
}

bool AdvertiseClient::PlayersChanged(void)
{
	if (!mTransport)
	{
		return false;
	}
	// MPi: TODO: Put some client and server side throttling check here
	mWantPlayers = true;
	return true;
}

bool AdvertiseClient::StopAdvertiseSession(void)
{
	TransportConfig::SetInfoString();
	if (!mIsAdvertising)
	{
		return true;
	}
	if (mBroadcast)
	{
		THREADSAFELOCK();
		mBroadcastURL.erase();
		mBroadcastData.erase();
		mBroadcastServerID = 0;
		return true;
	}
	THREADSAFELOCK();
	if (!mTransport)
	{
		return false;
	}
	mIsAdvertising = false;
	DynamicMessageHelper message;
	message << mNOnce;
	message << AdvertiseServerPrivate::kClientStopAdvertise;
	PackageAndSendData(mTransport,message);
	Backend::SetAdvertised();

	return true;
}

bool AdvertiseClient::GetListings(const unsigned int maxResults,const unsigned int offset,const char *filter)
{
	if (mBroadcast)
	{
		assert(!filter && "AdvertiseClient::GetListings filter should be null. Filtering is not supported for LAN queries.");
		GenerateNewNonce();
		DynamicMessageHelper message;
		message << mNOnce;
		message << AdvertiseServerPrivate::kClientGetListings;
		// MPi: Filtering isn't used for LAN queries.
		for (int i=0;i<kAdvertisePortStep;i++)
		{
			mBroadcast->Send((char *)message.GetBuffer(),message.GetSize(),XPAddress(kAdvertisePort + i,255,255,255,255));
			// Send a packet to ourselves to get around some machines local host routing problems
			mBroadcast->Send((char *)message.GetBuffer(),message.GetSize(),XPAddress(kAdvertisePort + i,127,0,0,1));
		}
		mGotReplyFrom.clear();
		// Stack context for lock
		{
			// MPi: TODO: Tidy this and others like it into a common block of code.
			THREADSAFELOCKCLASSNAMED(mPingServer);
			mPingServer.mLocalServerInfo.clear();
			mPingServer.mServerIndexByAddress.clear();
			mPingServer.mServerIDsPingFinished.clear();
			mPingServer.mAnyActivePings = false;
		}
		mRequestListingTime = FloatTime()+0.5f;
		CallbackListingsBegin();
		return true;
	}
	if (mDoingListing)
	{
		StopListings();
	}

	// Stack context for lock
	{
		THREADSAFELOCKCLASSNAMED(mPingServer);
		mPingServer.mLocalServerInfo.clear();
		mPingServer.mServerIndexByAddress.clear();
		mPingServer.mServerIDsPingFinished.clear();
		mPingServer.mAnyActivePings = false;
	}
	THREADSAFELOCK();
	if (!mTransport)
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << AdvertiseServerPrivate::kClientGetListings;
	message << Backend::GetTitleID();
	message << Backend::GetLoginID();
	message << maxResults;
	message << offset;
	message << filter;
	PackageAndSendData(mTransport,message);

	return true;
}

bool AdvertiseClient::StopListings(void)
{
	if (mBroadcast)
	{
		return true;
	}
	if (!mDoingListing)
	{
		return true;
	}
	THREADSAFELOCK();
	if (!mTransport)
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << AdvertiseServerPrivate::kClientStopGetListings;
	PackageAndSendData(mTransport,message);

	mDoingListing = true;

	return true;
}

bool AdvertiseClient::AddRule(const char *rule,const char *userData)
{
	assert(rule);
	assert(userData);
	if (!mDoingRules)
	{
		return false;
	}

	if (mBroadcast)
	{
		DynamicMessageHelper message;
		message.SetSize(0);
		message << mCurrentNOnce;
		message << AdvertiseServerPrivate::kServerAddRule;
		message << mBroadcastServerID;
		message << rule;
		message << userData;
		mBroadcast->Send((char *)message.GetBuffer(),message.GetSize(),mCurrentReply);
		return true;
	}
	THREADSAFELOCK();
	if (!mTransport)
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << AdvertiseServerPrivate::kClientAddRule;
	message << rule;
	message << userData;
	PackageAndSendData(mTransport,message);
	return true;
}

bool AdvertiseClient::AddPlayer(const char *name,const char *userData,const int loginID)
{
	assert(name);
	assert(userData);
	if (!mDoingPlayers)
	{
		return false;
	}

	if (mBroadcast)
	{
		DynamicMessageHelper message;
		message.SetSize(0);
		message << mCurrentNOnce;
		message << AdvertiseServerPrivate::kServerAddPlayer;
		message << mBroadcastServerID;
		message << name;
		message << userData;
		message << loginID;
		mBroadcast->Send((char *)message.GetBuffer(),message.GetSize(),mCurrentReply);
		return true;
	}
	THREADSAFELOCK();
	if (!mTransport)
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << AdvertiseServerPrivate::kClientAddPlayer;
	message << name;
	message << userData;
	message << loginID;
	PackageAndSendData(mTransport,message);
	return true;
}

bool AdvertiseClient::RequestRules(const int serverIndex)
{
	if (serverIndex < 0)
	{
		return false;
	}

	if (mBroadcast)
	{
		std::map<int,XPAddress>::iterator found = mGotReplyFrom.find(serverIndex);
		if (found == mGotReplyFrom.end())
		{
			return false;
		}
		THREADSAFELOCK();
		CallbackRulesBegin(serverIndex);
		DynamicMessageHelper message;
		message << mNOnce;
		message << AdvertiseServerPrivate::kClientRequestRules;
		message << serverIndex;
		mBroadcast->Send((char *)message.GetBuffer(),message.GetSize(),(*found).second);
		mRequestRulesTimes.push_back(std::pair<SysTimeType,int>(FloatTime()+0.5f,serverIndex));
		return true;
	}
	THREADSAFELOCK();
	if (!mTransport)
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << AdvertiseServerPrivate::kClientRequestRules;
	message << serverIndex;
	PackageAndSendData(mTransport,message);
	return true;
}

bool AdvertiseClient::RequestPlayers(const int serverIndex)
{
	if (serverIndex < 0)
	{
		return false;
	}

	if (mBroadcast)
	{
		std::map<int,XPAddress>::iterator found = mGotReplyFrom.find(serverIndex);
		if (found == mGotReplyFrom.end())
		{
			return false;
		}
		CallbackPlayersBegin(serverIndex);
		DynamicMessageHelper message;
		message << mNOnce;
		message << AdvertiseServerPrivate::kClientRequestPlayers;
		message << serverIndex;
		mBroadcast->Send((char *)message.GetBuffer(),message.GetSize(),(*found).second);
		mRequestPlayersTimes.push_back(std::pair<SysTimeType,int>(FloatTime()+0.5f,serverIndex));
		return true;
	}
	THREADSAFELOCK();
	if (!mTransport)
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << AdvertiseServerPrivate::kClientRequestPlayers;
	message << serverIndex;
	PackageAndSendData(mTransport,message);
	return true;
}

bool AdvertiseClient::RequestLatency(const int serverIndex)
{
	if (serverIndex < 0)
	{
		return false;
	}

	THREADSAFELOCKCLASS(mPingServer);

	std::map<int,ServerInfo>::iterator found = mPingServer.mLocalServerInfo.find(serverIndex);
	if (found == mPingServer.mLocalServerInfo.end())
	{
		return false;
	}

	(*found).second.StartLatencyCalculate();

	return true;
}

bool AdvertiseClient::SendReliableMessage(const int serverIndex,const void *data,const int length)
{
	assert(data);
	assert(length);
	if ((serverIndex < 0) || !data || (length <= 0) || (length > 512))
	{
		return false;
	}

	if (mBroadcast)
	{
		std::map<int,XPAddress>::iterator found = mGotReplyFrom.find(serverIndex);
		if (found == mGotReplyFrom.end())
		{
			return false;
		}
		DynamicMessageHelper message;
		message << mNOnce;
		message << AdvertiseServerPrivate::kClientMessage;
		message << serverIndex;
		message << length;
		message.AddData(data,length);
		mBroadcast->Send((char *)message.GetBuffer(),message.GetSize(),(*found).second);
		mRequestPlayersTimes.push_back(std::pair<SysTimeType,int>(FloatTime()+0.5f,serverIndex));
		return true;
	}
	THREADSAFELOCK();
	if (!mTransport)
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << AdvertiseServerPrivate::kClientMessage;
	message << serverIndex;
	int loginID = Backend::GetLoginID();
	message << loginID;
	message << length;
	message.AddData(data,length);
	PackageAndSendData(mTransport,message);
	return true;
}

AdvertiseClient::PingServer::PingServer()
{
	mPingSocket = 0;
	mAnyActivePings = false;
	mAPingSent = false;
}

AdvertiseClient::PingServer::~PingServer()
{
	Terminate();
	if (mPingSocket)
	{
		XPSock_Close(mPingSocket);
		mPingSocket = 0;
	}
}

int AdvertiseClient::PingServer::ThreadEntry(void)
{
	mPingSocket = XPSock_ICMPCreate();
	while (true)
	{
		bool anyPingsBeingDone = false;
		// First read without mutex safe because it is a read only operation
		// MPi: TODO: Consider separating the ping requests from mLocalServerInfo so that when all pings are done this list iteration isn't needed.
		if (!mLocalServerInfo.empty())
		{
			THREADSAFELOCK();
			unsigned short id,seq;
			unsigned int theTime;
			XPAddress retAddr;
			if (!mLocalServerInfo.empty())
			{
				std::map<int,ServerInfo>::iterator st = mLocalServerInfo.begin();
				while (st != mLocalServerInfo.end())
				{
					// MPi: Put in some checks for maximum number of ping sends done in a certain amount of time...
					ServerInfo &info = (*st).second;
					if (info.mWantPing)
					{
						anyPingsBeingDone = true;
						if ( ((BaseTransportServer::FloatTime() - info.mLastPingSentTime) > 1.0f ) || (info.mLastPingSentTime < 0.0f))
						{
							// MPi: TODO: Note the id and seq and only accept the reply if it is the same...
							XPAddress addr = info.mExternalIP;
							addr.port = 0;
							if (!info.mPingAcked && info.mPingTries > 0)
							{
								info.mPacketsLost++;
							}
							if (info.mPingTries == kMaxPingTries)
							{
								info.mWantPing = false;
								mServerIDsPingFinished.push_back((*st).first);
							}
							else
							{
								if (info.mPingTries == 0)
								{
									mServerIndexByAddress.insert(std::pair<XPAddress,int>(addr,(*st).first));
								}
								XPSock_ICMPSendPing(mPingSocket,&addr,&id,&seq,&theTime);
								info.mLastPingSentTime = BaseTransportServer::FloatTime();
								info.mPingAcked = false;
								info.mPingTries++;
								mAPingSent = true;
							}
						}
					}
					st++;
				}
			}
			if (mAPingSent)
			{
				// This wait is on any packet data being received, with a maximum wait time to avoid blocking the thread forever.
				XPSock_ICMPWaitForPing(mPingSocket,0.1f);
				int ret;
				do
				{
					ret = XPSock_ICMPRecvPing(mPingSocket,&retAddr,&id,&seq,&theTime);
					// MPi: TODO: Maybe instead of matching with the address there could be a match with the id and seq instead with a double check that the address is correct.
					// Although matching with an address seems to work quite well for hosts that are hosting more than one game session.
					// There are however packet loss calculation inaccuracies with hosts that have more than one session advertised.
					if (ret > 0)
					{
						anyPingsBeingDone = true;
						THREADSAFELOCK();
						std::multimap<XPAddress,int>::iterator lb = mServerIndexByAddress.lower_bound(retAddr);
						std::multimap<XPAddress,int>::iterator ub = mServerIndexByAddress.upper_bound(retAddr);
						while (lb != ub)
						{
							int index = (*lb++).second;
							std::map<int,ServerInfo>::iterator found2 = mLocalServerInfo.find(index);
							if (found2 != mLocalServerInfo.end())
							{
								ServerInfo &info = (*found2).second;
								if (info.mWantPing)
								{
									info.mPingAcked = true;
									info.mLastPingSentTime = -10.0f;	// Trigger another send ASAP
									info.mTotalRoundTripTime += SysTimeType(theTime) / 1000.0f;
									info.mReplies++;
									if (info.mPingTries >= kMaxPingTries)
									{
										info.mWantPing = false;
										mServerIDsPingFinished.push_back(index);
									}
								}
							}
						}
					}
				} while (ret > 0);
			}
			else	//< if (mAPingSent)
			{
				// No pings sent at all, ever, so just wait
				Sleep(100);
			}
		} // End if (!mLocalServerInfo.empty())

		// Grab the status here 
		mAnyActivePings = anyPingsBeingDone;

		if (!anyPingsBeingDone)
		{
			// Nothing to do so sleep for a bit
			Sleep(10);
		}

		CheckQuit();
	}
	return 0;
}

void AdvertiseClient::PingServer::ThreadExiting(const int returnCode)
{
	if (mPingSocket)
	{
		XPSock_Close(mPingSocket);
		mPingSocket = 0;
	}
}

bool AdvertiseClient::GetAnyActivePings(void) const
{
	return mPingServer.mAnyActivePings;
}

AdvertiseClient::ServerInfo::ServerInfo()
{
	mWantPing = false;
	mPingTries = 0;
	mLastPingSentTime = -10.0f;
	mPacketsLost = 0;
	mReplies = 0;
	mTotalRoundTripTime = 0.0f;
}

void AdvertiseClient::ServerInfo::StartLatencyCalculate(void)
{
	mWantPing = true;
	mPingTries = 0;
	mLastPingSentTime = -10.0f;
	mPacketsLost = 0;
	mReplies = 0;
	mTotalRoundTripTime = 0.0f;
	mPingAcked = false;
}

// If the latency has not been calculated then it returns a value less than 0.0f
float AdvertiseClient::ServerInfo::GetLatency(void)
{
	if (!mReplies)
	{
		return -1.0f;
	}
	return (float)((mTotalRoundTripTime / float(mReplies)) / 2.0f);
}

float AdvertiseClient::ServerInfo::GetPacketLoss(void)
{
	if (!mPingTries)
	{
		return 0.0f;
	}
	if (mReplies > mPingTries)
	{
		mReplies = mPingTries;
	}
	return 100.0f * float(mPacketsLost) / float(mPingTries);
}
//From: RNLobby/BackendClient.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <time.h>
#include <string.h>

#include "RNLobby/Inc/BackendClient.h"
//Skipping: #include "RNLobby/BackendPrivate.h"
//Skipping: #include "RNPlatform/Inc/CheckSum.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
//Skipping: #include "RNPlatform/Inc/CheckSum.h"
#include "RNLobby/Inc/NOnceGen.h"

using namespace RNReplicaNet;
using namespace RNLobby;


volatile static bool sOrderingCheck = true;

BackendClient::BackendClient() : mAddress(BackendServer::kDefaultPort,127,0,0,1) , mUseReleaseServers(false)
{
	if (sOrderingCheck)
	{
		assert(!Backend::gAnyServiceRequestedTitleID && "Trying to construct BackendClient after an RNLobby service requests the TitleID. See BackendClient::DisableValidateOrderingCheck()");
	}
	CleanQuery();
}

BackendClient::~BackendClient()
{
	Stop();
}

bool BackendClient::Start(const int titleID,const char *encryptionKey)
{
	if (sOrderingCheck)
	{
		assert(!Backend::gAnyServiceRequestedTitleID && "Trying to call BackendClient::Start() after an RNLobby service requests the TitleID. See BackendClient::DisableValidateOrderingCheck()");
	}
	assert(encryptionKey);
	Stop();

	// First of all make sure things are reset.
	// MPi: TODO: Consider moving this to a function so that it can be called by the PlatformHeap::ForceFree() mechanism
	Backend::SetTitleID();
	Backend::SetAdvertised();
	Backend::SetLoginID();
	Backend::gAuthenticateDone = false;

	CleanQuery();

	mTitleID = titleID;
	mEncryptionKey  = encryptionKey;

	XPSock_Init();

	// TitleID 0 is a special case and does not set the addresses for the other services, therefore it uses the locally hosted services instead.
	if (mTitleID == 0)
	{
		mReply = BackendServer::kReply_ValidTitleID;
		union
		{
			float f;
			int i;
		} aNonce;
		aNonce.f = (float)FloatTime();
		NOnceGen::SetNOnce(aNonce.i);
		Backend::SetSessionID(aNonce.i);
		Backend::SetTitleID(mTitleID);
		Backend::gAuthenticateDone = true;
		CallbackCompleted();
	}
	else
	{
		t_XPSocket *sock = XPSock_UrgentCreate(XPSOCK_PORT_ANY);
		BaseServer::StartWithSocket(sock);
	}
	return true;
}

bool BackendClient::GetCompleted(void)
{
	return !GetIsRunning();
}

BackendServer::Reply BackendClient::GetReply(void) const
{
	return mReply;
}

void BackendClient::CleanQuery(void)
{
	mReply = BackendServer::kReply_ServerCannotBeContacted;
	mTitleID = 0;
	mLastSentTime = -10.0f;
	mTries = 0;
	mAddressGot = false;
}

bool BackendClient::CallbackServerAddress(XPAddress &address)
{
	char name[32];
	if (mUseReleaseServers)
	{
		sprintf(name,"s%d.rnlobby.com",((mTitleID ^ (mTitleID >> 8) ^ (mTitleID >> 16) ^ (mTitleID >> 24)) & 3)+1);
	}
	else
	{
		sprintf(name,"ds%d.rnlobby.com",((mTitleID ^ (mTitleID >> 8) ^ (mTitleID >> 16) ^ (mTitleID >> 24)) & 3)+1);
	}
	int ret = XPSock_Resolve(&address,name);
	return (ret == XPSOCK_EOK);
}

static const int kClientMaxTries = 20;
static const float kClientRetryTime = 0.2f;

#include "RNLobby/Inc/BackendServer.h"

bool BackendClient::CallbackParseValidMessage(DynamicMessageHelper &message,const size_t length,const XPAddress &address)
{
	int NOnce;
	message >> NOnce;
	if (NOnce != mNOnce)
	{
		// NOnce doesn't match. Bad reply.
		return true;
	}
	int serverNonce;
	message >> serverNonce;

	message >> mReply;
	if (mReply == BackendServer::kReply_ValidTitleID)
	{
		BackendServer::TitleIDInfo info;

		message >> info.mRLSrvAdvertiseAddress;
		message >> info.mRLSrvAdvertisePort;
		message >> info.mRLSrvAdvertiseCrypto;
		message >> info.mRLSrvCodeAddress;
		message >> info.mRLSrvCodePort;
		message >> info.mRLSrvCodeCrypto;
		message >> info.mRLSrvNATAddress;
		message >> info.mRLSrvNATPort;
		message >> info.mRLSrvNATCrypto;
		message >> info.mRLSrvNATDetect1Address;
		message >> info.mRLSrvNATDetect1Port;
		message >> info.mRLSrvNATDetect2Address;
		message >> info.mRLSrvNATDetect2Port;
		message >> info.mRLSrvNATDetectCrypto;
		message >> info.mRLSrvStatAddress;
		message >> info.mRLSrvStatPort;
		message >> info.mRLSrvStatCrypto;
		message >> info.mRLSrvUserAddress;
		message >> info.mRLSrvUserPort;
		message >> info.mRLSrvUserCrypto;
		message >> info.mRLSrvCloudAddress;
		message >> info.mRLSrvCloudPort;
		message >> info.mRLSrvCloudCrypto;

		// Default to this error first
		mReply = BackendServer::kReply_ServerCannotBeContacted;
		if (!Backend::SetAdvertiseServerInformation(info.mRLSrvAdvertiseAddress,info.mRLSrvAdvertisePort,info.mRLSrvAdvertiseCrypto))
		{
			CallbackCompleted();
			return false;
		}
		if (!Backend::SetCodeServerInformation(info.mRLSrvCodeAddress,info.mRLSrvCodePort,info.mRLSrvCodeCrypto))
		{
			CallbackCompleted();
			return false;
		}
		if (!Backend::SetNATServerInformation(info.mRLSrvNATAddress,info.mRLSrvNATPort,info.mRLSrvNATCrypto))
		{
			CallbackCompleted();
			return false;
		}
		if (!Backend::SetNATDetectServerInformation(info.mRLSrvNATDetect1Address,info.mRLSrvNATDetect1Port,info.mRLSrvNATDetect2Address,info.mRLSrvNATDetect2Port,info.mRLSrvNATDetectCrypto))
		{
			CallbackCompleted();
			return false;
		}
		if (!Backend::SetStatServerInformation(info.mRLSrvStatAddress,info.mRLSrvStatPort,info.mRLSrvStatCrypto))
		{
			CallbackCompleted();
			return false;
		}
		if (!Backend::SetUserServerInformation(info.mRLSrvUserAddress,info.mRLSrvUserPort,info.mRLSrvUserCrypto))
		{
			CallbackCompleted();
			return false;
		}
		if (!Backend::SetCloudServerInformation(info.mRLSrvCloudAddress,info.mRLSrvCloudPort,info.mRLSrvCloudCrypto))
		{
			CallbackCompleted();
			return false;
		}
		// Then everything looks OK so carry on
		mReply = BackendServer::kReply_ValidTitleID;
		NOnceGen::SetNOnce(serverNonce);
		Backend::SetSessionID(serverNonce);
		Backend::SetTitleID(mTitleID);
		Backend::gAuthenticateDone = true;
	}
	CallbackCompleted();
	return false;
}

bool BackendClient::CallbackPoll(void)
{
	if (!mAddressGot)
	{
		mAddressGot = true;
		if (mUseReleaseServers)
		{
			mAddress.port = RNReplicaNet::RNLobby::BackendServer::kDefaultPort;
		}
		else
		{
			mAddress.port = RNReplicaNet::RNLobby::BackendServer::kDefaultDebugPort;
		}
		mAddress.port6 = mAddress.port;
		if (!CallbackServerAddress(mAddress))
		{
			CallbackCompleted();
			return false;
		}
	}

	if ( (FloatTime() - mLastSentTime) > kClientRetryTime )
	{
		mLastSentTime = FloatTime();
		if (mTries >= kClientMaxTries)
		{
			CallbackCompleted();
			return false;
		}
		mTries++;
		DynamicMessageHelper message;
		message << mNOnce;
		message << mTitleID;
		float tempf = (float)FloatTime();	// Just for some extra fake bits, nothing else.
		message << tempf;
		DynamicMessageHelper toHash;
		toHash << tempf;
		toHash << mEncryptionKey;
		int slots[4];
		memset(slots,0,sizeof(slots));
//		printf("%s\n",toHash.DumpAsHex(false).c_str());
		Checksum::ChecksumDataWithSlots(slots,4,toHash.GetBuffer(),toHash.GetSize());
		message.AddData(slots,sizeof(slots));

		PackageAndSendData(mSocket,message,mAddress);
	}
	return true;
}

void BackendClient::DisableValidateOrderingCheck(void)
{
	sOrderingCheck = false;
}

bool BackendClient::IsAuthenticated(void)
{
	return Backend::gAuthenticateDone;
}

void BackendClient::UseReleaseServers(const bool use)
{
	mUseReleaseServers = use;
}

//From: RNLobby/BackendServerTranslate.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <assert.h>
#include <string.h>
//Skipping: #include "RNLobby/Inc/BackendServer.h"
//Skipping: #include "RNLobby/BackendPrivate.h"

using namespace RNReplicaNet;
using namespace RNLobby;
using namespace RNODBCSQL;

std::string BackendServer::TranslateReply(const Reply reply)
{
	std::string text;
	switch(reply)
	{
		case kReply_ValidTitleID:
			text = "The TitleID is valid.";
			break;
		case kReply_InvalidTitleID:
			text = "The TitleID is invalid.";
			break;
		case kReply_TitleIDSupportPeriodExpired:
			text = "The TitleID support period has expired.";
			break;
		case kReply_ServerDownForMaintanence:
			text = "The RNLobby server is down for maintanence. Please try again later.";
			break;
		case kReply_ServerCannotBeContacted:
			text = "The RNLobby server cannot be contacted. Please check your internet connection and try again.";
			break;
	
		default:
			text = "RNLobby has reported an unknown error.";
			break;
	}

	return text;
}
//From: RNLobby/BackendPrivate.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <assert.h>
//Skipping: #include "RNLobby/BackendPrivate.h"

#include "RNLobby/Inc/CodeServer.h"
#include "RNLobby/Inc/NATResolver.h"
#include "RNLobby/Inc/NATDetectServer.h"
#include "RNLobby/Inc/AdvertiseServer.h"
#include "RNLobby/Inc/UserServer.h"
#include "RNLobby/Inc/StatServer.h"

namespace RNReplicaNet
{

namespace RNLobby
{

namespace Backend
{

volatile bool gAnyServiceRequestedTitleID = false;
volatile bool gAuthenticateDone = false;

// MPi: TODO: This will also store the keys for each component from the BackendServer sent to the BackendClient.

static int sTitleID = 0;
extern int GetTitleID(void)
{
	gAnyServiceRequestedTitleID = true;
	return sTitleID;
}

extern void SetTitleID(const int titleID)
{
	sTitleID = titleID;
}


static bool sIsAdvertised = false;
extern bool GetIsAdvertised(void)
{
	return sIsAdvertised;
}

static int sAdvertisedID = 0;
extern int GetAdvertisedID(void)
{
	return sAdvertisedID;
}

extern void SetAdvertised(const bool isAdvertised,const int advertisedID)
{
	sIsAdvertised = isAdvertised;
	sAdvertisedID = advertisedID;
}

static int sLoginID = UserInfo::kAnyLoginID;
extern int GetLoginID(void)
{
	return sLoginID;
}

extern void SetLoginID(const int loginID)
{
	sLoginID = loginID;
}

static int sSessionID = 0;
extern int GetSessionID(void)
{
	return sSessionID;
}
extern void SetSessionID(const int sessionID)
{
	sSessionID = sessionID;
}

static XPAddress sCodeServerAddress(CodeServer::kDefaultPort,127,0,0,1);
static char sCodeServerCrypto[kMaxServerCryptoLength];
XPAddress GetCodeServerAddress(void)
{
	return sCodeServerAddress;
}
const char *GetCodeServerCrypto(void)
{
	return (char *)sCodeServerCrypto;
}

static XPAddress sNATServerAddress(NATResolver::kDefaultPort,127,0,0,1);
static char sNATServerCrypto[kMaxServerCryptoLength];
XPAddress GetNATServerAddress(void)
{
	return sNATServerAddress;
}
const char *GetNATServerCrypto(void)
{
	return (char *)sNATServerCrypto;
}

static XPAddress sNATDetectServerAddress1(NATDetectServer::kDefaultPort,127,0,0,1);
static XPAddress sNATDetectServerAddress2(NATDetectServer::kDefaultPort+2,127,0,0,1);
static char sNATDetectServerCrypto[kMaxServerCryptoLength];
void GetNATDetectServerAddress(XPAddress &address1,XPAddress &address2)
{
	address1 = sNATDetectServerAddress1;
	address2 = sNATDetectServerAddress2;
}
const char *GetNATDetectServerCrypto(void)
{
	return (char *)sNATDetectServerCrypto;
}

static XPAddress sAdvertiseServerAddress(AdvertiseServer::kDefaultPort,127,0,0,1);
static char sAdvertiseServerCrypto[kMaxServerCryptoLength];
XPAddress GetAdvertiseServerAddress(void)
{
	return sAdvertiseServerAddress;
}
const char *GetAdvertiseServerCrypto(void)
{
	return (char *)sAdvertiseServerCrypto;
}

static XPAddress sUserServerAddress(UserServer::kDefaultPort,127,0,0,1);
static char sUserServerCrypto[kMaxServerCryptoLength];
XPAddress GetUserServerAddress(void)
{
	return sUserServerAddress;
}
const char *GetUserServerCrypto(void)
{
	return (char *)sUserServerCrypto;
}

static XPAddress sStatServerAddress(StatServer::kDefaultPort,127,0,0,1);
static char sStatServerCrypto[kMaxServerCryptoLength];
XPAddress GetStatServerAddress(void)
{
	return sStatServerAddress;
}
const char *GetStatServerCrypto(void)
{
	return (char *)sStatServerCrypto;
}


// MPi: TODO: Change this to a proper constant
static XPAddress sCloudServerAddress(0/*StatServer::kDefaultPort*/,127,0,0,1);
static char sCloudServerCrypto[kMaxServerCryptoLength];

static bool CommonSetSingleServer(const std::string &address, const int port, const std::string &crypto, const int defaultPort, XPAddress &outAddr, char *outCrypto)
{
	if (address.empty())
	{
		// An empty address is not a failure, it just doesn't set the server config.
		return true;
	}
	int realPort = port?port:defaultPort;
	XPAddress addr;
	if (!addr.Import(address))
	{
		if (XPSock_Resolve(&addr,address.c_str()) != XPSOCK_EOK)
		{
			return false;
		}

		addr.port = realPort;
		addr.port6 = realPort;
	}
	outAddr = addr;
	strncpy(outCrypto , crypto.c_str() , kMaxServerCryptoLength);
	return true;
}
bool SetAdvertiseServerInformation(const std::string &address, const int port, const std::string &crypto)
{
	return CommonSetSingleServer(address,port,crypto,AdvertiseServer::kDefaultPort,sAdvertiseServerAddress,sAdvertiseServerCrypto);
}

bool SetCodeServerInformation(const std::string &address, const int port, const std::string &crypto)
{
	return CommonSetSingleServer(address,port,crypto,CodeServer::kDefaultPort,sCodeServerAddress,sCodeServerCrypto);
}

bool SetNATServerInformation(const std::string &address, const int port, const std::string &crypto)
{
	return CommonSetSingleServer(address,port,crypto,NATResolver::kDefaultPort,sNATServerAddress,sNATServerCrypto);
}

bool SetNATDetectServerInformation(const std::string &address1, const int port1, const std::string &address2, const int port2, const std::string &crypto)
{
	if (!CommonSetSingleServer(address1,port1,crypto,NATDetectServer::kDefaultPort,sNATDetectServerAddress1,sNATDetectServerCrypto))
	{
		return false;
	}
	return CommonSetSingleServer(address2,port2,crypto,NATDetectServer::kDefaultPort,sNATDetectServerAddress2,sNATDetectServerCrypto);
}


bool SetStatServerInformation(const std::string &address, const int port, const std::string &crypto)
{
	return CommonSetSingleServer(address,port,crypto,StatServer::kDefaultPort,sStatServerAddress,sStatServerCrypto);
}

bool SetUserServerInformation(const std::string &address, const int port, const std::string &crypto)
{
	return CommonSetSingleServer(address,port,crypto,UserServer::kDefaultPort,sUserServerAddress,sUserServerCrypto);
}

bool SetCloudServerInformation(const std::string &address, const int port, const std::string &crypto)
{
	// MPi: TODO: Once CloudServer::kDefaultPort is defined use it below
	return CommonSetSingleServer(address,port,crypto,port/*CloudServer::kDefaultPort*/,sCloudServerAddress,sCloudServerCrypto);
}

class EnsureInitialised
{
public:
	EnsureInitialised()
	{
		Init();
	}

	static void Init(void)
	{
		memset(sAdvertiseServerCrypto,0,sizeof(sAdvertiseServerCrypto));
		memset(sCodeServerCrypto,0,sizeof(sCodeServerCrypto));
		memset(sCloudServerCrypto,0,sizeof(sCloudServerCrypto));
		memset(sNATDetectServerCrypto,0,sizeof(sNATDetectServerCrypto));
		memset(sNATServerCrypto,0,sizeof(sNATServerCrypto));
		memset(sStatServerCrypto,0,sizeof(sStatServerCrypto));
		memset(sUserServerCrypto,0,sizeof(sUserServerCrypto));
	}
};

static EnsureInitialised foo;

} // namespace Backend

} // namespace RNLobby

} // namespace RNReplicaNet
//From: RNLobby/BaseServer.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <assert.h>
#include <time.h>
//Skipping: #include "RNPlatform/DebugSupport.h"
//Skipping: #include "RNLobby/BackendPrivate.h"
#include "RNLobby/Inc/BaseServer.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
//Skipping: #include "RNPlatform/Inc/SysTime.h"
//Skipping: #include "RNPlatform/Inc/Encryption.h"
//Skipping: #include "RNPlatform/Inc/RegistryManagerList.h"
//Skipping: #include "RNPlatform/Inc/PlatformHeap.h"
//Skipping: #include "RNXPURL/UDPReliableManager.h"
//Skipping: #include "RNXPURL/Inc/TransportConfig.h"

// Define this to disable the timeout when using breakpoints.
//#define DISABLE_TIMEOUT
// Define this to enable debug printing
//#define BASEDEBUG_PRINTS

using namespace RNReplicaNet;
using namespace RNLobby;


static SysTime sBaseServerTheTime;

BaseServer::BaseServer() : mSocket(0) , mAllowDelete(false)
{
}

BaseServer::~BaseServer()
{
	Stop();
}

bool BaseServer::StartWithSocket(t_XPSocket *socket,const bool allowDelete)
{
	THREADSAFELOCK();

	mSocket = socket;
	mAllowDelete = allowDelete;

	union
	{
		float fval;
		int ival;
	} salt;
	salt.fval = (float)FloatTime();
	mNOnce = salt.ival;

#ifdef BASEDEBUG_PRINTS
	dprintf("BaseServer::Start\n");
#endif

	if (mSocket)
	{
#ifdef BASEDEBUG_PRINTS
		XPAddress exportedAddr;
		XPSock_GetAddress(socket,&exportedAddr);
		dprintf("sock addr %s\n",exportedAddr.Export().c_str());
#endif
	}

	Begin(this);

	return true;
}

bool BaseServer::Stop(void)
{
	Terminate();

	Tidy();

	return true;
}

void BaseServer::SetEncryptionKey(const void *data,const int length)
{
	mCryptoKey.Create((void *)data,length);
}

bool BaseServer::CallbackParsePacketData(t_XPSocket *socket,const XPAddress &addr,void *data,size_t &length,DynamicMessageHelper &result)
{
	return CommonCallbackParsePacketData(data,length,result);
}

bool BaseServer::PackageAndSendData(t_XPSocket *socket,const DynamicMessageHelper &message,const XPAddress &address)
{
	if (!socket)
	{
		return false;
	}
	if (message.GetSize() <= 0)
	{
		return true;
	}

	DynamicMessageHelper target;
	CommonPackageAndSendData(message,target);

	XPAddress finalOut = address;
	CallbackDataSend(target,finalOut);

	int ret = XPSock_UrgentSend(socket,(char *) target.GetBuffer(), target.GetSize() , &finalOut);

	return (ret == XPSOCK_EOK);
}

int BaseServer::ThreadEntry(void)
{
	bool gotError = false;
	while (!gotError)
	{
		if (!CallbackPoll())
		{
			return -1;
		}
		// Stack context for the message helper to avoid the Sleep cancel point leaking memory.
		{
			RNReplicaNet::DynamicMessageHelper message( RNReplicaNet::TransportConfig::GetPacketMTU() );
			RNReplicaNet::DynamicMessageHelper result;
			int times = 100;
			int ret;
			size_t realLen;
			do
			{
				RNReplicaNet::XPAddress addr;
				bool validPacket = false;
				// Stack context for the lock around the mSocket pointer
				{
					THREADSAFELOCK();
					ret = XPSock_UrgentRecv(mSocket,(char *) message.GetBuffer(),message.GetBufferSize(),XPSOCK_FNULL,&addr);
					if (ret == XPSOCK_EERROR)
					{
						// Expire errors and count them as packets with data
//						int real = asocket_lasterror;
						ret = 1;
						continue;
					}
					if (ret > 0)
					{
						realLen = ret;
						message.SetSize(0);
						validPacket = CallbackParsePacketData(mSocket,addr,message.GetBuffer(),realLen,result);
					}
				}
				if (validPacket)
				{
#if defined(RN_EXCEPTIONS_ENABLED)
					try
					{
#endif
						if (!CallbackParseValidMessage(result,realLen,addr))
						{
							return -1;
						}
#if defined(RN_EXCEPTIONS_ENABLED)
					}
					catch (MessageHelper::Exception E)
					{
						// Do nothing since we don't disconnect a connection as such
					}
#endif
				}
			} while ( (times-- > 0) && (ret > 0) );
		}

		Sleep(10);	// Sleep for a bit
	}
	
	return 0;
}

SysTimeType BaseServer::FloatTime(void)
{
	return sBaseServerTheTime.FloatTime();
}

void BaseServer::Tidy(void)
{
	THREADSAFELOCK();
	CallbackTidy();

	if (mAllowDelete && mSocket)
	{
		XPSock_Close(mSocket);
	}
	mSocket = 0;
}

void BaseServer::ThreadExiting(const int returnCode)
{
	Tidy();
}
//From: RNLobby/CommonServer.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <assert.h>
#include "RNLobby/Inc/CommonServer.h"
//Skipping: #include "RNPlatform/Inc/CheckSum.h"
//Skipping: #include "RNPlatform/Inc/SysTime.h"
//Skipping: #include "RNXPURL/Inc/TransportConfig.h"

// Define this to enable debug printing
//#define COMMONDEBUG_PRINTS

using namespace RNReplicaNet;
using namespace RNLobby;

static SysTime sCommonServerTheTime;

bool CommonServer::CommonCallbackParsePacketData(void *data,size_t &length,DynamicMessageHelper &result,const int moreSalt)
{
	// Do some early out tests. The char is at least one byte of real message
	if ( length < (sizeof(short) + sizeof(int) + sizeof(int) + sizeof(char)) )
	{
		return false;
	}
	MessageHelper tempM;
	tempM.SetBuffer(data);
	unsigned short theSize;
	MESSAGEHELPER_GETVARIABLEp(tempM,theSize);

	if (length < (size_t) theSize)
	{
		return false;
	}

	if ( (theSize < (unsigned short)(sizeof(short) + sizeof(int) + sizeof(char))) || (theSize > (unsigned short)RNReplicaNet::TransportConfig::GetPacketMTU()) )
	{
		return false;
	}

	result.SetSize(0);
	// It passed these tests so we continue with some slightly more expensive tests
	int checksum;
	MESSAGEHELPER_GETVARIABLEp(tempM,checksum);

	int ival;
	MESSAGEHELPER_GETVARIABLEp(tempM,ival);

	result.AddData(tempM.GetCurrentPosition(),theSize - tempM.GetSize());

	Encryption::Key key = mCryptoKey;
	key.AddCrypto(&ival,sizeof(ival));
	key.AddCrypto(&moreSalt,sizeof(moreSalt));
	Encryption::Decrypt(result.GetBuffer(),result.GetSize(),&key);
	int testChecksum = Checksum::ChecksumData(result.GetBuffer(),result.GetSize());
	if (testChecksum != checksum)
	{
		return false;
	}
#ifdef COMMONDEBUG_PRINTS
	dprintf("CommonServer::CallbackParsePacketData: Passed inital tests data %s\n",result.DumpAsHex().c_str());
#endif
	length = result.GetSize();
	result.SetSize(0);
	result.SetGuardSize((int)length);

	return true;
}


void CommonServer::CommonPackageAndSendData(const DynamicMessageHelper &message,DynamicMessageHelper &result,const int moreSalt)
{
	short theSize = 0;	// To be filled in later
	result << theSize;

	result << Checksum::ChecksumData(message.GetBuffer(),message.GetSize());

	union
	{
		float fval;
		int ival;
	} salt;
	salt.fval = (float) sCommonServerTheTime.FloatTime();
	result << salt.ival;


	DynamicMessageHelper toCrypt;
	toCrypt.AddData(message.GetBuffer(),message.GetSize());
	Encryption::Key key = mCryptoKey;
	key.AddCrypto(&salt.ival,sizeof(salt.ival));
	key.AddCrypto(&moreSalt,sizeof(moreSalt));
	Encryption::Encrypt(toCrypt.GetBuffer(),toCrypt.GetSize(),&key);

	result.AddData(toCrypt.GetBuffer(),toCrypt.GetSize());

	// Update the size
	MessageHelper tempMessage;
	tempMessage.SetBuffer(result.GetBuffer());
	theSize = (short) result.GetSize();
	MESSAGEHELPER_ADDVARIABLEp(tempMessage,theSize);
}
//From: RNLobby/BaseTransportServer.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <assert.h>
#include <time.h>
//Skipping: #include "RNPlatform/DebugSupport.h"
//Skipping: #include "RNLobby/BackendPrivate.h"
#include "RNLobby/Inc/BaseTransportServer.h"
//Skipping: #include "RNPlatform/Inc/CheckSum.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
//Skipping: #include "RNPlatform/Inc/SysTime.h"
//Skipping: #include "RNPlatform/Inc/Encryption.h"
//Skipping: #include "RNPlatform/Inc/RegistryManagerList.h"
//Skipping: #include "RNPlatform/Inc/PlatformHeap.h"
//Skipping: #include "RNXPURL/UDPReliableManager.h"
//Skipping: #include "RNXPURL/Inc/TransportConfig.h"

// Define this to disable the timeout when using breakpoints.
//#define DISABLE_TIMEOUT
// Define this to enable debug printing
//#define BASEDEBUG_PRINTS

using namespace RNReplicaNet;
using namespace RNLobby;


static SysTime sBaseTransportServerTheTime;

BaseTransportServer::BaseTransportServer() : mTransport(0) , mAllowDelete(false) , mIsListen(true) , mNumConnections(0) , mNumTotalConnections(0)
{
}

BaseTransportServer::~BaseTransportServer()
{
	Stop();
}

bool BaseTransportServer::StartWithTransport(Transport *transport,const bool allowDelete,const bool isListen)
{
	THREADSAFELOCK();

	mTransport = transport;
	mAllowDelete = allowDelete;
	mIsListen = isListen;
	mClientGotAPacket = false;
	mClientIsStable = false;
	mNumConnections = 0;
	mNumTotalConnections = 0;

	mClientEntry = Entry();

	GenerateNewNonce();

#ifdef BASEDEBUG_PRINTS
	dprintf("BaseTransportServer::StartWithTransport\n");
#endif

	if (mTransport)
	{
#ifdef BASEDEBUG_PRINTS
		XPAddress exportedAddr;
		XPSock_GetAddress(socket,&exportedAddr);
		dprintf("sock addr %s\n",exportedAddr.Export().c_str());
#endif
	}

	Begin(this);

	return true;
}

bool BaseTransportServer::Stop(void)
{
	Terminate();

	Tidy();

	return true;
}

void BaseTransportServer::SetEncryptionKey(const void *data,const int length)
{
	mCryptoKey.Create((void *)data,length);
}

bool BaseTransportServer::CallbackParsePacketData(Transport *transport,void *data,size_t &length,DynamicMessageHelper &result,Entry &entry)
{
	return CommonCallbackParsePacketData(data,length,result,GetConnectionNOnce(transport,&entry));
}

bool BaseTransportServer::PackageAndSendData(Transport *transport,const DynamicMessageHelper &message)
{
	if (!transport)
	{
		return false;
	}
	if (message.GetSize() <= 0)
	{
		return true;
	}

	int moreSalt = GetConnectionNOnce(transport);
	assert(moreSalt && "CommonServer::CommonPackageAndSendData A BaseTransportServer derived class is sending a command before the CallbackConnectionEstablished() is triggered.");

	DynamicMessageHelper target;
	CommonPackageAndSendData(message,target,moreSalt);

	CallbackDataSend(target);

	Transport::Error ret = transport->SendReliable((char *) target.GetBuffer(), target.GetSize());

	return (ret == Transport::kTransport_EOK);
}

int BaseTransportServer::ThreadEntry(void)
{
	bool gotError = false;
	while (!gotError)
	{
		// Can be called with or without a valid mTransport
		if (!CallbackPoll())
		{
			return -1;
		}
		if (mTransport)
		{
			if (mIsListen)
			{
				// Accept connections first
				Transport *transport;
				do
				{
					transport = mTransport->Accept();
					if (transport)
					{
						mNumConnections++;
						mNumTotalConnections++;

						// Calculate and send the client's connection nonce as the first packet
						Entry newEntry;
						newEntry.mCachedConnectionNonce = CalculateConnectionNOnce(transport);
						// Note no endian needed, it is data.
						transport->SendReliable((char*)&newEntry.mCachedConnectionNonce,sizeof(newEntry.mCachedConnectionNonce));
				
						std::pair<std::map<Transport*,Entry>::iterator,bool> ret = mConnected.insert(std::pair<Transport*,Entry>(transport,newEntry));
						assert(ret.second && "This insert should always succeed");

						CallbackAccepted(transport);
					}
				} while (transport);
				std::map<Transport *,Entry>::iterator st = mConnected.begin();
				// Iterate mConnected
				while (st != mConnected.end())
				{
					THREADSAFELOCK();
					std::map<Transport *,Entry>::iterator old = st++;
					Transport *transport = (*old).first;
					Entry &entry = (*old).second;
					if (transport->GetStatus() == Transport::kTransport_EERROR)
					{
						entry.mError = true;
					}
					if ((entry.mWaitingForDisconnect >= 0.0f) && (FloatTime() > entry.mWaitingForDisconnect))
					{
						entry.mError = true;
					}
					if (entry.mError)
					{
						if (mNumConnections)
						{
							mNumConnections--;
						}
						CallbackDisconnected(transport);
						delete transport;
						mConnected.erase(old);
						continue;
					}
					int ret = RunThink(transport,entry);
					if (ret != 0)
					{
						if (mNumConnections)
						{
							mNumConnections--;
						}
						CallbackDisconnected(transport);
						delete transport;
						mConnected.erase(old);
						continue;
					}
				}
			}
			else	//<< if (mIsListen)
			{
				if (mTransport->GetStatus() == Transport::kTransport_EERROR)
				{
					mClientEntry.mError = true;
				}
				if (mClientEntry.mWaitingForDisconnect >= 0.0f && FloatTime() > mClientEntry.mWaitingForDisconnect)
				{
					mClientEntry.mError = true;
				}
				if (mClientEntry.mError)
				{
					mNumConnections = 0;
					CallbackDisconnected(mTransport);
					return 0;
				}
				int ret = RunThink(mTransport,mClientEntry);
				if (ret != 0)
				{
					mNumConnections = 0;
					CallbackDisconnected(mTransport);
					return ret;
				}
			}
		}	//< if (mIsListen)

		Sleep(10);	// Sleep for a bit
	}
	
	return 0;
}

int BaseTransportServer::RunThink(Transport *transport,Entry &entry)
{
	if (transport->GetStatus() == Transport::kTransport_EERROR)
	{
		return -1;
	}
	RNReplicaNet::DynamicMessageHelper message( RNReplicaNet::TransportConfig::GetPacketMTU() );
	RNReplicaNet::DynamicMessageHelper result;
	int times = 10;	// Expire a maximum of 'times' packets per connection per iteration
	int ret;
	size_t realLen;
	do
	{
		std::string addr;
		bool validPacket = false;
		// Stack context for the lock around the mTransport derived transport
		{
			THREADSAFELOCK();
			ret = transport->Recv((char *) message.GetBuffer(),message.GetBufferSize());
			if (ret == XPSOCK_EERROR)
			{
				// Expire errors and count them as packets with data
//				int real = asocket_lasterror;
				ret = 1;
				continue;
			}
			if (ret > 0)
			{
				entry.mLastPacketTime = FloatTime();
				addr = transport->GetPeerURL();
				realLen = ret;
				message.SetSize(0);

				if (!mIsListen && (ret >= (int)sizeof(int)) && !mClientGotAPacket)
				{
					// Intercept the connection nonce packet
					mClientGotAPacket = true;
					// Note no endian needed, it is data.
					mClientEntry.mCachedConnectionNonce = ((int*)message.GetBuffer())[0];
					// Send back the ACK as the same value
					transport->SendReliable((char *)&mClientEntry.mCachedConnectionNonce,sizeof(mClientEntry.mCachedConnectionNonce));
					continue;
				}

				if (mIsListen && (ret >= (int)sizeof(int)) && !entry.mClientACKConnectionNonce)
				{
					// Note no endian needed, it is data.
					int testConnNonce = ((int*)message.GetBuffer())[0];
					// Check to see if the nonce matches, if it doesn't then it might be a command so let it pass through to below.
					if (entry.mCachedConnectionNonce == testConnNonce)
					{
						// Client got the connection nonce so we can use it now
						entry.mClientACKConnectionNonce = true;
						continue;
					}
				}

				validPacket = CallbackParsePacketData(transport,message.GetBuffer(),realLen,result,entry);
			}
		}
		if (validPacket && (entry.mWaitingForDisconnect < 0.0f))
		{
			if (!mClientIsStable && !mIsListen)
			{
				// Running as a single connection client a callback is triggered once only when a valid packet is received from the server.
				mClientIsStable = true;
				mNumConnections = 1;
				CallbackAccepted(transport);
			}
#if defined(RN_EXCEPTIONS_ENABLED)
			try
			{
#endif
				if (!CallbackParseValidMessage(transport,result,realLen))
				{
					assert(!"Invalid packet parse returned by CallbackParseValidMessage()");
					return -1;
				}
#if defined(RN_EXCEPTIONS_ENABLED)
			}
			catch (MessageHelper::Exception E)
			{
				assert(!"CallbackParseValidMessage() generated a MessageHelper exception");
				return -1;
			}
#endif
		}
	} while ( (times-- > 0) && (ret > 0) );

	if (entry.mLastPacketsSent != transport->GetPacketsSent())
	{
		entry.mLastPacketTime = FloatTime();
		entry.mLastPacketsSent = transport->GetPacketsSent();
	}

	// Send a keep-alive if there hasn't been much sent recently
	// If the connection is bad this also causes the connection to be marked as disconnecting due to the certain/reliable send eventually failing.
	if ( (FloatTime() - entry.mLastPacketTime) > 30.0f)
	{
		char temp = 0;
		entry.mLastPacketTime = FloatTime();
		transport->SendCertain(&temp,1);	// This one byte packet is too small and will get ignored by users of this server
	}

	return 0;
}

SysTimeType BaseTransportServer::FloatTime(void)
{
	return sBaseTransportServerTheTime.FloatTime();
}

void BaseTransportServer::Tidy(void)
{
	THREADSAFELOCK();
	CallbackTidy();

	// Iterate mConnected
	while (!mConnected.empty())
	{
		std::map<Transport *,Entry>::iterator st = mConnected.begin();
		delete (*st).first;
		mConnected.erase(st);
	}

	if (mAllowDelete && mTransport)
	{
		delete mTransport;
	}
	mTransport = 0;
}

void BaseTransportServer::ThreadExiting(const int returnCode)
{
	Tidy();
}

size_t BaseTransportServer::GetNumConnections(void) const
{
	return mNumConnections;
}

size_t BaseTransportServer::GetNumTotalSessions(void) const
{
	return mNumTotalConnections;
}

bool BaseTransportServer::SetAsDisconnecting(Transport *transport)
{
	if (mIsListen)
	{
		std::map<Transport*,Entry>::iterator found = mConnected.find(transport);
		if (found == mConnected.end())
		{
			return false;
		}
		Entry &entry = (*found).second;
		if (entry.mWaitingForDisconnect >= 0.0f)
		{
			return true;
		}
		entry.mWaitingForDisconnect = FloatTime() + 30.0f;
		return true;
	}
	if (mClientEntry.mWaitingForDisconnect >= 0.0f)
	{
		return true;
	}
	mClientEntry.mWaitingForDisconnect = FloatTime() + 30.0f;
	return true;
}

void BaseTransportServer::GenerateNewNonce(void)
{
	union
	{
		float fval;
		int ival;
	} salt;
	salt.fval = (float)FloatTime();
	mNOnce = salt.ival;
}

int BaseTransportServer::GetConnectionNOnce(Transport *transport, const Entry *entry)
{
	if (mIsListen)
	{
		if (entry && !entry->mClientACKConnectionNonce)
		{
			return 1;
		}
		return CalculateConnectionNOnce(transport);
	}
	assert((transport == mTransport) && "GetConnectionNOnce called from the client without a valid Transport");
	if (transport != mTransport)
	{
		return 0;
	}

	if (!mClientEntry.mCachedConnectionNonce)
	{
		return 1;
	}
	return mClientEntry.mCachedConnectionNonce;
}

int BaseTransportServer::CalculateConnectionNOnce(Transport *transport)
{
	assert(mIsListen && "CalculateConnectionNOnce not called from a server instance");
	if (!mIsListen)
	{
		return 0;
	}
	assert(transport && "CalculateConnectionNOnce called from the server without a valid Transport");
	if (!transport)
	{
		return 0;
	}
	int connNonce = transport->GetInstance() ^ mNOnce;
	// Don't allow 0 nonces
	if (!connNonce)
	{
		connNonce = 1;
	}
	return connNonce;
}

const BaseTransportServer::Entry *BaseTransportServer::FindEntry(Transport *transport)
{
	assert(mIsListen && "FindEntry not called from a server instance");
	if (!mIsListen)
	{
		return 0;
	}

	std::map<Transport*,Entry>::iterator found = mConnected.find(transport);
	if (found == mConnected.end())
	{
		return 0;
	}
	Entry &entry = (*found).second;
	return &entry;
}
//From: RNLobby/CodeClient.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <time.h>
//Skipping: #include "RNLobby/BackendPrivate.h"
#include "RNLobby/Inc/CodeClient.h"
//Skipping: #include "RNPlatform/Inc/CheckSum.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
//Skipping: #include "RNPlatform/Inc/Rand.h"

using namespace RNReplicaNet;
using namespace RNLobby;


static SysTime sCodeClientTheTime;

CodeClient::CodeClient() : mServerAddressSet(false)
{
	CleanQuery();
}

CodeClient::~CodeClient()
{
	Stop();
}

bool CodeClient::Start(const char *code,const int nOnce1,const int nOnce2)
{
	assert(code);
	if (!mServerAddressSet)
	{
		mServerAddress = Backend::GetCodeServerAddress();
	}
	Stop();
	Backend::ServerCryptoHelper<CodeClient>::SetEncryption(this,Backend::GetCodeServerCrypto());
	if (!code)
	{
		return false;
	}
	CleanQuery();
	mCode = (char *) malloc(strlen(code)+1);
	assert(mCode);
	if (!mCode)
	{
		return false;
	}
	memcpy(mCode,code,strlen(code)+1);
	mSend = new XPSocketUrgent();
	assert(mSend);
	if (!mSend)
	{
		free(mCode);
		mCode = 0;
		return false;
	}
	mSend->Create();

	mNOnce1 = nOnce1;
	mNOnce2 = nOnce2;

	Begin(this);

	return true;
}

bool CodeClient::Stop(bool hardware)
{
	if (GetIsRunning())
	{
		Terminate();
	}
	free(mCode);
	mCode = 0;
	delete mSend;
	mSend = 0;
	if (hardware)
	{
		XPSock_Quit();
	}
	return true;
}

bool CodeClient::GetCompleted(void)
{
	if (mGotReply)
	{
		Stop();
	}
	return mGotReply;
}

CodeServer::Reply CodeClient::GetReply(void)
{
	if (!mGotReply)
	{
		return CodeServer::kReply_UnspecifiedError;
	}
	return mReply;
}

int CodeClient::GetUserSuppliedReply(void)
{
	return mUserSuppliedReply;
}

void CodeClient::GetNOnces(int &nOnce1,int &nOnce2)
{
	nOnce1 = mNOnce1;
	nOnce2 = mNOnce2;
}

void CodeClient::SetEncryptionKey(const void *data,const int length)
{
	mCryptoKey.Create((void *)data,length);
}

int CodeClient::ThreadEntry(void)
{
	// Get some salt
	union
	{
		float fval;
		int ival;
	} salt;
	salt.fval = (float)sCodeClientTheTime.FloatTime();
	RNReplicaNet::Rand::SeedFastWeak(salt.ival);

	// Use the same reply key for this attempt regardless on how long it can take to get a reply.
	// This avoids resent requests arriving late from producing the "corrupt" reply.
	int replyKeyData = RNReplicaNet::Rand::FastWeak() | (RNReplicaNet::Rand::FastWeak() << 16);

	int times = 0;
	while (times < 10)
	{
		times++;
		char temp[1024];
		MessageHelper message;
		message.SetBuffer(temp);
		// 0/3   = version = 1
		// 4/7   = Random bytes, my one time key
		// 8/11  = Random bytes for the reply key
		// 12/19 = Number once data if known or 0/0 if not known (mLastNOnce1 and mLastNOnce2)
		// 12+   = Key data
		message.AddInteger(1);			// The version
		int oneTimeData = RNReplicaNet::Rand::FastWeak() | (RNReplicaNet::Rand::FastWeak() << 16);
		message.AddData(&oneTimeData,sizeof(oneTimeData));	// Avoid the endian check
		int startPos = message.GetSize();
		message.AddData(&replyKeyData,sizeof(replyKeyData));	// Avoid the endian check
		message.AddInteger(mNOnce1);
		message.AddInteger(mNOnce2);
		char *theTestKey = mCode;
		message.AddData(theTestKey,(int)strlen(theTestKey)+1);

		Encryption::Key oneTime;
		oneTime.Create(&oneTimeData,sizeof(oneTimeData));
		Encryption::Encrypt(temp+startPos,message.GetSize()-startPos,&oneTime);

		Encryption::Encrypt(temp,message.GetSize(),&mCryptoKey);
		mSend->Send(temp,message.GetSize(),mServerAddress);
		XPAddress addr;
		int i;
		for (i=0;i<5;i++)
		{
			int ret = mSend->Recv(temp,sizeof(temp),&addr);
			if (ret == XPSOCK_EERROR)
			{
				break;
			}
			if (ret > 0)
			{
				message.SetBuffer(temp);
				Encryption::Key replyKey;
				replyKey.Create(&replyKeyData,sizeof(replyKeyData));
				Encryption::Decrypt(temp,ret,&replyKey);
				int tempv = message.GetInteger();		// Some random value, not important
				int result = message.GetInteger();		// The reply
				mUserSuppliedReply = message.GetInteger();
				mNOnce1 = message.GetInteger();
				mNOnce2 = message.GetInteger();
				int calc = Checksum::ChecksumData(temp,message.GetSize());
				int verifyChecksum;
				message.GetData(&verifyChecksum,sizeof(verifyChecksum));
				if (calc == verifyChecksum)
				{
					mReply = (CodeServer::Reply) result;
				}
				else
				{
					mReply = CodeServer::kReply_CorruptReply;
				}
				mGotReply = true;
				return 0;
			}
			else
			{
				CurrentThread::Sleep(100);
			}
		}
	}

	mReply = CodeServer::kReply_Timeout;
	mGotReply = true;
	return 0;
}

void CodeClient::SetServer(const RNReplicaNet::XPAddress &address)
{
	mServerAddressSet = true;
	mServerAddress = address;
}

void CodeClient::CleanQuery(void)
{
	mReply = CodeServer::kReply_UnspecifiedError;
	mGotReply = false;
	mCode = 0;
	mSend = 0;
	mUserSuppliedReply = 0;
	mNOnce1 = 0;
	mNOnce2 = 0;
}

//From: RNLobby/NATDetectClient.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include "RNLobby/Inc/NATDetectClient.h"
//Include inline: #include "RNLobby/NATDetectServerPrivate.h"
//From: RNLobby/NATDetectServerPrivate.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef _NATDETECTSERVERPRIVATE_H_
#define _NATDETECTSERVERPRIVATE_H_

namespace RNReplicaNet
{

namespace RNLobby
{

namespace NATDetectServerPrivate
{

enum kPacket
{
	kProbe = 0,
	kProbeReply,
	kProbeFromOtherReply
};

} // namespace NATDetectServerPrivate

} // namespace RNLobby

} // namespace RNReplicaNet

#endif
//Skipping: #include "RNLobby/BackendPrivate.h"

using namespace RNReplicaNet;
using namespace RNLobby;

NATDetectClient::NATDetectClient() : mServerAddressSet(false)
{
	Init();
}

void NATDetectClient::Init(void)
{
	mLastSentTime = -10.0f;
	mGot1Times = 0;
	mGot2Times = 0;
	mTries = 0;
	mReply = NATDetectServer::kReply_Pending;
	mIsNiceNAT = false;
	mGotOther = false;
}

NATDetectClient::~NATDetectClient()
{
	Stop();
}

bool NATDetectClient::Start(const int channel)
{
	Stop();
	Backend::ServerCryptoHelper<NATDetectClient>::SetEncryption(this,Backend::GetNATDetectServerCrypto());
	THREADSAFELOCK();
	if (!mServerAddressSet)
	{
		Backend::GetNATDetectServerAddress(mAddress1,mAddress2);
	}
	Init();
	XPSock_Init();
	t_XPSocket *sock = XPSock_UrgentCreate(channel);
	if (sock == (t_XPSocket *) XPSOCK_EERROR)
	{
		sock = XPSock_UrgentCreate(XPSOCK_PORT_ANY);
	}
	BaseServer::StartWithSocket(sock);
	return true;
}

static const int kMaxTries = 20;
static const int kMaxTriesForOther = 10;
static const float kRetryTime = 0.2f;

bool NATDetectClient::CallbackParseValidMessage(DynamicMessageHelper &message,const size_t length,const XPAddress &address)
{
	int NOnce;
	message >> NOnce;
	if (NOnce != mNOnce)
	{
		// NOnce doesn't match. Bad reply.
		return true;
	}

	NATDetectServerPrivate::kPacket packet;
	message >> packet;
	switch(packet)
	{
		default:
			break;
		case NATDetectServerPrivate::kProbeFromOtherReply:
		{
//			printf("mGotOther\n");
			mGotOther = true;
			break;
		}

		case NATDetectServerPrivate::kProbeReply:
		{
			float ftemp;
			message >> ftemp;
			std::string temp;
			message >> temp;
			if (address == mAddress1)
			{
				mAddress1Reply = XPAddress(temp);
//				printf("mAddress1Reply %s\n",mAddress1Reply.Export().c_str());
				mGot1Times++;
			}
			if (address == mAddress2)
			{
				mAddress2Reply = XPAddress(temp);
//				printf("mAddress2Reply %s\n",mAddress2Reply.Export().c_str());
				mGot2Times++;
			}
			break;
		}
	}

	return true;
}

bool NATDetectClient::CallbackPoll(void)
{
	// If we have replies from both sides and got the other reply then exit with success
	if ((mGot1Times > 0) && (mGot2Times > 0) && mGotOther)
	{
		return DoSuccessState();
	}

	// If we have more than kMaxTriesForOther replies from ones of the sides and at least reply from the other side
	// then exit with success
	if ( ((mGot1Times > kMaxTriesForOther) && (mGot2Times > 0)) ||
			((mGot1Times > 0) && (mGot2Times > kMaxTriesForOther)) )
	{
		return DoSuccessState();
	}

	if ( (FloatTime() - mLastSentTime) > kRetryTime )
	{
		mLastSentTime = FloatTime();
		if (mTries >= kMaxTries)
		{
			mReply = NATDetectServer::kReply_Timeout;
			CallbackCompleted();
			return false;
		}
		mTries++;
		DynamicMessageHelper message;
		message << mNOnce;
		message << NATDetectServerPrivate::kProbe;
		message << (float) FloatTime();	// Some pseudo random bits to add to the message
		message << (float) FloatTime();
		message << (float) FloatTime();
		message << (float) FloatTime();
		message.AddInteger(0);	// Tests for the packet ending with this 0

		if ((mGot1Times == 0) || !mGotOther)
		{
			PackageAndSendData(mSocket,message,mAddress1);
		}
		if ((mGot2Times == 0) || !mGotOther)
		{
			PackageAndSendData(mSocket,message,mAddress2);
		}
	}
	return true;
}

void NATDetectClient::SetServers(const XPAddress &address1,const XPAddress &address2)
{
	mServerAddressSet = true;
	mAddress1 = address1;
	mAddress2 = address2;
}

bool NATDetectClient::GetCompleted(void)
{
	return !GetIsRunning();
}

NATDetectClient::NATType NATDetectClient::GetNATType(void) const
{
	if (mIsNiceNAT)
	{
		if (mGotOther)
		{
			return NATDetectClient::kOpen;
		}

		return NATDetectClient::kModerate;
	}
	return NATDetectClient::kStrict;
}

NATDetectServer::Reply NATDetectClient::GetReply(void)
{
	return mReply;
}

XPAddress NATDetectClient::GetPublicAddress(void) const
{
	if (mGot1Times)
	{
		return mAddress1Reply;
	}
	if (mGot2Times)
	{
		return mAddress2Reply;
	}
	return XPAddress(0,0,0,0,0);
}

bool NATDetectClient::DoSuccessState(void)
{
	// Check for the two different servers seeing the same external client IP address
	if (mAddress1Reply == mAddress2Reply)
	{
		mIsNiceNAT = true;
	}

	mReply = NATDetectServer::kReply_Success;
	CallbackCompleted();

	return false;
}

void NATDetectClient::GetAddressReplies(XPAddress &addr1,XPAddress &addr2)
{
	addr1 = mAddress1Reply;
	addr2 = mAddress2Reply;
}
//From: RNLobby/NATResolver.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <assert.h>
#include <time.h>
//Skipping: #include "RNPlatform/Options.h"
//Skipping: #include "RNPlatform/DebugSupport.h"
//Skipping: #include "RNLobby/BackendPrivate.h"
//Skipping: #include "RNLobby/Inc/NATResolver.h"
//Skipping: #include "RNPlatform/Inc/CheckSum.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
//Skipping: #include "RNPlatform/Inc/SysTime.h"
//Skipping: #include "RNPlatform/Inc/Encryption.h"
//Skipping: #include "RNPlatform/Inc/RegistryManagerList.h"
//Skipping: #include "RNPlatform/Inc/PlatformHeap.h"
//Skipping: #include "RNXPURL/UDPReliableManager.h"
//Skipping: #include "RNXPURL/Inc/TransportConfig.h"

// Define this to disable the timeout when using breakpoints.
//#define DISABLE_TIMEOUT

using namespace RNReplicaNet;
using namespace RNLobby;


static const int kMaxHostContactTries = 18;
static const float kHostResendTime = 0.3f;
static const float kTimeout = 30.0f;	// The time taken for entries to expire from the internal lists.
static const float kTimeoutPersistent = 60.0f * 5.0f;	// The time taken for persistent entries to expire from the internal lists when not receiving any keep alive packets.
static const int kMaxClientContactTriesBeforeNext = 7;
static const float kPersistentSendTime = 30.0f;
static const float kEmptyListsIdleTime = 10.0f;

static SysTime sNATResolverTheTime;

// Only used for setting or deleting sNATsManager. Nothing else.
static MutexClass sManagerMutex;
static RegistryManagerList<NATResolver> *sNATsManager = 0;

class MyUDPReliableManagerPacketReceiveHook : public UDPReliableManagerPacketReceiveHook
{
public:
	bool CallbackParsePacketData(t_XPSocket *socket,const XPAddress &addr,void *data,size_t length)
	{
		THREADSAFELOCKCLASS(sManagerMutex);
		bool gotOne = false;
		if (sNATsManager)
		{
			sNATsManager->BeginIterate();
			NATResolver *resolver;
			while ( (resolver = sNATsManager->Iterate()) != 0 )
			{
				if (resolver->CallbackParsePacketData(socket,addr,data,length))
				{
					gotOne = true;
				}
			}
		}
		return gotOne;
	}
};

class NATResolver::PerHostState
{
public:
	PerHostState();
	virtual ~PerHostState();
	int mHostStateUID;
	XPAddress mHostAddress;
	int mTries;
	bool mGotAckForInfo;
	SysTimeType mLastTimeSent;
	SysTimeType mLastKeepAliveSent;
};

class NATResolver::NATState
{
public:
	enum tPacketType
	{
		kAdvertise = 10,	// Starts at this number so old versions don't respond
		kAdvertiseACK,
		kAdvertisePersistent,
		kWantResolveFromClient,
		kServerIsAtAddress,
		kClientIsAtAddress,
		kProbeFromServer,
		kProbeFromClient,
		kProbeACK
	};

	NATState();
	NATState(t_XPSocket *socket,void *userPointer,const int titleID,const bool isAdvertised,const int globalID,const int sessionID,const int nonceID,const bool isServer);
	virtual ~NATState();

	void Clear(void);

	std::multiset<NATState *,ltSocket>::iterator mIterBySocket;
	std::set<NATState *,ltIDs>::iterator mIterByIDs;
	std::set<NATState *,ltIDsWithSocket>::iterator mIterByIDsWithSocket;
	std::multiset<NATState *,ltUserPointer>::iterator mIterByUserPointer;
	std::list<NATState *>::iterator mIterByOrder;

	t_XPSocket *mSocket;
	int mTitleID;
	bool mIsAdvertised;
	int mGlobalID;
	int mSessionID;
	int mNonceID;
	bool mIsServer;

	bool mResolved;
	XPAddress mResolvedAddress;
	std::list<PerHostState> mHostStates;	// Used by BeginAdvertise
	std::list<PerHostState> mHostAddresses;	// Used by BeginResolve
	bool mFailed;

	bool mAdvertiseFromValid;
	XPAddress mAdvertiseFrom;

	SysTimeType mTimeAdded;

	bool mIsLocallyHosted;

	XPAddress mServerMostLocalAddress;
	bool mAdvertisedExternalAddressValid;
	XPAddress mAdvertisedExternalAddress;

	bool mPersistent;

	void *mUserPointer;

	bool mIncludeAddressInACK;

	t_XPSocket *mReceivedAvertiseOn;		// Not used for sending, just used for pointer testing/debugging purposes.

	bool mCalledFromBeginResolve;
};

static MyUDPReliableManagerPacketReceiveHook sMyUDPReliableManagerPacketReceiveHook;

namespace RNReplicaNet
{
class XNATResolverHeapBlock;
}

static XNATResolverHeapBlock *sTheHeapBlock = 0;
static int sHostUID = 1;

namespace RNReplicaNet
{
class XNATResolverHeapBlock : public RNReplicaNet::PlatformHeapBlock
{
public:
	virtual ~XNATResolverHeapBlock()
	{
		THREADSAFELOCKCLASS(sManagerMutex);
		UDPReliableManagerPacketReceiveHook::SetUDPReliableManagerPacketReceiveHook(0);
		if (sNATsManager)
		{
			delete sNATsManager;
			sNATsManager = 0;
			sTheHeapBlock = 0;
			sHostUID = 1;
		}
	}
};
}

NATResolver::NATResolver() : mHost(0) , mBecameEmptyAt(0.0f) , mIsEmpty(false) , mServerAddressSet(false)
{
	SetAutomaticThreadStop();
	SetAutomaticHostSocketReads();

	THREADSAFELOCKCLASS(sManagerMutex);
	if (!sNATsManager)
	{
		sNATsManager = new RegistryManagerList<NATResolver>;
		if (!sTheHeapBlock)
		{
			sTheHeapBlock = new XNATResolverHeapBlock();
			sTheHeapBlock->Register();
		}
	}
	sNATsManager->AddItem(this);
	UDPReliableManagerPacketReceiveHook::SetUDPReliableManagerPacketReceiveHook(&sMyUDPReliableManagerPacketReceiveHook);
}

NATResolver::~NATResolver()
{
	// Stack context for lock
	{
		THREADSAFELOCKCLASS(sManagerMutex);
		if (sNATsManager)
		{
			sNATsManager->RemoveItem(this);
			if (sNATsManager->IsEmpty())
			{
				UDPReliableManagerPacketReceiveHook::SetUDPReliableManagerPacketReceiveHook(0);
				delete sNATsManager;
				sNATsManager = 0;
			}
		}
	}

	Stop();
}

bool NATResolver::Stop(void)
{
	Terminate();

	THREADSAFELOCK();

	std::multiset<NATState *,ltSocket>::iterator st,en;
	st = mSetBySocket.begin();
	en = mSetBySocket.end();
	while (st != en)
	{
		std::multiset<NATState *,ltSocket>::iterator tst = st;
		NATState *state = *st++;
		assert(state);
		assert(state->mIterBySocket == tst);		// Paranoia check of the added iterator
		delete state;
	}
	mSetBySocket.clear();
	mSetByIDs.clear();
	mSetByUserPointer.clear();
	mListByOrder.clear();
	return true;
}

void NATResolver::SetAutomaticThreadStop(const bool allow)
{
	mAllowAutoThreadStop = allow;
}

void NATResolver::SetAutomaticHostSocketReads(const bool allow)
{
	mAllowAutoHostSocketReads = allow;
	SetAutomaticThreadStop(false);
}

void NATResolver::SetEncryptionKey(const void *data,const int length)
{
	mCryptoKey.Create((void *)data,length);
}

bool NATResolver::Start(void)
{
	THREADSAFELOCK();
	if (!mServerAddressSet)
	{
		mServerAddress = Backend::GetNATServerAddress();
	}
	if (!GetIsRunning())
	{
		Backend::ServerCryptoHelper<NATResolver>::SetEncryption(this,Backend::GetNATServerCrypto());
		Begin(this);
	}
	return true;
}

bool NATResolver::BeginHosting(t_XPSocket *socket)
{
	THREADSAFELOCK();
	Start();
	mHost = socket;

#ifdef DEBUG_PRINTS7
	dprintf("NATResolver::BeginHosting\n");
#endif

	if (mHost)
	{
#ifdef DEBUG_PRINTS7
		XPAddress exportedAddr;
		XPSock_GetAddress(socket,&exportedAddr);
		dprintf("sock addr %s\n",exportedAddr.Export().c_str());
#endif
	}

	return true;
}

NATResolver::NATState::NATState()
{
	mSocket = 0;
	mUserPointer = 0;
	mIsServer = false;
	Clear();
}

void NATResolver::NATState::Clear(void)
{
	mResolved = false;
	mFailed = false;
	mAdvertiseFromValid = false;
	mTimeAdded = -1.0f;
	mIsLocallyHosted = false;
	mPersistent = false;
	mIncludeAddressInACK = false;
	mAdvertisedExternalAddressValid = false;
	mCalledFromBeginResolve = false;
}

NATResolver::NATState::NATState(t_XPSocket *socket,void *userPointer,const int titleID,const bool isAdvertised,const int globalID,const int sessionID,const int nonceID,const bool isServer) :
	mSocket(socket),mUserPointer(userPointer),mTitleID(titleID),mIsAdvertised(isAdvertised),mGlobalID(globalID),
	mSessionID(sessionID),mNonceID(nonceID),mIsServer(isServer),mReceivedAvertiseOn(0)
{
	Clear();
}

NATResolver::NATState::~NATState()
{
}

bool NATResolver::ltSocket::operator()(const NATState *a,const NATState *b) const
{
	assert(a);
	assert(b);
	return a->mSocket < b->mSocket;
}

// Whee I love these nested compares
bool NATResolver::ltIDs::operator()(const NATState *a,const NATState *b) const
{
	assert(a);
	assert(b);

	if (a->mIsAdvertised < b->mIsAdvertised)
	{
		return true;
	}
	else if (a->mIsAdvertised == b->mIsAdvertised)
	{
		if (a->mIsServer < b->mIsServer)
		{
			return true;
		}
		else if (a->mIsServer == b->mIsServer)
		{
			if (a->mTitleID < b->mTitleID)
			{
				return true;
			}
			else if (a->mTitleID == b->mTitleID)
			{
				if (a->mGlobalID < b->mGlobalID)
				{
					return true;
				}
				else if (a->mGlobalID == b->mGlobalID)
				{
					if (a->mSessionID < b->mSessionID)
					{
						return true;
					}
					else if (a->mSessionID == b->mSessionID)
					{
						return (a->mNonceID < b->mNonceID);
					}
				}
			}
		}
	}
	return false;
}

// Whee I love these nested compares
bool NATResolver::ltIDsWithSocket::operator()(const NATState *a,const NATState *b) const
{
	assert(a);
	assert(b);

	if (a->mSocket < b->mSocket)
	{
		return true;
	}
	else if (a->mSocket == b->mSocket)
	{
		if (a->mIsAdvertised < b->mIsAdvertised)
		{
			return true;
		}
		else if (a->mIsAdvertised == b->mIsAdvertised)
		{
			if (a->mIsServer < b->mIsServer)
			{
				return true;
			}
			else if (a->mIsServer == b->mIsServer)
			{
				if (a->mTitleID < b->mTitleID)
				{
					return true;
				}
				else if (a->mTitleID == b->mTitleID)
				{
					if (a->mGlobalID < b->mGlobalID)
					{
						return true;
					}
					else if (a->mGlobalID == b->mGlobalID)
					{
						if (a->mSessionID < b->mSessionID)
						{
							return true;
						}
						else if (a->mSessionID == b->mSessionID)
						{
							return (a->mNonceID < b->mNonceID);
						}
					}
				}
			}
		}
	}
	return false;
}

bool NATResolver::ltUserPointer::operator()(const NATState *a,const NATState *b) const
{
	assert(a);
	assert(b);
	return a->mUserPointer < b->mUserPointer;
}

bool NATResolver::BeginAdvertise(t_XPSocket *socket,void *userPointer,const bool isAdvertised,const int globalID,const int sessionID,const int nonceID,const bool externalHost,const XPAddress *optionalHost,const bool persistant)
{
	THREADSAFELOCK();

	Start();
	NATState *state = new NATState(socket,userPointer,Backend::GetTitleID(),isAdvertised,globalID,sessionID,nonceID,true);
	state->mPersistent = persistant;

#ifdef DEBUG_PRINTS7
	dprintf("NATResolver::BeginAdvertise: state $%p: sock $%p userP $%p isAd %d globalID %d sessionID %d nonceID %d isServer %d\n",
	(int)state,(int)state->mSocket,(int)state->mUserPointer,(int)state->mIsAdvertised,state->mGlobalID,state->mSessionID,state->mNonceID,state->mIsServer);
	XPAddress exportedAddr;
	XPSock_GetAddress(socket,&exportedAddr);
	dprintf("sock addr %s\n",exportedAddr.Export().c_str());
#endif

	if (externalHost)
	{
		PerHostState hostState;
		hostState.mHostStateUID = sHostUID++;
		hostState.mHostAddress = mServerAddress;
		state->mHostStates.push_back(hostState);
	}
	if (optionalHost)
	{
		PerHostState hostState;
		hostState.mHostStateUID = sHostUID++;
		hostState.mHostAddress = *optionalHost;
		state->mHostStates.push_back(hostState);
	}

	state->mIsLocallyHosted = true;
	XPSock_GetAddress(socket,&state->mServerMostLocalAddress);
	return InsertState(state);
}

bool NATResolver::BeginResolve(t_XPSocket *socket,void *userPointer,const bool isAdvertised,const int globalID,const int sessionID,const int nonceID,const bool tryExternalHost,const XPAddress *optionalHost,const XPAddress *optionalFirstTargetTry)
{
	THREADSAFELOCK();
	Start();
	NATState *state = new NATState(socket,userPointer,Backend::GetTitleID(),isAdvertised,globalID,sessionID,nonceID,false);

#ifdef DEBUG_PRINTS7
	dprintf("NATResolver::BeginResolve: state $%p: sock $%p userP $%p isAd %d globalID %d sessionID %d nonceID %d isServer %d\n",
	(int)state,(int)state->mSocket,(int)state->mUserPointer,(int)state->mIsAdvertised,state->mGlobalID,state->mSessionID,state->mNonceID,state->mIsServer);
	XPAddress exportedAddr;
	XPSock_GetAddress(socket,&exportedAddr);
	dprintf("tryExternalHost %d sock addr %s mServerAddress %s\n",(int)tryExternalHost,exportedAddr.Export().c_str(),mServerAddress.Export().c_str());
	if (optionalHost)
	{
		dprintf("optionalHost = %s\n",optionalHost->Export().c_str());
	}
	if (optionalFirstTargetTry)
	{
		dprintf("optionalFirstTargetTry = %s\n",optionalFirstTargetTry->Export().c_str());
	}
#endif

	XPAddress a1(0,0,0,0,0);
	XPAddress a2(0,0,0,0,0);

	if (optionalFirstTargetTry)
	{
		a1 = *optionalFirstTargetTry;
	}
	if (optionalHost)
	{
		if (*optionalHost != a1)
		{
			a2 = *optionalHost;
		}
	}

	// Try to go through the externally hosted NATResolver server first of all. The server will then try to contact both peers and tell them to contact each
	// other with kClientIsAtAddress and kServerIsAtAddress
	if (tryExternalHost)
	{
		if ( (mServerAddress != a1) && (mServerAddress != a2) )
		{
			PerHostState hostState;
			hostState.mHostAddress = mServerAddress;
			state->mHostAddresses.push_back(hostState);
		}
	}

	if (optionalFirstTargetTry)
	{
		PerHostState hostState;
		hostState.mHostAddress = *optionalFirstTargetTry;
		state->mHostAddresses.push_back(hostState);
	}

	if (optionalHost)
	{
		if (*optionalHost != a1)
		{
			PerHostState hostState;
			hostState.mHostAddress = *optionalHost;
			state->mHostAddresses.push_back(hostState);
		}
	}

	state->mCalledFromBeginResolve = true;

	return InsertState(state);
}

bool NATResolver::InsertState(NATState *state)
{
#ifdef DEBUG_PRINTS7
	dprintf("NATResolver::InsertState: state $%p: sock $%p userP $%p isAd %d globalID %d sessionID %d nonceID %d isServer %d\n",
	(int)state,(int)state->mSocket,(int)state->mUserPointer,(int)state->mIsAdvertised,state->mGlobalID,state->mSessionID,state->mNonceID,state->mIsServer);
#endif

	state->mTimeAdded = sNATResolverTheTime.FloatTime();
	state->mIterBySocket = mSetBySocket.insert(state);
	state->mIterByUserPointer = mSetByUserPointer.insert(state);
	bool isInserted = false;
	if (state->mIsServer)
	{
		std::pair<std::set<NATState *,ltIDs>::iterator,bool> ret1;
		ret1 = mSetByIDs.insert(state);
		assert(ret1.second);
		state->mIterByIDs = ret1.first;
		isInserted = ret1.second;
	}
	else
	{
		std::pair<std::set<NATState *,ltIDsWithSocket>::iterator,bool> ret1;
		ret1 = mSetByIDsWithSocket.insert(state);
		assert(ret1.second);
		state->mIterByIDsWithSocket = ret1.first;
		isInserted = ret1.second;
	}
	mListByOrder.push_back(state);
	state->mIterByOrder = --mListByOrder.end();
	return isInserted;
}

void NATResolver::DeleteState(NATState * &state)
{
#ifdef DEBUG_PRINTS7
	dprintf("NATResolver::DeleteState: state $%p: sock $%p userP $%p isAd %d globalID %d sessionID %d nonceID %d isServer %d\n",
	(int)state,(int)state->mSocket,(int)state->mUserPointer,(int)state->mIsAdvertised,state->mGlobalID,state->mSessionID,state->mNonceID,state->mIsServer);
#endif

	if (state->mCalledFromBeginResolve && !state->mResolved)
	{
		CallbackResolveFailed(state->mSocket,state->mUserPointer,state->mTitleID,state->mIsAdvertised,state->mGlobalID,state->mSessionID,state->mNonceID);
	}

	if (state->mIsServer)
	{
		mSetByIDs.erase(state->mIterByIDs);
	}
	else
	{
		mSetByIDsWithSocket.erase(state->mIterByIDsWithSocket);
	}
	mSetBySocket.erase(state->mIterBySocket);
	mSetByUserPointer.erase(state->mIterByUserPointer);
	mListByOrder.erase(state->mIterByOrder);
	state->mSocket = 0;
	delete state;
	state = 0;
}

void NATResolver::ForgetSocket(const t_XPSocket *socket)
{
	THREADSAFELOCK();

#ifdef DEBUG_PRINTS7
	dprintf("NATResolver::ForgetSocket: sock $%p\n",(int)socket);
#endif

	if (mHost == socket)
	{
#ifdef DEBUG_PRINTS7
		dprintf("Was host\n");
#endif
		mHost = 0;
	}

	NATState temp;
	temp.mSocket = (t_XPSocket *) socket;
	std::pair<std::multiset<NATState *,ltSocket>::iterator,std::multiset<NATState *,ltSocket>::iterator> range;
	range.first = mSetBySocket.lower_bound(&temp);
	range.second = mSetBySocket.upper_bound(&temp);
	if (range.first != range.second)
	{
		std::multiset<NATState *,ltSocket>::iterator st = range.first;
		while (st != range.second)
		{
#ifdef DEBUG_PRINTS7
			dprintf("Found state so delete\n");
#endif

			std::multiset<NATState *,ltSocket>::iterator tst = st;
			NATState *state = *st++;
			assert(state);
			assert(state->mIterBySocket == tst);		// Paranoia check of the added iterator
			DeleteState(state);
		}
	}
}

void NATResolver::ForgetResolve(t_XPSocket *socket,const bool isAdvertised,const int globalID,const int sessionID,const int nonceID)
{
	THREADSAFELOCK();

#ifdef DEBUG_PRINTS7
	dprintf("NATResolver::ForgetResolve: isAdvertised %d globalID %d sessionID %d nonceID %d\n",(int)isAdvertised,globalID,sessionID,nonceID);
#endif

	NATState temp;
	temp.mSocket = socket;
	temp.mTitleID = Backend::GetTitleID();
	temp.mIsAdvertised = isAdvertised;
	temp.mGlobalID = globalID;
	temp.mSessionID = sessionID;
	temp.mNonceID = nonceID;

	std::set<NATState *,ltIDs>::iterator found;
	temp.mIsServer = true;
	found = mSetByIDs.find(&temp);
	if (found != mSetByIDs.end())
	{
#ifdef DEBUG_PRINTS7
		dprintf("Found state so delete\n");
#endif

		NATState *state = *found;
		assert(state);
		assert(state->mIterByIDs == found);		// Paranoia check of the added iterator
		DeleteState(state);
	}

	std::set<NATState *,ltIDsWithSocket>::iterator found2;
	temp.mIsServer = false;
	found2 = mSetByIDsWithSocket.find(&temp);
	if (found2 != mSetByIDsWithSocket.end())
	{
#ifdef DEBUG_PRINTS7
		dprintf("Found state so delete\n");
#endif

		NATState *state = *found2;
		assert(state);
		assert(state->mIterByIDsWithSocket == found2);		// Paranoia check of the added iterator
		DeleteState(state);
	}
}

void NATResolver::ForgetUserPointer(const void *userPointer)
{
	THREADSAFELOCK();

#ifdef DEBUG_PRINTS7
	dprintf("NATResolver::ForgetUserPointer: userPointer $%p\n",(int)userPointer);
#endif

	NATState temp;
	temp.mUserPointer = (void *) userPointer;
	std::pair<std::multiset<NATState *,ltUserPointer>::iterator,std::multiset<NATState *,ltUserPointer>::iterator> range;
	range.first = mSetByUserPointer.lower_bound(&temp);
	range.second = mSetByUserPointer.upper_bound(&temp);
	if (range.first != range.second)
	{
		std::multiset<NATState *,ltUserPointer>::iterator st = range.first;
		while (st != range.second)
		{
#ifdef DEBUG_PRINTS7
			dprintf("Found state so delete\n");
#endif

			std::multiset<NATState *,ltUserPointer>::iterator tst = st;
			NATState *state = *st++;
			assert(state);
			assert(state->mIterByUserPointer == tst);		// Paranoia check of the added iterator
			DeleteState(state);
		}
	}
}

static void SetAddr(DynamicMessageHelper &message,const XPAddress &addr)
{
	message << addr.port;
	message << addr.addr[0];
	message << addr.addr[1];
	message << addr.addr[2];
	message << addr.addr[3];
}

static void GetAddr(DynamicMessageHelper &message,XPAddress &addr)
{
	message >> addr.port;
	message >> addr.addr[0];
	message >> addr.addr[1];
	message >> addr.addr[2];
	message >> addr.addr[3];
	addr.mIPv4 = true;
	addr.mIPv6 = false;
}

bool NATResolver::CallbackParsePacketData(t_XPSocket *socket,const XPAddress &addr,void *data,size_t length)
{
	// Do some early out tests
	if (length < (sizeof(short) + sizeof(char)))
	{
		return false;
	}
	MessageHelper tempM;
	tempM.SetBuffer(data);
	short theSize;
	MESSAGEHELPER_GETVARIABLEp(tempM,theSize);
	char packetType;
	MESSAGEHELPER_GETVARIABLEp(tempM,packetType);

	if (packetType != UDPReliableManager::kNAT)
	{
		return false;
	}

	if (length < (size_t) theSize)
	{
		return false;
	}

	if ( (theSize < (int)(sizeof(short) + sizeof(char) + sizeof(int))) || (theSize > 2048) )
	{
		return false;
	}

	// It passed these tests so we continue with some slightly more expensive tests
	int checksum;
	MESSAGEHELPER_GETVARIABLEp(tempM,checksum);

	DynamicMessageHelper message;
	message.AddData(tempM.GetCurrentPosition(),theSize - tempM.GetSize());

	// Yes this accesses mCryptoKey which is a class member variable and yes this class could be deleted in a thread other than this one.
	// But to stop the thread from prematurely locking during the decrypt we accept this small risk since people should not be attempting to call this function during a delete of this class.
	Encryption::Decrypt(message.GetBuffer(),message.GetSize(),&mCryptoKey);
	int testChecksum = Checksum::ChecksumData(message.GetBuffer(),message.GetSize());
	if (testChecksum != checksum)
	{
		return false;
	}

	THREADSAFELOCK();

#ifdef DEBUG_PRINTS7
	dprintf("NATResolver::CallbackParsePacketData: Passed inital tests\nsock $%p from %s data %s\n",(int)socket,addr.Export().c_str(),message.DumpAsHex().c_str());
#endif


	Start();

	// Rewind the message
	message.SetSize(0);
	NATState::tPacketType packet;
	message >> packet;
	switch(packet)
	{
		default:
		{
#ifdef DEBUG_PRINTS7
			dprintf("Got unknown NAT packet %d\n",(int)packet);
#endif
			return true;
			break;
		}
		case NATState::kAdvertise:
		case NATState::kAdvertisePersistent:
		{
			// Don't forget kAdvertise is sent even if it is persistent until the host gets its kAdvertiseACK
			NATState tempState;
			PerHostState hostState;
			message >> hostState.mHostStateUID;
			message >> tempState.mTitleID;
			message >> tempState.mIsAdvertised;
			message >> tempState.mGlobalID;
			message >> tempState.mSessionID;
			message >> tempState.mNonceID;
			message >> tempState.mPersistent;
#ifdef DEBUG_PRINTS7
			dprintf("kAdvertise persistent=%d HSUID%d TID%d isAd %d globalID %d sessionID %d nonceID %d P%d\n",packet == NATState::kAdvertisePersistent,hostState.mHostStateUID,
				tempState.mTitleID,(int)tempState.mIsAdvertised,tempState.mGlobalID,tempState.mSessionID,tempState.mNonceID,tempState.mPersistent);
#endif
			tempState.mIsServer = true;
			XPAddress myMostLocalAddress;
			GetAddr(message,myMostLocalAddress);

			// Look for it
			std::set<NATState *,ltIDs>::iterator found;
			found = mSetByIDs.find(&tempState);
			NATState *state = 0;
			if (found != mSetByIDs.end())
			{
				// Don't forget, even a locally hosted NATResolver can get these packet types
				state = *found;
				assert(state);
				assert(state->mIterByIDs == found);		// Paranoia check of the added iterator
#ifdef DEBUG_PRINTS7
				dprintf("NATState found $%p , $%p\n",state->mSocket , socket);
#endif
				// We received an advertise packet, but we have an entry for it already so don't do much.
				state->mReceivedAvertiseOn = socket;
			}
			else
			{
				// Not found so we must be an external host who has received the packet
				state = new NATState();
				*state = tempState;
				state->mSocket = socket;
				state->mIncludeAddressInACK = true;
				InsertState(state);
				state->mReceivedAvertiseOn = socket;
			}
			state->mServerMostLocalAddress = myMostLocalAddress;
			state->mAdvertiseFrom = addr;
			state->mAdvertiseFromValid = true;

			if (packet == NATState::kAdvertise)
			{
				message.SetSize(0);
				NATState::tPacketType packet = NATState::kAdvertiseACK;
				message << packet;
				message << hostState.mHostStateUID;
				message << state->mTitleID;
				message << state->mIsAdvertised;
				message << state->mGlobalID;
				message << state->mSessionID;
				message << state->mNonceID;
				bool includesAddress = state->mIncludeAddressInACK;
				message << includesAddress;
				if (includesAddress)
				{
					SetAddr(message,addr);
				}

				PackageAndSendData(socket,message,addr);
			}
			else
			{
				assert(state->mPersistent);		// Should only be flagged as persistent with this packet type
			}
			// This notes the last time for timeout reasons.
			state->mTimeAdded = sNATResolverTheTime.FloatTime();

			return true;
			break;
		}

		case NATState::kAdvertiseACK:
		{
			NATState tempState;
			PerHostState hostState;
			message >> hostState.mHostStateUID;
			message >> tempState.mTitleID;
			message >> tempState.mIsAdvertised;
			message >> tempState.mGlobalID;
			message >> tempState.mSessionID;
			message >> tempState.mNonceID;
#ifdef DEBUG_PRINTS7
			dprintf("kAdvertiseACK HSUID%d TID%d isAd %d globalID %d sessionID %d nonceID %d\n",hostState.mHostStateUID,
				tempState.mTitleID,(int)tempState.mIsAdvertised,tempState.mGlobalID,tempState.mSessionID,tempState.mNonceID);
#endif
			bool includesAddress;
			message >> includesAddress;
			XPAddress theAddr;
			if (includesAddress)
			{
				GetAddr(message,theAddr);
			}
			tempState.mIsServer = true;

			// Look for it
			std::set<NATState *,ltIDs>::iterator found;
			found = mSetByIDs.find(&tempState);
			NATState *state = 0;
			if (found != mSetByIDs.end())
			{
				state = *found;
				assert(state);
				assert(state->mIterByIDs == found);		// Paranoia check of the added iterator
#ifdef DEBUG_PRINTS7
				dprintf("NATState found $%p , $%p\n",state->mSocket , socket);
#endif
				std::list<PerHostState>::iterator st = state->mHostStates.begin();
				while (st != state->mHostStates.end())
				{
					PerHostState &hostStateFromList = *st++;
					if (hostStateFromList.mHostStateUID == hostState.mHostStateUID)
					{
						if (includesAddress)
						{
							state->mAdvertisedExternalAddressValid = true;
							state->mAdvertisedExternalAddress = theAddr;
							if (!hostStateFromList.mGotAckForInfo)
							{
								CallbackExternalAddressKnown(socket,state->mUserPointer,state->mAdvertisedExternalAddress,tempState.mTitleID,tempState.mIsAdvertised,tempState.mGlobalID,tempState.mSessionID,tempState.mNonceID);
							}
						}
						hostStateFromList.mGotAckForInfo = true;
						return true;
						break;
					}
				}
			}

			return true;
			break;
		}

		case NATState::kWantResolveFromClient:
		{
			NATState tempState;
			message >> tempState.mTitleID;
			message >> tempState.mIsAdvertised;
			message >> tempState.mGlobalID;
			message >> tempState.mSessionID;
			message >> tempState.mNonceID;
#ifdef DEBUG_PRINTS7
			dprintf("kWantResolveFromClient TID%d isAd %d globalID %d sessionID %d nonceID %d\n",
				tempState.mTitleID,(int)tempState.mIsAdvertised,tempState.mGlobalID,tempState.mSessionID,tempState.mNonceID);
#endif
			tempState.mIsServer = true;

			// Look for it
			std::set<NATState *,ltIDs>::iterator found;
			found = mSetByIDs.find(&tempState);
			NATState *state = 0;
			if (found != mSetByIDs.end())
			{
				state = *found;
				assert(state);
				assert(state->mIterByIDs == found);		// Paranoia check of the added iterator
#ifdef DEBUG_PRINTS7
				dprintf("NATState found $%p , $%p ILH%d AFV%d\n",state->mSocket , socket,(int)state->mIsLocallyHosted,(int)state->mAdvertiseFromValid);
#endif

				if (state->mIsLocallyHosted && state->mSocket == socket)
				{
					// If we are locally hosted and the state socket matches the incoming socket then we react as if there has been a probe
					state->mResolved = true;
					state->mResolvedAddress = addr;

					message.SetSize(0);
					NATState::tPacketType packet = NATState::kProbeACK;
					message << packet;
					message << state->mTitleID;
					message << state->mIsAdvertised;
					message << state->mGlobalID;
					message << state->mSessionID;
					message << state->mNonceID;

					PackageAndSendData(state->mSocket,message,addr);

#ifdef DEBUG_PRINTS7
					dprintf("kProbeACK sent to %s\n",addr.Export().c_str());
#endif

				}
				else
				{
					if (state->mAdvertiseFromValid)
					{
						// Tell both parties where the other is as viewed from the intermediate socket
						// Send to where we know the server side is who advertised
						message.SetSize(0);
						packet = NATState::kClientIsAtAddress;
						message << packet;
						message << state->mTitleID;
						message << state->mIsAdvertised;
						message << state->mGlobalID;
						message << state->mSessionID;
						message << state->mNonceID;
						SetAddr(message,addr);
						PackageAndSendData(state->mSocket,message,state->mAdvertiseFrom);

						// Tell the client where the server is
						message.SetSize(0);
						NATState::tPacketType packet = NATState::kServerIsAtAddress;
						message << packet;
						message << state->mTitleID;
						message << state->mIsAdvertised;
						message << state->mGlobalID;
						message << state->mSessionID;
						message << state->mNonceID;
						SetAddr(message,state->mAdvertiseFrom);
						SetAddr(message,state->mServerMostLocalAddress);
						// Send back to the client requesting the resolve
						PackageAndSendData(socket,message,addr);

#ifdef DEBUG_PRINTS7
						dprintf("kClientIsAtAddress sent to %s and kServerIsAtAddress sent to %s\n",state->mAdvertiseFrom.Export().c_str(),addr.Export().c_str());
#endif
					}
				}
			}

			return true;
			break;
		}

		case NATState::kServerIsAtAddress:
		{
			NATState tempState;
			tempState.mSocket = socket;
			message >> tempState.mTitleID;
			message >> tempState.mIsAdvertised;
			message >> tempState.mGlobalID;
			message >> tempState.mSessionID;
			message >> tempState.mNonceID;
#ifdef DEBUG_PRINTS7
			dprintf("kServerIsAtAddress TID%d isAd %d globalID %d sessionID %d nonceID %d\n",
				tempState.mTitleID,(int)tempState.mIsAdvertised,tempState.mGlobalID,tempState.mSessionID,tempState.mNonceID);
#endif
			tempState.mIsServer = false;
			XPAddress toAddr;
			GetAddr(message,toAddr);
			XPAddress toAddrMostLocal;
			GetAddr(message,toAddrMostLocal);
#ifdef DEBUG_PRINTS7
			dprintf("toAddr = %s\n",toAddr.Export().c_str());
			dprintf("toAddrMostLocal = %s\n",toAddrMostLocal.Export().c_str());
#endif

			// Look for it
			std::set<NATState *,ltIDsWithSocket>::iterator found;
			found = mSetByIDsWithSocket.find(&tempState);
			NATState *state = 0;
			if (found != mSetByIDsWithSocket.end())
			{
				state = *found;
				assert(state);
				assert(state->mIterByIDsWithSocket == found);		// Paranoia check of the added iterator
#ifdef DEBUG_PRINTS7
				dprintf("NATState found $%p , $%p\n",state->mSocket , socket);
#endif
				if (state->mSocket != socket)
				{
					return true;
				}

				message.SetSize(0);
				packet = NATState::kProbeFromClient;
				message << packet;
				message << state->mTitleID;
				message << state->mIsAdvertised;
				message << state->mGlobalID;
				message << state->mSessionID;
				message << state->mNonceID;

				if (toAddrMostLocal != toAddr)
				{
					PackageAndSendData(socket,message,toAddrMostLocal);		// Client tries to send a probe also over the local network if the addresses do not match
				}

				// Port guessing
				int i;
				for (i=0;i<10;i++)
				{
					PackageAndSendData(socket,message,toAddr);				// Potentially and most likely over the internet
					toAddr.port++;
				}
			}

			return true;
			break;
		}

		case NATState::kClientIsAtAddress:
		{
			NATState tempState;
			tempState.mSocket = socket;
			message >> tempState.mTitleID;
			message >> tempState.mIsAdvertised;
			message >> tempState.mGlobalID;
			message >> tempState.mSessionID;
			message >> tempState.mNonceID;
#ifdef DEBUG_PRINTS7
			dprintf("kClientIsAtAddress TID%d isAd %d globalID %d sessionID %d nonceID %d\n",
				tempState.mTitleID,(int)tempState.mIsAdvertised,tempState.mGlobalID,tempState.mSessionID,tempState.mNonceID);
#endif
			tempState.mIsServer = true;
			XPAddress toAddr;
			GetAddr(message,toAddr);
#ifdef DEBUG_PRINTS7
			dprintf("toAddr = %s\n",toAddr.Export().c_str());
#endif

			// Look for it
			std::set<NATState *,ltIDs>::iterator found;
			found = mSetByIDs.find(&tempState);
			NATState *state = 0;
			if (found != mSetByIDs.end())
			{
				state = *found;
				assert(state);
				assert(state->mIterByIDs == found);		// Paranoia check of the added iterator
#ifdef DEBUG_PRINTS7
				dprintf("NATState found $%p , $%p\n",state->mSocket , socket);
#endif
				if (state->mSocket != socket)
				{
					return true;
				}

				message.SetSize(0);
				packet = NATState::kProbeFromServer;
				message << packet;
				message << state->mTitleID;
				message << state->mIsAdvertised;
				message << state->mGlobalID;
				message << state->mSessionID;
				message << state->mNonceID;
				
#ifdef DEBUG_PRINTS7
				dprintf("Sending kProbeFromServer\n");
#endif
				// Port guessing
				int i;
				for (i=0;i<10;i++)
				{
					PackageAndSendData(socket,message,toAddr);
					toAddr.port++;
				}
			}

			return true;
			break;
		}

		case NATState::kProbeFromServer:
		{
#ifdef DEBUG_PRINTS7
			dprintf("kProbeFromServer\n");
#endif
			// Don't do anything with it...
			return true;
			break;
		}

		case NATState::kProbeFromClient:
		{
			NATState tempState;
			message >> tempState.mTitleID;
			message >> tempState.mIsAdvertised;
			message >> tempState.mGlobalID;
			message >> tempState.mSessionID;
			message >> tempState.mNonceID;
#ifdef DEBUG_PRINTS7
			dprintf("kProbeFromClient TID%d isAd %d globalID %d sessionID %d nonceID %d\n",
				tempState.mTitleID,(int)tempState.mIsAdvertised,tempState.mGlobalID,tempState.mSessionID,tempState.mNonceID);
#endif
			tempState.mIsServer = true;

			// Look for it
			std::set<NATState *,ltIDs>::iterator found;
			found = mSetByIDs.find(&tempState);
			NATState *state = 0;
			if (found != mSetByIDs.end())
			{
				state = *found;
				assert(state);
				assert(state->mIterByIDs == found);		// Paranoia check of the added iterator
#ifdef DEBUG_PRINTS7
				dprintf("NATState found $%p , $%p\n",state->mSocket , socket);
#endif
				if (state->mSocket != socket)
				{
					return true;
				}

				message.SetSize(0);
				packet = NATState::kProbeACK;
				message << packet;
				message << state->mTitleID;
				message << state->mIsAdvertised;
				message << state->mGlobalID;
				message << state->mSessionID;
				message << state->mNonceID;

				PackageAndSendData(socket,message,addr);
			}

			return true;
			break;
		}

		case NATState::kProbeACK:
		{
			NATState tempState;
			tempState.mSocket = socket;
			message >> tempState.mTitleID;
			message >> tempState.mIsAdvertised;
			message >> tempState.mGlobalID;
			message >> tempState.mSessionID;
			message >> tempState.mNonceID;
#ifdef DEBUG_PRINTS7
			dprintf("kProbeACK TID%d isAd %d globalID %d sessionID %d nonceID %d\n",
				tempState.mTitleID,(int)tempState.mIsAdvertised,tempState.mGlobalID,tempState.mSessionID,tempState.mNonceID);
#endif
			tempState.mIsServer = false;

			// Look for it
			std::set<NATState *,ltIDsWithSocket>::iterator found;
			found = mSetByIDsWithSocket.find(&tempState);
			NATState *state = 0;
			if (found != mSetByIDsWithSocket.end())
			{
				state = *found;
				assert(state);
				assert(state->mIterByIDsWithSocket == found);		// Paranoia check of the added iterator
#ifdef DEBUG_PRINTS7
				dprintf("NATState found $%p , $%p\n",state->mSocket , socket);
#endif
				if (state->mSocket != socket)
				{
					return true;
				}

				state->mResolved = true;
				state->mResolvedAddress = addr;

				CallbackResolveResult(socket,state->mUserPointer,addr,tempState.mTitleID,tempState.mIsAdvertised,tempState.mGlobalID,tempState.mSessionID,tempState.mNonceID);
				DeleteState(state);
			}

			return true;
			break;
		}
	}

	return true;
}

void NATResolver::SetServer(const XPAddress &address)
{
	mServerAddressSet = true;
	mServerAddress = address;
}

void NATResolver::CallbackResolveFailed(t_XPSocket *socket,void *userPointer,const int titleID,const bool isAdvertised,const int globalID,const int sessionID,const int nonceID)
{
}

void NATResolver::CallbackResolveResult(t_XPSocket *socket,void *userPointer,const XPAddress &targetAddress,const int titleID,const bool isAdvertised,const int globalID,const int sessionID,const int nonceID)
{
}

void NATResolver::CallbackExternalAddressKnown(t_XPSocket *socket,void *userPointer,const XPAddress &externalAddress,const int titleID,const bool isAdvertised,const int globalID,const int sessionID,const int nonceID)
{
}

bool NATResolver::PackageAndSendData(t_XPSocket *socket,const DynamicMessageHelper &message,const XPAddress &address)
{
	if (message.GetSize() <= 0)
	{
		return true;
	}
	DynamicMessageHelper target;
	short theSize = 0;	// To be filled in later
	target << theSize;
	char packetType = UDPReliableManager::kNAT;
	target << packetType;

	target << Checksum::ChecksumData(message.GetBuffer(),message.GetSize());

	DynamicMessageHelper toCrypt;
	toCrypt.AddData(message.GetBuffer(),message.GetSize());
	Encryption::Encrypt(toCrypt.GetBuffer(),toCrypt.GetSize(),&mCryptoKey);

	target.AddData(toCrypt.GetBuffer(),toCrypt.GetSize());

	// Update the size
	MessageHelper tempMessage;
	tempMessage.SetBuffer(target.GetBuffer());
	theSize = (short) target.GetSize();
	MESSAGEHELPER_ADDVARIABLEp(tempMessage,theSize);

	int ret = XPSock_UrgentSend(socket,(char *) target.GetBuffer(), target.GetSize() , &address);

	return (ret == XPSOCK_EOK);
}


NATResolver::PerHostState::PerHostState() :
	mHostStateUID(0) , mTries(0) , mGotAckForInfo(false) , mLastTimeSent(-1000.0f) , mLastKeepAliveSent(-1000.0f)
{
}

NATResolver::PerHostState::~PerHostState()
{
}

int NATResolver::ThreadEntry(void)
{
	bool gotError = false;
	while (!gotError)
	{
		// Stack context for safe lock
		{
			THREADSAFELOCK();

			if (mAllowAutoHostSocketReads && mHost)
			{
				RNReplicaNet::DynamicMessageHelper message( RNReplicaNet::TransportConfig::GetPacketMTU() );
				int times = 100;
				int ret;
				do
				{
					RNReplicaNet::XPAddress addr;
					ret = XPSock_UrgentRecv(mHost,(char *) message.GetBuffer(),message.GetBufferSize(),XPSOCK_FNULL,&addr);
					if (ret > 0)
					{
						CallbackParsePacketData(mHost,addr,message.GetBuffer(),ret);
					}
					if (ret == XPSOCK_EERROR)
					{
						// Expire errors and count them as packets with data
//						int real = asocket_lasterror;
						ret = 1;
					}
				} while ( (times-- > 0) && (ret > 0) );
			}

			std::multiset<NATState *,ltSocket>::iterator st,en;
			st = mSetBySocket.begin();
			en = mSetBySocket.end();
			while (st != en)
			{
				std::multiset<NATState *,ltSocket>::iterator tst = st;
				NATState *state = *st++;
				assert(state);
				assert(state->mIterBySocket == tst);		// Paranoia check of the added iterator

#ifndef DISABLE_TIMEOUT
				if (state->mFailed)
				{
#ifdef DEBUG_PRINTS7
					dprintf("NATResolver::ThreadEntry state->mFailed del\n");
#endif
					DeleteState(state);
					continue;
				}

				if (state->mPersistent)
				{
					if ( (sNATResolverTheTime.FloatTime() - state->mTimeAdded) > kTimeoutPersistent)
					{
#ifdef DEBUG_PRINTS7
						dprintf("NATResolver::ThreadEntry mPersistent del\n");
#endif
						DeleteState(state);
						continue;
					}
				}
				else
				{
					if ( (sNATResolverTheTime.FloatTime() - state->mTimeAdded) > kTimeout)
					{
#ifdef DEBUG_PRINTS7
						dprintf("NATResolver::ThreadEntry !mPersistent del\n");
#endif
						DeleteState(state);
						continue;
					}
				}
#endif

				if (state->mIsServer)
				{
					std::list<PerHostState>::iterator st = state->mHostStates.begin();
					while (st != state->mHostStates.end())
					{
						std::list<PerHostState>::iterator tst = st;
						PerHostState &hostState = *st++;
						if (!hostState.mGotAckForInfo)
						{
							if (hostState.mTries < kMaxHostContactTries)
							{
								if ( (sNATResolverTheTime.FloatTime() - hostState.mLastTimeSent) > kHostResendTime )
								{
									hostState.mLastKeepAliveSent = hostState.mLastTimeSent = sNATResolverTheTime.FloatTime();

									DynamicMessageHelper message;
									NATState::tPacketType packet = NATState::kAdvertise;
									message << packet;
									BuildAndSendAdvertisePacket(message,state,hostState);
									hostState.mTries++;
								}
							}
							else
							{
								state->mHostStates.erase(tst);
								if (state->mHostStates.empty())
								{
									state->mFailed = true;
								}
								continue;
							}
						}
						else
						{
							// Got advertise ack so we test for persistent ones and continue to send a smaller advertise
							if ( state->mPersistent )
							{
								if ( (sNATResolverTheTime.FloatTime() - hostState.mLastKeepAliveSent) > kPersistentSendTime )
								{
									hostState.mLastKeepAliveSent = sNATResolverTheTime.FloatTime();

									DynamicMessageHelper message;
									NATState::tPacketType packet = NATState::kAdvertisePersistent;
									message << packet;
									BuildAndSendAdvertisePacket(message,state,hostState);
								}
								// This notes the last time for timeout reasons.
								state->mTimeAdded = sNATResolverTheTime.FloatTime();
							}
						}
					} // while (st != state->mHostStates.end())
				}
				else	// if (state->mIsServer)
				{
					std::list<PerHostState>::iterator st = state->mHostAddresses.begin();
					while (st != state->mHostAddresses.end())
					{
						std::list<PerHostState>::iterator tst = st;
						PerHostState &hostState = *st++;

						if ( (sNATResolverTheTime.FloatTime() - hostState.mLastTimeSent) > kHostResendTime )
						{
							hostState.mLastTimeSent = sNATResolverTheTime.FloatTime();

							DynamicMessageHelper message;
							NATState::tPacketType packet = NATState::kWantResolveFromClient;
							message << packet;
							message << state->mTitleID;
							message << state->mIsAdvertised;
							message << state->mGlobalID;
							message << state->mSessionID;
							message << state->mNonceID;

							PackageAndSendData(state->mSocket,message,hostState.mHostAddress);
//							OutputDebugStringA(hostState.mHostAddress.Export().c_str());
//							OutputDebugStringA("\n");

#ifdef DEBUG_PRINTS7
							dprintf("NATResolver::ThreadEntry : state $%p sending from sock $%p kWantResolveFromClient toaddr %s\n",state,state->mSocket,hostState.mHostAddress.Export().c_str());
							dprintf("kWantResolveFromClient TID%d isAd %d globalID %d sessionID %d nonceID %d\n",
								state->mTitleID,(int)state->mIsAdvertised,state->mGlobalID,state->mSessionID,state->mNonceID);
#endif


							hostState.mTries++;
							if (hostState.mTries > kMaxHostContactTries)
							{
								state->mHostAddresses.erase(tst);
#ifdef DEBUG_PRINTS7
								dprintf("NATResolver::ThreadEntry : state $%p from sock $%p erase toaddr %s\n",state,state->mSocket,hostState.mHostAddress.Export().c_str());
#endif
								if (state->mHostAddresses.empty())
								{
									state->mFailed = true;

#ifdef DEBUG_PRINTS7
									dprintf("NATResolver::ThreadEntry : state $%p from sock $%p Failed toaddr %s\n",state,state->mSocket,hostState.mHostAddress.Export().c_str());
#endif
									break;
								}
							}
						} // if ( (sNATResolverTheTime.FloatTime() - hostState.mLastTimeSent) > kHostResendTime )

						// This test causes a little bit of staggering so that we send kMaxClientContactTriesBeforeNext packets before trying the next item in the list
						if (hostState.mTries < kMaxClientContactTriesBeforeNext)
						{
#ifdef DEBUG_PRINTS7
							dprintf("NATResolver::ThreadEntry : state $%p from sock $%p skip toaddr %s\n",state,state->mSocket,hostState.mHostAddress.Export().c_str());
#endif
							break;
						}

					} // while (st != state->mHostAddresses.end())
				} // else... if (state->mIsServer)
			} // while (st != en)
			// Was there entries and then an empty list this cycle?
			if (!mSetBySocket.empty())
			{
				mIsEmpty = false;
			}
			else if (!mIsEmpty)
			{
				mIsEmpty = true;
				mBecameEmptyAt = sNATResolverTheTime.FloatTime();
			}
			// If we have been empty for more than kEmptyListsIdleTime seconds then we exit this thread
			if (mAllowAutoThreadStop && mSetBySocket.empty() && (sNATResolverTheTime.FloatTime() - mBecameEmptyAt) > kEmptyListsIdleTime)
			{
				return 0;
			}
		}
		Sleep(10);
	}

	return 0;
}

bool NATResolver::BuildAndSendAdvertisePacket(DynamicMessageHelper &message,NATState *state,PerHostState &hostState)
{
	message << hostState.mHostStateUID;
	message << state->mTitleID;
	message << state->mIsAdvertised;
	message << state->mGlobalID;
	message << state->mSessionID;
	message << state->mNonceID;
	message << state->mPersistent;
	XPAddress myMostLocalAddress;
	XPSock_GetAddress(state->mSocket,&myMostLocalAddress);
	SetAddr(message,myMostLocalAddress);

	return PackageAndSendData(state->mSocket,message,hostState.mHostAddress);
}
//From: RNLobby/NOnceGen.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
//Skipping: #include "RNLobby/Inc/NOnceGen.h"
//Skipping: #include "RNPlatform/Inc/ThreadClass.h"
#include <time.h>

namespace RNReplicaNet
{
namespace RNLobby
{

MutexClass sMutex;
static int sLastNOnce = 0;
static unsigned int sCycleValue = 0x97908D1F;

int NOnceGen::GetNOnce(void)
{
	THREADSAFELOCKCLASS(sMutex);
	// Generate a number that is not exactly sequential
	sLastNOnce += (sCycleValue & 3) + 1;
	time_t theTime = time(&theTime);
	sLastNOnce += (int) (theTime & 3);
	sCycleValue = (sCycleValue >> 1) | (sCycleValue << 31);

	return sLastNOnce;
}

void NOnceGen::SetNOnce(int nOnce)
{
	THREADSAFELOCKCLASS(sMutex);
	sLastNOnce = nOnce;
	sCycleValue = 0x97908D1F;
}

}
}
//From: RNLobby/Patcher.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include "RNLobby/Inc/Patcher.h"
//Skipping: #include "RNPlatform/Inc/MinMax.h"

using namespace RNReplicaNet;
using namespace RNLobby;

typedef unsigned long int ulong;
const int kMaxTableSize = 128;
#define END_OF_BUFFER		EOF - 1

enum
{
	kOpCodeCopyFrom = 0x23,		// Must be the first one
	kOpCodeUpdate,
	kOpCodeAdd,
	kOpCodeRemove,
	kOpCodeNoChange,
	kOpCodeCommand				// Must be the last one
};

static const int		sPrimeTable[24] =
{
	2147483647,
	1073741789,
	536870909,
	268435399,
	134217689,
	67108859,
	33554393,
	16777213,
	8388593,
	4194301,
	2097143,
	1048573,
	524287,
	262139,
	131071,
	65521,
	32749,
	16381,
	8191,
	4093,
	2039,
	1021,
	509,
	251
};

template <class T>
static void MyTSwap( T &a, T &b )
{
	T temp = a;
	a = b;
	b = temp;
}

#define MyPrevNextSwap(x)	MyTSwap((x)[index],(x)[nextIndex])

	
class FileCache
{
public:
	FileCache();
	virtual ~FileCache();

	int OpenFile(const char *filePath, const ulong bufferSize);
	int CloseFile();
	int GetByte(ulong *position,int readType);

	FILE			*mFileHandle;
	unsigned char	*mCache;
	unsigned char	*mCacheEnd;
	unsigned char	*mCachePos;
	ulong			mCachePosition;
	ulong			mLastCachePosition;
	ulong			mFilePosition;
	ulong			mEOFFilePosition;
	int				mCacheTotalBytes;
	ulong			mBufferSize;
	size_t			mTotalFileSize;
};

class RNReplicaNet::RNLobby::PatcherPrivate
{
public:

	PatcherPrivate() : mWorker(0)
	{
		mHashTable = NULL;
		DoInit();
	}

	virtual ~PatcherPrivate()
	{
		free(mHashTable);
	}

	void DoInit(void)
	{
		mFileCacheSize = 256 * 1024;
		mMaxNoChangeLimit = 20;
		mPreScanState = 0;
		mMaxEntries = 8;
		mMinEntries = 4;
		mMaxDistance = 1024;

		mWrittenData = 0;
		mDeletedBytes = 0;

		mForceOpCode = false;

		mHashIndex = 17;
		mHashPrime = 16381;
	}

	void HashInit(void);
	void HashNext(int currentValue, ulong *currentHash);
	void HashAdd(ulong currentHash, ulong position, ulong baseValue);
	long HashGet(ulong currentHash);
	void HashReset();
	int MatchCheckFree(ulong newBaseValue);
	int MatchBest(FileCache *baseFile,FileCache *newFile,ulong basePosition,ulong newBaseValue,ulong *foundPosition,ulong *foundBest);
	int MatchAdd(FileCache *baseFile, FileCache *newFile, ulong foundToAdd, ulong foundNewAdd, ulong newBaseValue);
	void FindAheadRead(FileCache *fileOut, ulong *position, int *theValue, int *previous, int *equalResult, int cacheType);
	void PreScanFile(FileCache *baseFile);
	int CompareFiles(FileCache *baseFile, FileCache *newFile, ulong *basePosition, ulong *newPosition, int theValue, int cacheType);
	int FindAhead(FileCache *baseFile,FileCache *newFile,ulong posInBaseFile,ulong posInNewFile,int *skipBytesInBaseFile,int *skipBytesInNewFile,int *maxAheadCheck);
	void WriteBytes(ulong theValue, FILE *fileOut);
	void WriteOpCode(int opCode, FILE *fileOut);
	void WriteByte(int value, FILE *fileOut);
	void WriteByteBinary(int opCode,int baseOffset,int newOffset,FileCache *baseFile,FileCache *newFile,FILE *fileOut,ulong	basePosition,ulong newPosition);
	int RunDiffWork(FileCache *baseFile, FileCache *newFile, FILE *fileOut);
	int GetByt(FILE *theFile);
	int GetInt(FILE *theFile);
	void RunPatchWork(FILE *baseFile, FILE *patchFile, FILE *fileOut);


	RNReplicaNet::RNLobby::Patcher *mWorker;

	// Variables for config and work
	ulong	mFileCacheSize;
	int		mMaxNoChangeLimit;
	int		mPreScanState;
	int		mMaxEntries;
	int		mMinEntries;
	ulong	mMaxDistance;

	ulong	mWrittenData;
	ulong	mDeletedBytes;
	int		mHashCollision;

	bool	mForceOpCode;

	int		mHashIndex;
	int		mHashPrime;

	int		mMaxHashCollision;
	ulong	mHashCollisionPosition;

	int		mHashTableSize;
	ulong	*mHashTable;

	ulong	mCalcFirstMatch[kMaxTableSize];
	ulong	mCalcLastMatch[kMaxTableSize];
	ulong	mCalcLastFound[kMaxTableSize];
	int		mCalcCollisions[kMaxTableSize];

	ulong	mCalcLastFind[kMaxTableSize];
	ulong	mCalcFound[kMaxTableSize];
	int		mCalcComp[kMaxTableSize];


	// For each patch generation these get initialised
	ulong	mOnceAheadBase;
	ulong	mOnceAheadNew;
	ulong	mOnceBaseHashValue;
	ulong	mOnceHashNew;
	int		mOnceBaseValue;
	int		mOnceValueNew;
	int		mOnceBasePreviousValue;
	int		mOncePreviousNew;
	int		mOnceNumValueInHash;
	int		mOnceEqualNew;
	bool	mOnceHashInit;

	int	mOnceCurrentOpCode;
	int	mOnceNumEqualBytes;
	int	mOnceTempEqualBytes[4];		// First four bytes of the matched area
};

Patcher::Patcher() : mData(*(new PatcherPrivate))
{
	mData.mWorker = this;
}

Patcher::~Patcher()
{
	delete &mData;
}


FileCache::FileCache()
{
	mFileHandle = 0;
	mCache = 0;
	mCacheEnd = 0;
	mCachePos = 0;
	mCachePosition = 0;
	mLastCachePosition = 0;
	mFilePosition = 0;
	mEOFFilePosition = -1;
	mCacheTotalBytes = 0;
	mBufferSize = 0;
}

FileCache::~FileCache()
{
	CloseFile();
}

int FileCache::OpenFile(const char *filePath, const ulong bufferSize)
{
	mFileHandle = fopen(filePath, "rb");
	if(mFileHandle == NULL) return(false);

	mCache = (unsigned char *) malloc(bufferSize);
	if(mCache == NULL) return(false);
	mCacheEnd = mCache + bufferSize;
	mCachePos = mCache;
	mCacheTotalBytes = 0;
	mCachePosition = 0;
	mFilePosition = 0;
	mEOFFilePosition = -1;
	mBufferSize = bufferSize;
	fseek(mFileHandle,0,SEEK_END);
	mTotalFileSize = ftell(mFileHandle);
	fseek(mFileHandle,0,SEEK_SET);

	return true;
}

int FileCache::CloseFile()
{
	if (mFileHandle)
	{
		fclose(mFileHandle);
	}
	free(mCache);
	mCache = 0;
	return 1;
}

int FileCache::GetByte(ulong *position,int readType)
{
	assert(mFileHandle);
	int ret;
	unsigned char *data;

	// Test for eof
	if(*position >= mEOFFilePosition) return EOF;

	// Grab new data
	if((*position >= mLastCachePosition - mCacheTotalBytes) && (*position < mLastCachePosition))
	{
		data = mCachePos - (mLastCachePosition -*position);
		if(data < mCache) data += mBufferSize;

		if(readType == 0) mCachePosition = *position + 1;
		(*position)++;
		return *data;
	}

	if(readType == 2 && (*position != mLastCachePosition || *position - mCachePosition > mBufferSize)) return END_OF_BUFFER;

	// Update the file position
	if(*position != mFilePosition)
	{
		if(fseek(mFileHandle, *position, SEEK_SET) == EOF)
		{
			exit(6);
		}

		mFilePosition = *position;
	}

	// Get the data and check for eof
	ret = getc(mFileHandle);
	if(ret == EOF)
	{
		mEOFFilePosition = *position;
		return EOF;
	}
	else
		mFilePosition++;

	// Update cache
	if(readType == 0)
	{
		if(*position != mLastCachePosition)
		{
			mCacheTotalBytes = 0;
			mLastCachePosition = *position;
		}

		mCachePosition = *position;
	}

	if(*position == mLastCachePosition && *position - mCachePosition < mBufferSize)
	{
		*mCachePos = (unsigned char) ret;

		mLastCachePosition++;
		mCachePos++;
		if(mCachePos == mCacheEnd) mCachePos = mCache;
		if((ulong) mCacheTotalBytes < mBufferSize) mCacheTotalBytes++;
	}

	if(readType == 0) mCachePosition++;
	(*position)++;

	return ret;
}

// Compare files with the positions
int PatcherPrivate::CompareFiles(FileCache *baseFile, FileCache *newFile, ulong *basePosition, ulong *newPosition, int theValue, int cacheType)
{
	int origPos;
	int newPos;
	int isEqual = 0;
	int ret = 0;

	for(; theValue > 24 && ret == 0 && isEqual < 24; theValue--)
	{
		origPos = baseFile->GetByte(basePosition, cacheType);
		newPos = newFile->GetByte(newPosition, cacheType);

		if(origPos <= EOF || newPos <= EOF)
			ret = 1;
		else if(origPos != newPos)
			isEqual = 0;
		else
			isEqual++;
	}

	for(; theValue > 0 && ret == 0 && isEqual < 24; theValue--)
	{
		origPos = baseFile->GetByte(basePosition, cacheType);
		newPos = newFile->GetByte(newPosition, cacheType);

		if(origPos <= EOF || newPos <= EOF)
			ret = 1;
		else if(origPos != newPos)
			ret = 2;
		else
			isEqual++;
	}

	switch(ret)
	{
		case 0:
			*basePosition = *basePosition - isEqual;
			*newPosition = *newPosition - isEqual;
			return 0;

		case 1:
			if(origPos == EOF || newPos == EOF) return 2;
			else
			{
				*basePosition = *basePosition + theValue;
				*newPosition = *newPosition + theValue;
				return 1;
			}

		case 2:
			return 2;
	}

	return 0;
}

void PatcherPrivate::HashInit(void)
{
	if(mHashTable == NULL)
	{
		mHashTableSize = mHashPrime * 2 * sizeof(ulong);
		mHashTable = (unsigned long *) malloc(mHashTableSize);

		mHashCollision = 0;
		mMaxHashCollision = 2;
		mHashCollisionPosition = mHashPrime;
	}

	if(mHashTable == NULL)
	{
		exit(7);
	}

	memset(mHashTable, 0, mHashTableSize);
}

void PatcherPrivate::HashReset()
{
	memset(mCalcCollisions, 0, kMaxTableSize * sizeof(int));
}

void PatcherPrivate::HashNext(int currentValue, ulong *currentHash)
{
	*currentHash = ((*currentHash) << 1) + currentValue;
}

// Add hash values to the table
void PatcherPrivate::HashAdd(ulong currentHash, ulong position, ulong baseValue)
{
	int theKey;

	// Calculate the key
	theKey = (currentHash % mHashPrime) * 2;

	// Check for collisions
	if(position - baseValue >= mHashCollisionPosition)
	{
		mHashCollisionPosition += mHashPrime;
		mMaxHashCollision++;
	}

	if(!((mHashTable[theKey] == 0) || (mHashTable[theKey + 1] < baseValue)))
	{
		mHashCollision++;
	}

	// Update key entry with new data if required
	if((mHashTable[theKey] == 0) || (mHashTable[theKey + 1] < baseValue) || (mHashCollision >= mMaxHashCollision))
	{
		mHashTable[theKey] = currentHash;
		mHashTable[theKey + 1] = position;
		mHashCollision = 0;
	}
}

long PatcherPrivate::HashGet(ulong currentHash)
{
	int theKey;

	// Calculate the key
	theKey = (currentHash % mHashPrime) * 2;

	// Do the lookup
	if(mHashTable[theKey] == currentHash)
	{
		return mHashTable[theKey + 1];
	}

	return 0;
}

int PatcherPrivate::MatchCheckFree(ulong newBaseValue)
{
	int index;

	for(index = 0; index < mMaxEntries; index++)
	{
		if(mCalcCollisions[index] == 0 || mCalcLastFound[index] < newBaseValue) return true;
	}
	return false;
}

int PatcherPrivate::MatchAdd(FileCache *baseFile, FileCache *newFile, ulong foundToAdd, ulong foundNewAdd, ulong newBaseValue)
{
	int index;
	int freeIndex = -1;
	int nextIndex = -1;

	foundToAdd -= 24;
	foundNewAdd -= 24;

	for(index = 0; index < mMaxEntries; index++)
	{
		if(mCalcCollisions[index] == 0)
		{
			if(freeIndex == -1 || mCalcCollisions[freeIndex] != 0)
			{
				nextIndex = freeIndex;
				freeIndex = index;
			}
			else if(nextIndex == -1)
			{
				nextIndex = index;
			}
		}
		else
		{
			if	( (foundToAdd - mCalcLastMatch[index] == foundNewAdd - mCalcLastFound[index])
					&&	(foundNewAdd <= mCalcLastFound[index] + mMaxDistance)
					&&	(foundNewAdd + mMaxDistance >= mCalcFirstMatch[index])	)
			{
				mCalcCollisions[index]++;
				if(foundNewAdd > mCalcLastFound[index])
				{
					mCalcLastFound[index] = foundNewAdd;
					mCalcLastMatch[index] = foundToAdd;
				}
				else if(foundNewAdd < mCalcFirstMatch[index])
				{
					mCalcFirstMatch[index] = foundNewAdd;
				}

				return 2;
			}

			if(mCalcLastFound[index] < newBaseValue)
			{
				if((freeIndex == -1) || (mCalcCollisions[freeIndex] != 0 && mCalcLastFound[index] < mCalcLastFound[freeIndex]))
				{
					nextIndex = freeIndex;
					freeIndex = index;
				}
				else if(nextIndex == -1)
				{
					nextIndex = index;
				}
			}
		}
	}

	if(freeIndex == -1)
	{
		return 0;
	}
	else
	{
		mCalcLastMatch[freeIndex] = foundToAdd;
		mCalcLastFound[freeIndex] = foundNewAdd;
		mCalcFirstMatch[freeIndex] = foundNewAdd;
		mCalcLastFind[freeIndex] = 0;
		mCalcFound[freeIndex] = 0;
		mCalcComp[freeIndex] = 0;
		mCalcCollisions[freeIndex] = 1;

		if(nextIndex != -1)
		{
			return 1;
		}
		else
		{
			return 0;
		}
	}
}

int PatcherPrivate::MatchBest(FileCache *baseFile,FileCache *newFile,ulong basePosition,ulong newBaseValue,ulong *foundPosition,ulong *foundBest)
{
	int		index;
	int		theBest = -1;
	int		check;
	int		nextIndex;
	int		status = 0;
	ulong	testNewPos = 0;
	ulong	testOrigPos = 0;
	ulong	testBasePos = 0;
	ulong	testNextPos = 0;

	for(index = 0, nextIndex = 0; index < mMaxEntries && nextIndex >= 0; index++)
	{
		if(theBest == -1)
		{
			nextIndex = -1;
		}
		else
		{
			nextIndex = theBest;
			testNextPos = *foundBest + 1;
		}

		// Best?
		for(check = index; check < mMaxEntries && mCalcCollisions[check] > 0; check++)
		{
			if(mCalcCollisions[check] > 0)
			{
				if(mCalcLastFound[check] + mMaxDistance >= newBaseValue)
				{
					if(mCalcFirstMatch[check] <= newBaseValue + mMaxDistance - 24)
					{
						testNewPos = newBaseValue;
					}
					else
					{
						testNewPos = mCalcFirstMatch[check] - mMaxDistance + 24;
					}
				}
				else
				{
					testNewPos = 0;
				}

				if(testNewPos > 0)
				{
					if(nextIndex == -1)
					{
						testNextPos = testNewPos;
						nextIndex = check;
					}
					else if(testNewPos < testNextPos)
					{
						testNextPos = testNewPos;
						nextIndex = check;
					}
				}
			}
		}

		// Found?
		if(nextIndex <= theBest)
		{
			nextIndex = -1;
		}
		else
		{
			status = 0;

			// Do the updates
			if(nextIndex != index)
			{
				MyPrevNextSwap(mCalcFirstMatch);
				MyPrevNextSwap(mCalcLastFound);
				MyPrevNextSwap(mCalcLastMatch);
				MyPrevNextSwap(mCalcCollisions);
				MyPrevNextSwap(mCalcLastFind);
				MyPrevNextSwap(mCalcFound);
				MyPrevNextSwap(mCalcComp);
			}

			// Find original position
			testNewPos = testNextPos;
			testBasePos = testNextPos;
			if((mCalcLastMatch[index] + testNewPos) >= mCalcLastFound[index])
			{
				testOrigPos = mCalcLastMatch[index] + testNewPos - mCalcLastFound[index];
			}
			else
			{
				status = 4;
			}

			// Compare
			if(status == 0)
			{
				// Avoid multiple comparisons
				if((mCalcLastFind[index] > 0) && (testNewPos >= mCalcLastFind[index]) && (testNewPos <= mCalcFound[index]))
				{
					status = mCalcComp[index];
					testNewPos = mCalcFound[index];
					testOrigPos = mCalcLastMatch[index] + testNewPos - mCalcLastFound[index];
				}
				else
				{
					// Find it
					status = CompareFiles(baseFile, newFile, &testOrigPos, &testNewPos, mMaxDistance, 1);

					// EOF?
					if(status == 1 && mCalcCollisions[index] <= 3)
					{
						status = 7;
					}

					// Get rid of bogus matches
					if(status == 2 && mCalcCollisions[index] == 1 && testBasePos <= mCalcFirstMatch[index] && testNewPos > mCalcFirstMatch[index])
					{
						mCalcCollisions[index] = 0;
						status = 2;
					}

					// Remember the result
					if(status <= 1)
					{
						mCalcLastFind[index] = testBasePos;
						mCalcFound[index] = testNewPos;
						mCalcComp[index] = status;
					}
				}
			}

			// Store one of the best results back to the caller
			if(status <= 1)
			{
				if( (theBest == -1) ||	(testNewPos + 4 <= *foundBest) || ((testNewPos <= *foundBest + 4) && (mCalcCollisions[index] > mCalcCollisions[theBest])) )
				{
					*foundBest = testNewPos;
					*foundPosition = testOrigPos;
					theBest = index;
				}
			}
		}
	}

	if(theBest == -1)
	{
		return -1;
	}

	return theBest;
}

void PatcherPrivate::PreScanFile(FileCache *baseFile)
{
	ulong	baseHashValue = 0;
	int		baseValue;
	int		basePreviousValue;
	int		numValueInHash = 0;
	ulong	basePos = 0;
	int		index;
	size_t	totalSize = baseFile->mTotalFileSize;
	size_t	lastCallbackValue = 0;

	assert(mWorker);
	if (!mWorker->CallbackScanning(lastCallbackValue , totalSize))
	{
		return;
	}

	baseValue = baseFile->GetByte(&basePos, 1);
	for(index = 0; (index < 31) && (baseValue > EOF); index++)
	{
		HashNext(baseValue, &baseHashValue);
		FindAheadRead(baseFile, &basePos, &baseValue, &basePreviousValue, &numValueInHash, 1);
	}

	while(baseValue > EOF)
	{
		HashNext(baseValue, &baseHashValue);
		if(numValueInHash < mMaxNoChangeLimit)
		{
			HashAdd(baseHashValue, basePos, 0);
		}

		FindAheadRead(baseFile, &basePos, &baseValue, &basePreviousValue, &numValueInHash, 1);

		size_t tLastCallbackValue = (size_t) ftell(baseFile->mFileHandle);
		size_t maxRes = max(totalSize / 100 , 1024);
		if ( (tLastCallbackValue - lastCallbackValue) > maxRes)
		{
			lastCallbackValue = tLastCallbackValue;
			assert(mWorker);
			if (!mWorker->CallbackScanning(lastCallbackValue , totalSize))
			{
				return;
			}
		}
	}
}

// Scans ahead in two files and finds matching blocks then calculates the difference between the two files
void PatcherPrivate::FindAheadRead(FileCache *fileOut, ulong *position, int *theValue, int *previous, int *equalResult, int cacheType)
{
	*previous = *theValue;
	*theValue = fileOut->GetByte(position, cacheType);
	if(*previous == *theValue)
	{
		if(*equalResult < 32) (*equalResult)++;
	}
	else
	{
		if(*equalResult > 0) (*equalResult)--;
	}
}

int PatcherPrivate::FindAhead(FileCache*baseFile,FileCache*newFile,ulong posInBaseFile,ulong posInNewFile,int *skipBytesInBaseFile,int *skipBytesInNewFile,int *maxAheadCheck)
{
	ulong foundBase = 0;
	ulong foundNew = 0;
	ulong theBasePos;
	int index;
	int numMatches = 0;
	int theBest;
	int lookType;

	// Reset the matches if required
	if(!mOnceHashInit)
	{
		HashReset();
		mOnceHashInit = true;
	}

	lookType = 1;

	// Did we want to pre-scan the file?
	if(mPreScanState == 1)
	{
		PreScanFile(baseFile);
		mPreScanState = 2;
	}

	if(mPreScanState == 0 && (mOnceAheadBase == 0 || mOnceAheadBase < posInBaseFile))
	{
		mOnceAheadBase = posInBaseFile;
		mOnceNumValueInHash = 0;
		mOnceBaseHashValue = 0;

		mOnceBaseValue = baseFile->GetByte(&mOnceAheadBase, lookType);
		for(index = 0; (index < 31) && (mOnceBaseValue > EOF); index++)
		{
			HashNext(mOnceBaseValue, &mOnceBaseHashValue);
			FindAheadRead(baseFile, &mOnceAheadBase, &mOnceBaseValue, &mOnceBasePreviousValue, &mOnceNumValueInHash, lookType);
		}
	}

	if(mOnceAheadNew == 0 || mOnceAheadNew < posInNewFile)
	{
		mOnceAheadNew = posInNewFile;
		mOnceEqualNew = 0;
		mOnceHashNew = 0;

		mOnceValueNew = newFile->GetByte(&mOnceAheadNew, lookType);
		for(index = 0; (index < 31) && (mOnceValueNew > EOF); index++)
		{
			HashNext(mOnceValueNew, &mOnceHashNew);
			FindAheadRead(newFile, &mOnceAheadNew, &mOnceValueNew, &mOncePreviousNew, &mOnceEqualNew, lookType);
		}
	}

	// Build tables
	if(MatchCheckFree(posInNewFile))
	{
		theBasePos = 0;

		if(mPreScanState > 0)
		{
			mOnceBaseValue = END_OF_BUFFER;
		}

		// Scan both files for equal hashes
		while(((mOnceBaseValue > EOF) || (mOnceValueNew > EOF)) && (numMatches < mMaxEntries))
		{
			if(mOnceBaseValue > EOF)
			{
				HashNext(mOnceBaseValue, &mOnceBaseHashValue);

				if(mOnceNumValueInHash < mMaxNoChangeLimit)
				{
					HashAdd(mOnceBaseHashValue, mOnceAheadBase, theBasePos);
				}

				FindAheadRead(baseFile, &mOnceAheadBase, &mOnceBaseValue, &mOnceBasePreviousValue, &mOnceNumValueInHash, lookType);
			}

			// Compare new and base file
			if(mOnceValueNew > EOF)
			{
				HashNext(mOnceValueNew, &mOnceHashNew);
				if(mOnceEqualNew < mMaxNoChangeLimit)
				{
					foundBase = HashGet(mOnceHashNew);
				}
				else
				{
					foundBase = 0;
				}

				// If we found it...
				if(foundBase > theBasePos)
				{
					// ..Add the matches
					switch(MatchAdd(baseFile, newFile, foundBase, mOnceAheadNew, posInNewFile))
					{
						case 0:
							numMatches = mMaxEntries;
							break;

						case 1:
							numMatches++;
							lookType = (numMatches >= mMinEntries) ? 2 : 1;
							break;

						case 2:
						case -1:
							break;
					}
				}

				// Proceed with getting the next data
				FindAheadRead(newFile, &mOnceAheadNew, &mOnceValueNew, &mOncePreviousNew, &mOnceEqualNew, lookType);
			}
		}
	}

	// Get the best match
	theBest = MatchBest(baseFile, newFile, posInBaseFile, posInNewFile, &foundBase, &foundNew);
	if(theBest == -1)
	{
		*skipBytesInBaseFile = 0;
		*skipBytesInNewFile = 0;
		*maxAheadCheck = (mOnceAheadNew - posInNewFile) / 4;
		if(*maxAheadCheck < 256) *maxAheadCheck = 256;
		return false;
	}
	else
	{
		// Calculate the offset between the files
		if(foundBase >= posInBaseFile)
		{
			if(foundBase - posInBaseFile >= foundNew - posInNewFile)
			{
				*skipBytesInBaseFile = foundBase - posInBaseFile + posInNewFile - foundNew;
				*skipBytesInNewFile = 0;
				*maxAheadCheck = foundNew - posInNewFile;
			}
			else
			{
				*skipBytesInBaseFile = 0;
				*skipBytesInNewFile = foundNew - posInNewFile + posInBaseFile - foundBase;
				*maxAheadCheck = foundBase - posInBaseFile;
			}
		}
		else
		{
			*skipBytesInBaseFile = (int) posInBaseFile - foundBase + foundNew - posInNewFile;
			if((ulong) * skipBytesInBaseFile < posInBaseFile)
			{
				*skipBytesInNewFile = 0;
				*skipBytesInBaseFile = -*skipBytesInBaseFile;
				*maxAheadCheck = foundNew - posInNewFile;
			}
			else
			{
				*skipBytesInNewFile = *skipBytesInBaseFile - (int) posInBaseFile;
				*skipBytesInBaseFile = -(int) posInBaseFile;
				*maxAheadCheck = (foundNew - posInNewFile) -*skipBytesInNewFile;
			}

			mOnceAheadBase = 0;
		}

		return true;
	}
}

void PatcherPrivate::WriteByteBinary(int opCode,int baseOffset,int newOffset,FileCache *baseFile,FileCache *newFile,FILE *fileOut,ulong basePosition,ulong newPosition)
{
	int			count;

	if(mOnceNumEqualBytes > 0 && opCode != kOpCodeNoChange)
	{
		if(mOnceNumEqualBytes > 4 || (mOnceCurrentOpCode != kOpCodeUpdate && opCode != kOpCodeUpdate))
		{
			mOnceCurrentOpCode = kOpCodeNoChange;
			WriteOpCode(kOpCodeNoChange, fileOut);
			WriteBytes(mOnceNumEqualBytes, fileOut);
		}
		else
		{
			if(mOnceCurrentOpCode != kOpCodeUpdate)
			{
				mOnceCurrentOpCode = kOpCodeUpdate;
				WriteOpCode(kOpCodeUpdate, fileOut);
			}

			for(count = 0; count < mOnceNumEqualBytes; count++) WriteByte(mOnceTempEqualBytes[count], fileOut);
		}

		mOnceNumEqualBytes = 0;
	}

	switch(opCode)
	{
		case kOpCodeCommand:
			WriteOpCode(kOpCodeCommand, fileOut);
			mOnceCurrentOpCode = kOpCodeCommand;
			break;

		case kOpCodeNoChange:
			if(mOnceNumEqualBytes < 4) mOnceTempEqualBytes[mOnceNumEqualBytes] = baseOffset;
			mOnceNumEqualBytes++;
			break;

		case kOpCodeRemove:
			WriteOpCode(kOpCodeRemove, fileOut);
			WriteBytes(newOffset, fileOut);

			mOnceCurrentOpCode = kOpCodeRemove;
			mDeletedBytes += newOffset;
			break;

		case kOpCodeUpdate:
		case kOpCodeAdd:
			if(mOnceCurrentOpCode != opCode)
			{
				mOnceCurrentOpCode = opCode;
				WriteOpCode(opCode, fileOut);
			}

			WriteByte(newOffset, fileOut);
			break;

		case kOpCodeCopyFrom:
			WriteOpCode(kOpCodeCopyFrom, fileOut);
			WriteBytes(newOffset, fileOut);

			mOnceCurrentOpCode = kOpCodeCopyFrom;
			break;
	}
}

// Output a length value using a variable length encode
void PatcherPrivate::WriteBytes(ulong theValue, FILE *fileOut)
{
	if(theValue <= 252)
	{
		putc(theValue - 1, fileOut);
	}
	else if(theValue < 509)
	{
		putc(252, fileOut);
		putc((theValue - 253), fileOut);
	}
	else if(theValue <= 0xffff)
	{
		putc(253, fileOut);
		putc((theValue >> 8), fileOut);
		putc((theValue) & 0xff, fileOut);
	}
	else if(theValue <= 0xffffffff)
	{
		putc(254, fileOut);
		putc((theValue >> 24), fileOut);
		putc((theValue >> 16) & 0xff, fileOut);
		putc((theValue >> 8) & 0xff, fileOut);
		putc((theValue) & 0xff, fileOut);
	}
}

void PatcherPrivate::WriteOpCode(int opCode, FILE *fileOut)
{
	if(mForceOpCode)
	{
		putc(kOpCodeCommand, fileOut);
		putc(kOpCodeCommand, fileOut);
		mForceOpCode = false;
		mWrittenData++;
	}

	if(opCode != kOpCodeCommand)
	{
		putc(kOpCodeCommand, fileOut);
		putc(opCode, fileOut);
	}
}

void PatcherPrivate::WriteByte(int value, FILE *fileOut)
{
	// Do we need a forced opcode?
	if(mForceOpCode)
	{
		mForceOpCode = false;
		if(value >= kOpCodeCopyFrom && value <= kOpCodeCommand)
		{
			// Make sure we output it
			putc(kOpCodeCommand, fileOut);
		}

		putc(kOpCodeCommand, fileOut);
		mWrittenData++;
	}

	if(value == kOpCodeCommand)
	{
		mForceOpCode = true;
	}
	else
	{
		putc(value, fileOut);
		mWrittenData++;
	}
}

// The main function that does the work
int PatcherPrivate::RunDiffWork(FileCache *baseFile, FileCache *newFile, FILE *fileOut)
{
	int		origData;
	int		newData;
	ulong	basePos = 0;
	ulong	newReadPos = 0;
	int		foundStatus = 0;
	int		numAheadSteps = 0;
	int		numBaseSkip;
	int		numNewSkip;
	size_t	totalSize = newFile->mTotalFileSize;
	size_t	lastCallbackValue = 0;

	assert(mWorker);
	if (!mWorker->CallbackScanning(lastCallbackValue , totalSize))
	{
		return -1;
	}

	// Get one byte from each file
	origData = baseFile->GetByte(&basePos, 0);
	newData = newFile->GetByte(&newReadPos, 0);
	while(newData > EOF)
	{
		if(numAheadSteps > 0)
		{
			// Carry on going until we reach the end of the equal blocks
			numAheadSteps--;
		}
		else if(origData != newData)
		{
			if(origData > EOF)
			{
				basePos--;
			}
			newReadPos--;

			// Difference found, look ahead to find the start of the next block
			foundStatus = FindAhead(baseFile, newFile, basePos, newReadPos, &numBaseSkip, &numNewSkip, &numAheadSteps);

			if(foundStatus)
			{
				// Equal blocks found so add the remove, copy or update op code
				if(numBaseSkip > 0)
				{
					WriteByteBinary(kOpCodeRemove, 0, numBaseSkip, baseFile, newFile, fileOut, basePos + 1, newReadPos + 1);
					basePos += numBaseSkip;
					origData = baseFile->GetByte(&basePos, 0);
				}
				else if(numBaseSkip < 0)
				{
					WriteByteBinary(kOpCodeCopyFrom, 0, -numBaseSkip, baseFile, newFile, fileOut, basePos + 1, newReadPos + 1);
					basePos += numBaseSkip;
					origData = baseFile->GetByte(&basePos, 0);
				}
				else if(origData > EOF)
				{
					basePos++;
				}

				newReadPos++;
				if(numNewSkip > 0)
				{
					while(numNewSkip > 0)
					{
						WriteByteBinary(kOpCodeAdd, 0, newData, baseFile, newFile, fileOut, basePos, newReadPos);
						numNewSkip--;
						newData = newFile->GetByte(&newReadPos, 0);
					}
				}
			}
			else
			{
				if(origData > EOF) basePos++;
				newReadPos++;
			}
		}

		if(numAheadSteps == 0)
		{
			numAheadSteps--;
		}

		// Then store no change or update
		if(origData == newData)
		{
			WriteByteBinary(kOpCodeNoChange, origData, newData, baseFile, newFile, fileOut, basePos, newReadPos);
		}
		else
		{
			WriteByteBinary(kOpCodeUpdate, origData, newData, baseFile, newFile, fileOut, basePos, newReadPos);
		}

		// And start the whole thing again with getting another two bytes
		origData = baseFile->GetByte(&basePos, 0);
		newData = newFile->GetByte(&newReadPos, 0);

		size_t tLastCallbackValue = (size_t) ftell(newFile->mFileHandle);
		size_t maxRes = max(totalSize / 100 , 1024);
		if ( (tLastCallbackValue - lastCallbackValue) > maxRes)
		{
			lastCallbackValue = tLastCallbackValue;
			assert(mWorker);
			if (!mWorker->CallbackScanning(lastCallbackValue , totalSize))
			{
				return -1;
			}
		}
	}

	// Is the new file shorter than the old file?
	if (baseFile->mFilePosition > newFile->mFilePosition)
	{
		mDeletedBytes++;
	}
	WriteByteBinary(kOpCodeCommand, 0, 0, 0, 0, fileOut, basePos, newReadPos);
	return 1;
}

#define MYMAXINT	0x7fffffff

int PatcherPrivate::GetByt(FILE *theFile)
{
	return getc(theFile);
}

int PatcherPrivate::GetInt(FILE *theFile)
{
	int value;

	value = getc(theFile);
	if(value < 252)
		return value + 1;
	else if(value == 252)
		return 253 + getc(theFile);
	else if(value == 253)
	{
		value = getc(theFile);
		value = (value << 8) + getc(theFile);
		return value;
	}
	else if(value == 254)
	{
		value = getc(theFile);
		value = (value << 8) + getc(theFile);
		value = (value << 8) + getc(theFile);
		value = (value << 8) + getc(theFile);
		return value;
	}

	exit(6);
	return 0;
}

// This combines the base file with the patch file and produces the new file
void PatcherPrivate::RunPatchWork(FILE *baseFile, FILE *patchFile, FILE *fileOut)
{
	int theInput;
	int origData;
	int theOpCode;
	int count;
	bool opCodeChanged = false;
	bool isOpCode = false;
	fseek(patchFile,0,SEEK_END);
	long totalSize = ftell(patchFile);
	fseek(patchFile,0,SEEK_SET);

	assert(mWorker);
	if (!mWorker->CallbackScanning(0 , totalSize))
	{
		return;
	}

	theOpCode = kOpCodeCommand;
	while((theInput = GetByt(patchFile)) != EOF)
	{
		if(theInput == kOpCodeCommand)
		{
			theInput = GetByt(patchFile);
			switch(theInput)
			{
				case kOpCodeUpdate:
					theOpCode = kOpCodeUpdate;
					opCodeChanged = true;
					break;

				case kOpCodeAdd:
					theOpCode = kOpCodeAdd;
					opCodeChanged = true;
					break;

				case kOpCodeRemove:
					theOpCode = kOpCodeRemove;
					theInput = GetInt(patchFile);

					if(fseek(baseFile, theInput, SEEK_CUR) != 0)
					{
						exit(5);
					}

					opCodeChanged = true;
					break;

				case kOpCodeNoChange:
					theOpCode = kOpCodeNoChange;
					theInput = GetInt(patchFile);

					for(count = 0; count < theInput; count++)
					{
						origData = getc(baseFile);
						putc(origData, fileOut);
					}

					opCodeChanged = true;
					break;

				case kOpCodeCopyFrom:
					theOpCode = kOpCodeCopyFrom;
					theInput = GetInt(patchFile);

					if(fseek(baseFile, -theInput, SEEK_CUR) != 0)
					{
						exit(5);
					}

					opCodeChanged = true;
					break;

				case kOpCodeCommand:
					break;

				default:
					isOpCode = true;
					break;
			}
		}

		if(opCodeChanged)
		{
			opCodeChanged = false;
		}
		else
		{
			switch(theOpCode)
			{
				case kOpCodeRemove:
					break;

				case kOpCodeNoChange:
					break;

				case kOpCodeCopyFrom:
					break;

				case kOpCodeUpdate:
					if(isOpCode)
					{
						putc(kOpCodeCommand, fileOut);
						origData = getc(baseFile);
					}

					putc(theInput, fileOut);
					origData = getc(baseFile);
					break;

				case kOpCodeAdd:
					if(isOpCode)
					{
						putc(kOpCodeCommand, fileOut);
					}

					putc(theInput, fileOut);
					break;
			}
		}

		isOpCode = false;

		assert(mWorker);
		if (!mWorker->CallbackScanning((size_t) ftell(patchFile) , totalSize))
		{
			return;
		}

	}// while...
}

int Patcher::GeneratePatch(const char *sourcePath, const char *newPath, const char *patchPath,const size_t level)
{
	FileCache		fileBaseHandle;
	FileCache		fileNewHandle;
	FILE	*outFileHandle;
	int realLevel = (int)level;

	if (realLevel < 1)
	{
		realLevel = 1;
	}
	if (realLevel > 10)
	{
		realLevel = 10;
	}
	mData.DoInit();

	// Some sensible defaults
	mData.mFileCacheSize = 4096 * 1024;
	mData.mPreScanState = 1;
	mData.mMinEntries = 8;
	mData.mMaxEntries = 64;
	mData.mHashIndex = 9;
	mData.mMaxDistance = 1024;

	// Use realLevel to give us some config parameters, the default is 8.
	mData.mFileCacheSize = 512 * realLevel * 1024;
	mData.mHashIndex = 12 - (realLevel /2);
	mData.mMaxDistance = 1024 * realLevel;
	mData.mMaxEntries = 12 - realLevel;

	// This is calculated from whatever is set from above
	mData.mHashPrime = sPrimeTable[mData.mHashIndex];

	// Once only init per patch generated
	mData.mOnceAheadBase = 0;
	mData.mOnceAheadNew = 0;
	mData.mOnceBaseHashValue = 0;
	mData.mOnceHashNew = 0;
	mData.mOnceNumValueInHash = 0;
	mData.mOnceEqualNew = 0;
	mData.mOnceHashInit = false;
	mData.mOnceBaseValue = 0;
	mData.mOnceValueNew = 0;
	mData.mOnceBasePreviousValue = 0;
	mData.mOncePreviousNew = 0;

	mData.mOnceCurrentOpCode = kOpCodeCommand;
	mData.mOnceNumEqualBytes = 0;
	memset(&mData.mOnceTempEqualBytes[0],0,sizeof(mData.mOnceTempEqualBytes));

	// Start your engines...
	mData.HashInit();

	// Open the files we need
	if(!fileBaseHandle.OpenFile(sourcePath, mData.mFileCacheSize))
	{
		return -1;
	}

	if(!fileNewHandle.OpenFile(newPath, mData.mFileCacheSize))
	{
		fileBaseHandle.CloseFile();
		return -1;
	}

	outFileHandle = fopen(patchPath, "wb");
	if(outFileHandle == NULL)
	{
		fileBaseHandle.CloseFile();
		fileNewHandle.CloseFile();
		return -1;
	}

	mData.RunDiffWork(&fileBaseHandle, &fileNewHandle, outFileHandle);

	// Close everything
	fileBaseHandle.CloseFile();
	fileNewHandle.CloseFile();

	fclose(outFileHandle);

	// If there were no significant changes then clear the resultant patch file
	if(mData.mWrittenData == 0 && mData.mDeletedBytes == 0)
	{
		outFileHandle = fopen(patchPath, "wb");
		if(outFileHandle == NULL)
		{
			return -1;
		}
		fclose(outFileHandle);
		return 0;
	}

	outFileHandle = fopen(patchPath, "rb");
	if(outFileHandle == NULL)
	{
		return -1;
	}
	fseek(outFileHandle,0,SEEK_END);
	mData.mWrittenData = ftell(outFileHandle);
	fclose(outFileHandle);

	return (int)mData.mWrittenData;
}

bool Patcher::PatchFile(const char *sourcePath, const char *patchPath, const char *destinationPath)
{
	FILE	*origFileHandle;
	FILE	*patchFileHandle;
	FILE	*outFileHandle;

	origFileHandle = fopen(sourcePath, "rb");
	if(origFileHandle == NULL)
	{
		return false;
	}

	patchFileHandle = fopen(patchPath, "rb");
	if(patchFileHandle == NULL)
	{
		fclose(origFileHandle);
		return false;
	}

	outFileHandle = fopen(destinationPath, "wb");
	if(outFileHandle == NULL)
	{
		fclose(origFileHandle);
		fclose(patchFileHandle);
		return false;
	}

	mData.RunPatchWork(origFileHandle, patchFileHandle, outFileHandle);

	fclose(origFileHandle);
	fclose(patchFileHandle);
	fclose(outFileHandle);

	return true;
}

bool Patcher::CallbackScanning(const size_t filePos,const size_t fileMax)
{
	return true;
}
//From: RNLobby/RNLobby.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <assert.h>
#include "RNLobby/Inc/RNLobby.h"
//Skipping: #include "RNLobby/BackendPrivate.h"
//Skipping: #include "RNPlatform/Inc/PlatformHeap.h"
#include "RNLobby/Inc/TransportNATUDP.h"
//Skipping: #include "RNXPURL/TransportCrypto.h"
//Skipping: #include "RNXPURL/Inc/XPURL.h"

using namespace RNReplicaNet;
using namespace RNLobby;

static Transport *tempTrans = 0;
static TransportNATUDP *newTrans = 0;
static Transport *tempTrans2 = 0;
static TransportNATUDP *newTrans2 = 0;
static bool doneLobbyRegister = false;

namespace RNReplicaNet
{
namespace RNLobby
{
class RegisterDefaultTransportsHeap : public PlatformHeapBlock
{
public:
	virtual ~RegisterDefaultTransportsHeap()
	{
		delete newTrans;
		newTrans = 0;
		delete tempTrans;
		tempTrans = 0;
		delete newTrans2;
		newTrans2 = 0;
		delete tempTrans2;
		tempTrans2 = 0;
		doneLobbyRegister = false;
		Backend::gAuthenticateDone = false;
	}
};
}
}

void RNReplicaNet::RNLobby::RegisterDefaultTransports(void)
{
	if (!doneLobbyRegister)
	{
		doneLobbyRegister = true;
		XPURL::RegisterDefaultTransports();
		XPURL urls;
		tempTrans = urls.FindTransport("UDP@")->Allocate();
		newTrans = new RNReplicaNet::RNLobby::TransportNATUDP();
		newTrans->SetBaseTransport(tempTrans);
		RNReplicaNet::XPURL::RegisterTransport(*newTrans);

		tempTrans2 = urls.FindTransport("CRYPTOUDP@")->Allocate();
		newTrans2 = new RNReplicaNet::RNLobby::TransportNATUDP();
		newTrans2->SetBaseTransport(tempTrans2);
		RNReplicaNet::XPURL::RegisterTransport(*newTrans2);

		(new RegisterDefaultTransportsHeap())->Register();
	}
}
//From: RNLobby/RNLobbyPrivate.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
//Include inline: #include "RNLobby/RNLobbyPrivate.h"
//From: RNLobby/RNLobbyPrivate.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef _RNLOBBYPRIVATE_H_
#define _RNLOBBYPRIVATE_H_
#include <string>

namespace RNReplicaNet
{

namespace RNLobby
{

} // namespace RNLobby

} // namespace RNReplicaNet

#endif

namespace RNReplicaNet
{

namespace RNLobby
{

int gRemoveMePlaceholderValue = 1;

} // namespace RNLobby

} // namespace RNReplicaNet
//From: RNLobby/StatClient.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "RNLobby/Inc/StatClient.h"
//Include inline: #include "RNLobby/StatServerPrivate.h"
//From: RNLobby/StatServerPrivate.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef _STATSERVERPRIVATE_H_
#define _STATSERVERPRIVATE_H_

namespace RNReplicaNet
{

namespace RNLobby
{

namespace StatServerPrivate
{

const int kMaximumScriptSize = 65536;
const int kMaximumPairValueSize = 128;

enum kPacket
{
	kServerProbeFromConnect = 0,
	kClientWantToUpload,
	kServerAuthOKBeginUpload,
	kServerAuthFailed,
	kClientUploadDataChunk,
	kClientUploadFinished,
	kServerACKUploadedData,
	kClientBeginSession,
	kServerBeginSession,
	kClientUpdatePairsBegin,
	kClientUpdatePairsValue,
	kClientUpdatePairsEnd,
	kClientEndSession,
	kServerEndSession,
	kServerEndSessionScriptNotFound,
	kServerEndSessionScriptNotCompleted
};

} // namespace UserServerPrivate

} // namespace RNLobby

} // namespace RNReplicaNet

#endif
//Skipping: #include "RNLobby/BackendPrivate.h"
//Skipping: #include "RNXPURL/TransportUDP.h"
//Skipping: #include "RNXPURL/Inc/XPURL.h"
//Skipping: #include "RNPlatform/Inc/MinMax.h"

using namespace RNReplicaNet;
using namespace RNLobby;

StatClient::StatClient() : mServerAddressSet(false)
{
//	mSerial = 0;	// This can always count up for as long as we want and doesn't need to be reset.
	CallbackTidy();
}

StatClient::~StatClient()
{
	Stop();
}

bool StatClient::Start(void)
{
	Stop();
	Backend::ServerCryptoHelper<StatClient>::SetEncryption(this,Backend::GetStatServerCrypto());

	InitInternalState();

	XPURL::RegisterDefaultTransports();
	THREADSAFELOCK();
	if (!mServerAddressSet)
	{
		mServerAddress = Backend::GetStatServerAddress();
	}
	XPURL xpurl;
	Transport *transport = xpurl.FindTransport("UDP@");
	assert(transport && "Unable to find UDP@ Transport");
	TransportUDP *transport2 = (TransportUDP *) transport->Allocate();
	assert(transport2);
	transport2->Connect("UDP@"+mServerAddress.Export());
	return BaseTransportServer::StartWithTransport(transport2,true,false);
}

void StatClient::SetServer(const RNReplicaNet::XPAddress &address)
{
	mServerAddressSet = true;
	mServerAddress = address;
}

void StatClient::CallbackTidy(void)
{
	InitInternalState();
}

bool StatClient::CallbackPoll(void)
{
	return true;
}

bool StatClient::CallbackParseValidMessage(Transport *transport,DynamicMessageHelper &message,const size_t length)
{
	int NOnce;
	message >> NOnce;
	StatServerPrivate::kPacket packet;
	message >> packet;
	switch(packet)
	{
		default:
			break;

		case StatServerPrivate::kServerProbeFromConnect:
		{
			CallbackConnectionEstablished(mTransport);
			break;
		}

		case StatServerPrivate::kServerAuthFailed:
		{
			if (NOnce == mNOnce)
			{
				CallbackUploadAuthenticationFailure();
			}
			else
			{
				assert(!"StatClient kServerAuthFailed NOnce failure");
				return false;
			}
			break;
		}

		case StatServerPrivate::kServerAuthOKBeginUpload:
		{
			if (NOnce == mNOnce)
			{
				mCanUpload = true;
				CallbackUploadAuthenticationSuccess();
			}
			else
			{
				assert(!"StatClient kServerAuthOKBeginUpload NOnce failure");
				return false;
			}
			break;
		}

		case StatServerPrivate::kServerACKUploadedData:
		{
			if (NOnce == mNOnce)
			{
				mCanUpload = false;
				int scriptID;
				message >> scriptID;
				int titleID;
				message >> titleID;
				CallbackUploadACK(scriptID);
			}
			else
			{
				assert(!"StatClient kServerACKUploadedData NOnce failure");
				return false;
			}
			break;
		}

		case StatServerPrivate::kServerBeginSession:
		{
			if (NOnce == mNOnce)
			{
				mCanUpload = false;
				CallbackBeginSession();
			}
			else
			{
				assert(!"StatClient kServerBeginSession NOnce failure");
				return false;
			}
			break;
		}

		case StatServerPrivate::kServerEndSession:
		{
			if (NOnce == mNOnce)
			{
				mCanUpload = false;
				CallbackEndSession();
			}
			else
			{
				assert(!"StatClient kServerBeginSession NOnce failure");
				return false;
			}
			break;
		}

		case StatServerPrivate::kServerEndSessionScriptNotFound:
		{
			if (NOnce == mNOnce)
			{
				mCanUpload = false;
				CallbackEndSessionScriptNotFound();
				CallbackEndSession();
			}
			else
			{
				assert(!"StatClient kServerEndSessionScriptNotFound NOnce failure");
				return false;
			}
			break;
		}

		case StatServerPrivate::kServerEndSessionScriptNotCompleted:
		{
			if (NOnce == mNOnce)
			{
				mCanUpload = false;
				CallbackEndSessionScriptNotCompleted();
				CallbackEndSession();
			}
			else
			{
				assert(!"StatClient kServerEndSessionScriptNotCompleted NOnce failure");
				return false;
			}
			break;
		}

	}
	return true;
}

void StatClient::InitInternalState(void)
{
	mCanUpload = false;
	mUpdatingPairs = false;
	mInASession = false;
}

bool StatClient::WantToUpload(const char *userNonce, const int scriptID)
{
	assert(userNonce);

	THREADSAFELOCK();
	if (!mTransport || !userNonce)
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << StatServerPrivate::kClientWantToUpload;
	message << std::string(userNonce);
	message << scriptID;
	message << Backend::GetTitleID();

	PackageAndSendData(mTransport,message);

	return true;
}

bool StatClient::UploadData(const void *data,const int size)
{
	assert(data);
	assert(size);

	THREADSAFELOCK();
	if (!mTransport || !data ||!size || !mCanUpload || (size > StatServerPrivate::kMaximumScriptSize))
	{
		return false;
	}

	char *tdata = (char *) data;
	int tsize = size;
	const int theChunkSize = 256;
	while (tsize > 0)
	{
		DynamicMessageHelper message;
		message << mNOnce;
		message << StatServerPrivate::kClientUploadDataChunk;
		DynamicMessageHelper td;
		td.AddData(tdata,min(theChunkSize,tsize));
		message << td;
		PackageAndSendData(mTransport,message);
		tsize -= theChunkSize;
		tdata += theChunkSize;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << StatServerPrivate::kClientUploadFinished;
	PackageAndSendData(mTransport,message);

	return true;
}

bool StatClient::BeginSession(const int scriptID)
{
	assert(!mInASession);
	THREADSAFELOCK();
	if (!mTransport || mInASession)
	{
		return false;
	}

	mInASession = true;
	DynamicMessageHelper message;
	message << mNOnce;
	message << StatServerPrivate::kClientBeginSession;
	message << scriptID;
	message << Backend::GetTitleID();

	PackageAndSendData(mTransport,message);

	return true;
}

bool StatClient::UpdatePairsBegin(const char *userNonce)
{
	assert(userNonce);
	assert(!mUpdatingPairs);
	assert(mInASession);

	THREADSAFELOCK();
	if (!mTransport || !userNonce || mUpdatingPairs || !mInASession)
	{
		return false;
	}

	mUpdatingPairs = true;

	DynamicMessageHelper message;
	message << mNOnce;
	message << StatServerPrivate::kClientUpdatePairsBegin;
	message << std::string(userNonce);

	PackageAndSendData(mTransport,message);
	return true;
}

bool StatClient::UpdatePairsValue(const char *name,const char *value)
{
	assert(name);
	assert(mUpdatingPairs);

	THREADSAFELOCK();
	if (!mTransport || !name || !mUpdatingPairs)
	{
		return false;
	}

	if ( strlen( name ) > (size_t)StatServerPrivate::kMaximumPairValueSize )
	{
		return false;
	}

	if ( value && ( strlen( value ) > (size_t)StatServerPrivate::kMaximumPairValueSize ) )
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << StatServerPrivate::kClientUpdatePairsValue;
	message << std::string(name);
	message << std::string(value);

	PackageAndSendData(mTransport,message);
	return true;
}

bool StatClient::UpdatePairsValue(const char *name,const int value)
{
	char svalue[256];
	sprintf(svalue,"%d",value);

	return UpdatePairsValue(name,svalue);
}

bool StatClient::UpdatePairsValue(const char *name,const float value)
{
	char svalue[256];
	sprintf(svalue,"%f",value);

	return UpdatePairsValue(name,svalue);
}

bool StatClient::UpdatePairsEnd(void)
{
	assert(mUpdatingPairs);
	THREADSAFELOCK();
	if (!mTransport || !mUpdatingPairs)
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << StatServerPrivate::kClientUpdatePairsEnd;

	PackageAndSendData(mTransport,message);

	mUpdatingPairs = false;
	return true;
}

bool StatClient::EndSession(void)
{
	assert(mInASession);
	assert(!mUpdatingPairs);

	THREADSAFELOCK();
	if (!mTransport || !mInASession)
	{
		return false;
	}

 	DynamicMessageHelper message;
	message << mNOnce;
	message << StatServerPrivate::kClientEndSession;

	PackageAndSendData(mTransport,message);

	mInASession = false;
	return true;
}
//From: RNLobby/TransportNATUDP.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
//Skipping: #include "RNPlatform/Options.h"
//Skipping: #include "RNLobby/BackendPrivate.h"
//Skipping: #include "RNPlatform/Inc/PlatformHeap.h"
//Skipping: #include "RNLobby/Inc/TransportNATUDP.h"
//Skipping: #include "RNLobby/Inc/NATResolver.h"
//Skipping: #include "RNXPURL/Inc/XPURL.h"
//Skipping: #include "RNXPURL/TransportUDP.h"
//Skipping: #include "RNLobby/Inc/NOnceGen.h"
//Skipping: #include "RNPlatform/Inc/CheckSum.h"
//Skipping: #include "RNPlatform/DebugSupport.h"

// Define this to disable the timeout when using breakpoints.
//#define DISABLE_TIMEOUT

using namespace RNReplicaNet;
using namespace RNLobby;

static bool sNATResolverServerSet = false;
static XPAddress sNATResolverServer;

// Enable this to add extra crypto
#define ENABLE_NAT_CRYPTO

namespace RNReplicaNet
{
namespace RNLobby
{
class MyNATResolver : public NATResolver
{
public:
	void CallbackResolveFailed(RNReplicaNet::t_XPSocket *socket,void *userPointer,const int titleID,const bool isAdvertised,const int globalID,const int sessionID,const int nonceID)
	{
		// This gets called for each connecting client TransportNATUDP
#ifdef DEBUG_PRINTS7
		dprintf("MyNATResolver::CallbackResolveFailed $%p : tID %d isAd %d globalID %d sessionID %d nonceID %d\n",(int)socket,titleID,(int)isAdvertised,globalID,sessionID,nonceID);
#endif
		assert(userPointer);
		TransportNATUDP *transport = (TransportNATUDP *)userPointer;
		assert(transport->mBaseTransport);
		assert(transport->mBaseTransport->CanAccept() == "UDP@");
		transport->SetError();
		TransportUDP *real = (TransportUDP *) transport->mBaseTransport;
		real->RemoveSocketAutoPoll();
	}

	void CallbackResolveResult(RNReplicaNet::t_XPSocket *socket,void *userPointer,const RNReplicaNet::XPAddress &targetAddress,const int titleID,const bool isAdvertised,const int globalID,const int sessionID,const int nonceID)
	{
		// This gets called for each connecting client TransportNATUDP
#ifdef DEBUG_PRINTS7
		dprintf("MyNATResolver::CallbackResolveResult $%p : %s tID %d isAd %d globalID %d sessionID %d nonceID %d\n",(int)socket,targetAddress.Export().c_str(),titleID,(int)isAdvertised,globalID,sessionID,nonceID);
#endif
		assert(userPointer);
		TransportNATUDP *transport = (TransportNATUDP *)userPointer;
		if (!transport->mIsResolved /*&& transport->mBeginResolveCalled*/)
		{
			transport->mIsResolved = true;
			assert(transport->mBaseTransport);
			assert(transport->mBaseTransport->CanAccept() == "UDP@");
			TransportUDP *real = (TransportUDP *) transport->mBaseTransport;
			real->RemoveSocketAutoPoll();

			std::string url = "UDP@" + targetAddress.Export() + "/";

#ifdef DEBUG_PRINTS7
			dprintf("MyNATResolver::CallbackResolveResult $%p : ConnectStage2 '%s'\n",(int)socket,url.c_str());
#endif

			real->ConnectStage2(url);
		}
	}

	void CallbackExternalAddressKnown(RNReplicaNet::t_XPSocket *socket,void *userPointer,const RNReplicaNet::XPAddress &externalAddress,const int titleID,const bool isAdvertised,const int globalID,const int sessionID,const int nonceID)
	{
#ifdef DEBUG_PRINTS7
		dprintf("MyNATResolver::CallbackExternalAddressKnown $%p : %s tID %d isAd %d globalID %d sessionID %d nonceID %d\n",(int)socket,externalAddress.Export().c_str(),titleID,(int)isAdvertised,globalID,sessionID,nonceID);
#endif
		assert(userPointer);
		((TransportNATUDP *)userPointer)->mExternalAddress = externalAddress;
		((TransportNATUDP *)userPointer)->mKnowExternalAddress = true;
	}
};
}
}

static MyNATResolver *sMyNAT = 0;

namespace RNReplicaNet
{
class TransportNATUDPHeapBlock : public RNReplicaNet::PlatformHeapBlock
{
public:
	virtual ~TransportNATUDPHeapBlock()
	{
		delete sMyNAT;
		sMyNAT = 0;
		sNATResolverServerSet = false;
	}
};
}

#ifdef ENABLE_NAT_CRYPTO
static const int kMagicKnown = 0x26926548;

static std::string EncryptText(const std::string input)
{
	DynamicMessageHelper message;
	int textChecksum = Checksum::ChecksumData(input.c_str(),input.length());
	message << textChecksum;
	message << kMagicKnown;
	message << input;
	Encryption::Key key;
	Encryption::Encrypt( message.GetBuffer() , message.GetSize() , &key );
	return message.DumpAsHex(false);
}

static std::string DecryptText(const std::string input)
{
	DynamicMessageHelper message;
	if (!message.ReadAsHex(input))
	{
		return "";
	}
	// Way too short?
	int totalSize = message.GetSize();
	if (totalSize < (int)(sizeof(int) * 3))
	{
		return "";
	}
	Encryption::Key key;
	Encryption::Decrypt( message.GetBuffer() , message.GetSize() , &key );
	message.SetSize(0);
	int textChecksum;
	message >> textChecksum;
	int magic;
	message >> magic;
	if (magic != kMagicKnown)
	{
		return "";
	}
	std::string realText;
	message >> realText;
	int textChecksumCheck = Checksum::ChecksumData(realText.c_str(),realText.length());
	if (textChecksumCheck != textChecksum)
	{
		return "";
	}
	return realText;
}
#else
#define EncryptText(a) a
#define DecryptText(a) a
#endif

extern std::string DecryptTransportNATUDPURL(const std::string &address)
{
	std::string work = address.substr(7);
	size_t slashPos = work.find("/");
	// No std::string::npos check needed because if there is no trailing slash it takes the entire substring.
	// If there is a trailing slash it removes it.
	// XPSession can provide URLs with no trailing slash.
	return DecryptText(work.substr(0,slashPos));
}

/*
extern std::string EncryptTransportNATUDPURL(const std::string &address)
{
	return std::string("NATUDP@") + EncryptText(address) + "/";
}
*/

TransportNATUDP::TransportNATUDP() : mAllocated(false) , mBaseTransport(0) , mIsResolved(false) , mMyNOnceUsed(-1) ,
	mKnowExternalAddress(false) , mIsListen(false) , mIsUsed(false) /*, mBeginResolveCalled(false)*/
{
	mStateIsAdvertised = false;
	mStateGlobalID = -1;
	mStateSessionID = -1;

	if (!sMyNAT)
	{
		sMyNAT = new MyNATResolver;
		if (sNATResolverServerSet)
		{
			sMyNAT->SetServer(sNATResolverServer);
		}
		(new TransportNATUDPHeapBlock())->Register();
	}
}

TransportNATUDP::~TransportNATUDP()
{
	sMyNAT->ForgetUserPointer(this);
	if (mAllocated && mBaseTransport)
	{
		assert(mBaseTransport->CanAccept() == "UDP@");
		TransportUDP *real = (TransportUDP *) mBaseTransport;
		real->RemoveSocketAutoPoll();

		delete mBaseTransport;
		mBaseTransport = 0;
		mAllocated = false;
	}
}

int TransportNATUDP::GetPacketsSent(const bool reset)
{
	return mBaseTransport->GetPacketsSent(reset);
}

int TransportNATUDP::GetPacketsSentMerged(const bool reset)
{
	return mBaseTransport->GetPacketsSentMerged(reset);
}

int TransportNATUDP::GetPacketsSentSize(const bool reset)
{
	return mBaseTransport->GetPacketsSentSize(reset);
}

int TransportNATUDP::GetPacketsReceived(const bool reset)
{
	return mBaseTransport->GetPacketsReceived(reset);
}

int TransportNATUDP::GetPacketsReceivedMerged(const bool reset)
{
	return mBaseTransport->GetPacketsReceivedMerged(reset);
}

int TransportNATUDP::GetPacketsReceivedSize(const bool reset)
{
	return mBaseTransport->GetPacketsReceivedSize(reset);
}

int TransportNATUDP::GetPacketsLost(const bool reset)
{
	return mBaseTransport->GetPacketsLost(reset);
}

void TransportNATUDP::SetBandwidthLimit(const Bandwidth enable)
{
	mBaseTransport->SetBandwidthLimit(enable);
}

Transport::Bandwidth TransportNATUDP::GetBandwidthLimit()
{
	return mBaseTransport->GetBandwidthLimit();
}

void TransportNATUDP::SetMaximumOutputBandwidth(const int bytesPerSecond)
{
	mBaseTransport->SetMaximumOutputBandwidth(bytesPerSecond);
}

int TransportNATUDP::GetMaximumOutputBandwidth(void)
{
	return mBaseTransport->GetMaximumOutputBandwidth();
}

void TransportNATUDP::SetMaximumInputBandwidth(const int bytesPerSecond)
{
	mBaseTransport->SetMaximumInputBandwidth(bytesPerSecond);
}

int TransportNATUDP::GetMaximumInputBandwidth(void)
{
	return mBaseTransport->GetMaximumInputBandwidth();
}

std::string TransportNATUDP::GetPeerURL(void)
{
	assert(mBaseTransport);
	assert(mBaseTransport->CanAccept() == "UDP@");
	TransportUDP *real = (TransportUDP *) mBaseTransport;
	if (!real->mOnlyReceiveFrom)
	{
		return std::string("");
	}

	char temp[256];
	sprintf(temp,"*%d:%d:%d:%d",
	mStateIsAdvertised,mStateGlobalID,mStateSessionID,mMyNOnceUsed
	);
	
	return std::string(CanAccept() + "<" + EncryptText(real->mReceiveFrom.Export() + temp) + "/");
}

bool TransportNATUDP::GetTransportClosed(void)
{
	return mBaseTransport->GetTransportClosed();
}

void TransportNATUDP::SetEnableLANDiscovery(const bool enable)
{
	mBaseTransport->SetEnableLANDiscovery(enable);
}

bool TransportNATUDP::GetEnableLANDiscovery(void)
{
	return mBaseTransport->GetEnableLANDiscovery();
}

std::string TransportNATUDP::CanAccept()
{
	std::string ret = mBaseTransport->CanAccept();
	if (ret == "")
	{
		return "";
	}
	return std::string("NAT") + ret;
}

std::string TransportNATUDP::CanRoute()
{
	std::string ret = mBaseTransport->CanRoute();
	if (ret == "")
	{
		return "";
	}
	return std::string("NAT") + ret;
}

std::string TransportNATUDP::ExportURL(void)
{
	std::string ret = mBaseTransport->ExportURL();
	if (ret == "")
	{
		return "";
	}

	char temp[256];
	sprintf(temp,"*%d:%d:%d:%d",
	mStateIsAdvertised,mStateGlobalID,mStateSessionID,mMyNOnceUsed
	);

	if (!mIsListen)
	{
		assert(mBaseTransport);
		assert(mBaseTransport->CanAccept() == "UDP@");
		TransportUDP *real = (TransportUDP *) mBaseTransport;
		assert(real->GetPersistantSocket());
		XPAddress tempAddr;
		real->GetPersistantSocket()->GetAddress(&tempAddr);
		return std::string("NATUDP@<") + EncryptText(tempAddr.Export() + temp) + "/";
	}

	XPAddress local;
	assert(mBaseTransport);
	assert(mBaseTransport->CanAccept() == "UDP@");
	TransportUDP *real = (TransportUDP *) mBaseTransport;
	assert(real->GetPersistantSocket());
	assert(real->GetPersistantSocket()->GetSocketPointer());
	real->GetPersistantSocket()->GetAddress(&local);

	if (mKnowExternalAddress && (mExternalAddress != local))
	{
		return std::string("NATUDP@") + EncryptText(local.Export() + "*" + mExternalAddress.Export() + temp) + "/";
	}

	return std::string("NATUDP@") + EncryptText(local.Export() +"*" + temp) + "/";
}

Transport *TransportNATUDP::Allocate(void)
{
	TransportNATUDP *temp = new TransportNATUDP();
	temp->mBaseTransport = mBaseTransport->Allocate();
	temp->mAllocated = true;

	return temp;
}

Transport::Error TransportNATUDP::Listen(const int channel)
{
	Error ret = mBaseTransport->Listen(channel);

	if (ret == kTransport_EOK)
	{
		CommonListen();
	}

	return ret;
}

Transport::Error TransportNATUDP::Listen(const std::string &address)
{
	std::string work = address.substr(7);	// 7 Being the length of NATUDP@
	work = mBaseTransport->CanAccept() + work;
	Error ret = mBaseTransport->Listen(work);

	if (ret == kTransport_EOK)
	{
		CommonListen();
	}

	return ret;
}

void TransportNATUDP::CommonListen(void)
{
	mStateIsAdvertised = Backend::GetIsAdvertised();
	mStateGlobalID = mStateIsAdvertised ? Backend::GetAdvertisedID() : Backend::GetLoginID();
	mStateSessionID = Backend::GetSessionID();


	assert(mBaseTransport);
	assert(mBaseTransport->CanAccept() == "UDP@");
	TransportUDP *real = (TransportUDP *) mBaseTransport;
	assert(sMyNAT);
	assert(real->GetPersistantSocket());
	assert(real->GetPersistantSocket()->GetSocketPointer());
	mIsResolved = true;
	mIsListen = true;
	mMyNOnceUsed = NOnceGen::GetNOnce();
	mIsUsed = true;
	sMyNAT->BeginAdvertise(real->GetPersistantSocket()->GetSocketPointer(),this,
		mStateIsAdvertised,mStateGlobalID,mStateSessionID,mMyNOnceUsed
		,true,0,true);
}

Transport::Error TransportNATUDP::Connect(const std::string address)
{
	// The URL will arrive something like this after being decrypted:
	// NATUDP@10.10.10.8:2015*127.0.0.1:2015*0:0:0:0/
	// The format is: NATUDP@<Most local address of socket on LAN>*<External address from NATResolve server>*<NATResolve values>/
	std::string work = address.substr(7);	// 7 Being the length of NATUDP@
	size_t slashPos = work.find("/");
	// No std::string::npos check needed because if there is no trailing slash is takes the entire substring.
	// If there is a trailing slash it removes it.
	// XPSession can provide URLs with no trailing slash.
	work = DecryptText(work.substr(0,slashPos));
	if (work == "")
	{
		SetError();
		return kTransport_EERROR;
	}
	work += "/";	// Add a trailing slash
	size_t starPos = work.find("*");
	std::string first = work.substr(0,starPos);
	work = work.substr(starPos+1);
	starPos = work.find("*");
	std::string second = work.substr(0,starPos);
	slashPos = work.find("/");
	std::string third = work.substr(starPos+1,slashPos - (starPos+1));
	if (third == "")
	{
		SetError();
		return kTransport_EERROR;
	}

	if (second == first)
	{
		second = "";
	}

	int isAdvertised;
	int globalID;
	int sessionID;
	int nonceID;
	int ret = sscanf(third.c_str(),"%d:%d:%d:%d",&isAdvertised,&globalID,&sessionID,&nonceID);
	if (ret != 4)
	{
		SetError();
		return kTransport_EERROR;
	}
	mStateIsAdvertised = Backend::GetIsAdvertised();
	mStateGlobalID = mStateIsAdvertised ? Backend::GetAdvertisedID() : Backend::GetLoginID();
	mStateSessionID = Backend::GetSessionID();

	mMyNOnceUsed = nonceID;
	mIsUsed = true;

	assert(mBaseTransport);
	assert(mBaseTransport->CanAccept() == "UDP@");
	TransportUDP *real = (TransportUDP *) mBaseTransport;
	real->ConnectStage1();
	assert(sMyNAT);
	assert(real->GetPersistantSocket());
	assert(real->GetPersistantSocket()->GetSocketPointer());
	real->AddSocketAutoPoll();

	XPAddress *pFirst = 0;
	XPAddress *pSecond = 0;
	XPAddress firstAddr;
	XPAddress secondAddr;
	if (first != "")
	{
		firstAddr = XPAddress(first);
		pFirst = &firstAddr;
	}
	if (second != "")
	{
		secondAddr = XPAddress(second);
		pSecond = &secondAddr;
	}

	// Set this before so the callback that check for mBeginResolveCalled = true has no timing issues
/*
	mBeginResolveCalledTime.Reset();
	mBeginResolveCalled = true;
*/
	if (!sMyNAT->BeginResolve(real->GetPersistantSocket()->GetSocketPointer(),this,
	isAdvertised!=0,globalID,sessionID,nonceID
	,true,pSecond,pFirst))
	{
		SetError();
		real->RemoveSocketAutoPoll();
		return Transport::kTransport_EERROR;
	}

	return Transport::kTransport_EOK;
}

Transport *TransportNATUDP::Accept(void)
{
	// The Accept() returns a new transport when the connecting client's buildup packets are received.
	// The connecting client's address is then added by the UDPReliableManager to the transport's list of pending connections.
	Transport *accepted = mBaseTransport->Accept();
	if (accepted == NULL)
	{
		return NULL;
	}

	// So allocate a server side copy of the transport connection
	TransportNATUDP *temp = new TransportNATUDP();
	temp->mStateIsAdvertised = mStateIsAdvertised;
	temp->mStateGlobalID = mStateGlobalID;
	temp->mStateSessionID = mStateSessionID;
	temp->mBaseTransport = accepted;
	temp->mAllocated = true;
	temp->mMyNOnceUsed = mMyNOnceUsed;
	temp->mIsResolved = true;
	return temp;
}

Transport::Error TransportNATUDP::Send(const char *data,const int len)
{
	if (mBaseTransport->GetStatus() == kTransport_EOK)
	{
		return mBaseTransport->Send(data,len);
	}
	return kTransport_EWAITING;
}

Transport::Error TransportNATUDP::SendOrdered(const char *data,const int len,const unsigned int band)
{
	if (mBaseTransport->GetStatus() == kTransport_EOK)
	{
		return mBaseTransport->SendOrdered(data,len,band);
	}
	return kTransport_EWAITING;
}

Transport::Error TransportNATUDP::SendReliable(const char *data,const int len,const unsigned int band)
{
	if (mBaseTransport->GetStatus() == kTransport_EOK)
	{
		return mBaseTransport->SendReliable(data,len,band);
	}
	return kTransport_EWAITING;
}

Transport::Error TransportNATUDP::SendCertain(const char *data,const int len)
{
	if (mBaseTransport->GetStatus() == kTransport_EOK)
	{
		return mBaseTransport->SendCertain(data,len);
	}
	return kTransport_EWAITING;
}

int TransportNATUDP::Recv(char *const data,const int maxlen)
{
	return mBaseTransport->Recv(data,maxlen);
}

int TransportNATUDP::GetMaxPacketSize(void)
{
	return mBaseTransport->GetMaxPacketSize();
}

std::string TransportNATUDP::HandleDiscovery(void)
{
	std::string retstr;
	retstr = mBaseTransport->HandleDiscovery();
	if (retstr == "")
	{
		return "";
	}
	return std::string("NAT") + retstr;
}

void TransportNATUDP::HandleDiscoveryReply(const std::string reply)
{
	mBaseTransport->HandleDiscoveryReply(reply);
}

void TransportNATUDP::BeginDiscovery(void)
{
	mBaseTransport->BeginDiscovery();
}

std::string TransportNATUDP::GetNextDiscovery(void)
{
	return mBaseTransport->GetNextDiscovery();
}

Transport::Error TransportNATUDP::GetStatus(void)
{
	if (mBaseTransport->GetStatus() == kTransport_EERROR)
	{
		return kTransport_EERROR;
	}

	// MPi: TODO: Think about removing/enabling this code later on, for now it should be superfluous.
	// The addition of CallbackResolveFailed() has made this timeout code below redundant.
#if 0
	if (!mIsResolved && mBeginResolveCalled)
	{
		// As part of a last gasp attempt to trap all failure conditions:
		// If the NATResolve request has not been resolved and BeginResolve was called then...
		float theTime = mBeginResolveCalledTime.FloatTime();
		// ... And if it has been more than thirty seconds...
#ifndef DISABLE_TIMEOUT
		if (theTime > 30.0f)
		{
			// Report an error condition
#ifdef DEBUG_PRINTS7
			dprintf("TransportNATUDP::GetStatus Setting kTransport_EERROR due to timeout.\n");
#endif
			// Stop this particular function triggering again
			mBeginResolveCalled = false;
			// Set the error condition
			SetError();
			assert(mBaseTransport);
			assert(mBaseTransport->CanAccept() == "UDP@");
			TransportUDP *real = (TransportUDP *) mBaseTransport;
			assert(sMyNAT);
			assert(real->GetPersistantSocket());
			assert(real->GetPersistantSocket()->GetSocketPointer());
			return kTransport_EERROR;
		}
#endif
	}
#endif

	if (!mIsResolved)
	{
		return kTransport_EWAITING;
	}
	return mBaseTransport->GetStatus();
}

void TransportNATUDP::SetBaseTransport(Transport *baseTransport)
{
	mBaseTransport = baseTransport;
}

void TransportNATUDP::SetError(void)
{
	assert(mBaseTransport);
	assert(mBaseTransport->CanAccept() == "UDP@");
	TransportUDP *real = (TransportUDP *) mBaseTransport;
	real->mError = kTransport_EERROR;
}


// Extension API for this transport type
bool TransportNATUDP::SetNATValues(const bool isAdvertised,const int globalID,const int sessionID)
{
	// Don't allow the values to be changed once this transport has Listen() or Connect() used.
	if (mIsUsed)
	{
		return false;
	}

	mStateIsAdvertised = isAdvertised;
	mStateGlobalID = globalID;
	mStateSessionID = sessionID;

	return true;
}

void TransportNATUDP::GetNATValues(bool &isAdvertised,int &globalID,int &sessionID)
{
	isAdvertised = mStateIsAdvertised;
	globalID = mStateGlobalID;
	sessionID = mStateSessionID;
}

void TransportNATUDP::SetServer(const XPAddress &address)
{
	sNATResolverServerSet = true;
	sNATResolverServer = address;
}

void TransportNATUDP::ClearServer(void)
{
	sNATResolverServerSet = false;
}
//From: RNLobby/UserClient.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
//Skipping: #include "RNLobby/Inc/UserClient.h"
//Include inline: #include "RNLobby/UserServerPrivate.h"
//From: RNLobby/UserServerPrivate.h
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifndef _USERSERVERPRIVATE_H_
#define _USERSERVERPRIVATE_H_
//Skipping: #include "RNLobby/Inc/UserClient.h"

namespace RNReplicaNet
{

namespace RNLobby
{

namespace UserServerPrivate
{

const int kMaximumUsernameSize = 32;
const int kMaximumEmailSize = 256;
const int kMaximumMessageSize = 384;

extern bool VariableAccessAllowed(const int myId,const int otherID,const UserClient::VariableAccess access,const bool writing);

enum kPacket
{
	kServerProbeFromConnect = 0,
	kClientCreateLogin,	// Will also login that user
	kClientLogin,
	kServerClientLogout,	// Can come from either the server or the client
	kServerLoginID,	// Any other queries below here must be logged in
	kServerUserLoginFailed,
	kServerUserAlreadyExists,
	kServerUserLoginFromOtherClient,
	kClientDelete,
	kClientAddFriend,
	kClientRemoveFriend,
	kClientAuthoriseFriendRequest,
	kClientDenyFriendRequest,
	kServerFriendInfoAdd,
	kServerFriendInfoChange,
	kServerFriendInfoDelete,
	kClientFindByLoginID,
	kClientFindByName,
	kClientSendMessage,
	kServerSendMessage,
	kClientSendGameInvite,	// The invite cancel is a blank invite
	kClientAnswerGameInvite,
	kClientSetVariable,
	kClientDeleteVariable,
	kClientGetVariable,
	kServerVariableReply,
	kClientAddUser,
	kClientRemoveUser,
	kServerUserInfoAdd,
	kServerUserInfoChange,
	kServerUserInfoDelete,
	kClientCreateChatRoom,
	kClientLeaveChatRoom,
	kServerChatRoomCreated,
	kServerChatRoomLeft,
	kServerChatRoomClosed,
	kServerChatRoomUserEntered,
	kServerChatRoomUserLeft,
	kClientEnterChatRoom,
	kServerChatRoomEntered,
	kServerChatRoomEnterFailed,
	kClientChatRoomSay,
	kServerChatRoomSay,
	kClientChatRoomWhisper,
	kClientChatRoomAdminMessage,
	kClientChatRoomKick,
	kServerChatRoomKick,
	kClientGlobalKick,
	kServerGlobalKick,
	kClientChangePassword,
	kServerPasswordChanged,
	kClientChangeEmail,
	kServerEmailChanged,
	kClientPlayingAGame,
	kClientRequestUserNonce,
	kServerUserNonce,
	kServerNewStatsAvailable,
	kClientRequestNamesLike,
	kServerRequestNamesLikeBegin,
	kServerRequestNamesLike,
	kServerRequestNamesLikeEnd,
	kClientGlobalRestore,
	kClientChatRoomSayEx,
	kClientChatRoomWhisperEx,
	kClientChatRoomAdminMessageEx,
	kServerPasswordCannotChange,
	kServerEmailCannotChange
};

} // namespace UserServerPrivate

} // namespace RNLobby

} // namespace RNReplicaNet

#endif
//Skipping: #include "RNLobby/StatServerPrivate.h"
//Skipping: #include "RNLobby/BackendPrivate.h"
//Skipping: #include "RNXPURL/TransportUDP.h"
//Skipping: #include "RNXPURL/Inc/XPURL.h"
//Skipping: #include "RNLobby/Inc/NOnceGen.h"
//Skipping: #include "RNPlatform/Inc/CheckSum.h"
//Skipping: #include "RNPlatform/Inc/StringUtils.h"

using namespace RNReplicaNet;
using namespace RNLobby;

namespace RNReplicaNet
{

	// Also in RNLobby\Web\ValidateUsername.vbs
	std::string ValidateUsername(const std::string &input)
	{
		std::string input2 = TrimWhite(input);
		std::string work;
		size_t pos;
		for (pos = 0 ; pos < input2.length() ; pos++)
		{
			char t = input2[pos];
			if (t >= 'a' && t <= 'z')
			{
				work = work + t;
			}
			else if (t >= 'A' && t <= 'Z')
			{
				work = work + t;
			}
			else if (t >= '0' && t <= '9')
			{
				work = work + t;
			}
			else if (strchr(" !$^&*():;@/.,-=`#~{}[]_", t))
			{
				work = work + t;
			}
		}

		return work.substr(0 , UserServerPrivate::kMaximumUsernameSize);
	}

	// Also in RNLobby\Web\ValidateEmail.vbs
	std::string ValidateEmail(const std::string &input)
	{
		std::string input2 = TrimWhite(input);
		std::string work;
		size_t pos;
		for (pos = 0 ; pos < input2.length() ; pos++)
		{
			char t = input2[pos];
			if (t >= 'a' && t <= 'z')
			{
				work = work + t;
			}
			else if (t >= 'A' && t <= 'Z')
			{
				work = work + t;
			}
			else if (t >= '0' && t <= '9')
			{
				work = work + t;
			}
			else if (strchr("!$^&*():;@/.,-=`#~{}[]_", t))
			{
				work = work + t;
			}
		}

		return work.substr(0 , UserServerPrivate::kMaximumEmailSize);
	}

	namespace RNLobby
	{
		namespace UserServerPrivate
		{
			// This is here because it is used by the server and client side code
			bool VariableAccessAllowed(const int myId,const int otherID,const UserClient::VariableAccess access,const bool writing)
			{
				switch(access)
				{
				case UserClient::kPrivateRead:
					if ((myId == otherID) && !writing)
					{
						return true;
					}
					break;

				case UserClient::kPrivateReadWrite:
					if (myId == otherID)
					{
						return true;
					}
					break;

				case UserClient::kPublicReadPrivateReadWrite:
					if (myId == otherID)
					{
						return true;
					}
					if ((myId != otherID) && !writing)
					{
						return true;
					}
					break;

				case UserClient::kPublicReadPrivateRead:
					if (!writing)
					{
						return true;
					}
					break;
				default:
					return false;
					break;
				}

				return false;
			}
		} // namespace UserServerPrivate
	} // namespace RNLobby
} // namespace RNReplicaNet

// Little user info storage class

UserInfo::UserInfo() : mID(UserInfo::kAnyLoginID) , mLoginID(UserInfo::kAnyLoginID) , mState(0)
{
}

UserInfo::~UserInfo()
{
}

int UserInfo::GetLoginID(void) const
{
	return mLoginID;
}

std::string UserInfo::GetName(void) const
{
	return mName;
}

int UserInfo::GetState(void) const
{
	return mState;
}

std::string UserInfo::GetGameInvite(void) const
{
	return mGameInvite;
}

std::string UserInfo::GetLastOnlineTime(void) const
{
	return mLastOnlineTime;
}

std::string UserInfo::GetPlayingAGameURL(void) const
{
	return mPlayingAGameURL;
}

// ********************************************************************
// ********************************************************************
// The main client

// mLoginTried = true because InitInternalState() resets it to be false when Start() has been called
UserClient::UserClient() : mLoginTried(true) , mPreviousState(0) , mCurrentState(0) , mMessagePending(false) , mGameInvitePending(false) , mServerAddressSet(false) , mPendingGetVariables(0)
{
}

UserClient::~UserClient()
{
	Stop();
	Backend::SetAdvertised();
}

bool UserClient::Start(void)
{
	Stop();
	Backend::ServerCryptoHelper<UserClient>::SetEncryption(this,Backend::GetUserServerCrypto());

	InitInternalState();

	XPURL::RegisterDefaultTransports();
	THREADSAFELOCK();
	if (!mServerAddressSet)
	{
		mServerAddress = Backend::GetUserServerAddress();
	}
	XPURL xpurl;
	Transport *transport = xpurl.FindTransport("UDP@");
	assert(transport && "Unable to find UDP@ Transport");
	TransportUDP *transport2 = (TransportUDP *) transport->Allocate();
	assert(transport2);
	transport2->Connect("UDP@"+mServerAddress.Export());
	return BaseTransportServer::StartWithTransport(transport2,true,false);
}

bool UserClient::Stop(void)
{
	LogoutUser();
	return BaseTransportServer::Stop();
}

void UserClient::SetServer(const RNReplicaNet::XPAddress &address)
{
	mServerAddressSet = true;
	mServerAddress = address;
}

void UserClient::CallbackTidy(void)
{
	InitInternalState();
}

bool UserClient::CallbackPoll(void)
{
	DoStateChangeCalc();
	return true;
}

bool UserClient::CallbackParseValidMessage(Transport *transport,DynamicMessageHelper &message,const size_t length)
{
	int NOnce;
	message >> NOnce;
	UserServerPrivate::kPacket packet;
	message >> packet;
	switch(packet)
	{
		default:
			break;

		case UserServerPrivate::kServerProbeFromConnect:
		{
			CallbackConnectionEstablished(mTransport);
			break;
		}

		case UserServerPrivate::kServerLoginID:
		{
			if (NOnce == mNOnce)
			{
				int loginID;
				message >> loginID;
				message >> mIsGlobalAdmin;
				message >> mMyLoginName;
				message >> mLastOnlineTime;

				mMyLoginID = loginID;
				Backend::SetLoginID(loginID);
				CallbackUserLogin(loginID);
			}
			else
			{
				assert(!"UserClient kServerLoginID NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerUserAlreadyExists:
		{
			if (NOnce == mNOnce)
			{
				int loginID;
				message >> loginID;
				InitInternalState();
				CallbackUserAlreadyExists(loginID);
			}
			else
			{
				assert(!"UserClient kServerUserAlreadyExists NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerUserLoginFailed:
		{
			if (NOnce == mNOnce)
			{
				UserClient::Reason reason;
				message >> reason;
				InitInternalState();
				CallbackUserLoginFailed(reason);
			}
			else
			{
				assert(!"UserClient kServerUserLoginFailed NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerUserLoginFromOtherClient:
		{
			if (NOnce == mNOnce)
			{
				InitInternalState();
				CallbackUserLoginFromOtherClient();
			}
			else
			{
				assert(!"UserClient kServerUserLoginFromOtherClient NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerClientLogout:
		{
			if (NOnce == mNOnce)
			{
				InitInternalState();
				CallbackUserLogout(kReason_ServerForcedLogout);
			}
			else
			{
				assert(!"UserClient kServerClientLogout NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerSendMessage:
		{
			if (NOnce == mNOnce)
			{
				int fromLoginID;
				message >> fromLoginID;
				std::string theMessage;
				message >> theMessage;
				mMessagePending = true;
				DoStateChangeCalc();
				CallbackMessageReceived(fromLoginID,theMessage.c_str());
				DoStateChangeCalc();
			}
			else
			{
				assert(!"UserClient kServerSendMessage NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerFriendInfoDelete:
		{
			if (NOnce == mNOnce)
			{
				int internalID;
				message >> internalID;
				int loginID;
				message >> loginID;
				THREADSAFELOCKCLASS(mInternalLists);
				mPendingFriendIDs.erase(loginID);
				mUsers.erase(loginID);
				DoStateChangeCalc();
				CallbackFriendDeleted(loginID);
			}
			else
			{
				assert(!"UserClient kServerFriendInfoDelete NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerUserInfoDelete:
		{
			if (NOnce == mNOnce)
			{
				int internalID;
				message >> internalID;
				int loginID;
				message >> loginID;
				THREADSAFELOCKCLASS(mInternalLists);
				mUsers.erase(loginID);
				DoStateChangeCalc();
				CallbackUserInfoDeleted(loginID);
			}
			else
			{
				assert(!"UserClient kServerUserInfoDelete NOnce failure");
				return false;
			}
			break;
		}


		// When the player is a friend the client will get these messages.
		case UserServerPrivate::kServerFriendInfoAdd:
		case UserServerPrivate::kServerFriendInfoChange:
		{
			if (NOnce == mNOnce)
			{
				int internalID;
				message >> internalID;
				int loginID;
				message >> loginID;

				THREADSAFELOCKCLASS(mInternalLists);

				std::map<int,UserInfo>::iterator found = mUsers.insert(std::pair<int,UserInfo>(loginID,UserInfo())).first;
				UserInfo &user = (*found).second;

				std::string name;
				message >> name;
				bool authorised;
				message >> authorised;
				bool online;
				message >> online;
				std::string gameInvite;
				message >> gameInvite;
				std::string lastOnlineTime;
				message >> lastOnlineTime;
				bool playingAGame;
				message >> playingAGame;
				std::string playingAGameURL;
				if (playingAGame)
				{
					message >> playingAGameURL;
				}

				user.mID = internalID;
				user.mLoginID = loginID;
				user.mLastOnlineTime = lastOnlineTime;

				// Reset the state to nothing first
				user.mState = 0;
				// Now calculate the real state
				if (!authorised)
				{
					user.mState |= UserInfo::kState_FriendRequest;
					mPendingFriendIDs.insert(user.mLoginID);
				}
				else
				{
					user.mState |= UserInfo::kState_Friend;
				}

				if (online)
				{
					user.mState |= UserInfo::kState_Online;
				}
				if (playingAGame)
				{
					user.mState |= UserInfo::kState_PlayingAGame;
					user.mPlayingAGameURL = playingAGameURL;
				}
				else
				{
					user.mPlayingAGameURL = "";
				}

				if (gameInvite != "" && (user.mState & UserInfo::kState_Friend))
				{
					user.mState |= UserInfo::kState_GameInvite;
					user.mGameInvite = gameInvite;
					mGameInvitePending = true;
				}
				else
				{
					user.mGameInvite = "";
				}

				user.mName = name;
				DoStateChangeCalc();
				if (packet == UserServerPrivate::kServerFriendInfoAdd)
				{
					CallbackFriendAdded(user);
				}
				else
				{
					CallbackFriendUpdated(user);
				}
				DoStateChangeCalc();
			}
			else
			{
				assert(!"UserClient kServerFriendInfo [Add/Change] NOnce failure");
				return false;
			}
			break;
		}


		// Only if the player is not a friend will the client gets these messages.
		case UserServerPrivate::kServerUserInfoAdd:
		case UserServerPrivate::kServerUserInfoChange:
		{
			if (NOnce == mNOnce)
			{
				int internalID;
				message >> internalID;
				int loginID;
				message >> loginID;

				THREADSAFELOCKCLASS(mInternalLists);

				std::map<int,UserInfo>::iterator found = mUsers.insert(std::pair<int,UserInfo>(loginID,UserInfo())).first;

				UserInfo &user = (*found).second;

				std::string name;
				message >> name;
				bool online;
				message >> online;
				std::string lastOnlineTime;
				message >> lastOnlineTime;
				bool playingAGame;
				message >> playingAGame;

				user.mID = internalID;
				user.mLoginID = loginID;
				user.mLastOnlineTime = lastOnlineTime;

				// Reset the state to nothing first
				user.mState = 0;
				// Now calculate the real state

				if (online)
				{
					user.mState |= UserInfo::kState_Online;
				}
				if (playingAGame)
				{
					user.mState |= UserInfo::kState_PlayingAGame;
				}

				user.mGameInvite = "";

				user.mName = name;
				DoStateChangeCalc();
				if (packet == UserServerPrivate::kServerUserInfoAdd)
				{
					CallbackUserInfoAdded(user);
				}
				else
				{
					CallbackUserInfoUpdated(user);
				}
				DoStateChangeCalc();
			}
			else
			{
				assert(!"UserClient kServerUserInfo [Add/Change] NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerVariableReply:
		{
			if (NOnce == mNOnce)
			{
				{
					THREADSAFELOCK();
					mPendingGetVariables--;
				}
				int loginID;
				message >> loginID;
				int titleID;
				message >> titleID;
				int section;
				message >> section;
				std::string name;
				message >> name;
				UserClient::VariableAccess access;
				message >> access;
				bool success;
				message >> success;

				if (success)
				{
					std::string value;
					message >> value;
					CallbackGotVariable(loginID,section,name.c_str(),value.c_str(),access);
				}
				else
				{
					CallbackVariableNotFound(loginID,section,name.c_str(),access);
				}
			}
			else
			{
				assert(!"UserClient kServerVariableReply NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerChatRoomCreated:
		{
			if (NOnce == mNOnce)
			{
				int roomID;
				message >> roomID;

				mIsRoomAdmin = true;
				mInCurrentRoom = roomID;
				mRoomMode = true;

				CallbackChatRoomCreated(roomID);
			}
			else
			{
				assert(!"UserClient kServerChatRoomCreated NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerChatRoomEntered:
		{
			if (NOnce == mNOnce)
			{
				int roomID;
				message >> roomID;

				mInCurrentRoom = roomID;
				mRoomMode = true;

				CallbackChatRoomEntered(roomID);
			}
			else
			{
				assert(!"UserClient kServerChatRoomEntered NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerChatRoomUserEntered:
		{
			if (NOnce == mNOnce)
			{
				int loginID;
				message >> loginID;
				std::string name;
				message >> name;
				bool admin;
				message >> admin;

				UserInfo userInfo;
				GetUserInfo(loginID,&userInfo);	// Get any locally cached info first
				userInfo.mLoginID = loginID;
				userInfo.mName = name;
				userInfo.mState |= UserInfo::kState_Online;

				// Then copy any changes we know about back into the users list
				// MPi: TODO: These mUser entries need to be expired after a certain amount of time due to them being added
				// outside of the kServerFriendInfoAdd and kServerUserInfoDelete structure.
				std::map<int,UserInfo>::iterator found = mUsers.insert(std::pair<int,UserInfo>(userInfo.mLoginID,UserInfo())).first;
				UserInfo &user = (*found).second;
				user = userInfo;

				CallbackChatRoomUserEntered(userInfo);
			}
			else
			{
				assert(!"UserClient kServerChatRoomUserEntered NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerChatRoomLeft:
		{
			if (NOnce == mNOnce)
			{
				mInCurrentRoom = -1;
				mRoomMode = false;
				mIsRoomAdmin = false;
				CallbackChatRoomLeft(kReason_ChatRoomUserLeft);
			}
			else
			{
				assert(!"UserClient kServerChatRoomLeft NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerChatRoomClosed:
		{
			if (NOnce == mNOnce)
			{
				UserClient::Reason reason;
				message >> reason;
				mIsRoomAdmin = false;
				mRoomMode = false;
				CallbackChatRoomLeft(reason);
			}
			else
			{
				assert(!"UserClient kServerChatRoomClosed NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerChatRoomUserLeft:
		{
			if (NOnce == mNOnce)
			{
				UserClient::Reason reason;
				message >> reason;
				int loginID;
				message >> loginID;
				std::string name;
				message >> name;

				UserInfo userInfo;
				userInfo.mLoginID = loginID;
				userInfo.mName = name;

				CallbackChatRoomUserLeft(userInfo,reason);
			}
			else
			{
				assert(!"UserClient kServerChatRoomUserLeft NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerChatRoomEnterFailed:
		{
			if (NOnce == mNOnce)
			{
				UserClient::Reason reason;
				message >> reason;
				int roomID;
				message >> roomID;
				mInCurrentRoom = -1;
				mRoomMode = false;
				mIsRoomAdmin = false;

				CallbackChatRoomEnterFailed(roomID,reason);
			}
			else
			{
				assert(!"UserClient kServerChatRoomEnterFailed NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerChatRoomSay:
		{
			if (NOnce == mNOnce)
			{
				int loginID;
				message >> loginID;
				std::string name;
				message >> name;

				UserInfo userInfo;
				userInfo.mLoginID = loginID;
				userInfo.mName = name;

				std::string text;
				message >> text;

				bool whispered;
				message >> whispered;

				bool isAdmin;
				message >> isAdmin;

				unsigned int flags;
				message >> flags;

				CallbackChatRoomMessage(text.c_str(),userInfo,whispered,isAdmin,flags);
			}
			else
			{
				assert(!"UserClient kServerChatRoomSay NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerChatRoomKick:
		{
			if (NOnce == mNOnce)
			{
				int loginID;
				message >> loginID;
				std::string name;
				message >> name;

				UserInfo userInfo;
				userInfo.mLoginID = loginID;
				userInfo.mName = name;

				bool banned;
				message >> banned;

				std::string reason;
				message >> reason;

				mRoomMode = false;

				CallbackChatRoomKicked(reason.c_str(),banned,userInfo);
				CallbackChatRoomLeft(kReason_ChatRoomKickedByAdmin);
			}
			else
			{
				assert(!"UserClient kServerChatRoomKick NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerGlobalKick:
		{
			if (NOnce == mNOnce)
			{
				int loginID;
				message >> loginID;
				std::string name;
				message >> name;

				UserInfo userInfo;
				userInfo.mLoginID = loginID;
				userInfo.mName = name;

				bool banned;
				message >> banned;

				std::string reason;
				message >> reason;

				mRoomMode = false;

				if (mInCurrentRoom != -1)
				{
					CallbackChatRoomLeft(kReason_ChatRoomKickedByAdmin);
				}
				CallbackGlobalKicked(reason.c_str(),banned,userInfo);
				LogoutUser();
			}
			else
			{
				assert(!"UserClient kServerGlobalKick NOnce failure");
				return false;
			}
			break;
		}


		case UserServerPrivate::kServerPasswordChanged:
		{
			if (NOnce == mNOnce)
			{
				CallbackPasswordChanged();
			}
			else
			{
				assert(!"UserClient kServerPasswordChanged NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerPasswordCannotChange:
		{
			if (NOnce == mNOnce)
			{
				CallbackCannotChangePassword();
			}
			else
			{
				assert(!"UserClient kServerPasswordCannotChange NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerEmailChanged:
		{
			if (NOnce == mNOnce)
			{
				CallbackEmailChanged();
			}
			else
			{
				assert(!"UserClient kServerEmailChanged NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerEmailCannotChange:
		{
			if (NOnce == mNOnce)
			{
				CallbackCannotChangeEmail();
			}
			else
			{
				assert(!"UserClient kServerEmailCannotChange NOnce failure");
				return false;
			}
			break;
		}


		case UserServerPrivate::kServerUserNonce:
		{
			if (NOnce == mNOnce)
			{
				std::string userNonce;
				message >> userNonce;
				int seconds;
				message >> seconds;
				CallbackGotUserNonce(userNonce.c_str(),seconds);
			}
			else
			{
				assert(!"UserClient kServerUserNonce NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerNewStatsAvailable:
		{
			if (NOnce == mNOnce)
			{
				int lastTitleIDPlus1;
				message >> lastTitleIDPlus1;
				CallbackNewStatsAvailable(lastTitleIDPlus1-1);
			}
			else
			{
				assert(!"UserClient kServerNewStatsAvailable NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerRequestNamesLikeBegin:
		{
			if (NOnce == mNOnce)
			{
				std::string name;
				message >> name;
				bool banned;
				message >> banned;
				CallbackNamesLikeBegin(name.c_str(),banned);
			}
			else
			{
				assert(!"UserClient kServerRequestNamesLikeBegin NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerRequestNamesLike:
		{
			if (NOnce == mNOnce)
			{
				int loginID;
				message >> loginID;
				std::string name;
				message >> name;

				UserInfo userInfo;
				userInfo.mLoginID = loginID;
				userInfo.mName = name;

				CallbackNamesLike(userInfo);
			}
			else
			{
				assert(!"UserClient kServerRequestNamesLikeEnd NOnce failure");
				return false;
			}
			break;
		}

		case UserServerPrivate::kServerRequestNamesLikeEnd:
		{
			if (NOnce == mNOnce)
			{
				CallbackNamesLikeEnd();
			}
			else
			{
				assert(!"UserClient kServerRequestNamesLikeEnd NOnce failure");
				return false;
			}
			break;
		}

	}
	return true;
}

//Include inline: #include "RNLobby/ObfuscatePassword.h"
//From: RNLobby/ObfuscatePassword.h
//Ignored: #pragma once
#include <algorithm> 
#include <string>

//Skipping: #include "RNPlatform/Inc/CheckSum.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"

namespace RNReplicaNet
{

namespace RNLobby
{

/// \param name will be trimmed for whitespace
std::string ObfuscatePassword(const char *name, const char *password);

} // namespace RNLobby

} // namespace RNReplicaNet

bool UserClient::CreateLoginUser(const char *fname,const char *fpassword,const char *femailAddress,const char *foptionalID)
{
	assert(fname);
	assert(fpassword);
	assert(femailAddress);
	assert(foptionalID);
	THREADSAFELOCK();
	if (mLoginTried || !mTransport)
	{
		return false;
	}

	mMyLoginName = fname;
	mMyLoginName = ValidateUsername(mMyLoginName);
	mLoginTried = true;
	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientCreateLogin;

	int titleID = Backend::GetTitleID();
	message << titleID;
	message << mMyLoginName;
	message << ObfuscatePassword(fname,fpassword);
	std::string emailAddress = femailAddress;
	emailAddress = ValidateEmail(emailAddress);
	message << emailAddress;
	std::string optionalID = foptionalID;
	optionalID = TrimWhite(optionalID);
	message << optionalID;

	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::LoginUser(const char *fname,const char *fpassword)
{
	assert(fname);
	assert(fpassword);
	THREADSAFELOCK();
	if (mLoginTried || !mTransport)
	{
		return false;
	}

	// Temporarily store the name we got passed in until we get the real one back from the server
	mMyLoginName = ValidateUsername(fname);
	mLoginTried = true;
	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientLogin;

	int titleID = Backend::GetTitleID();
	message << titleID;
	message << mMyLoginName;
	std::string obfuscatedPassword = ObfuscatePassword(fname,fpassword);
	int conectionNonce = GetConnectionNOnce(mTransport);
	std::string salt = RNReplicaNet::MessageHelper::DumpAsHex(&conectionNonce,(int)sizeof(conectionNonce),false);
	std::string saltedObfuscatedPassword = ObfuscatePassword(salt.c_str(),obfuscatedPassword.c_str());
	message << saltedObfuscatedPassword;
	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::ChangePassword(const char *fpassword)
{
	assert(fpassword);
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport)
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientChangePassword;
	message << ObfuscatePassword(mMyLoginName.c_str(),fpassword);

	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::ChangeEmail(const char *femailAddress)
{
	assert(femailAddress);
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport)
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientChangeEmail;
	std::string emailAddress = femailAddress;
	message << emailAddress;

	PackageAndSendData(mTransport,message);

	return true;
}

int UserClient::GetLoginID(void)
{
	return mMyLoginID;
}

std::string UserClient::GetLoginName(void)
{
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport)
	{
		return "";
	}
	return mMyLoginName;
}

bool UserClient::LogoutUser(void)
{
	// Stack context for mTransport access
	{
		THREADSAFELOCK();
		if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport)
		{
			return false;
		}

		InitInternalState();
		DynamicMessageHelper message;
		message << mNOnce;
		message << UserServerPrivate::kServerClientLogout;

		assert(mTransport);
		PackageAndSendData(mTransport,message);
	}

	CallbackUserLogout(kReason_ClientForcedLogout);

	return true;
}

bool UserClient::DeleteUser(void)
{
	// Stack context for mTransport access
	{
		THREADSAFELOCK();
		if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport)
		{
			return false;
		}

		InitInternalState();
		DynamicMessageHelper message;
		message << mNOnce;
		message << UserServerPrivate::kClientDelete;

		assert(mTransport);
		PackageAndSendData(mTransport,message);
	}

	CallbackUserLogout(kReason_ClientForcedLogout);

	return true;
}

bool UserClient::AddFriend(const int friendLoginID)
{
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport || (friendLoginID == mMyLoginID))
	{
		return false;
	}

	UserInfo user;
	// If it is already a friend then don't bother to send the request.
	if (GetUserInfo(friendLoginID,&user) && (user.GetState() & UserInfo::kState_Friend))
	{
		return true;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientAddFriend;
	message << friendLoginID;

	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::SendMessageTo(const int loginID,const char *pmessage)
{
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport || !pmessage || (loginID == mMyLoginID))
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientSendMessage;
	message << loginID;
	message << pmessage;

	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::AuthoriseFriendRequest(const int friendLoginID)
{
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport || (friendLoginID == mMyLoginID))
	{
		return false;
	}

	UserInfo user;
	// If it is already a friend or it's not a request then don't bother to send the reply.
	if (GetUserInfo(friendLoginID,&user))
	{
		if(user.GetState() & UserInfo::kState_Friend)
		{
			return true;
		}
		if (!(user.GetState() & UserInfo::kState_FriendRequest))
		{
			return false;
		}
	}

	THREADSAFELOCKCLASS(mInternalLists);
	if (mPendingFriendIDs.erase(friendLoginID))
	{
		DynamicMessageHelper message;
		message << mNOnce;
		message << UserServerPrivate::kClientAuthoriseFriendRequest;
		message << friendLoginID;

		PackageAndSendData(mTransport,message);

		return true;
	}
	return false;
}

bool UserClient::DenyFriendRequest(const int friendLoginID)
{
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport || (friendLoginID == mMyLoginID))
	{
		return false;
	}

	THREADSAFELOCKCLASS(mInternalLists);
	if (mPendingFriendIDs.erase(friendLoginID))
	{
		DynamicMessageHelper message;
		message << mNOnce;
		message << UserServerPrivate::kClientDenyFriendRequest;
		message << friendLoginID;

		PackageAndSendData(mTransport,message);

		return true;
	}
	return false;
}

bool UserClient::RemoveFriend(const int friendLoginID)
{
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport || (friendLoginID == mMyLoginID))
	{
		return false;
	}

	UserInfo user;
	if (!GetUserInfo(friendLoginID,&user))
	{
		return false;
	}

	if (!(user.mState & UserInfo::kState_Friend))
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientRemoveFriend;
	message << friendLoginID;

	PackageAndSendData(mTransport,message);

	return true;
}

void UserClient::InitInternalState(void)
{
	// Must not ever disconnect or delete mTransport or reset mNonce inside this function
	Backend::SetLoginID();	// Set it so that nobody is logged in
	mMyLoginID = UserInfo::kAnyLoginID;
	mMyLoginName = "";
	mLoginTried = false;
	mMessagePending = false;
	mGameInvitePending = false;
	mPreviousState = 0;
	mCurrentState = 0;
	mInCurrentRoom = -1;
	mRoomMode = false;
	mIsRoomAdmin = false;
	mIsGlobalAdmin = false;
	mLastPlayingAGame = false;
	mLastOnlineTime = "";
	mLastPlayingAGameURL = "";
	mPendingGetVariables = 0;

	THREADSAFELOCKCLASS(mInternalLists);
	mPendingFriendIDs.clear();
	mUsers.clear();
}

int UserClient::GetState(void)
{
	return mCurrentState;
}

void UserClient::AnswerMessage(const int fromLoginID)
{
	mMessagePending = false;
}

void UserClient::DoStateChangeCalc(void)
{
	int state = 0;

	if (mMyLoginID != UserInfo::kAnyLoginID)
	{
		state |= kState_Online;
	}
	// Stack context for the lock
	{
		THREADSAFELOCKCLASS(mInternalLists);

		if (!mPendingFriendIDs.empty())
		{
			state |= kState_FriendRequest;
		}
	}

	if (mMessagePending)
	{
		state |= kState_Message;
	}

	// MPi: TODO: Should this really enumerate the friends and display this icon if at least one has this flag set instead of relying on a flag?
	if (mGameInvitePending)
	{
		state |= kState_GameInvite;
	}

	if (mCurrentState != state)
	{
		mPreviousState = mCurrentState;
		mCurrentState = state;
		CallbackStateChange(mPreviousState,mCurrentState);
	}
}

bool UserClient::SendGameInvite(const int friendLoginID,const char *invite)
{
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport || !invite || (friendLoginID == mMyLoginID))
	{
		return false;
	}

	UserInfo user;
	if (!GetUserInfo(friendLoginID,&user))
	{
		return false;
	}
	if (!(user.mState & UserInfo::kState_Friend))
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientSendGameInvite;
	message << friendLoginID;
	message << invite;

	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::CancelGameInvite(const int friendLoginID)
{
	return SendGameInvite(friendLoginID,0);
}

bool UserClient::AnswerGameInvite(const int friendLoginID)
{
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport || (friendLoginID == mMyLoginID))
	{
		return false;
	}

	if (friendLoginID != UserInfo::kAnyLoginID)
	{
		UserInfo user;
		if (!GetUserInfo(friendLoginID,&user))
		{
			return false;
		}
		if (!(user.mState & UserInfo::kState_Friend) || !(user.mState & UserInfo::kState_GameInvite))
		{
			return false;
		}
	}

	mGameInvitePending = false;

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientAnswerGameInvite;
	message << friendLoginID;

	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::SetVariable(const int section,const char *name,const char *value,const VariableAccess access)
{
	assert(name);
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport || !name || !UserServerPrivate::VariableAccessAllowed(mMyLoginID,mMyLoginID,access,true))
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;

	if (value)
	{
		if ( ( strlen( name ) > (size_t)StatServerPrivate::kMaximumPairValueSize ) || ( strlen( value ) > (size_t)StatServerPrivate::kMaximumPairValueSize ) )
		{
			return false;
		}

		message << UserServerPrivate::kClientSetVariable;
		message << Backend::GetTitleID();
		message << section;
		message << name;
		message << value;
		message << access;
	}
	else
	{
		if ( strlen( name ) > (size_t)StatServerPrivate::kMaximumPairValueSize )
		{
			return false;
		}

		message << UserServerPrivate::kClientDeleteVariable;
		message << Backend::GetTitleID();
		message << section;
		message << name;
		message << access;
	}

	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::GetVariable(const int section,const char *name,const VariableAccess access)
{
	return GetVariable(mMyLoginID,section,name,access);
}

bool UserClient::GetVariable(const int loginID,const int section,const char *name,const VariableAccess access)
{
	assert(name);
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport || !name || !UserServerPrivate::VariableAccessAllowed(loginID,mMyLoginID,access,false))
	{
		return false;
	}

	if ( strlen( name ) > (size_t)StatServerPrivate::kMaximumPairValueSize )
	{
		return false;
	}

	mPendingGetVariables++;

	DynamicMessageHelper message;
	message << mNOnce;

	message << UserServerPrivate::kClientGetVariable;
	message << loginID;
	message << Backend::GetTitleID();
	message << section;
	message << name;
	message << access;

	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::AddUserInfo(const int loginID,const bool useCache,const bool trackChanges)
{
	// MPi: TODO: Implement useCache and trackChanges
	// Hunt through known friends to see if the request can be satisfied from this information first.
	if (useCache)
	{
	}


	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport || (loginID == mMyLoginID))
	{
		return false;
	}

	UserInfo user;
	if (GetUserInfo(loginID,&user))
	{
		if (user.mState & UserInfo::kState_Friend)
		{
			return false;
		}
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientAddUser;
	message << loginID;
	message << trackChanges;

	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::RemoveUserInfo(const int loginID)
{
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport || (loginID == mMyLoginID))
	{
		return false;
	}

	UserInfo user;
	if (!GetUserInfo(loginID,&user))
	{
		return false;
	}

	if (user.mState & UserInfo::kState_Friend)
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientRemoveUser;
	message << loginID;

	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::GetUserInfo(const int loginID,UserInfo *result)
{
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport)
	{
		return false;
	}
	if (loginID == mMyLoginID)
	{
		if (result)
		{
			result->mName = mMyLoginName;
			result->mLoginID = loginID;
			result->mID = UserInfo::kAnyLoginID;
			result->mGameInvite = "";
			result->mState = UserInfo::kState_Online;
		}
		return true;
	}

	std::map<int,UserInfo>::iterator found = mUsers.find(loginID);
	if (found == mUsers.end())
	{
		return false;
	}
	UserInfo &user = (*found).second;

	if (result)
	{
		*result = user;
	}
	return true;
}


bool UserClient::CreateChatRoom(const char *password)
{
	// password can be null or empty

	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport)
	{
		return false;
	}

	// If we are in a chat room we make sure we have left it first. The server double checks this
	// as well.
	LeaveChatRoom();

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientCreateChatRoom;
	message << ObfuscatePassword(0,password);

	PackageAndSendData(mTransport,message);
	mRoomMode = true;
	mInCurrentRoom = -1;
	mIsRoomAdmin = false;

	return true;
}

bool UserClient::LeaveChatRoom(void)
{
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport || !mRoomMode)
	{
		return false;
	}

	mRoomMode = false;
	mInCurrentRoom = -1;
	mIsRoomAdmin = false;

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientLeaveChatRoom;

	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::EnterChatRoom(const int chatRoomID,const char *password)
{
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport)
	{
		return false;
	}


	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientEnterChatRoom;
	message << chatRoomID;
	message << ObfuscatePassword(0,password);

	PackageAndSendData(mTransport,message);
	mRoomMode = true;
	mInCurrentRoom = -1;
	mIsRoomAdmin = false;

	return true;
}

int UserClient::GetCurrentRoom(void)
{
	return mInCurrentRoom;
}

bool UserClient::ChatRoomSay(const char *text,const unsigned int flags)
{
	assert(text);

	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport || !mRoomMode || !text)
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientChatRoomSayEx;
	message << text;
	message << flags;

	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::ChatRoomAdminMessage(const char *text,const unsigned int flags)
{
	assert(text);

	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport || !mRoomMode || !text || !(mIsRoomAdmin || mIsGlobalAdmin))
	{
		return false;
	}

	if ( strlen( text ) > (size_t)UserServerPrivate::kMaximumMessageSize )
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientChatRoomAdminMessageEx;
	message << text;
	message << flags;

	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::ChatRoomWhisper(const int loginID,const char *text,const unsigned int flags)
{
	assert(text);

	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport || !mRoomMode || !text || (loginID == UserInfo::kAnyLoginID))
	{
		return false;
	}

	if ( strlen( text ) > (size_t)UserServerPrivate::kMaximumMessageSize )
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientChatRoomWhisperEx;
	message << loginID;
	message << text;
	message << flags;

	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::ChatRoomKickUser(const int loginID,const bool ban,const char *reason)
{
	assert(reason);

	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport || !mRoomMode || !reason || !(mIsRoomAdmin || mIsGlobalAdmin))
	{
		return false;
	}

	if ( strlen( reason ) > (size_t)UserServerPrivate::kMaximumMessageSize )
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientChatRoomKick;
	message << loginID;
	message << ban;
	message << reason;

	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::GlobalKickUser(const int loginID,const bool ban,const char *reason)
{
	assert(reason);

	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport || !reason || !mIsGlobalAdmin)
	{
		return false;
	}

	if ( strlen( reason ) > (size_t)UserServerPrivate::kMaximumMessageSize )
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientGlobalKick;
	message << loginID;
	message << ban;
	message << reason;

	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::GlobalRestoreUser(const int loginID)
{
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport || !mIsGlobalAdmin)
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientGlobalRestore;
	message << loginID;

	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::IsRoomAdmin(void)
{
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport)
	{
		return false;
	}

	return (mIsGlobalAdmin || mIsRoomAdmin);
}

bool UserClient::IsSuperAdmin(void)
{
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport)
	{
		return false;
	}

	return mIsGlobalAdmin;
}

bool UserClient::PlayingAGame(const bool playing,const char *url)
{
	assert(url);

	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport || !url)
	{
		return false;
	}

	if ( strlen( url ) > (size_t)UserServerPrivate::kMaximumMessageSize )
	{
		return false;
	}

	// Don't bother updating if the inputs don't change
	if (!playing)
	{
		if (mLastPlayingAGame == playing)
		{
			return true;
		}
	}
	else
	{
		if ((mLastPlayingAGame == playing) && (mLastPlayingAGameURL == url))
		{
			return true;
		}
	}

	mLastPlayingAGame = playing;
	if (playing)
	{
		mLastPlayingAGameURL = url;
	}
	else
	{
		mLastPlayingAGameURL = "";
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientPlayingAGame;
	message << mLastPlayingAGame;
	if(mLastPlayingAGame)
	{
		message << url;
	}

	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::GetPlayingAGame(void)
{
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport)
	{
		return false;
	}
	return mLastPlayingAGame;
}

std::string UserClient::GetPlayingAGameURL(void)
{
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport)
	{
		return "";
	}
	return mLastPlayingAGameURL;
}

std::string UserClient::GetLastOnlineTime(void)
{
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport)
	{
		return "";
	}
	return mLastOnlineTime;
}

bool UserClient::RequestUserNonce(const int seconds)
{
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport)
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientRequestUserNonce;
	message << seconds;

	PackageAndSendData(mTransport,message);

	return true;
}

bool UserClient::RequestNamesLike(const char *match,const bool banned)
{
	THREADSAFELOCK();
	if ((mMyLoginID == UserInfo::kAnyLoginID) || !mLoginTried || !mTransport)
	{
		return false;
	}

	if (banned && !mIsGlobalAdmin)
	{
		return false;
	}

	DynamicMessageHelper message;
	message << mNOnce;
	message << UserServerPrivate::kClientRequestNamesLike;
	message << ValidateUsername( match );
	message << banned;

	PackageAndSendData(mTransport,message);

	return true;
}

int UserClient::GetPendingGetVariableRequests(void)
{
	THREADSAFELOCK();
	return mPendingGetVariables;
}
//From: RNSimpleScript/SimpleScript.cpp
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "RNSimpleScript/Inc/SimpleScript.h"

SimpleScript::SimpleScript()
{
	mCallBack = 0;
	mMemory = 0;
	mThreads = 0;
	mThreadArraySize = 0;
	mThreadID = 0;
	mThreadsToTidy = 0;
	mThreadArraySizeToTidy = 0;
	mTotalCycles = 0;
}

// TODO: dtor
SimpleScript::~SimpleScript()
{
	std::set<SimpleScriptThread *>::iterator st = mAllocatedThreads.begin();
	while (st != mAllocatedThreads.end())
	{
		SimpleScriptThread *thread = *st++;
		delete thread;

	}
	free(mThreads);
	free(mThreadsToTidy);
}

SimpleScriptMemory *SimpleScript::LoadProgram(const char *filename)
{
	SimpleScriptMemory *memory;
	memory = new SimpleScriptMemory;
	if (!memory)
	{
		return 0;
	}
	if (!memory->LoadBinary(filename))
	{
		delete memory;
		return 0;
	}
	return memory;
}

SimpleScriptThread *SimpleScript::AllocateThread(SimpleScriptMemory *const memory)
{
	SimpleScriptThread *thread;

	thread = new SimpleScriptThread;
	if (!thread)
	{
		return 0;
	}
	thread->SetSimpleScript(this);
	thread->SetMemory(memory);
	thread->SetCallBack(mCallBack);
	return thread;
}

void SimpleScript::AddThread(SimpleScriptThread *const thread)
{
	if (!mThreads)
	{
		mThreadArraySize = 8;
		mThreads = (SimpleScriptThread **) calloc(mThreadArraySize,sizeof(SimpleScriptThread *));
	}

	int slotFound = -1;
	int i;
	for(i=0;i<mThreadArraySize;i++)
	{
		if (!mThreads[i])
		{
			slotFound = i;
			break;
		}
	}
	if (slotFound == -1)
	{
		slotFound = mThreadArraySize;
		mThreadArraySize += 16;
		SimpleScriptThread **newBlock = (SimpleScriptThread **) calloc(mThreadArraySize,sizeof(SimpleScriptThread *));
		assert(newBlock);
		memcpy(newBlock,mThreads,slotFound * sizeof(SimpleScriptThread *));
		free(mThreads);
		mThreads = newBlock;
	}

	mThreads[slotFound] = thread;
	thread->SetThreadID(mThreadID++);
	if (mThreadID == -1)
	{
		mThreadID = 0;
	}
}

int SimpleScript::RunThreads(int forCycles)
{
	int totalRunning = 0;
	int i;
	for(i=0;i<mThreadArraySize;i++)
	{
		if (mThreads[i])
		{
			// This will try to run up to forCycles for the current thread. If the thread starts to wait or yields then any next thread will execute.
			mTotalCycles += mThreads[i]->RunCycles(forCycles);

			if(mThreads[i]->GetIsActive())
			{
				totalRunning++;
			}

			if (!mThreads[i]->GetIsActive() && mThreads[i]->GetRemoveOnExit())
			{
				if (mThreads[i]->GetDeleteOnRemove())
				{
					RemoveAndDeleteThread(mThreads[i]->GetThreadID());
				}
				else
				{
					RemoveThread(mThreads[i]->GetThreadID());
				}
				i--;
			}
		}
	}

	if (mThreadArraySizeToTidy > 0)
	{
		assert(mThreadsToTidy);
		for (i=0;i<mThreadArraySizeToTidy;i++)
		{
			if (mThreadsToTidy[i])
			{
				delete mThreadsToTidy[i];
				mThreadsToTidy[i] = 0;
			}
		}
		free(mThreadsToTidy);
		mThreadArraySizeToTidy = 0;
		mThreadsToTidy = 0;
	}
	return totalRunning;
}

SimpleScriptThread *SimpleScript::GetThreadFromID(const int threadID) const
{
	if (!mThreads)
	{
		return 0;
	}

	int i;
	for (i=0;i<mThreadArraySize;i++)
	{
		if (mThreads[i])
		{
			if (mThreads[i]->GetThreadID() == threadID)
			{
				return mThreads[i];
			}
		}
	}

	return 0;
}

void SimpleScript::RemoveThread(const int threadID)
{
	if (!mThreads)
	{
		return;
	}

	int i;
	for (i=0;i<mThreadArraySize;i++)
	{
		if (mThreads[i])
		{
			if (mThreads[i]->GetThreadID() == threadID)
			{
				mRemoved.insert(mThreads[i]);
				mThreads[i] = 0;
				return;
			}
		}
	}
}


// TODO : This has to free the thread from a queue if the thread is the one currently running...
void SimpleScript::RemoveAndDeleteThread(const int threadID)
{
	if (!mThreads)
	{
		return;
	}

	int i;
	for (i=0;i<mThreadArraySize;i++)
	{
		if (mThreads[i])
		{
			if (mThreads[i]->GetThreadID() == threadID)
			{
//				delete mThreads[i];
				AddThreadToTidy(mThreads[i]);
				mThreads[i] = 0;
				return;
			}
		}
	}
}

void SimpleScript::ClearSignalForThreads(const unsigned int signal)
{
	if (!mThreads)
	{
		return;
	}

	int i;
	for (i=0;i<mThreadArraySize;i++)
	{
		if (mThreads[i])
		{
			mThreads[i]->SetSignal(mThreads[i]->GetSignal() & ~signal);
		}
	}
}

void SimpleScript::SetSignalForThreads(const unsigned int signal)
{
	if (!mThreads)
	{
		return;
	}

	int i;
	for (i=0;i<mThreadArraySize;i++)
	{
		if (mThreads[i])
		{
			mThreads[i]->SetSignal(mThreads[i]->GetSignal() | signal);
		}
	}
}

int SimpleScript::GetKnownThreadIDs(int *const array,const int maxEntries)
{
	int total = 0;

	int i;
	for (i=0;i<mThreadArraySize;i++)
	{
		if (mThreads[i])
		{
			if (array)
			{
				if (total < maxEntries)
				{
					array[total] = mThreads[i]->GetThreadID();
					total++;
				}
			}
			else
			{
				total++;
			}
		}
	}

	return total;
}


void SimpleScript::AddThreadToTidy(SimpleScriptThread *const thread)
{
	if (!mThreadsToTidy)
	{
		mThreadArraySizeToTidy = 8;
		mThreadsToTidy = (SimpleScriptThread **) calloc(mThreadArraySizeToTidy,sizeof(SimpleScriptThread *));
	}

	int slotFound = -1;
	int i;
	for(i=0;i<mThreadArraySizeToTidy;i++)
	{
		if (!mThreadsToTidy[i])
		{
			slotFound = i;
			break;
		}
	}
	if (slotFound == -1)
	{
		slotFound = mThreadArraySizeToTidy;
		mThreadArraySizeToTidy += 16;
		SimpleScriptThread **newBlock = (SimpleScriptThread **) calloc(mThreadArraySizeToTidy,sizeof(SimpleScriptThread *));
		assert(newBlock);
		memcpy(newBlock,mThreadsToTidy,slotFound * sizeof(SimpleScriptThread *));
		free(mThreads);
		mThreadsToTidy = newBlock;
	}

	mThreadsToTidy[slotFound] = thread;
}

void SimpleScript::SetCallBack(SimpleScriptCallBack *const callBack)
{
	mCallBack = callBack;
}
SimpleScriptCallBack *SimpleScript::GetCallBack(void) const
{
	return mCallBack;
}

void SimpleScript::SetMemory(SimpleScriptMemory *const memory)
{
	mMemory = memory;
}

SimpleScriptMemory *SimpleScript::GetMemory(void) const
{
	return mMemory;
}
//From: RNSimpleScript/SimpleScriptMemory.cpp
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "RNSimpleScript/Inc/SimpleScriptMemory.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"

SimpleScriptMemory::SimpleScriptMemory()
{
	mMemory = 0;
	mSize = 0;

	mException = 0;
	mExceptionAddress = 0;
}

SimpleScriptMemory::~SimpleScriptMemory()
{
	free(mMemory);
}

bool SimpleScriptMemory::LoadBinary(const char *filename)
{
	FILE *fp;

	fp = fopen(filename,"rb");
	if (!fp)
	{
		return false;
	}

	fseek(fp,0,SEEK_END);
	mSize = ftell(fp);
	fseek(fp,0,SEEK_SET);

	mMemory = malloc(mSize);

	size_t freadRet = fread(mMemory,1,mSize,fp);

	fclose(fp);

	return true;
}

unsigned char SimpleScriptMemory::GetU8(const int address)
{
	if (address < 0 || address >= mSize)
	{
		mException = 1;
		mExceptionAddress = address;
		return 0;
	}

	return ((unsigned char*)mMemory)[address];
}

bool SimpleScriptMemory::SetU8(const int address,const unsigned char value)
{
	if (address < 0 || address >= mSize)
	{
		mException = 2;
		mExceptionAddress = address;
		return false;
	}

	((unsigned char*)mMemory)[address] = value;

	return true;
}

signed char SimpleScriptMemory::GetS8(const int address)
{
	if (address < 0 || address >= mSize)
	{
		mException = 1;
		mExceptionAddress = address;
		return 0;
	}

	return ((signed char*)mMemory)[address];
}

bool SimpleScriptMemory::SetS8(const int address,const signed char value)
{
	if (address < 0 || address >= mSize)
	{
		mException = 2;
		mExceptionAddress = address;
		return false;
	}

	((signed char*)mMemory)[address] = value;

	return true;
}

unsigned short SimpleScriptMemory::GetU16(const int address)
{
	if (address < 0 || address >= mSize-1)
	{
		mException = 1;
		mExceptionAddress = address;
		return 0;
	}

	unsigned short value;
	assert(sizeof(value) == 2);
	RNReplicaNet::MessageHelper::GetVariable(((unsigned char*)mMemory)+address,&value,sizeof(value));

	return value;
}

bool SimpleScriptMemory::SetU16(const int address,const unsigned short value)
{
	if (address < 0 || address >= mSize-1)
	{
		mException = 2;
		mExceptionAddress = address;
		return false;
	}


	assert(sizeof(value) == 2);
	RNReplicaNet::MessageHelper::AddVariable(((unsigned char*)mMemory)+address,&value,sizeof(value));

	return true;
}

signed short SimpleScriptMemory::GetS16(const int address)
{
	if (address < 0 || address >= mSize-1)
	{
		mException = 1;
		mExceptionAddress = address;
		return 0;
	}

	signed short value;
	assert(sizeof(value) == 2);
	RNReplicaNet::MessageHelper::GetVariable(((unsigned char*)mMemory)+address,&value,sizeof(value));

	return value;
}

bool SimpleScriptMemory::SetS16(const int address,const signed short value)
{
	if (address < 0 || address >= mSize-1)
	{
		mException = 2;
		mExceptionAddress = address;
		return false;
	}

	assert(sizeof(value) == 2);
	RNReplicaNet::MessageHelper::AddVariable(((unsigned char*)mMemory)+address,&value,sizeof(value));

	return true;
}

unsigned int SimpleScriptMemory::GetU32(const int address)
{
	if (address < 0 || address >= mSize-3)
	{
		mException = 1;
		mExceptionAddress = address;
		return 0;
	}

	unsigned int value;
	assert(sizeof(value) == 4);
	RNReplicaNet::MessageHelper::GetVariable(((unsigned char*)mMemory)+address,&value,sizeof(value));

	return value;
}

bool SimpleScriptMemory::SetU32(const int address,const unsigned int value)
{
	if (address < 0 || address >= mSize-3)
	{
		mException = 2;
		mExceptionAddress = address;
		return false;
	}

	assert(sizeof(value) == 4);
	RNReplicaNet::MessageHelper::AddVariable(((unsigned char*)mMemory)+address,&value,sizeof(value));

	return true;
}

signed int SimpleScriptMemory::GetS32(const int address)
{
	if (address < 0 || address >= mSize-3)
	{
		mException = 1;
		mExceptionAddress = address;
		return 0;
	}

	signed int value;
	assert(sizeof(value) == 4);
	RNReplicaNet::MessageHelper::GetVariable(((unsigned char*)mMemory)+address,&value,sizeof(value));

	return value;
}

bool SimpleScriptMemory::SetS32(const int address,const signed int value)
{
	if (address < 0 || address >= mSize-3)
	{
		mException = 2;
		mExceptionAddress = address;
		return false;
	}

	assert(sizeof(value) == 4);
	RNReplicaNet::MessageHelper::AddVariable(((unsigned char*)mMemory)+address,&value,sizeof(value));

	return true;
}

int SimpleScriptMemory::GetException(void) const
{
	return mException;
}

int SimpleScriptMemory::GetExceptionAddress(void) const
{
	return mExceptionAddress;
}

void *SimpleScriptMemory::GetPointer(const int address)
{
	if ( address < 0 )
	{
		mException = 3;
		mExceptionAddress = address;
		return 0;
	}
	if ( address >= mSize )
	{
		mException = 3;
		mExceptionAddress = address;
		return 0;
	}
	return (void *)(((char *)mMemory) + address);
}
//From: RNSimpleScript/SimpleScriptRegister.cpp
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include "RNSimpleScript/Inc/SimpleScriptRegister.h"

SimpleScriptRegister::SimpleScriptRegister()
{
	mIsConstant = false;
	mLastTypeWritten = kUndefined;
	mValue.mIntValue = 0;
	mLastComparisonResult = 0;
	mRegisterIndex = -1;
}

SimpleScriptRegister::~SimpleScriptRegister()
{
}

void SimpleScriptRegister::SetProgramCounter(const unsigned int address)
{
	if (mIsConstant)
	{
		return;
	}

	mLastTypeWritten = kProgramCounter;
	mValue.mProgramCounter = address;
}

unsigned int SimpleScriptRegister::GetProgramCounter(void) const
{
	assert(mLastTypeWritten == kProgramCounter);

	return mValue.mProgramCounter;
}

void SimpleScriptRegister::SetInteger(const int value)
{
	if (mIsConstant)
	{
		return;
	}

	mLastTypeWritten = kInt;
	mValue.mIntValue = value;
}

int SimpleScriptRegister::GetInteger(void) const
{
//	assert(!(mLastTypeWritten == kUndefined || mLastTypeWritten == kProgramCounter));

	switch(mLastTypeWritten)
	{
		default:
			return 0;
			break;
		case kInt:
			return (int) mValue.mIntValue;
			break;

		case kProgramCounter:
			return (unsigned int) mValue.mProgramCounter;
			break;

		case kFloat:
			return (int) mValue.mFloatValue;
			break;
	}
}

void SimpleScriptRegister::SetRaw32(const int value)
{
	if (mIsConstant)
	{
		return;
	}

	mValue.mIntValue = value;
}

void SimpleScriptRegister::SetRaw32Float(const float value)
{
	if (mIsConstant)
	{
		return;
	}

	mValue.mFloatValue = value;
}

int SimpleScriptRegister::GetRaw32(void) const
{
	return mValue.mIntValue;
}

float SimpleScriptRegister::GetRaw32Float(void) const
{
	return mValue.mFloatValue;
}

void SimpleScriptRegister::SetFloat(const float value)
{
	if (mIsConstant)
	{
		return;
	}

	mLastTypeWritten = kFloat;
	mValue.mFloatValue = value;
}

float SimpleScriptRegister::GetFloat(void) const
{
	switch(mLastTypeWritten)
	{
		default:
			break;
		case kInt:
			return (float) mValue.mIntValue;
			break;

		case kFloat:
			return (float) mValue.mFloatValue;
			break;
	}

	return 0;
}


SimpleScriptRegister::LastType SimpleScriptRegister::GetRegisterType(void) const
{
	return mLastTypeWritten;
}

void SimpleScriptRegister::SetIsConstant(const bool isConstant)
{
	mIsConstant = isConstant;
}

void SimpleScriptRegister::SetLastComparisonResult(const int lastComparisonResult)
{
	mLastComparisonResult = lastComparisonResult;
}

int SimpleScriptRegister::GetLastComparisonResult(void) const
{
	return mLastComparisonResult;
}

void SimpleScriptRegister::WriteTo64Bits(void *const memory)
{
	// MPi: TODO: This needs expanding to read other register types not just kInt
	((int *)memory)[0] = (int) mLastTypeWritten;
	((int *)memory)[1] = mValue.mIntValue;
}

void SimpleScriptRegister::LoadFrom64Bits(void *const memory)
{
	// MPi: TODO: This needs expanding to read other register types not just kInt
	mLastTypeWritten = (LastType) ((int *)memory)[0];
	mValue.mIntValue = ((int *)memory)[1];
}

void SimpleScriptRegister::WriteTo32Bits(void *const memory)
{
	((int *)memory)[0] = mValue.mIntValue;
}

void SimpleScriptRegister::LoadFrom32Bits(void *const memory , LastType type)
{
	mLastTypeWritten = type;
	mValue.mIntValue = ((int *)memory)[0];
}


void SimpleScriptRegister::SetNumberFromString(const char *value)
{
	if ( !value )
	{
		SetInteger( 0 );
		return;
	}
	float theFloat = (float) atof(value);
	int theInt = atoi(value);
	// See which type we can use best for the return value
	if ( (theFloat == (float)theInt) || !strchr( value , '.') )
	{
		SetInteger(theInt);
	}
	else
	{
		SetFloat(theFloat);
	}
}

void SimpleScriptRegister::SetFloatNumberFromString(const char *value)
{
	if ( !value )
	{
		SetFloat( 0 );
		return;
	}
	float theFloat = (float) atof(value);
	SetFloat(theFloat);
}

void SimpleScriptRegister::SetFloatingPointType(void)
{
	if (mIsConstant)
	{
		return;
	}

	mLastTypeWritten = kFloat;
}
//From: RNSimpleScript/SimpleScriptThread.cpp
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <stdio.h>
#include <assert.h>
//Skipping: #include "RNSimpleScript/Inc/SimpleScript.h"
#include "RNSimpleScript/Inc/OpCodeEnums.h"
//Include inline: #include "RNSimpleScriptCompiler/ProgramState.h"
//From: RNSimpleScriptCompiler/ProgramState.h
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#ifndef __PROGRAMSTATE_H__
#define __PROGRAMSTATE_H__


#include <list>
#include <set>
#include <string>

//Skipping: #include "RNSimpleScript/Inc/OpCodeEnums.h"

class Variable;
class CommandBase;
class TextFileReader;

// All these are inclusive
const int kRegisterLowerReserveLimit = 0;
const int kRegisterFunctionReturnReserve = 1;
const int kRegisterFunctionParseReserveLower = 1;
const int kRegisterFunctionParseReserveHigher = 8;
const int kRegisterScratchReserveLower = 9;
const int kRegisterScratchReserveHigher = kSimpleScriptThreadRegisters-2;
const int kRegisterStackContextCount = kSimpleScriptThreadRegisters-1;

class ProgramState
{
public:
	ProgramState();
	virtual ~ProgramState();

	void PushBackCommand(CommandBase *command)
	{
		mProgram.push_back(command);
	}

	void PushLevel(const std::string level);
	void PopLevel(void);
	std::string GetCurrentLevel(void);
	int GetLevelDepth(void);

	void AddVariable(Variable *variable)
	{
		mVariables.push_back(variable);
	}

	Variable *GetLastAdded(const int greaterThanDepth = -1);

	void VariableBeginIterate(void);
	Variable *VariableIterate(void);

	int VariableFindFreeRegister(const int startRange = kRegisterScratchReserveLower,const int endRange = kRegisterScratchReserveHigher);

	void DestackNestedForEndIf(TextFileReader &fileReader,CommandBase &command);

	Variable *VariableFind(const std::string name);

	void RemoveVariable(Variable *variable);

	int WriteProgramBinary(const std::string fileName);

	int WriteProgramASM(const std::string fileName);

	CommandBase *FindLabelCommand(std::string label,const size_t plusExtra = 0);

	void AddIfLevel(void)
	{
		mIfLevel++;
	}
	void PopIfLevel(void)
	{
		mIfLevel--;
	}
	int GetIfLevel(void)
	{
		return mIfLevel;
	}

	Variable *GetVariableForToken(const std::string token,TextFileReader &fileReader,bool destinationOnly = false);

	Variable *HandleFunction(TextFileReader &fileReader);


	void CheckForDeScopeVariable(TextFileReader &fileReader,Variable *const var);

	void IncrUnique(void)
	{
		mUnique++;
	}
	int GetUnique(void) const
	{
		return mUnique;
	}

	/// Optimises the program state.
	/// \return The number of passes used for optimisation.
	int Optimise(void);

	std::list<int> mIfID;

	bool mInProc;
	std::string mInProcName;
	bool mProcStackBreakEncountered;

	std::set<std::string> mLabelsFound;

	bool mNeedFunctionEpilogue;
	bool mIncludedFunctionEpilogue;

	void SetVerboseOptimisations( const bool enable = false )
	{
		mVerboseOptimisations = enable;
	}

private:
	std::list<CommandBase *> mProgram;
	std::list<Variable *> mVariables;

	std::list<std::string> mLevelList;

	int mIfLevel;

	int mUnique;

	bool mVerboseOptimisations;
};

#endif
//Include inline: #include "RNSimpleScriptCompiler/lang/SSE_Standard.lang"
//From: RNSimpleScriptCompiler/lang/SSE_Standard.lang
//Ignored: #pragma once
// Values used by SimpleScriptThread.cpp for AsmExternal calls
#define SSE_ThreadExit					0
#define SSE_DumpRegisters				1
#define SSE_ThreadYield					2
#define SSE_ThreadCreate				3
#define SSE_ThreadGetID					4
#define SSE_ThreadSignalIndexSet		5
#define SSE_ThreadSignalIndexClear		6
#define SSE_ThreadGetSignal				7
#define SSE_ThreadSetSignal				8
#define SSE_Print						9
//Skipping: #include "RNPlatform/Inc/StringUtils.h"
//Skipping: #include "RNPlatform/Inc/MinMax.h"

using namespace RNReplicaNet;

SimpleScriptThread::SimpleScriptThread()
{
	mControl = 0;

	mMemory = 0;
	int i;
	for (i=0;i<kSimpleScriptThreadRegisters;i++)
	{
		mRegisters[i].SetInteger(0);
		mRegisters[i].mRegisterIndex = i;
	}
	mRegisters[0].SetIsConstant(true);
	mProgramCounter.SetProgramCounter(0);

	mCallBack = 0;

	mExceptionNotFlag = true;

	mWaitForSignal = 0;

	mThreadID = -1;

	mRemoveOnExit = false;
	mDeleteOnRemove = false;

	mCycles = 0;
}

SimpleScriptThread::~SimpleScriptThread()
{
	if (mControl)
	{
		mControl->mRemoved.erase(this);
		mControl->mAllocatedThreads.erase(this);
	}
}

SimpleScript *SimpleScriptThread::GetSimpleScript(void) const
{
	return mControl;
}

SimpleScriptMemory *SimpleScriptThread::GetMemory(void) const
{
	return mMemory;
}

SimpleScriptRegister *SimpleScriptThread::GetRegister(const int reg)
{
	if (reg < 0 || reg >= kSimpleScriptThreadRegisters)
	{
		return 0;
	}
	return &mRegisters[reg];
}

SimpleScriptRegister *SimpleScriptThread::GetProgramCounter(void)
{
	return &mProgramCounter;
}

int SimpleScriptThread::GetNumberofRegisters(void) const
{
	return kSimpleScriptThreadRegisters;
}

void SimpleScriptThread::SetCallBack(SimpleScriptCallBack *const callBack)
{
	mCallBack = callBack;
}
SimpleScriptCallBack *SimpleScriptThread::GetCallBack(void) const
{
	return mCallBack;
}

/**
 * If there are any signal flags then the thread is paused until all flags are clear.
 */
void SimpleScriptThread::SetSignal(const unsigned int signal)
{
	mWaitForSignal = signal;
}

unsigned int SimpleScriptThread::GetSignal(void) const
{
	return mWaitForSignal;
}

void SimpleScriptThread::AddSignal(const unsigned int signal)
{
	mWaitForSignal |= signal;
}

unsigned int SimpleScriptThread::RemoveSignal(const unsigned int signal)
{
	mWaitForSignal &= ~signal;
	return mWaitForSignal;
}

void SimpleScriptThread::SignalIndexAdd(const unsigned int signalIndex)
{
	mWaitForSignal |= (1<<signalIndex);
}

void SimpleScriptThread::SignalIndexClear(const unsigned int signalIndex)
{
	mWaitForSignal &= ~(1<<signalIndex);
}

void SimpleScriptThread::SetThreadID(const int threadID)
{
	mThreadID = threadID;
}

int SimpleScriptThread::GetThreadID(void) const
{
	return mThreadID;
}

bool SimpleScriptThread::GetIsActive(void) const
{
	return mExceptionNotFlag;
}
void SimpleScriptThread::SetIsActive(const bool active)
{
	mExceptionNotFlag = active;
}

void SimpleScriptThread::RunFromPC(unsigned int address)
{
	mProgramCounter.SetProgramCounter(address);
	SetIsActive(true);
}

void SimpleScriptThread::SetRemoveOnExit(const bool remove)
{
	mRemoveOnExit = remove;
}

bool SimpleScriptThread::GetRemoveOnExit(void) const
{
	return mRemoveOnExit;
}

void SimpleScriptThread::SetDeleteOnRemove(const bool self)
{
	mDeleteOnRemove = self;
}

bool SimpleScriptThread::GetDeleteOnRemove(void) const
{
	return mDeleteOnRemove;
}

void SimpleScriptThread::SetSimpleScript(SimpleScript *const scriptControl)
{
	mControl = scriptControl;
	mControl->mAllocatedThreads.insert(this);
}

void SimpleScriptThread::SetMemory(SimpleScriptMemory *const memory)
{
	mMemory = memory;
}

int SimpleScriptThread::RunCycles(const int numberCycles)
{
	assert(mControl);
	assert(mMemory);

	if (mWaitForSignal)
	{
		return 0;
	}

	int toRun = numberCycles;

	while (toRun-- && mExceptionNotFlag)
	{
		// A cycle includes any waiting context switch, this stops a deadlocked bit of code from endlessly waiting.
		mCycles++;
		if (mWaitForSignal)
		{
			return (numberCycles - toRun);
		}

		int opCodeSize = sizeof(tSS_OpCode);
		bool handled = false;
		kOpCode opCode = (kOpCode) mMemory->GetU8(mProgramCounter.GetProgramCounter());

#ifdef WIN32
//		printf("Address %.8d	opcode %d\r",mProgramCounter.GetProgramCounter(),opCode);
#endif

		if (mMemory->GetException())
		{
			mExceptionNotFlag = false;
			if (mCallBack)
			{
				mCallBack->MemoryException(this);
			}

#ifdef WIN32
//			printf("\nMemory exception %d at %d\n",mMemory->GetException(),mMemory->GetExceptionAddress());
#endif
		}

		switch (opCode)
		{
			case kOpCodeNOP:
			{
				handled = true;
				break;
			}
			case kOpCodeAdd_DstSrc1Src2:
			{
				tSS_Register dst = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				tSS_Register src1 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				tSS_Register src2 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register)+sizeof(tSS_Register));

				if (mRegisters[src1].GetRegisterType() != SimpleScriptRegister::kFloat && mRegisters[src2].GetRegisterType() != SimpleScriptRegister::kFloat)
				{
					mRegisters[dst].SetInteger(mRegisters[src1].GetInteger() + mRegisters[src2].GetInteger());
				}
				else
				{
					mRegisters[dst].SetFloat(mRegisters[src1].GetFloat() + mRegisters[src2].GetFloat());
				}

				opCodeSize = sizeof(tSS_OpCode) + (3*sizeof(tSS_Register));
				handled = true;

				break;
			}
			case kOpCodeSub_DstSrc1Src2:
			{
				tSS_Register dst = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				tSS_Register src1 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				tSS_Register src2 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register)+sizeof(tSS_Register));

				if (mRegisters[src1].GetRegisterType() != SimpleScriptRegister::kFloat && mRegisters[src2].GetRegisterType() != SimpleScriptRegister::kFloat)
				{
					mRegisters[dst].SetInteger(mRegisters[src1].GetInteger() - mRegisters[src2].GetInteger());
				}
				else
				{
					mRegisters[dst].SetFloat(mRegisters[src1].GetFloat() - mRegisters[src2].GetFloat());
				}

				opCodeSize = sizeof(tSS_OpCode) + (3*sizeof(tSS_Register));
				handled = true;

				break;
			}
			case kOpCodeMul_DstSrc1Src2:
			{
				tSS_Register dst = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				tSS_Register src1 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				tSS_Register src2 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register)+sizeof(tSS_Register));

				if (mRegisters[src1].GetRegisterType() != SimpleScriptRegister::kFloat && mRegisters[src2].GetRegisterType() != SimpleScriptRegister::kFloat)
				{
					mRegisters[dst].SetInteger(mRegisters[src1].GetInteger() * mRegisters[src2].GetInteger());
				}
				else
				{
					mRegisters[dst].SetFloat(mRegisters[src1].GetFloat() * mRegisters[src2].GetFloat());
				}

				opCodeSize = sizeof(tSS_OpCode) + (3*sizeof(tSS_Register));
				handled = true;

				break;
			}
			case kOpCodeDiv_DstSrc1Src2:
			{
// Divide always promotes the result to a float value, be careful this is slow
				tSS_Register dst = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				tSS_Register src1 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				tSS_Register src2 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register)+sizeof(tSS_Register));

//				if (mRegisters[src1].GetRegisterType() != SimpleScriptRegister::kFloat && mRegisters[src2].GetRegisterType() != SimpleScriptRegister::kFloat)
//				{
//					mRegisters[dst].SetInteger(mRegisters[src1].GetInteger() / mRegisters[src2].GetInteger());
//				}
//				else
//				{
					mRegisters[dst].SetFloat(mRegisters[src1].GetFloat() / mRegisters[src2].GetFloat());
//				}

				opCodeSize = sizeof(tSS_OpCode) + (3*sizeof(tSS_Register));
				handled = true;

				break;
			}
			case kOpCodeIDiv_DstSrc1Src2:
			{
// Divide always promotes the result to a float value, be careful this is slow
				tSS_Register dst = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				tSS_Register src1 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				tSS_Register src2 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register)+sizeof(tSS_Register));

				mRegisters[dst].SetInteger(mRegisters[src1].GetInteger() / mRegisters[src2].GetInteger());

				opCodeSize = sizeof(tSS_OpCode) + (3*sizeof(tSS_Register));
				handled = true;

				break;
			}

			case kOpCodeGetInt_DstVal:
			{
				tSS_Register reg = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				int value = mMemory->GetS32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				handled = true;
				opCodeSize = sizeof(tSS_OpCode) + sizeof(tSS_Register) + sizeof(int);
				mRegisters[reg].SetInteger(value);
				break;
			}
			case kOpCodeGetFloat_DstVal:
			{
				tSS_Register reg = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				int value = mMemory->GetU32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				union bigVal
				{
					unsigned int i;
					float f;
				};
				bigVal bVal;
				bVal.i = value;

				handled = true;
				opCodeSize = sizeof(tSS_OpCode) + sizeof(tSS_Register) + sizeof(int);
				mRegisters[reg].SetFloat(bVal.f);
				break;
			}
			case kOpCodeGetNDataPointer_DstLenNData:
			{
				tSS_Register reg = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				int len = mMemory->GetU32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				handled = true;
				opCodeSize = sizeof(tSS_OpCode) + sizeof(tSS_Register) + sizeof(int) + len;
				mRegisters[reg].SetInteger(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register)+sizeof(int));
				break;
			}
			case kOpCodePush_Src:
			{
				handled = true;
				opCodeSize = sizeof(tSS_OpCode) + sizeof(tSS_Register);
				tSS_Register reg = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));

				if (!PushRegister(mRegisters[reg]))
				{
					if (mCallBack)
					{
						mCallBack->ThreadException(this);
					}
					mExceptionNotFlag = false;
				}
				break;
			}
			case kOpCodePop_Dst:
			{
				handled = true;
				opCodeSize = sizeof(tSS_OpCode) + sizeof(tSS_Register);
				tSS_Register reg = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				if (!PopRegister(mRegisters[reg]))
				{
					if (mCallBack)
					{
						mCallBack->ThreadException(this);
					}
					mExceptionNotFlag = false;
				}
				break;
			}
			case kOpCodeCmp_Src1Src2:
			{
				handled = true;
				opCodeSize = sizeof(tSS_OpCode) + (2*sizeof(tSS_Register));
				tSS_Register reg1 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				tSS_Register reg2 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));

				if ((mRegisters[reg1].GetRegisterType() != SimpleScriptRegister::kFloat) && (mRegisters[reg2].GetRegisterType() != SimpleScriptRegister::kFloat))
				{
					// cmp r1,#5
					// if r1 == 2 then blt will execute
					// but bgt will not
					// blt compares with mProgramCounter.GetLastComparisonResult() < 0
					mProgramCounter.SetLastComparisonResult(mRegisters[reg1].GetInteger() - mRegisters[reg2].GetInteger());
				}
				else
				{
					mProgramCounter.SetLastComparisonResult(0);
					if (mRegisters[reg1].GetFloat() > mRegisters[reg2].GetFloat())
					{
						mProgramCounter.SetLastComparisonResult(200);		// Trigger bgt
					}
					else if (mRegisters[reg1].GetFloat() < mRegisters[reg2].GetFloat())
					{
						mProgramCounter.SetLastComparisonResult(-200);		// Trigger blt
					}
				}
				break;
			}
			case kOpCodePushPCVal:
			{
				handled = true;
				opCodeSize = sizeof(tSS_OpCode) + sizeof(int);
				int offset = mMemory->GetS32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				SimpleScriptRegister tempReg = mProgramCounter;
				tempReg.SetProgramCounter(tempReg.GetProgramCounter()+offset);
				if (!PushRegister(tempReg))
				{
					if (mCallBack)
					{
						mCallBack->ThreadException(this);
					}
					mExceptionNotFlag = false;
				}

				break;
			}
			case kOpCodeRet:
			{
				handled = true;
				opCodeSize = 0;
				SimpleScriptRegister tempReg;
				tempReg.SetInteger(0);
				if (!PopRegister(tempReg))
				{
#ifdef WIN32
//					printf("Stop thread ID %d due to AsmRet popping the end of the stack\n",GetThreadID());
#endif
					// No exception needed in this case
					mExceptionNotFlag = false;
					if (mCallBack)
					{
						mCallBack->ThreadTerminated(this);
					}
				}
				mProgramCounter.SetProgramCounter(tempReg.GetInteger());
				break;
			}
			case kOpCodeBranch:
			{
				handled = true;
				opCodeSize = 0;
				int offset = mMemory->GetS32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				mProgramCounter.SetProgramCounter(mProgramCounter.GetProgramCounter()+offset);
				break;
			}
			case kOpCodeBranch_EQ:
			{
				handled = true;
				if (mProgramCounter.GetLastComparisonResult() == 0)
				{
					opCodeSize = 0;
					int offset = mMemory->GetS32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
					mProgramCounter.SetProgramCounter(mProgramCounter.GetProgramCounter()+offset);
				}
				else
				{
					opCodeSize = sizeof(tSS_OpCode) + sizeof(int);
				}
				break;
			}
			case kOpCodeBranch_NE:
			{
				handled = true;
				if (mProgramCounter.GetLastComparisonResult() != 0)
				{
					opCodeSize = 0;
					int offset = mMemory->GetS32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
					mProgramCounter.SetProgramCounter(mProgramCounter.GetProgramCounter()+offset);
				}
				else
				{
					opCodeSize = sizeof(tSS_OpCode) + sizeof(int);
				}
				break;
			}
			case kOpCodeBranch_GT:
			{
				handled = true;
				if (mProgramCounter.GetLastComparisonResult() > 0)
				{
					opCodeSize = 0;
					int offset = mMemory->GetS32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
					mProgramCounter.SetProgramCounter(mProgramCounter.GetProgramCounter()+offset);
				}
				else
				{
					opCodeSize = sizeof(tSS_OpCode) + sizeof(int);
				}
				break;
			}
			case kOpCodeBranch_LT:
			{
				handled = true;
				if (mProgramCounter.GetLastComparisonResult() < 0)
				{
					opCodeSize = 0;
					int offset = mMemory->GetS32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
					mProgramCounter.SetProgramCounter(mProgramCounter.GetProgramCounter()+offset);
				}
				else
				{
					opCodeSize = sizeof(tSS_OpCode) + sizeof(int);
				}
				break;
			}
			case kOpCodeBranch_GE:
			{
				handled = true;
				if (mProgramCounter.GetLastComparisonResult() >= 0)
				{
					opCodeSize = 0;
					int offset = mMemory->GetS32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
					mProgramCounter.SetProgramCounter(mProgramCounter.GetProgramCounter()+offset);
				}
				else
				{
					opCodeSize = sizeof(tSS_OpCode) + sizeof(int);
				}
				break;
			}
			case kOpCodeBranch_LE:
			{
				handled = true;
				if (mProgramCounter.GetLastComparisonResult() <= 0)
				{
					opCodeSize = 0;
					int offset = mMemory->GetS32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
					mProgramCounter.SetProgramCounter(mProgramCounter.GetProgramCounter()+offset);
				}
				else
				{
					opCodeSize = sizeof(tSS_OpCode) + sizeof(int);
				}
				break;
			}

			case kOpCodeBranchPP:
			{
				handled = true;
				opCodeSize = 0;
				int offset = mMemory->GetS32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));

				SimpleScriptRegister tempReg = mProgramCounter;
				tempReg.SetProgramCounter(tempReg.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(int));
				if (!PushRegister(tempReg))
				{
					if (mCallBack)
					{
						mCallBack->ThreadException(this);
					}
					mExceptionNotFlag = false;
				}

				mProgramCounter.SetProgramCounter(mProgramCounter.GetProgramCounter()+offset);

				break;
			}
			case kOpCodeBranchPP_EQ:
			{
				handled = true;
				if (mProgramCounter.GetLastComparisonResult() == 0)
				{
					opCodeSize = 0;
					int offset = mMemory->GetS32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));

					SimpleScriptRegister tempReg = mProgramCounter;
					tempReg.SetProgramCounter(tempReg.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(int));
					if (!PushRegister(tempReg))
					{
						if (mCallBack)
						{
							mCallBack->ThreadException(this);
						}
						mExceptionNotFlag = false;
					}

					mProgramCounter.SetProgramCounter(mProgramCounter.GetProgramCounter()+offset);
				}
				else
				{
					opCodeSize = sizeof(tSS_OpCode) + sizeof(int);
				}
				break;
			}
			case kOpCodeBranchPP_NE:
			{
				handled = true;
				if (mProgramCounter.GetLastComparisonResult() != 0)
				{
					opCodeSize = 0;
					int offset = mMemory->GetS32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));

					SimpleScriptRegister tempReg = mProgramCounter;
					tempReg.SetProgramCounter(tempReg.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(int));
					if (!PushRegister(tempReg))
					{
						if (mCallBack)
						{
							mCallBack->ThreadException(this);
						}
						mExceptionNotFlag = false;
					}

					mProgramCounter.SetProgramCounter(mProgramCounter.GetProgramCounter()+offset);
				}
				else
				{
					opCodeSize = sizeof(tSS_OpCode) + sizeof(int);
				}
				break;
			}
			case kOpCodeBranchPP_GT:
			{
				handled = true;
				if (mProgramCounter.GetLastComparisonResult() > 0)
				{
					opCodeSize = 0;
					int offset = mMemory->GetS32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));

					SimpleScriptRegister tempReg = mProgramCounter;
					tempReg.SetProgramCounter(tempReg.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(int));
					if (!PushRegister(tempReg))
					{
						if (mCallBack)
						{
							mCallBack->ThreadException(this);
						}
						mExceptionNotFlag = false;
					}

					mProgramCounter.SetProgramCounter(mProgramCounter.GetProgramCounter()+offset);
				}
				else
				{
					opCodeSize = sizeof(tSS_OpCode) + sizeof(int);
				}
				break;
			}
			case kOpCodeBranchPP_LT:
			{
				handled = true;
				if (mProgramCounter.GetLastComparisonResult() < 0)
				{
					opCodeSize = 0;
					int offset = mMemory->GetS32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));

					SimpleScriptRegister tempReg = mProgramCounter;
					tempReg.SetProgramCounter(tempReg.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(int));
					if (!PushRegister(tempReg))
					{
						if (mCallBack)
						{
							mCallBack->ThreadException(this);
						}
						mExceptionNotFlag = false;
					}

					mProgramCounter.SetProgramCounter(mProgramCounter.GetProgramCounter()+offset);
				}
				else
				{
					opCodeSize = sizeof(tSS_OpCode) + sizeof(int);
				}
				break;
			}
			case kOpCodeBranchPP_GE:
			{
				handled = true;
				if (mProgramCounter.GetLastComparisonResult() >= 0)
				{
					opCodeSize = 0;
					int offset = mMemory->GetS32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));

					SimpleScriptRegister tempReg = mProgramCounter;
					tempReg.SetProgramCounter(tempReg.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(int));
					if (!PushRegister(tempReg))
					{
						if (mCallBack)
						{
							mCallBack->ThreadException(this);
						}
						mExceptionNotFlag = false;
					}

					mProgramCounter.SetProgramCounter(mProgramCounter.GetProgramCounter()+offset);
				}
				else
				{
					opCodeSize = sizeof(tSS_OpCode) + sizeof(int);
				}
				break;
			}
			case kOpCodeBranchPP_LE:
			{
				handled = true;
				if (mProgramCounter.GetLastComparisonResult() <= 0)
				{
					opCodeSize = 0;
					int offset = mMemory->GetS32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));

					SimpleScriptRegister tempReg = mProgramCounter;
					tempReg.SetProgramCounter(tempReg.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(int));
					if (!PushRegister(tempReg))
					{
						if (mCallBack)
						{
							mCallBack->ThreadException(this);
						}
						mExceptionNotFlag = false;
					}

					mProgramCounter.SetProgramCounter(mProgramCounter.GetProgramCounter()+offset);
				}
				else
				{
					opCodeSize = sizeof(tSS_OpCode) + sizeof(int);
				}
				break;
			}


			case kOpCodeExternal_Val:
			{
				handled = true;
				int external = mMemory->GetS32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				opCodeSize = sizeof(tSS_OpCode)+sizeof(int);
				if (mCallBack && external >= 1000)
				{
					if (mCallBack->ThreadExternalCall(this,external))
					{
						toRun = 0;
					}
				}
#ifdef WIN32
//				printf("\nExternal call of %d\n",external);
#endif
				switch(external)
				{
					default:
					{
						break;
					}

					case SSE_ThreadExit:
					{
						mExceptionNotFlag = false;
#ifdef WIN32
//						printf("Stop thread ID %d\n",GetThreadID());
#endif
						if (mCallBack)
						{
							mCallBack->ThreadTerminated(this);
						}
						SimpleScriptRegister tempReg;
						while (PopRegister(tempReg))
						{
						}
						break;
					}

					case SSE_DumpRegisters:
					{
#ifdef WIN32
						DumpStatus();
#endif
						break;
					}

					case SSE_ThreadYield:
					{
						toRun = 0;
						break;
					}

					case SSE_ThreadCreate:
					{
						SimpleScriptThread *newThread = GetSimpleScript()->AllocateThread(GetMemory());
						newThread->SetCallBack(GetCallBack());
						newThread->SetMemory(GetMemory());
						newThread->RunFromPC(mRegisters[1].GetInteger());
						*newThread->GetRegister(1) = mRegisters[2];
						GetSimpleScript()->AddThread(newThread);
						mRegisters[1].SetInteger(newThread->GetThreadID());

						break;
					}

					case SSE_ThreadGetID:
					{
						mRegisters[1].SetInteger(GetThreadID());
						break;
					}

					case SSE_ThreadSignalIndexSet:
					{
						SimpleScriptThread *aThread = GetSimpleScript()->GetThreadFromID(mRegisters[1].GetInteger());
						if (aThread)
						{
							aThread->SignalIndexAdd(mRegisters[2].GetInteger());
						}
						break;
					}

					case SSE_ThreadSignalIndexClear:
					{
						SimpleScriptThread *aThread = GetSimpleScript()->GetThreadFromID(mRegisters[1].GetInteger());
						if (aThread)
						{
							aThread->SignalIndexClear(mRegisters[2].GetInteger());
						}
						break;
					}

					case SSE_ThreadGetSignal:
					{
						SimpleScriptThread *aThread = GetSimpleScript()->GetThreadFromID(mRegisters[1].GetInteger());
						if (aThread)
						{
							mRegisters[1].SetInteger(aThread->GetSignal());
						}
						break;
					}

					case SSE_ThreadSetSignal:
					{
						SimpleScriptThread *aThread = GetSimpleScript()->GetThreadFromID(mRegisters[1].GetInteger());
						if (aThread)
						{
							aThread->SetSignal(mRegisters[2].GetInteger());
						}
						break;
					}

					case SSE_Print:
					{
						int addr = mRegisters[1].GetInteger();
						if ( addr )
						{
							std::string toPrint = GetStringSafe( (char*)(GetMemory()->GetPointer( addr )) , GetMemory()->GetSize() - addr );
#ifdef WIN32
							printf( "SSE_Print: %s\n" , toPrint.c_str() );
#endif
						}
#ifdef WIN32
						printf( "SSE_Print 2:%f(%d) 3:%f(%d) 4:%f(%d) 5:%f(%d)\n" ,
							mRegisters[2].GetRaw32Float() , mRegisters[2].GetRaw32() ,
							mRegisters[3].GetRaw32Float() , mRegisters[3].GetRaw32() ,
							mRegisters[4].GetRaw32Float() , mRegisters[4].GetRaw32() ,
							mRegisters[5].GetRaw32Float() , mRegisters[5].GetRaw32() );
#endif
						break;
					}

				}

				break;
			}
			case kOpCodeAddr_DstOffset:
			{
				handled = true;
				tSS_Register reg = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				int offset = mMemory->GetS32(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				opCodeSize = sizeof(tSS_OpCode)+sizeof(tSS_OpCode)+sizeof(int);
				mRegisters[reg].SetInteger(mProgramCounter.GetProgramCounter()+offset);
				break;
			}
/*
			case kOpCodeStoreInt_DstSrc:
			{
				break;
			}
			case kOpCodeStoreFloat_DstSrc:
			{
				break;
			}
*/
			case kOpCodeLoadRegInt_DstSrc:
			{
				handled = true;
				tSS_Register dst = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				tSS_Register src = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				opCodeSize = sizeof(tSS_OpCode)+(2*sizeof(tSS_Register));
				int val;
				val = mMemory->GetS32(mRegisters[src].GetInteger());
				mRegisters[dst].LoadFrom32Bits(&val , SimpleScriptRegister::kInt);
				break;
			}
			case kOpCodeLoadRegFloat_DstSrc:
			{
				handled = true;
				tSS_Register dst = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				tSS_Register src = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				opCodeSize = sizeof(tSS_OpCode)+(2*sizeof(tSS_Register));
				int val;
				val = mMemory->GetS32(mRegisters[src].GetInteger());
				mRegisters[dst].LoadFrom32Bits(&val , SimpleScriptRegister::kFloat);
				break;
			}
			case kOpCodeLoadReg_DstSrc:
			{
				handled = true;
				tSS_Register dst = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				tSS_Register src = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				opCodeSize = sizeof(tSS_OpCode)+(2*sizeof(tSS_Register));
				int vals[2];
				vals[0] = mMemory->GetS32(mRegisters[src].GetInteger());
				vals[1] = mMemory->GetS32(mRegisters[src].GetInteger()+sizeof(int));
				mRegisters[dst].LoadFrom64Bits(vals);
				break;
			}
			case kOpCodeStoreReg_DstSrc:
			{
				handled = true;
				tSS_Register dst = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				tSS_Register src = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				opCodeSize = sizeof(tSS_OpCode)+(2*sizeof(tSS_Register));
				int vals[2];
				mRegisters[src].WriteTo64Bits(vals);
				mMemory->SetS32(mRegisters[dst].GetInteger(),vals[0]);
				mMemory->SetS32(mRegisters[dst].GetInteger()+sizeof(int),vals[1]);
				break;
			}
			case kOpCodeStoreReg32_DstSrc:
			{
				handled = true;
				tSS_Register dst = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				tSS_Register src = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				opCodeSize = sizeof(tSS_OpCode)+(2*sizeof(tSS_Register));
				int val;
				mRegisters[src].WriteTo32Bits(&val);
				mMemory->SetS32(mRegisters[dst].GetInteger(),val);
				break;
			}

			case kOpCodeLsl_DstSrc1Src2:
			{
				tSS_Register dst = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				tSS_Register src1 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				tSS_Register src2 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register)+sizeof(tSS_Register));
				unsigned char shift = mRegisters[src2].GetRaw32() & 31;

				mRegisters[dst].SetRaw32( mRegisters[src1].GetRaw32() << shift );

				opCodeSize = sizeof(tSS_OpCode) + sizeof(tSS_Register) + sizeof(tSS_Register) + sizeof(tSS_Register);
				handled = true;

				break;
			}

			case kOpCodeLsr_DstSrc1Src2:
			{
				tSS_Register dst = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				tSS_Register src1 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				tSS_Register src2 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register)+sizeof(tSS_Register));
				unsigned char shift = mRegisters[src2].GetRaw32() & 31;

				mRegisters[dst].SetRaw32( (mRegisters[src1].GetRaw32() >> shift) & 0x7fffffff );

				opCodeSize = sizeof(tSS_OpCode) + sizeof(tSS_Register) + sizeof(tSS_Register) + sizeof(tSS_Register);
				handled = true;

				break;
			}

			case kOpCodeAsr_DstSrc1Src2:
			{
				tSS_Register dst = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				tSS_Register src1 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				tSS_Register src2 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register)+sizeof(tSS_Register));
				unsigned char shift = mRegisters[src2].GetRaw32() & 31;

				mRegisters[dst].SetRaw32( mRegisters[src1].GetRaw32() >> shift );

				opCodeSize = sizeof(tSS_OpCode) + sizeof(tSS_Register) + sizeof(tSS_Register) + sizeof(tSS_Register);
				handled = true;

				break;
			}

			case kOpCodeRor_DstSrc1Src2:
			{
				tSS_Register dst = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				tSS_Register src1 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				tSS_Register src2 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register)+sizeof(tSS_Register));
				unsigned char shift = mRegisters[src2].GetRaw32() & 31;

				mRegisters[dst].SetRaw32( ( (mRegisters[src1].GetRaw32() >> shift) & 0x7fffffff ) | ( ( mRegisters[src1].GetRaw32() & 1) << 31) );

				opCodeSize = sizeof(tSS_OpCode) + sizeof(tSS_Register) + sizeof(tSS_Register) + sizeof(tSS_Register);
				handled = true;

				break;
			}

			case kOpCodeAnd_DstSrc1Src2:
			{
				tSS_Register dst = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				tSS_Register src1 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				tSS_Register src2 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register)+sizeof(tSS_Register));

				mRegisters[dst].SetInteger( mRegisters[src1].GetRaw32() & mRegisters[src2].GetRaw32() );

				opCodeSize = sizeof(tSS_OpCode) + (3*sizeof(tSS_Register));
				handled = true;

				break;
			}

			case kOpCodeEor_DstSrc1Src2:
			{
				tSS_Register dst = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));
				tSS_Register src1 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register));
				tSS_Register src2 = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode)+sizeof(tSS_Register)+sizeof(tSS_Register));

				mRegisters[dst].SetInteger( mRegisters[src1].GetRaw32() ^ mRegisters[src2].GetRaw32() );

				opCodeSize = sizeof(tSS_OpCode) + (3*sizeof(tSS_Register));
				handled = true;

				break;
			}

			case kOpCodeFloatToInt_Src:
			{
				handled = true;
				opCodeSize = sizeof(tSS_OpCode) + sizeof(tSS_Register);
				tSS_Register reg = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));

				mRegisters[reg].SetInteger( (int) mRegisters[reg].GetRaw32Float() );
				break;
			}

			case kOpCodeIntToFloat_Src:
			{
				handled = true;
				opCodeSize = sizeof(tSS_OpCode) + sizeof(tSS_Register);
				tSS_Register reg = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));

				mRegisters[reg].SetFloat( (float) mRegisters[reg].GetRaw32() );
				break;
			}

			case kOpCodeSetFP_Src:
			{
				handled = true;
				opCodeSize = sizeof(tSS_OpCode) + sizeof(tSS_Register);
				tSS_Register reg = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));

				mRegisters[reg].SetFloatingPointType();
				break;
			}

			case kOpCodeNot_Src:
			{
				handled = true;
				opCodeSize = sizeof(tSS_OpCode) + sizeof(tSS_Register);
				tSS_Register reg = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));

				mRegisters[reg].SetInteger( ~mRegisters[reg].GetRaw32() );
				break;
			}

			case kOpCodeCastFP_Src:
			{
				handled = true;
				opCodeSize = sizeof(tSS_OpCode) + sizeof(tSS_Register);
				tSS_Register reg = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));

				mRegisters[reg].SetFloat( mRegisters[reg].GetFloat() );
				break;
			}

			case kOpCodeCastInt_Src:
			{
				handled = true;
				opCodeSize = sizeof(tSS_OpCode) + sizeof(tSS_Register);
				tSS_Register reg = mMemory->GetU8(mProgramCounter.GetProgramCounter()+sizeof(tSS_OpCode));

				mRegisters[reg].SetInteger( mRegisters[reg].GetInteger() );
				break;
			}

			default:
			{
				break;
			}
		} // switch (opCode)
		if (!handled)
		{
#ifdef WIN32
//			printf("\nUnhandled opcode %d at %d\n",opCode,mProgramCounter.GetProgramCounter());
#endif
			mExceptionNotFlag = false;

			if (mCallBack)
			{
				mCallBack->ThreadException(this);
				mCallBack->ThreadTerminated(this);
			}
		}
		if (!mExceptionNotFlag)
		{
#ifdef WIN32
//			printf("\nException generated at %d\n",mProgramCounter.GetProgramCounter());
#endif
		}
		mProgramCounter.SetProgramCounter(mProgramCounter.GetProgramCounter()+opCodeSize);
	} // while (toRun--)

	return (numberCycles - toRun);
}


bool SimpleScriptThread::PushRegister(SimpleScriptRegister &reg)
{
	mStack.push_back(reg);
	mRegisters[kRegisterStackContextCount].SetInteger(mRegisters[kRegisterStackContextCount].GetInteger()+1);
	return true;
}

bool SimpleScriptThread::PopRegister(SimpleScriptRegister &reg)
{
	if (mStack.empty())
	{
		return false;
	}

	mRegisters[kRegisterStackContextCount].SetInteger(mRegisters[kRegisterStackContextCount].GetInteger()-1);

	SimpleScriptRegister tempReg = mStack.back();
	mStack.pop_back();
	// Special case, restore the register from where it came from
	if (reg.mRegisterIndex == 0)
	{
		if (tempReg.mRegisterIndex > 0)
		{
			mRegisters[tempReg.mRegisterIndex] = tempReg;
		}
	}
	else
	{
		reg = tempReg;
	}
	return true;
}

void SimpleScriptThread::DumpStatus(void)
{
//#ifdef WIN32
	int i;

	printf( "Thread ID %d Cycles %d\n",GetThreadID() , GetCycles() );
	for (i=0;i<kSimpleScriptThreadRegisters;i+=2)
	{
		printf("r%2d = %12d %16f	r%2d = %12d %16f\n",i,mRegisters[i].GetInteger(),mRegisters[i].GetFloat(),
														i+1,mRegisters[i+1].GetInteger(),mRegisters[i+1].GetFloat());
	}
	unsigned int PCMem = 0;
	int addr = mProgramCounter.GetProgramCounter();
	PCMem = mMemory->GetU8( addr );
	if ( ( addr + 1 ) < mMemory->GetSize() )
	{
		PCMem |= int(mMemory->GetU8( addr + 1 )) << 8;
	}
	if ( ( addr + 2 ) < mMemory->GetSize() )
	{
		PCMem |= int(mMemory->GetU8( addr + 2 )) << 16;
	}
	if ( ( addr + 3 ) < mMemory->GetSize() )
	{
		PCMem |= int(mMemory->GetU8( addr + 3 )) << 24;
	}


	printf( "PC = %12d $%.8x PCMem=$%.8x Last comparison result = $%x Stack = $%x\n", addr , addr , PCMem , mProgramCounter.GetLastComparisonResult() , (int)mStack.size() );
//#endif
}
//From: RNLobby/ObfuscatePassword.cpp
#include <algorithm>
#include <string>

//Skipping: #include "RNPlatform/Inc/CheckSum.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
//Skipping: #include "RNPlatform/Inc/StringUtils.h"
//Skipping: #include "RNLobby/ObfuscatePassword.h"

/// \param name will be lowered and trimmed for whitespace
std::string RNReplicaNet::RNLobby::ObfuscatePassword(const char *name, const char *password)
{
	int slots[4];
	// Use known random values here to ensure even short passwords get updated with something other than 0.
	slots[0] = 0x7f45a3c7;
	slots[1] = 0xc1c0e9a6;
	slots[2] = 0x035336e2;
	slots[3] = 0x51e489a2;

	std::string toHash;
	if (name)
	{
		// If the same password is used then the hash will be different because the lower case
		// user name acts as a salt.
		toHash = name;
		std::transform(toHash.begin(), toHash.end(), toHash.begin(), ::tolower);
		toHash = RNReplicaNet::TrimWhite(toHash);
	}

	if (password)
	{
		toHash += std::string(password);
		RNReplicaNet::Checksum::ChecksumDataWithSlots(slots,sizeof(slots)/sizeof(slots[0]),toHash.c_str(),toHash.length());
	}
	std::string passwordHash = RNReplicaNet::MessageHelper::DumpAsHex(slots,sizeof(slots),false);
	return passwordHash;
}
//From: RNLobby/PatchIndexManager.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifdef _WIN32
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <assert.h>
#include <map>
#include "RNLobby/Inc/PatchIndexManager.h"
//Skipping: #include "RNLobby/Inc/Patcher.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
//Skipping: #include "RNXPCompression/Inc/XPCompression.h"
//Skipping: #include "RNPlatform/Inc/Encryption.h"


namespace RNReplicaNet
{

namespace RNLobby
{

static void makeLower(std::string &work)
{
	size_t pos;
	for (pos =0 ; pos < work.length() ; pos++)
	{
		work[pos] = tolower(work[pos]);
	}
}

bool PatchIndexManager::ltLowerStr::operator() (const std::string& a,const std::string& b) const
{
	// MPi: TODO: This does a lower case check for the index because Windows does not care about case of file names.
	// However for file systems that do care about case this check might just become a strcmp with the makeLower()
	// or a stricmp() of course.
	std::string ta = a,tb = b;
	makeLower(ta);
	makeLower(tb);
	
	return strcmp(ta.c_str() , tb.c_str()) < 0;
}

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

static const unsigned int kPatchIndexManagerVersion = 0;
static const unsigned int kPatchIndexManagerMagic = 0x6672abde;


void PatchIndexManager::VersionInfo::Read(DynamicMessageHelper &in)
{
	size_t i;
	for (i=0;i<ARRAY_SIZE(mChecksum.mValue);i++)
	{
		in >> mChecksum.mValue[i];
	}
	in >> mUniqueID;
	in >> mProductVersion;
	in >> mIsPatch;
	in >> mNewThisIteration;
	in >> mDataFileSize;
}

void PatchIndexManager::VersionInfo::Write(DynamicMessageHelper &out) const
{
	size_t i;
	for (i=0;i<ARRAY_SIZE(mChecksum.mValue);i++)
	{
		out << mChecksum.mValue[i];
	}
	out << mUniqueID;
	out << mProductVersion;
	out << mIsPatch;
	out << mNewThisIteration;
	out << mDataFileSize;
}

void PatchIndexManager::VersionInfo::Dump(void) const
{
	printf("mChecksum '%s'\n",MessageHelper::DumpAsHex(mChecksum.mValue,sizeof(mChecksum.mValue)).c_str());
	printf("mUniqueID %d\n",mUniqueID);
	printf("mProductVersion %d\n",mProductVersion);
	printf("mIsPatch %d\n",mIsPatch);
	printf("mNewThisIteration %d\n",mNewThisIteration);
}

PatchIndexManager::PatchIndexManager()
{
	Clear();
}

PatchIndexManager::~PatchIndexManager()
{
}

void PatchIndexManager::Clear(void)
{
	mProductVersion = 0;
	mLastUniqueID = 0;
}

bool PatchIndexManager::ReadIndex(const char *filename)
{
	mIndex.clear();

	FILE *fp = fopen(filename,"rb");
	if (!fp)
	{
		return false;
	}

	fseek(fp,0,SEEK_END);
	size_t len = ftell(fp);
	fseek(fp,0,SEEK_SET);

	DynamicMessageHelper compData( (int) len );
	size_t freadRet = fread(compData.GetBuffer(),1,len,fp);

	fclose(fp);


	unsigned int temp = kPatchIndexManagerMagic;
	Encryption::Key key;
	key.Create(&temp,sizeof(temp));
	Encryption::Decrypt(compData.GetBuffer(),(int)len,&key);


	MESSAGEHELPER_GETVARIABLEp(compData,temp);
	if (temp != kPatchIndexManagerMagic)
	{
		return false;
	}
	MESSAGEHELPER_GETVARIABLEp(compData,temp);
	switch (temp)
	{
		case 0:
		{
			int destLen;
			MESSAGEHELPER_GETVARIABLEp(compData,destLen);
			int origLen;
			MESSAGEHELPER_GETVARIABLEp(compData,origLen);
			DynamicMessageHelper in( origLen );

			XPCompression comp;
			int test;
			comp.Decompress(compData.GetCurrentPosition(),destLen,in.GetBuffer(),&test,in.GetBufferSize());
			assert(test == origLen);
			if (test != origLen)
			{
				return false;
			}

			MESSAGEHELPER_GETVARIABLEp(in,mProductVersion);
			MESSAGEHELPER_GETVARIABLEp(in,mLastUniqueID);
			size_t numEntries;
			MESSAGEHELPER_GETVARIABLEp(in,numEntries);
			while (numEntries--)
			{
				std::string index;
				in >> index;
				EntryInfo value;

				MESSAGEHELPER_GETVARIABLEp(in,value.mNumMaxVersions);
				value.mScratch.Read(in);

				unsigned int numVersions;
				MESSAGEHELPER_GETVARIABLEp(in,numVersions);
				while (numVersions--)
				{
					VersionInfo version;
					version.Read(in);
					value.mVersions.push_back(version);
				}
				mIndex.insert(std::pair<std::string,EntryInfo>(index,value));
			}
		}
		break;

		default:
		{
			return false;
		}
		break;
	}

	return true;
}

bool PatchIndexManager::WriteIndex(const char *filename,const bool minimalInfo)
{
	DynamicMessageHelper out;
	MESSAGEHELPER_ADDVARIABLEp(out,mProductVersion);
	MESSAGEHELPER_ADDVARIABLEp(out,mLastUniqueID);
	unsigned int numEntries = (unsigned int) mIndex.size();
	MESSAGEHELPER_ADDVARIABLEp(out,numEntries);
	std::map<std::string,EntryInfo,ltLowerStr>::iterator st,en;
	st = mIndex.begin();
	en = mIndex.end();
	while (st != en)
	{
		const std::string &index = (*st).first;
		const EntryInfo &value = (*st).second;
		st++;
		out << index;
		MESSAGEHELPER_ADDVARIABLEp(out,value.mNumMaxVersions);
		value.mScratch.Write(out);

		if (minimalInfo)
		{
			unsigned int numVersions = 0;
			std::list<VersionInfo>::const_iterator st2,en2;
			st2 = value.mVersions.begin();
			en2 = value.mVersions.end();
			while (st2 != en2)
			{
				const VersionInfo &version = *st2++;
				if (version.mIsPatch)
				{
					numVersions++;
				}
			}

			MESSAGEHELPER_ADDVARIABLEp(out,numVersions);
			st2 = value.mVersions.begin();
			en2 = value.mVersions.end();
			while (st2 != en2)
			{
				const VersionInfo &version = *st2++;
				if (version.mIsPatch)
				{
					version.Write(out);
				}
			}
		}
		else
		{
			unsigned int numVersions = (unsigned int) value.mVersions.size();
			MESSAGEHELPER_ADDVARIABLEp(out,numVersions);
			std::list<VersionInfo>::const_iterator st2,en2;
			st2 = value.mVersions.begin();
			en2 = value.mVersions.end();
			while (st2 != en2)
			{
				const VersionInfo &version = *st2++;
				version.Write(out);
			}
		}
	}
	XPCompression comp;
	DynamicMessageHelper compData( comp.CalculateMaximumMemory(out.GetSize()) );
	int destLen;
	comp.Compress(out.GetBuffer(),out.GetSize(),compData.GetBuffer(),&destLen);
	int origLen = out.GetSize();
	out.SetSize(0);
	MESSAGEHELPER_ADDVARIABLEp(out,kPatchIndexManagerMagic);
	MESSAGEHELPER_ADDVARIABLEp(out,kPatchIndexManagerVersion);
	MESSAGEHELPER_ADDVARIABLEp(out,destLen);
	MESSAGEHELPER_ADDVARIABLEp(out,origLen);
	out.AddData(compData.GetBuffer(),destLen);

	unsigned int temp = kPatchIndexManagerMagic;
	Encryption::Key key;
	key.Create(&temp,sizeof(temp));
	Encryption::Encrypt(out.GetBuffer(),out.GetSize(),&key);

	FILE *fp = fopen(filename,"wb");
	if (!fp)
	{
		return false;
	}
	fwrite(out.GetBuffer(),1,out.GetSize(),fp);
	fclose(fp);

	return true;
}

void PatchIndexManager::Dump(void) const
{
	std::map<std::string,EntryInfo,ltLowerStr>::const_iterator st,en;
	st = mIndex.begin();
	en = mIndex.end();
	while (st != en)
	{
		const std::string &index = (*st).first;
		const EntryInfo &value = (*st).second;
		st++;
		printf("index '%s'\n",index.c_str());
		printf("mNumMaxVersions %d\n",value.mNumMaxVersions);
		printf("*** From scratch ***\n");
		value.mScratch.Dump();

		std::list<VersionInfo>::const_iterator st2,en2;
		st2 = value.mVersions.begin();
		en2 = value.mVersions.end();
		int entry = 0;
		while (st2 != en2)
		{
			printf("*** Version entry %d ***\n",entry++);
			const VersionInfo &version = *st2++;
			version.Dump();
		}
	}
}

void PatchIndexManager::AddEntryInfo(std::string filename,const EntryInfo &entryInfo)
{
	mIndex.insert(std::pair<std::string,EntryInfo>(filename,entryInfo));
}

PatchIndexManager::EntryInfo *PatchIndexManager::GetEntryInfo(std::string filename)
{
	std::map<std::string,EntryInfo,ltLowerStr>::iterator found = mIndex.find(filename);
	EntryInfo *entry = 0;
	if (found != mIndex.end())
	{
		entry = & (*found).second;
	}
	return entry;
}

unsigned int PatchIndexManager::GetUniqueID(void)
{
	return mLastUniqueID++;
}

void PatchIndexManager::RemoveUnhandled(void)
{
	std::map<std::string,EntryInfo,ltLowerStr>::iterator st = mIndex.begin();
	while (st != mIndex.end())
	{
		std::map<std::string,EntryInfo,ltLowerStr>::iterator old = st++;
		EntryInfo &entry = (*old).second;
		if (!entry.mHasBeenHandled)
		{
			mIndex.erase(old);
		}
	}
}

void PatchIndexManager::ClearNewThisIteration(void)
{
	std::map<std::string,EntryInfo,ltLowerStr>::iterator st = mIndex.begin();
	while (st != mIndex.end())
	{
		std::map<std::string,EntryInfo,ltLowerStr>::iterator old = st++;
		EntryInfo &entry = (*old).second;
		entry.mScratch.mNewThisIteration = false;
		std::list<VersionInfo>::iterator st2;
		st2 = entry.mVersions.begin();
		while (st2 != entry.mVersions.end())
		{
			VersionInfo &version = *st2++;
			version.mNewThisIteration = false;
		}
	}
}

void PatchIndexManager::BeginIterate(void)
{
	mSt = mIndex.begin();
}

PatchIndexManager::EntryInfo *PatchIndexManager::Iterate(std::string &index)
{
	if (mSt != mIndex.end())
	{
		index = (*mSt).first;
		return &((*mSt++).second);
	}
	return 0;
}

unsigned int PatchIndexManager::GetVersion(void)
{
	return kPatchIndexManagerVersion;
}

static const unsigned int kPatchIndexManagerModifiedVersion = 0;
static const unsigned int kPatchIndexManagerModifiedMagic = 0x82ad1b7e;

void PatchIndexManager::ClearModified(void)
{
	mModified.clear();
}

bool PatchIndexManager::ReadModified(const char *filename)
{
	ClearModified();

	assert(filename);
	if (!filename)
	{
		return false;
	}

	DynamicMessageHelper data;
	if (!data.Read(filename))
	{
		return false;
	}

	unsigned int t;
	data >> t;
	if (t != kPatchIndexManagerModifiedMagic)
	{
		return false;
	}

	data >> t;
	if (t != kPatchIndexManagerModifiedVersion)
	{
		return false;
	}

	while (data.GetSize() < data.GetBufferSize())
	{
		std::string filename;
		data >> filename;
		ModifiedInfo info;
		data >> info.mTimeStamp;

		mModified[filename] = info;
	}

	return true;
}

bool PatchIndexManager::WriteModified(const char *filename)
{
	assert(filename);
	if (!filename)
	{
		return false;
	}

	DynamicMessageHelper data;

	data << kPatchIndexManagerModifiedMagic;
	data << kPatchIndexManagerModifiedVersion;

	std::map<std::string,ModifiedInfo,ltLowerStr>::iterator i;
	for (i = mModified.begin() ; i != mModified.end() ; i++)
	{
		if ((*i).second.mVisited)
		{
			data << (*i).first;
			data << (*i).second.mTimeStamp;
		}
	}

	return data.Write(filename);
}

bool PatchIndexManager::GetIsModified(const char *filename)
{
	ModifiedInfo &info = mModified[filename];
	info.mVisited = true;
	HANDLE file = CreateFileA(filename,GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);
	if (file == INVALID_HANDLE_VALUE)
	{
		return true;
	}

	FILETIME fileTimeCreate,fileTimeWrite;
	GetFileTime(file,&fileTimeCreate,0,&fileTimeWrite);
	char buffer[1024];
	sprintf(buffer,"%x,%x,%x,%x,%x",GetFileSize(file,0),fileTimeCreate.dwLowDateTime,fileTimeCreate.dwHighDateTime,fileTimeWrite.dwLowDateTime,fileTimeWrite.dwHighDateTime);

	CloseHandle(file);

	if (info.mTimeStamp != buffer)
	{
		info.mTimeStamp = buffer;
		return true;
	}
	return false;
}


} // namespace RNLobby

} // namespace RNReplicaNet
#endif
//From: RNLobby/ProductPatcher.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifdef _WIN32
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <assert.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <set>
#include <list>
#include <string>
#include "RNLobby/Inc/ProductPatcher.h"
//Skipping: #include "RNPlatform/Inc/CheckSum.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
//Skipping: #include "RNLobby/Inc/Patcher.h"
#include "RNLobby/Inc/ScanPath.h"
#include "RNLobby/Inc/ScanChecksum.h"
#include "RNLobby/Inc/ScanForDiffs.h"
//Skipping: #include "RNLobby/Inc/PatchIndexManager.h"
//Skipping: #include "RNPlatform/Inc/SysTime.h"

#ifdef _WIN32
#ifndef _XBOX
#pragma comment(lib, "wininet.lib")
#endif
#endif


namespace RNReplicaNet
{

namespace RNLobby
{

class MyDecompressFile : public RNReplicaNet::RNLobby::ScanForDiffs
{
public:
	MyDecompressFile(ProductPatcher *worker,const char *patchingFile) : mWorker(worker) , mPatchingFile(patchingFile) {}

	bool CallbackScanning(size_t pos,size_t max,const ScanPath::Entry &entry,const size_t filePos,const size_t fileMax)
	{
		assert(mWorker);
		mWorker->CallbackUpdateProgressFile(mPatchingFile,filePos,fileMax);
		return true;
	}

	const char *mPatchingFile;
	ProductPatcher *mWorker;
};

} // namespace RNLobby

} // namespace RNReplicaNet

using namespace RNReplicaNet;
using namespace RNReplicaNet::RNLobby;

static const char *sTempPatchFile = "_tempPatch.tmp";

ProductPatcher::ProductPatcher() : 	mInternet(0) , mTempBuffer(0) , mFile(0) , mFP(0) , mCallCompleteRequired(false)
									, mDownloadAttempts(0) , mDownloadAttemptsFailed(0)
									, mDownloadedBytes(0) , mDownloadedOverTime(0.0f)
{
}

ProductPatcher::~ProductPatcher()
{
	Stop();
}

void ProductPatcher::OpenInternet(void)
{
	if (mInternet)
	{
		InternetCloseHandle(mInternet);
	}
	mInternet = InternetOpenA("ReplicaNet Product Patcher http://www.replicanet.com/" , INTERNET_OPEN_TYPE_PRECONFIG,0,0,0);
}

bool ProductPatcher::Start(const char *productPath,const char *patchIndexURL,const char *patchDataURL,const bool multiThread,const size_t chunkSize)
{
	// Make sure any previous thread is terminated
	Stop();

	mChunkSize = chunkSize;

	mTempBuffer = malloc(mChunkSize);
	if (!mTempBuffer)
	{
		return false;
	}

	OpenInternet();

	mProductPath = productPath;
	mPatchIndexURL = patchIndexURL;
	mPatchDataURL = patchDataURL;

	mCallCompleteRequired = true;
	mAborted = false;

	mDownloadAttempts = 0;
	mDownloadAttemptsFailed = 0;

	mDownloadedBytes = 0;
	mDownloadedOverTime = 0.0f;

	if (multiThread)
	{
		Begin(this);
		return true;
	}
	// Not using a thread so just call the thread entry
	ThreadEntry();
	return true;
}

bool ProductPatcher::Stop(void)
{
	mAborted = true;
	Terminate();
	Tidy();
	return true;
}

void ProductPatcher::Tidy(void)
{
	if (mFP)
	{
		fclose(mFP);
		mFP = 0;
	}
	DeleteFileA(sTempPatchFile);
	if (mFile)
	{
		InternetCloseHandle(mFile);
		mFile = 0;
	}
	if (mInternet)
	{
		InternetCloseHandle(mInternet);
		mInternet = 0;
	}
	free(mTempBuffer);
	mTempBuffer = 0;
}

bool ProductPatcher::GetCompleted(void)
{
	return !GetIsRunning();
}

bool ProductPatcher::CallbackUpdateProgressProduct(const size_t fileIndex,const size_t maxFileIndex)
{
	return true;
}

bool ProductPatcher::CallbackUpdateDownloadPatch(const char *patchingFile,const size_t filePosition,const size_t fileLength)
{
	return true;
}

bool ProductPatcher::CallbackUpdateProgressFile(const char *patchingFile,const size_t filePosition,const size_t fileLength)
{
	return true;
}

void ProductPatcher::CallbackComplete(const Status status)
{
}

int ProductPatcher::ThreadEntry(void)
{
	int ret = RealThreadEntry(mProductPath.c_str(),mPatchIndexURL.c_str(),mPatchDataURL.c_str());
	Tidy();
	if (mCallCompleteRequired)
	{
		mCallCompleteRequired = false;
		if (ret == 0)
		{
			CallbackComplete(kSuccess);
		}
		else
		{
			if (mAborted)
			{
				CallbackComplete(kAborted);
			}
			else
			{
				CallbackComplete(kErrorEncountered);
			}
		}
	}
	return ret;
}

namespace RNReplicaNet
{

namespace RNLobby
{

struct ltScanPathEntryByName
{
	bool operator()(const RNReplicaNet::RNLobby::ScanPath::Entry &s1, const RNReplicaNet::RNLobby::ScanPath::Entry &s2) const
	{
		return strcmp(s1.mName.c_str(), s2.mName.c_str()) < 0;
	}
};

} // namespace RNLobby

} // namespace RNReplicaNet

#define TMPINDEX "_tempIndex.ind"

int ProductPatcher::RealThreadEntry(const char *productPath,const char *patchIndexURL,const char *patchDataURL)
{
	RNReplicaNet::RNLobby::ScanPath scanPath;

	RNReplicaNet::RNLobby::PatchIndexManager index;

	std::string tempName;
	int retry = 0;
	const char *failedToReadFile = 0;
	do
	{
		tempName = GetRealFilePath(patchIndexURL,"",TMPINDEX);
		if (tempName == "")
		{
			failedToReadFile = patchIndexURL;
			OpenInternet();
			continue;
		}

		bool retRead = index.ReadIndex(tempName.c_str());
		DeleteFileA(TMPINDEX);
		if (!retRead)
		{
			mDownloadAttemptsFailed++;
			failedToReadFile = tempName.c_str();
			OpenInternet();
			continue;
		}
		// Everything OK
		failedToReadFile = 0;
		break;
	} while (failedToReadFile && (retry++ < 5));
	if (failedToReadFile)
	{
		CallbackFailedToReadFile(failedToReadFile);
		return -1;
	}

	index.BeginIterate();
	RNReplicaNet::RNLobby::PatchIndexManager::EntryInfo *entryInfo = 0;
	std::string entryIndex;

	// Load the checksum cache if it is available
	// The cache operates on the slightly more qualified target name *not* the EntryInfo leaf path.
	std::set<RNReplicaNet::RNLobby::ScanPath::Entry,RNReplicaNet::RNLobby::ltScanPathEntryByName> checksumCache;
	std::string cachedChecksumIndex = std::string(productPath) + std::string("\\") + std::string("_sumCache.bin");
	std::list<RNReplicaNet::RNLobby::ScanPath::Entry> tempScansList;
	if (RNReplicaNet::RNLobby::ScanPath::Read(cachedChecksumIndex.c_str(),tempScansList))
	{
		std::list<RNReplicaNet::RNLobby::ScanPath::Entry>::iterator st = tempScansList.begin();
		while (st != tempScansList.end())
		{
			RNReplicaNet::RNLobby::ScanPath::Entry &entry = *st++;
			checksumCache.insert(entry);
		}
	}
	tempScansList.clear();	// We don't need this to be hanging around
	size_t maxNumEntries = index.GetNumEntries();
	int numEntries = 0;

	std::list<RNReplicaNet::RNLobby::ScanPath::Entry> existsSoScan;
	while ( (entryInfo = index.Iterate(entryIndex)) != 0)
	{
/*
		printf("EntryInfo: file '%s'\n",entryIndex.c_str());
		printf("FromScratch: V%d : ID%d isPatch %d gives checksum %s\n",entryInfo->mScratch.mProductVersion,entryInfo->mScratch.mUniqueID,(int)entryInfo->mScratch.mIsPatch,RNReplicaNet::MessageHelper::DumpAsHex(entryInfo->mScratch.mChecksum.mValue,sizeof(entryInfo->mScratch.mChecksum.mValue)).c_str());
		std::list<RNReplicaNet::RNLobby::PatchIndexManager::VersionInfo>::iterator st = entryInfo->mVersions.begin();
		while (st != entryInfo->mVersions.end())
		{
			RNReplicaNet::RNLobby::PatchIndexManager::VersionInfo &versionInfo = *st++;
			printf("VersionInfo: V%d : ID%d isPatch %d from checksum %s\n",versionInfo.mProductVersion,versionInfo.mUniqueID,(int)versionInfo.mIsPatch,RNReplicaNet::MessageHelper::DumpAsHex(versionInfo.mChecksum.mValue,sizeof(versionInfo.mChecksum.mValue)).c_str());
		}
*/
		std::string targetName = std::string(productPath) + std::string("\\") + entryIndex;

		if (!CallbackProcessFile(entryIndex.c_str()))
		{
			continue;
		}

		FILE *fp = fopen(targetName.c_str() , "rb");
		if (fp)
		{
			fclose(fp);

			RNReplicaNet::RNLobby::ScanPath::Entry toFind;
			toFind.mName = targetName;
			std::set<RNReplicaNet::RNLobby::ScanPath::Entry,RNReplicaNet::RNLobby::ltScanPathEntryByName>::iterator found = checksumCache.find(toFind);
			bool isOK = false;
			bool needChecksum = true;
			RNReplicaNet::RNLobby::ScanPath::Entry oneEntry;
			if (found != checksumCache.end())
			{
				const RNReplicaNet::RNLobby::ScanPath::Entry &entry = *found;
				HANDLE hnd = CreateFileA(targetName.c_str(),GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);
				if (hnd != INVALID_HANDLE_VALUE)
				{
					if (GetFileTime(hnd,0,0,&oneEntry.mLastWriteTime))
					{
						if (CompareFileTime(&oneEntry.mLastWriteTime,&entry.mLastWriteTime)==0)
						{
							needChecksum = false;
							oneEntry.mChecksum = entry.mChecksum;

							// FILETIME Matches so we can verify the checksum without needing to calculate it
							if (memcmp(&entryInfo->mScratch.mChecksum,&entry.mChecksum,sizeof(entry.mChecksum)) == 0)
							{
								isOK = true;
							}
						}
					}
					CloseHandle(hnd);
				}
			}

			oneEntry.mIsFile = true;
			if (needChecksum)
			{
				oneEntry.mName = targetName;
				// MPi: Maybe resolve this checksum bit into using the std::list version as one run through the list?
//				printf("Calculating checksum for file '%s'...",targetName.c_str());
				RNReplicaNet::RNLobby::ScanChecksum tc;
				tc.Start(oneEntry);
				CallbackUpdateProgressFile(entryIndex.c_str(),0,0);
			}

			// The file is not in the cache or the FILETIME differs so we want to checksum it later on.
			if (!isOK)
			{
				oneEntry.mName = entryIndex;
				existsSoScan.push_back(oneEntry);
			}
			else
			{
				CallbackUpdateProgressProduct(numEntries++,maxNumEntries);
			}
		}
		else
		{
			// Doesn't exist, so create from scratch.
			char patchSourceFilename[MAX_PATH];
			sprintf(patchSourceFilename,"%s\\%d.bin",patchDataURL,entryInfo->mScratch.mUniqueID);
			// Create the directory path if required.
			size_t pos = 0;
			pos = targetName.find('\\',pos);
			while (pos != std::string::npos)
			{
				std::string temp = targetName.substr(0,pos);
				CreateDirectoryA(temp.c_str(),0);
				pos = targetName.find('\\',pos+1);
			}

			int retry = 0;
			const char *failedToReadFile = 0;
			do
			{
				// Decompress the file from the patch location to the final location
				tempName = GetRealFilePath(patchSourceFilename,entryIndex.c_str());
				if (tempName == "")
				{
					failedToReadFile = patchIndexURL;
					OpenInternet();
					continue;
				}
				MyDecompressFile decomp(this,targetName.c_str());
				ScanPath::Entry entry;
				if (decomp.DecompressFile(0,0,entry,tempName.c_str(),targetName.c_str()) < 0)
				{
					mDownloadAttemptsFailed++;
					failedToReadFile = tempName.c_str();
					OpenInternet();
					continue;
				}
				// Everything OK
				failedToReadFile = 0;
				break;
			} while (failedToReadFile && (retry++ < 5));
			if (failedToReadFile)
			{
				CallbackFailedToReadFile(failedToReadFile);
				return -1;
			}

			// MPi: TODO: Tidy this common code block with the one above. Same comment line as below.
			// Update the checksum cache
			RNReplicaNet::RNLobby::ScanPath::Entry toFind;
			toFind.mName = targetName;
			std::set<RNReplicaNet::RNLobby::ScanPath::Entry,RNReplicaNet::RNLobby::ltScanPathEntryByName>::iterator found = checksumCache.find(toFind);
			if (found != checksumCache.end())
			{
				checksumCache.erase(found);
			}
			HANDLE hnd = CreateFileA(targetName.c_str(),GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);
			if (hnd != INVALID_HANDLE_VALUE)
			{
				RNReplicaNet::RNLobby::ScanPath::Entry entry;
				entry.mIsFile = true;
				entry.mName = targetName;
				if (GetFileTime(hnd,0,0,&entry.mLastWriteTime))
				{
					entry.mChecksum = entryInfo->mScratch.mChecksum;
					checksumCache.insert(entry);
				}
				CloseHandle(hnd);
			}
			CallbackUpdateProgressFile(entryIndex.c_str(),0,0);
			CallbackUpdateProgressProduct(numEntries++,maxNumEntries);
		}
	}

	// Now work through the existsSoScan list
	std::list<RNReplicaNet::RNLobby::ScanPath::Entry>::iterator scanIt;

	// The ones that are left are the ones we want to patch because the cache says the FILETIME differs
	scanIt = existsSoScan.begin();
	while (scanIt != existsSoScan.end())
	{
		RNReplicaNet::RNLobby::ScanPath::Entry oneEntry = *scanIt++;
		entryIndex = oneEntry.mName;
		entryInfo = index.GetEntryInfo(entryIndex);
		std::string targetName = std::string(productPath) + std::string("\\") + entryIndex;
		oneEntry.mName = targetName;

		// Check to see if the checksum differs from the head revision.
		if (memcmp(&entryInfo->mScratch.mChecksum,&oneEntry.mChecksum,sizeof(oneEntry.mChecksum)) != 0)
		{
//			printf("Patching file '%s'...",targetName.c_str());
			// Scan for a checksum match.
			std::list<RNReplicaNet::RNLobby::PatchIndexManager::VersionInfo>::iterator st = entryInfo->mVersions.begin();
			while (st != entryInfo->mVersions.end())
			{
				RNReplicaNet::RNLobby::PatchIndexManager::VersionInfo &versionInfo = *st;
				if (memcmp(&versionInfo.mChecksum,&oneEntry.mChecksum,sizeof(oneEntry.mChecksum)) == 0 && versionInfo.mIsPatch)
				{
					// Matched and found a patch
					char patchSourceFilename[MAX_PATH];
					std::string tempDecompPatchName = std::string(productPath) + std::string("\\") + entryIndex + ".dptch";
					std::string tempTargetName = std::string(productPath) + std::string("\\") + entryIndex + ".tmp";
					sprintf(patchSourceFilename,"%s\\%d.bin",patchDataURL,versionInfo.mUniqueID);

					int retry = 0;
					const char *failedToReadFile = 0;
					do
					{
						tempName = GetRealFilePath(patchSourceFilename,entryIndex.c_str());
						if (tempName == "")
						{
							failedToReadFile = patchIndexURL;
							OpenInternet();
							continue;
						}
						MyDecompressFile decomp(this,targetName.c_str());
						ScanPath::Entry entry;
						if (decomp.DecompressFile(0,0,entry,tempName.c_str(),tempDecompPatchName.c_str()) < 0)
						{
							mDownloadAttemptsFailed++;
							failedToReadFile = tempName.c_str();
							OpenInternet();
							continue;
						}
						// Everything OK
						failedToReadFile = 0;
						break;
					} while (failedToReadFile && (retry++ < 5));
					if (failedToReadFile)
					{
						CallbackFailedToReadFile(failedToReadFile);
						return -1;
					}


					RNReplicaNet::RNLobby::Patcher tp;
					tp.PatchFile(targetName.c_str(),tempDecompPatchName.c_str(),tempTargetName.c_str());
					DeleteFileA(tempDecompPatchName.c_str());
					DeleteFileA(targetName.c_str());
					rename(tempTargetName.c_str(),targetName.c_str());
					// Update the checksum since it got patched
//					RNReplicaNet::RNLobby::ScanChecksum tc;
//					tc.Start(oneEntry);
					oneEntry.mChecksum = entryInfo->mScratch.mChecksum;
					CallbackUpdateProgressFile(entryIndex.c_str(),0,0);
					break;
				}
				st++;
			}

			if (st == entryInfo->mVersions.end())
			{
				// Just use from scratch since there was no matched version with a patch found
				char patchSourceFilename[MAX_PATH];
				sprintf(patchSourceFilename,"%s\\%d.bin",patchDataURL,entryInfo->mScratch.mUniqueID);



				int retry = 0;
				const char *failedToReadFile = 0;
				do
				{
					tempName = GetRealFilePath(patchSourceFilename,entryIndex.c_str());
					if (tempName == "")
					{
						failedToReadFile = patchIndexURL;
						OpenInternet();
						continue;
					}
					MyDecompressFile decomp(this,targetName.c_str());
					ScanPath::Entry entry;
					if (decomp.DecompressFile(0,0,entry,tempName.c_str(),targetName.c_str()) < 0)
					{
						mDownloadAttemptsFailed++;
						failedToReadFile = tempName.c_str();
						OpenInternet();
						continue;
					}
					// Everything OK
					failedToReadFile = 0;
					break;
				} while (failedToReadFile && (retry++ < 5));
				if (failedToReadFile)
				{
					CallbackFailedToReadFile(failedToReadFile);
					return -1;
				}

				oneEntry.mChecksum = entryInfo->mScratch.mChecksum;
				CallbackUpdateProgressFile(entryIndex.c_str(),0,0);
			}
		}
		// MPi: TODO: Tidy this common code block with the one above. Same comment line as below.
		// Update the checksum cache
		RNReplicaNet::RNLobby::ScanPath::Entry toFind;
		toFind.mName = targetName;
		std::set<RNReplicaNet::RNLobby::ScanPath::Entry,RNReplicaNet::RNLobby::ltScanPathEntryByName>::iterator found = checksumCache.find(toFind);
		if (found != checksumCache.end())
		{
			checksumCache.erase(found);
		}
		HANDLE hnd = CreateFileA(targetName.c_str(),GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);
		if (hnd != INVALID_HANDLE_VALUE)
		{
			if (GetFileTime(hnd,0,0,&oneEntry.mLastWriteTime))
			{
				checksumCache.insert(oneEntry);
			}
			CloseHandle(hnd);
		}
		CallbackUpdateProgressProduct(numEntries++,maxNumEntries);
	}

	// Write the cache
	std::set<RNReplicaNet::RNLobby::ScanPath::Entry,RNReplicaNet::RNLobby::ltScanPathEntryByName>::iterator toSave = checksumCache.begin();
	tempScansList.clear();
	while (toSave != checksumCache.end())
	{
		tempScansList.push_back(*toSave++);
	}
	RNReplicaNet::RNLobby::ScanPath::Write(cachedChecksumIndex.c_str(),tempScansList);
	tempScansList.clear();

	CallbackUpdateProgressProduct(maxNumEntries,maxNumEntries);

	return 0;
}

std::string ProductPatcher::GetRealFilePath(const char *url,const char *patchingFile,const char *tempName)
{
	mDownloadAttempts++;
//	OutputDebugStringA("GetRealFilePath\n");

	// First try to open the url as a local file
	mFP = fopen(url,"rb");
	if (mFP)
	{
		fclose(mFP);
		mFP = 0;
		return std::string(url);
	}

	if (!CallbackUpdateDownloadPatch(patchingFile,0,0))	// MPi: TODO: Implement the file length.
	{
		return "";
	}

	int retries = 0;
	while(true)
	{
		// Open the temp file for writing.
		if (tempName)
		{
			mFP = fopen(tempName,"wb");
		}
		else
		{
			mFP = fopen(sTempPatchFile,"wb");
		}
		if (!mFP)
		{
			return "";
		}

		mFile = InternetOpenUrlA(mInternet,url,0,0,INTERNET_FLAG_NO_COOKIES | INTERNET_FLAG_EXISTING_CONNECT | INTERNET_FLAG_NO_UI | INTERNET_FLAG_RESYNCHRONIZE | INTERNET_FLAG_PASSIVE,0);

		if (!mFile)
		{
			mDownloadAttemptsFailed++;
			if (retries++ > 5)
			{
				return "";
			}
			else
			{
				OpenInternet();
				continue;
			}
		}

		DWORD totalSizeAvailable = 0;

		SysTimeType baseTime = mDownloadedOverTime;
		SysTime startDownloadTime;	

		totalSizeAvailable = InternetSetFilePointer(mFile,0,0,FILE_END,0);
		InternetSetFilePointer(mFile,0,0,FILE_BEGIN,0);
		if (totalSizeAvailable < 0)
		{
			if (!InternetQueryDataAvailable(mFile,&totalSizeAvailable,0,0))
			{
				totalSizeAvailable = 0;
			}
		}

		bool tryAgain = false;
		DWORD numRead;
		DWORD totalRead = 0;
		do
		{
			bool success;
			numRead = 0;
			success = (InternetReadFile(mFile,mTempBuffer,(DWORD)mChunkSize,&numRead) == TRUE);
			if (success)
			{
				mDownloadedBytes += numRead;
				totalRead += numRead;
				// MPi: TODO: Implement the file length as InternetQueryDataAvailable() doesn't seem to be doing the job.
				// Maybe have the file length used as the first bytes of the data stream?
				success = CallbackUpdateDownloadPatch(patchingFile,totalRead,totalSizeAvailable);
				if (!success)
				{
					// Early out if the callback indicates we should quit
					retries = 1000;
				}
			}

			mDownloadedOverTime = baseTime + startDownloadTime.FloatTime();

			if (!success)
			{
				mDownloadAttemptsFailed++;
				fclose(mFP);
				mFP = 0;

				// Delete the partial file that was downloaded
				if (tempName)
				{
					DeleteFileA(tempName);
				}
				else
				{
					DeleteFileA(sTempPatchFile);
				}

				InternetCloseHandle(mFile);
				mFile = 0;

				if (retries++ > 5)
				{
					return "";
				}
				else
				{
					OpenInternet();
					tryAgain = true;
					break;
				}
			}

//			char tmp[128];
//			sprintf(tmp,"fwrite %d\n",(int)numRead);
//			OutputDebugStringA(tmp);
			fwrite(mTempBuffer,1,numRead,mFP);
		} while (numRead > 0);

		if (tryAgain)
		{
			continue;
		}

		// Succeeded!
		fclose(mFP);
		mFP = 0;
		InternetCloseHandle(mFile);
		mFile = 0;
		break;
	}

	if (tempName)
	{
		return tempName;
	}
	return sTempPatchFile;
}

void ProductPatcher::CallbackFailedToReadFile(const char *file)
{
}

bool ProductPatcher::CallbackProcessFile(const char *file)
{
	return true;
}

void ProductPatcher::GetDownloadAttemptsAndFailed(size_t &attempts, size_t &failed) const
{
	attempts = mDownloadAttempts;
	failed = mDownloadAttemptsFailed;
}

void ProductPatcher::GetDownloadSpeed(size_t &totalBytes, float &overTime) const
{
	totalBytes = mDownloadedBytes;
	overTime = (float) mDownloadedOverTime;
}

#endif
//From: RNLobby/ScanChecksum.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifdef _WIN32
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <assert.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <list>
#include <string>
//Skipping: #include "RNLobby/Inc/ScanChecksum.h"
//Skipping: #include "RNPlatform/Inc/CheckSum.h"

using namespace RNReplicaNet::RNLobby;

ScanChecksum::ScanChecksum() : 	mPaths(0) , mFP(0) , mBuffer(0)
{
}

ScanChecksum::~ScanChecksum()
{
	Stop();
}

bool ScanChecksum::Start(std::list<ScanPath::Entry> &paths,const bool multiThread,const size_t chunkSize)
{
	// Make sure any previous thread is terminated
	Stop();

	mBuffer = malloc(chunkSize);
	if (!mBuffer)
	{
		return false;
	}

	mPaths = &paths;
	mFP = 0;
	mChunkSize = chunkSize;

	if (multiThread)
	{
		Begin(this);
		return true;
	}
	// Not using a thread so just call the thread entry
	ThreadEntry();
	return true;
}

bool ScanChecksum::Start(ScanPath::Entry &entry,const size_t chunkSize)
{
	std::list<ScanPath::Entry> paths;
	paths.push_back(entry);
	if (!Start(paths,false,chunkSize))
	{
		return false;
	}
	entry = *paths.begin();
	return true;
}

bool ScanChecksum::Stop(void)
{
	Terminate();
	if (mFP != 0)
	{
		fclose(mFP);
		mFP = 0;
	}
	free(mBuffer);

	CallbackComplete();
	return true;
}

bool ScanChecksum::GetCompleted(void)
{
	return !GetIsRunning();
}

bool ScanChecksum::CallbackUpdate(const size_t numFiles,const ScanPath::Entry &currentEntry,const size_t currentBytesScanned)
{
	return true;
}

void ScanChecksum::CallbackComplete(void)
{
}

int ScanChecksum::ThreadEntry(void)
{
	int ret = RealThreadEntry(*mPaths,mChunkSize);
	CallbackComplete();
	return ret;
}

int ScanChecksum::RealThreadEntry(std::list<ScanPath::Entry> &paths,const size_t chunkSize)
{
	std::list<ScanPath::Entry>::iterator st,en;
	st = paths.begin();
	en = paths.end();

	size_t totalFiles = 0;

	while (st != en)
	{
		ScanPath::Entry &theEntry = (*st++);

		if (!theEntry.mIsFile)
		{
			continue;
		}

		Sleep(0);	// Context switch to aid threading and is also a cancel point

		memset(theEntry.mChecksum.mValue,0,sizeof(theEntry.mChecksum.mValue));

		FILE *fp;
		const char *name = theEntry.mName.c_str();
		// mFP stores the fp in case the cancel point exits and the file handle needs closing by
		// the thread exit routine.
		mFP = fopen( name, "rb");
		fp = mFP;
		if (fp)
		{
			fseek(fp,0,SEEK_END);
			theEntry.mSize = ftell(fp);	// Ensure the file length is valid for the entry
			fseek(fp,0,SEEK_SET);

			size_t offset = 0;
			while (offset < theEntry.mSize)
			{
				Sleep(0);	// Context switch to aid threading and is also a cancel point
				size_t amountRead = fread(mBuffer,1,mChunkSize,fp);
				Checksum::ChecksumDataWithSlots(theEntry.mChecksum.mValue,sizeof(theEntry.mChecksum.mValue)/sizeof(*theEntry.mChecksum.mValue),mBuffer,(int)amountRead);

				if (!CallbackUpdate(totalFiles,theEntry,offset))
				{
					mFP = 0;
					fclose(fp);
					return 0;
				}

				offset += mChunkSize;
			}

			mFP = 0;
			fclose(fp);

			totalFiles++;
			if (!CallbackUpdate(totalFiles,theEntry,theEntry.mSize))
			{
				return 0;
			}
		}

	}

	return 0;
}
#endif
//From: RNLobby/ScanForDiffs.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifdef _WIN32
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <assert.h>
#include <map>
//Skipping: #include "RNLobby/Inc/PatchIndexManager.h"
//Skipping: #include "RNLobby/Inc/ScanForDiffs.h"
//Skipping: #include "RNLobby/Inc/ScanChecksum.h"
//Skipping: #include "RNLobby/Inc/Patcher.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"
//Skipping: #include "RNPlatform/Inc/CheckSum.h"
//Skipping: #include "RNXPCompression/Inc/XPCompression.h"
//Skipping: #include "RNPlatform/Inc/Encryption.h"
//Skipping: #include "RNPlatform/Inc/Rand.h"
//Skipping: #include "RNPlatform/Inc/Thread.h"
//Skipping: #include "RNPlatform/Inc/ThreadClass.h"
//Skipping: #include "RNPlatform/Inc/PlatformInfo.h"

namespace RNReplicaNet
{

namespace RNLobby
{

ScanForDiffs::ScanForDiffs()
{
	SetNumVersions();
}

ScanForDiffs::~ScanForDiffs()
{
}

class MyScanForDiffsPatcher : public Patcher
{
public:
	MyScanForDiffsPatcher(size_t pos,size_t max,const ScanPath::Entry &entry,ScanForDiffs *worker) :
		mPos(pos) , mMax(max) , mEntry(entry) , mWorker(worker)
		{}

	bool CallbackScanning(const size_t filePos,const size_t fileMax)
	{
		mWorker->CallbackScanning(mPos,mMax,mEntry,filePos,fileMax);
		return true;
	}

	size_t mPos;
	size_t mMax;
	const ScanPath::Entry &mEntry;
	ScanForDiffs *mWorker;
};

bool ScanForDiffs::Start(const char *patchIndexPath,const char *patchDataPath,const std::list<ScanPath::Entry> &productFiles,std::vector<size_t> &idsRemoved,const size_t stripProductPath,const size_t level)
{
	// What this does:
	// Read index if available.
	// Compare the last products by forming the versions of the products from the patch data directory.
	// Generate new patches from the last available versions to the new version.
	// Remembering to delete old unused patches if required.
	// Write the index back again.

	idsRemoved.clear();
	PatchIndexManager index;
	CreateDirectoryA(patchDataPath,0);
	RNReplicaNet::RNLobby::ScanChecksum scanChecksum;

	std::string tsCache = std::string(patchIndexPath)+".tscache";

	if (index.ReadIndex(patchIndexPath))
	{
		// Only if the index could be read then use the modified cache.
		index.ReadModified(tsCache.c_str());
	}

	index.ClearNewThisIteration();


	size_t numSegments = 6 + (mNumVersions * 3);
	size_t pos = 0,	max = (productFiles.size()*numSegments)+1;	// Roughly numSegments passes per file

	std::list<ScanPath::Entry>::const_iterator st = productFiles.begin();
	while (st != productFiles.end())
	{
		Sleep(0);
		ScanPath::Entry entry = *st++;
		std::string filename = entry.mName.substr(stripProductPath);
		PatchIndexManager::EntryInfo *entryInfo = index.GetEntryInfo(filename);

		if (!CallbackScanning(pos,max,entry,0,0))
		{
			return false;
		}

		pos+=numSegments;
		if (entryInfo)
		{
			entryInfo->mHasBeenHandled = true;

			if (!index.GetIsModified(entry.mName.c_str()))
			{
				continue;
			}

			// We have an entry!
			// Decompress the scratch entry, which is always the latest version.
			char sourceFile[MAX_PATH];
			char destFile[MAX_PATH];
			char patchFile[MAX_PATH];
			char compPatchFile[MAX_PATH];
			sprintf(sourceFile,"%s\\%d.bin",patchDataPath,entryInfo->mScratch.mUniqueID);
			sprintf(destFile,"%s\\t%d.bin",patchDataPath,entryInfo->mScratch.mUniqueID);
			sprintf(patchFile,"%s\\tp%d.bin",patchDataPath,entryInfo->mScratch.mUniqueID);
			// TODO: MPi: Here there could be a paranoia check that the from scratch checksum equals the checksum of the decompressed file.
			int relLen = DecompressFile(pos-numSegments,max,entry,sourceFile,destFile);

			MyScanForDiffsPatcher patcher(pos-numSegments+1,max,entry,this);
			// TODO: MPi: Here there is scope for checking the checksum before generating the diff.
			int ret = patcher.GeneratePatch(destFile,entry.mName.c_str(),patchFile,level);
			DeleteFileA(destFile);
			if (ret == 0)
			{
				// No change
				DeleteFileA(patchFile);
				continue;
			}

			// Create a potential patch version info block for this existing entry
			PatchIndexManager::VersionInfo newVersion;
			newVersion.mChecksum = entryInfo->mScratch.mChecksum;
			newVersion.mUniqueID = index.GetUniqueID();
			newVersion.mProductVersion = index.GetProductVersion();
			newVersion.mNewThisIteration = true;

			// Now create the new from scratch entry
			scanChecksum.Start(entry);
			entryInfo->mScratch.mUniqueID = index.GetUniqueID();
			entryInfo->mScratch.mNewThisIteration = true;
			entryInfo->mScratch.mChecksum = entry.mChecksum;
			entryInfo->mScratch.mProductVersion = index.GetProductVersion();

			sprintf(destFile,"%s\\%d.bin",patchDataPath,entryInfo->mScratch.mUniqueID);
			int compressedScratchSize = CompressFile(pos-numSegments+2,max,entry,entry.mName.c_str(),destFile,(int)level);	// MPi: TODO: Expose the chunk size of compressed files.
			if (compressedScratchSize == -1)
			{
				return false;
			}
			entryInfo->mScratch.mDataFileSize = (unsigned int) compressedScratchSize;

			// Check to see which is going to be shorter, the compressed diff or the compressed file on its own.
			sprintf(compPatchFile,"%s\\cp%d.bin",patchDataPath,newVersion.mUniqueID);
			int cp = CompressFile(pos-numSegments+3,max,entry,patchFile,compPatchFile,(int)level);	// MPi: TODO: Expose the chunk size of compressed files.
			if (cp == -1)
			{
				return false;
			}
			DeleteFileA(patchFile);
			if (cp < compressedScratchSize)
			{
				// This version has a patch that is smaller than the from scratch file then keep the patch
				newVersion.mIsPatch = true;
				sprintf(destFile,"%s\\%d.bin",patchDataPath,newVersion.mUniqueID);
				rename(compPatchFile,destFile);
				newVersion.mDataFileSize = (unsigned int) cp;
			}
			else
			{
				// This version has a patch that is bigger than the from scratch file then keep the scratch file as a backup
				newVersion.mIsPatch = false;
				DeleteFileA(compPatchFile);
				newVersion.mDataFileSize = (unsigned int) compressedScratchSize;
			}
			// Keep the old compressed scratch file for reference
			sprintf(destFile,"%s\\_%d.bin",patchDataPath,newVersion.mUniqueID);
			rename(sourceFile,destFile);

			newVersion.mProductVersion = index.GetProductVersion();
			entryInfo->mVersions.push_front(newVersion);

			if (entryInfo->mNumMaxVersions > 0)
			{
				while (entryInfo->mVersions.size() > entryInfo->mNumMaxVersions)
				{
					PatchIndexManager::VersionInfo &versionInfo = entryInfo->mVersions.back();
					if (versionInfo.mIsPatch)
					{
						sprintf(destFile,"%s\\%d.bin",patchDataPath,versionInfo.mUniqueID);
						DeleteFileA(destFile);	// Delete the patch since we won't be needing it.
					}
					sprintf(destFile,"%s\\_%d.bin",patchDataPath,versionInfo.mUniqueID);
					DeleteFileA(destFile);	// Delete the backup from scratch since we won't be needing it.
					idsRemoved.push_back(versionInfo.mUniqueID);
					entryInfo->mVersions.pop_back();
				}
			}

			// Parse the version blocks to see if we generate any patches from those versions.
			std::list<PatchIndexManager::VersionInfo>::iterator st = entryInfo->mVersions.begin();
			size_t counter = 0;
			while(st != entryInfo->mVersions.end())
			{
				std::list<PatchIndexManager::VersionInfo>::iterator now = st;
				PatchIndexManager::VersionInfo &versionInfo = *st++;
				// Skip ones we have added this time around
				if (versionInfo.mProductVersion == index.GetProductVersion() || versionInfo.mNewThisIteration)
				{
					continue;
				}

				if (!index.GetIsModified(entry.mName.c_str()))
				{
					continue;
				}

				char sourceFile[MAX_PATH];
				char destFile[MAX_PATH];
				char patchFile[MAX_PATH];
				char compPatchFile[MAX_PATH];

				sprintf(sourceFile,"%s\\_%d.bin",patchDataPath,versionInfo.mUniqueID);
				sprintf(destFile,"%s\\t%d.bin",patchDataPath,versionInfo.mUniqueID);
				sprintf(patchFile,"%s\\tp%d.bin",patchDataPath,versionInfo.mUniqueID);
				// TODO: MPi: Here there could be a paranoia check that the from scratch checksum equals the checksum of the decompressed file.
				// Decompress the backup compressed file
				int relLen = DecompressFile(pos-numSegments+4+counter,max,entry,sourceFile,destFile);
				counter++;

				MyScanForDiffsPatcher patcher(pos-numSegments+4+counter,max,entry,this);
				counter++;
				// TODO: MPi: Here there is scope for checking the checksum before generating the diff.
				int ret = patcher.GeneratePatch(destFile,entry.mName.c_str(),patchFile,level);
				Sleep(0);
				DeleteFileA(destFile);
				if (ret == 0)
				{
					// No change
					DeleteFileA(patchFile);
					continue;
				}
				// There is a difference
				// Delete the old patch file
				if (versionInfo.mIsPatch)
				{
					sprintf(destFile,"%s\\%d.bin",patchDataPath,versionInfo.mUniqueID);
					DeleteFileA(destFile);	// Delete the patch since we won't be needing it.
					idsRemoved.push_back(versionInfo.mUniqueID);
				}

				// Create a new patch for this existing entry with a new uniqueID
				versionInfo.mUniqueID = index.GetUniqueID();

				// Rename the old compressed version of this file to this new ID so we see it on later iterations.
				sprintf(destFile,"%s\\_%d.bin",patchDataPath,versionInfo.mUniqueID);
				rename(sourceFile,destFile);

				versionInfo.mNewThisIteration = true;

				// Check to see which is going to be shorter, the compressed diff or the compressed file on its own.
				sprintf(compPatchFile,"%s\\cp%d.bin",patchDataPath,versionInfo.mUniqueID);
				int cp = CompressFile(pos-numSegments+4+counter,max,entry,patchFile,compPatchFile,(int)level);	// MPi: TODO: Expose the chunk size of compressed files.
				counter++;
				if (cp == -1)
				{
					return false;
				}
				DeleteFileA(patchFile);
				if (cp < compressedScratchSize)
				{
					versionInfo.mIsPatch = true;
					sprintf(destFile,"%s\\%d.bin",patchDataPath,versionInfo.mUniqueID);
					rename(compPatchFile,destFile);
					versionInfo.mDataFileSize = (unsigned int) cp;
				}
				else
				{
					DeleteFileA(compPatchFile);
					versionInfo.mIsPatch = false;
					versionInfo.mDataFileSize = (unsigned int) compressedScratchSize;
				}
			}
		}	// if (entryInfo)

		// No entry so create one instead
		PatchIndexManager::EntryInfo newEntry;
		newEntry.mHasBeenHandled = true;
		newEntry.mNumMaxVersions = (unsigned int) mNumVersions;	// TODO: MPi: Expose this as a user defined value.
		scanChecksum.Start(entry);
		newEntry.mScratch.mUniqueID = index.GetUniqueID();
		newEntry.mScratch.mNewThisIteration = true;
		newEntry.mScratch.mChecksum = entry.mChecksum;
		newEntry.mScratch.mProductVersion = index.GetProductVersion();
		index.AddEntryInfo(filename,newEntry);
		char destFile[MAX_PATH];
		sprintf(destFile,"%s\\%d.bin",patchDataPath,newEntry.mScratch.mUniqueID);
		int tr = CompressFile(pos-numSegments+5+(mNumVersions*3),max,entry,entry.mName.c_str(),destFile,(int)level);	// MPi: TODO: Expose the chunk size of compressed files.
		if (tr == -1)
		{
			return false;
		}
		newEntry.mScratch.mDataFileSize = (unsigned int) tr;
	}

	ScanPath::Entry entry;	// A blank entry
	// Note: This last one uses max,max to make sure the last callback update indicates a completed scan.
	if (!CallbackScanning(max,max,entry,0,0))
	{
		return false;
	}

// Paranoia checking for the database produced
#ifdef _DEBUG
	PatchIndexManager::EntryInfo *entryInfo;
	index.BeginIterate();
	std::string sindex;
	while ( (entryInfo = index.Iterate(sindex)) != 0)
	{
		FILE *fp;
		char file[MAX_PATH];
		sprintf(file,"%s\\%d.bin",patchDataPath,entryInfo->mScratch.mUniqueID);
		fp = fopen(file,"rb");
		assert(fp);
		fclose(fp);

		std::list<PatchIndexManager::VersionInfo>::iterator st = entryInfo->mVersions.begin();
		while(st != entryInfo->mVersions.end())
		{
			PatchIndexManager::VersionInfo &versionInfo = *st++;
			if (versionInfo.mIsPatch)
			{
				sprintf(file,"%s\\%d.bin",patchDataPath,versionInfo.mUniqueID);
				fp = fopen(file,"rb");
				assert(fp);
				fclose(fp);
			}
			sprintf(file,"%s\\_%d.bin",patchDataPath,versionInfo.mUniqueID);
			fp = fopen(file,"rb");
			assert(fp);
			fclose(fp);
		}
	}
#endif

	index.RemoveUnhandled();
	index.SetProductVersion(index.GetProductVersion()+1);
	index.WriteIndex(patchIndexPath);
	index.WriteModified(tsCache.c_str());

	return true;
}

bool ScanForDiffs::CallbackScanning(size_t pos,size_t max,const ScanPath::Entry &entry,const size_t filePos,const size_t fileMax)
{
	return true;
}

void ScanForDiffs::SetNumVersions(const size_t numVersions)
{
	mNumVersions = numVersions;
}

size_t ScanForDiffs::GetNumVersions(void)
{
	return mNumVersions;
}

static const unsigned int kScanForDiffsVersion = 0;
static const unsigned int kScanForDiffsMagic = 0xa2be4a7b;

class ScanForDiffsWorker : public ThreadClass , public Thread
{
public:
	ScanForDiffsWorker();
	virtual ~ScanForDiffsWorker();

	virtual int ThreadEntry(void);

	std::list<long> *mLeftToGet;
	MutexClass *mLeftToGetMutex;
	const char *mSourceFile;
	const char *mDestinationFile;
	size_t mChunkSize;
	long mRealLen;
	int mLevel;
	volatile size_t *mNumProcessed;
};

ScanForDiffsWorker::ScanForDiffsWorker() : mLeftToGet( 0 ) , mLeftToGetMutex( 0 ) , mSourceFile( 0 ) , mDestinationFile( 0 ) , mChunkSize( 0 ) , mRealLen( 0 ) , mLevel( 0 ) , mNumProcessed( 0 )
{
}

ScanForDiffsWorker::~ScanForDiffsWorker()
{
}

int ScanForDiffsWorker::ThreadEntry(void)
{
	bool anyLeft = true;
	while ( anyLeft )
	{
//		printf( "ThreadEntry loop1 %p\n" , this );
		{// Stack context for CheckQuit()
		int thePos = 0;
		mLeftToGetMutex->Lock();
		if ( !mLeftToGet->empty() )
		{
			thePos = mLeftToGet->front();
			mLeftToGet->pop_front();
		}
		else
		{
			anyLeft = false;
		}
		mLeftToGetMutex->UnLock();
		if ( !anyLeft )
		{
			// Ends the loop
			continue;
		}

		XPCompression comp;
		DynamicMessageHelper tempData( 0 , (int)mChunkSize );
		DynamicMessageHelper tempCompData( 0 , comp.CalculateMaximumMemory((int)mChunkSize) );

		FILE *in;
		in = fopen(mSourceFile,"rb");
		if (!in)
		{
//			printf( "ThreadEntry return1 %p\n" , this );
			return -1;
		}


		fseek( in , thePos , SEEK_SET );
		unsigned int read = (unsigned int)fread(tempData.GetBuffer(),1,mChunkSize,in);

		fclose( in );

		char thePostFix[100];
		sprintf( thePostFix , "%d" , thePos );
		std::string outFilename = mDestinationFile;
		outFilename += thePostFix;

		FILE *out = fopen( outFilename.c_str() , "wb" );
		if ( !out )
		{
//			printf( "ThreadEntry return2 %p\n" , this );
			return -1;
		}

		DynamicMessageHelper outData;
		MESSAGEHELPER_ADDVARIABLEp(outData,read);
		int randomKey = RNReplicaNet::Rand::FastWeak();
		int outSize;
//		printf( "Compress %p %s\n" , this , outFilename.c_str() );
		comp.Compress(tempData.GetBuffer(),(int)read,tempCompData.GetBuffer(),&outSize,(int)mLevel);
//		printf( "EndComp  %p %s\n" , this , outFilename.c_str() );
		MESSAGEHELPER_ADDVARIABLEp(outData,randomKey);
		MESSAGEHELPER_ADDVARIABLEp(outData,outSize);
		int checksum = Checksum::ChecksumData(tempCompData.GetBuffer(),outSize);
		MESSAGEHELPER_ADDVARIABLEp(outData,checksum);	// Version 1 addition
		Encryption::Key key;
		key.Create(&randomKey,sizeof(randomKey));
		Encryption::Encrypt(tempCompData.GetBuffer(),outSize,&key);

//		printf( "Writing  %p %s\n" , this , outFilename.c_str() );

		fwrite(outData.GetBuffer(),1,outData.GetSize(),out);
		fwrite(tempCompData.GetBuffer(),1,outSize,out);

		fclose( out );
		(*mNumProcessed)++;

		}// End stack context for CheckQuit()
		Sleep(0);
		CheckQuit();
	}

//	printf( "ThreadEntry end %p\n" , this );
	return 0;
}

int ScanForDiffs::CompressFile(size_t pos,size_t max,const ScanPath::Entry &entry,const char *sourceFile,const char *destinationFile,const size_t level,const size_t chunkSize , const bool useCores )
{
	if (!CallbackScanning(pos,max,entry,0,0))
	{
		return -1;
	}

	long numCores = 1;
	if ( useCores )
	{
		numCores = PlatformInfo::GetNumberOfCores();
	}
	if ( numCores > 1 )
	{
		FILE *in;
		in = fopen(sourceFile,"rb");
		if (!in)
		{
			return -1;
		}
		fseek( in , 0 , SEEK_END );
		long realLen = ftell( in );
		fclose( in );

		std::list<long> leftToGet;
		MutexClass leftToGetMutex;
		std::vector<ScanForDiffsWorker> workers;
		workers.resize( numCores );

		volatile size_t numProcessed = 0;
		long i;
		for ( i = 0 ; i < realLen ; i += (long)chunkSize )
		{
			leftToGet.push_back( i );
		}
		for ( i = 0 ; i < numCores ; i++ )
		{
			workers[i].mLeftToGet = &leftToGet;
			workers[i].mLeftToGetMutex = &leftToGetMutex;
			workers[i].mSourceFile = sourceFile;
			workers[i].mDestinationFile = destinationFile;
			workers[i].mChunkSize = chunkSize;
			workers[i].mRealLen = realLen;
			workers[i].mLevel = (int)level;
			workers[i].mNumProcessed = &numProcessed;
			workers[i].Begin( &workers[i] );
		}

		// Now wait for everything to finish
		int numRunning = 0;
		do 
		{
			numRunning = numCores;
			for ( i = 0 ; i < numCores ; i++ )
			{
				if ( !workers[i].GetIsRunning() )
				{
					numRunning--;
				}
			}
			if ( numRunning )
			{
				CurrentThread::Sleep(0);

				// Only allow a cancel if the list isn't empty
				if ( !CallbackScanning(pos , max , entry , numProcessed * chunkSize , realLen ))
				{
					// Stop any threads
					for ( i = 0 ; i < numCores ; i++ )
					{
						workers[i].Terminate();
					}
					// Tidy up any temp files
					for ( i = 0 ; i < realLen ; i += (long) chunkSize )
					{
						char thePostFix[100];
						sprintf( thePostFix , "%d" , (int) i );
						std::string inFilename = destinationFile;
						inFilename += thePostFix;

						DeleteFileA( inFilename.c_str() );
					}
					return -1;
				}
			}
		} while ( numRunning );

		if ( !leftToGet.empty() )
		{
			return -1;
		}

		// Now reassemble the bits
		FILE *out;
		out = fopen(destinationFile,"wb");
		if (!out)
		{
			return -1;
		}

		DynamicMessageHelper outData;
		outData << kScanForDiffsMagic;
		outData << kScanForDiffsVersion;
		unsigned int len = (unsigned int ) realLen;
		MESSAGEHELPER_ADDVARIABLEp(outData,len);
		fwrite(outData.GetBuffer(),1,outData.GetSize(),out);

		DynamicMessageHelper inData( (int) chunkSize );

		for ( i = 0 ; i < realLen ; i += (long) chunkSize )
		{
			char thePostFix[100];
			sprintf( thePostFix , "%d" , (int) i );
			std::string inFilename = destinationFile;
			inFilename += thePostFix;

			in = fopen( inFilename.c_str() , "rb" );
			if ( !in )
			{
				fclose(out);
				return -1;
			}
			while ( !feof( in ) )
			{
				size_t read = fread( inData.GetBuffer() , 1 , (size_t) inData.GetBufferSize() , in );
				if ( read )
				{
					fwrite( inData.GetBuffer() , 1 , read , out );
				}
			}
			fclose( in );
			DeleteFileA( inFilename.c_str() );
		}

		len = ftell(out);
		fclose(out);

		if (!CallbackScanning(pos,max,entry,realLen,realLen))
		{
			return -1;
		}

		return (int) len;
	}

	// Not using multiple cores
	XPCompression comp;
	DynamicMessageHelper tempData( 0 , (int)chunkSize );
	DynamicMessageHelper tempCompData( 0 , comp.CalculateMaximumMemory((int)chunkSize) );

	FILE *in,*out;
	in = fopen(sourceFile,"rb");
	if (!in)
	{
		return -1;
	}
	out = fopen(destinationFile,"wb");
	if (!out)
	{
		fclose(in);
		return -1;
	}
	fseek(in,0,SEEK_END);
	unsigned int realLen,len;
	realLen = len = (unsigned int) ftell(in);
	fseek(in,0,SEEK_SET);
	DynamicMessageHelper outData;
	outData << kScanForDiffsMagic;
	outData << kScanForDiffsVersion;
	MESSAGEHELPER_ADDVARIABLEp(outData,len);
	fwrite(outData.GetBuffer(),1,outData.GetSize(),out);
	if (!CallbackScanning(pos,max,entry,0,realLen))
	{
		return -1;
	}
	while (len)
	{
		outData.SetSize(0);
		unsigned int read = (unsigned int)fread(tempData.GetBuffer(),1,chunkSize,in);
		len -= read;
		MESSAGEHELPER_ADDVARIABLEp(outData,read);
		int randomKey = RNReplicaNet::Rand::FastWeak();
		int outSize;
		comp.Compress(tempData.GetBuffer(),(int)read,tempCompData.GetBuffer(),&outSize,(int)level);
		MESSAGEHELPER_ADDVARIABLEp(outData,randomKey);
		MESSAGEHELPER_ADDVARIABLEp(outData,outSize);
		int checksum = Checksum::ChecksumData(tempCompData.GetBuffer(),outSize);
		MESSAGEHELPER_ADDVARIABLEp(outData,checksum);	// Version 1 addition
		Encryption::Key key;
		key.Create(&randomKey,sizeof(randomKey));
		Encryption::Encrypt(tempCompData.GetBuffer(),outSize,&key);
		fwrite(outData.GetBuffer(),1,outData.GetSize(),out);
		fwrite(tempCompData.GetBuffer(),1,outSize,out);

		if (!CallbackScanning(pos,max,entry,realLen - len,realLen))
		{
			fclose(in);
			fclose(out);
			return -1;
		}
	}
	len = ftell(out);

	fclose(in);
	fclose(out);

	if (!CallbackScanning(pos,max,entry,realLen,realLen))
	{
		return -1;
	}
	return (int) len;
}

int ScanForDiffs::DecompressFile(size_t pos,size_t max,const ScanPath::Entry &entry,const char *sourceFile,const char *destinationFile)
{
	FILE *in,*out;
	in = fopen(sourceFile,"rb");
	if (!in)
	{
		return -1;
	}
	out = fopen(destinationFile,"wb");
	if (!out)
	{
		fclose(in);
		return -1;
	}
	DynamicMessageHelper inData( 0 , 1024 );
	if (fread(inData.GetBuffer(),1,sizeof(unsigned int)*3,in) != (sizeof(unsigned int)*3))
	{
		fclose(in);
		fclose(out);
		return -1;
	}
	unsigned int len,retLen;
	unsigned int magic;
	unsigned int version;
	inData >> magic;
	inData >> version;
	MESSAGEHELPER_GETVARIABLEp(inData,len);

	if (magic != kScanForDiffsMagic)
	{
		fclose(in);
		fclose(out);
		return -1;
	}
	// Expand this for other version checks if needed in the future. I don't see this format
	// changing much to be honest.
	if (version != 0)
	{
		fclose(in);
		fclose(out);
		return -1;
	}

	DynamicMessageHelper decompData;

	retLen = len;
	if (!CallbackScanning(pos,max,entry,0,retLen))
	{
		fclose(in);
		fclose(out);
		return -1;
	}
	while (len)
	{
		inData.SetSize(0);
		inData.SetBufferSize(1024);
		inData.EnsureBufferAllocated();
		size_t freadRet = fread(inData.GetBuffer(),1,sizeof(unsigned int) + (sizeof(int)*3),in);
		unsigned int read;
		int randomKey;
		int outSize;
		int checksum;
		MESSAGEHELPER_GETVARIABLEp(inData,read);
		MESSAGEHELPER_GETVARIABLEp(inData,randomKey);
		MESSAGEHELPER_GETVARIABLEp(inData,outSize);
		MESSAGEHELPER_GETVARIABLEp(inData,checksum);

		len -= read;
		inData.SetSize(0);
		inData.SetBufferSize(outSize);
		inData.EnsureBufferAllocated();
		decompData.SetSize(0);
		decompData.SetBufferSize((int)read);
		decompData.EnsureBufferAllocated();
		freadRet = fread(inData.GetBuffer(),1,outSize,in);
		Encryption::Key key;
		key.Create(&randomKey,sizeof(randomKey));
		Encryption::Decrypt(inData.GetBuffer(),outSize,&key);

		// Check if the compressed data after decryption is valid
		int checksumCalc = Checksum::ChecksumData(inData.GetBuffer(),outSize);
		if (checksumCalc != checksum)
		{
			return -1;
		}

		XPCompression comp;
		int testLen;
		comp.Decompress(inData.GetBuffer(),outSize,decompData.GetBuffer(),&testLen,decompData.GetBufferSize());
		assert(testLen == read);
		if (testLen != read)
		{
			fclose(in);
			fclose(out);
			return -1;
		}
		fwrite(decompData.GetBuffer(),1,read,out);

		if (!CallbackScanning(pos,max,entry,retLen - len,retLen))
		{
			fclose(in);
			fclose(out);
			return -1;
		}
	}

	fclose(in);
	fclose(out);

	if (!CallbackScanning(pos,max,entry,retLen,retLen))
	{
		return -1;
	}
	return (int) retLen;
}

};
};
#endif
//From: RNLobby/ScanPath.cpp
/* START_LICENSE_HEADER

Copyright (C) 2000 Martin Piper, original design and program code
Copyright (C) 2001 Replica Software

This program file is copyright (C) Replica Software and can only be used under license.
For more information visit: http://www.replicanet.com/
Or email: info@replicanet.com

END_LICENSE_HEADER */
#ifdef _WIN32
//Skipping: #include "RNPlatform/Inc/MemoryTracking.h"
#include <assert.h>
#include <time.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <TCHAR.h>
#include <list>
#include <string>
//Skipping: #include "RNLobby/Inc/ScanPath.h"
//Skipping: #include "RNPlatform/Inc/MessageHelper.h"

namespace RNReplicaNet
{

namespace RNLobby
{

bool operator< (const ScanPath::Entry& a,const ScanPath::Entry& b)
{
	return strcmp(a.mName.c_str() , b.mName.c_str()) < 0;
}

static const unsigned int kScanPathMagic = 0x47ac89ef;
static const unsigned int kScanPathVersion = 0;

ScanPath::Entry::Entry()
{
	mSize = 0;
	mIsDirectory = false;
	mIsLink = false;
	mIsFile = false;
	memset(mChecksum.mValue,0,sizeof(mChecksum.mValue));
}

ScanPath::ScanPath() : 	mResult(0) , mRecurse(false) , mJustFiles(false) , mhSearch(INVALID_HANDLE_VALUE)
{
}

ScanPath::~ScanPath()
{
	Stop();
}

bool ScanPath::Start(const char *path,std::list<Entry> &result,const bool recurse,const bool justFiles,const bool multiThread)
{
	// Make sure any previous thread is terminated
	Stop();

	mPath = path;
	mResult = &result;
	mRecurse = recurse;
	mJustFiles = justFiles;
	mhSearch = INVALID_HANDLE_VALUE;

	if (multiThread)
	{
		Begin(this);
		return true;
	}
	// Not using a thread so just call the thread entry
	ThreadEntry();
	return true;
}

bool ScanPath::Stop(void)
{
	Terminate();
	if (mhSearch != INVALID_HANDLE_VALUE)
	{
		CloseHandle(mhSearch);
		mhSearch = INVALID_HANDLE_VALUE;
	}

	CallbackComplete();
	return true;
}

bool ScanPath::GetCompleted(void)
{
	return !GetIsRunning();
}

bool ScanPath::CallbackUpdate(const size_t numFiles,const size_t numFolders)
{
	return true;
}

void ScanPath::CallbackComplete(void)
{
}

int ScanPath::ThreadEntry(void)
{
	int ret = RealThreadEntry(mPath,*mResult,mRecurse,mJustFiles);
	CallbackComplete();
	return ret;
}

// MPi: TODO: This is windows code and needs to be made cross platform to Linux
int ScanPath::RealThreadEntry(const std::string path,std::list<Entry> &results,const bool recurse,const bool justFiles)
{
	std::string directory = path;
	while (directory.rfind('\\') == (directory.length()-1))
	{
		directory.erase(directory.length()-1);
	}

	size_t totalDirs = 0;
	size_t totalFiles = 0;

	std::list<std::string> others;
	others.push_back(directory);

	if (!justFiles)
	{
		Entry entry;
		entry.mName = directory;
		entry.mIsDirectory = true;
		// Stack context for safe lock
		THREADSAFELOCK();
		results.push_back(entry);
		totalDirs++;
		if (!CallbackUpdate(totalFiles,totalDirs))
		{
			return 0;
		}
	}

	while (!others.empty())
	{
		WIN32_FIND_DATAA findData;
		std::string thePath = *others.begin();
		std::string theDirectory = thePath;

		if (theDirectory.rfind('*') != std::string::npos)
		{
			std::string::size_type lastDirPos = theDirectory.rfind('\\');
			if (std::string::npos != lastDirPos)
			{
				theDirectory.erase(lastDirPos);
			}
		}


		others.pop_front();
		if (thePath.find("*") != std::string::npos)
		{
			mhSearch = FindFirstFileA(thePath.c_str(),&findData);
		}
		else
		{
			mhSearch = FindFirstFileA((thePath+"\\*").c_str(),&findData);
		}
		if (mhSearch != INVALID_HANDLE_VALUE)
		{
			do
			{
				if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
					// Skip result starting with '.' because it is the system stuff
					if (findData.cFileName[0] == '.')
					{
						continue;
					}
					if (recurse)
					{
						std::string newPath = theDirectory + "\\" + findData.cFileName;
						others.push_back(newPath);
						if (!justFiles)
						{
							Entry entry;
							entry.mName = newPath;
							entry.mIsDirectory = true;
							// Stack context for safe lock
							{
								THREADSAFELOCK();
								results.push_back(entry);
							}
							totalDirs++;
							CallbackUpdate(totalFiles,totalDirs);
						}
					}
					continue;
				}
				Entry entry;
				entry.mName = theDirectory + "\\" + findData.cFileName;
				entry.mIsFile = true;
				entry.mSize = (unsigned int) findData.nFileSizeLow;
				entry.mLastWriteTime = findData.ftLastWriteTime;
				// Stack context for safe lock
				{
					THREADSAFELOCK();
					results.push_back(entry);
				}
				totalFiles++;
				if (!CallbackUpdate(totalFiles,totalDirs))
				{
					others.clear();
					break;
				}
			} while ( FindNextFileA(mhSearch,&findData) );
			HANDLE temp = mhSearch;
			mhSearch = 0;
			FindClose(temp);
		}
	}

	return 0;
}

/// A utility function to write the entries to a file.
bool ScanPath::Write(const char *path,const std::list<Entry> &entries)
{
	DynamicMessageHelper message;

	message << kScanPathMagic;
	message << kScanPathVersion;

	std::list<Entry>::const_iterator st = entries.begin();
	while (st != entries.end())
	{
		const Entry &entry = *st++;
		message << entry.mName;
		message << entry.mIsDirectory;
		message << entry.mIsLink;
		message << entry.mIsFile;
		message.AddData(&entry.mLastWriteTime,sizeof(entry.mLastWriteTime));
		message.AddData(&entry.mChecksum,sizeof(entry.mChecksum));
	}

	return message.Write(path);
}

/// A utility function to read the entries from a file.
bool ScanPath::Read(const char *path,std::list<Entry> &entries)
{
	DynamicMessageHelper message;
	if (!message.Read(path))
	{
		return false;
	}

	unsigned int temp;
	message >> temp;
	if (temp != kScanPathMagic)
	{
		return false;
	}
	// Get the version
	message >> temp;
	switch(temp)
	{
		default:
			return false;
		break;
		case 0:
		{
			while (message.GetSize() < message.GetBufferSize())
			{
				Entry entry;
				message >> entry.mName;
				message >> entry.mIsDirectory;
				message >> entry.mIsLink;
				message >> entry.mIsFile;
				message.GetData(&entry.mLastWriteTime,sizeof(entry.mLastWriteTime));
				message.GetData(&entry.mChecksum,sizeof(entry.mChecksum));
				entries.push_back(entry);
			}
		}
		break;
	}
	return true;
}


};	// namespace RNLobby
};	// namespace RNReplicaNet
#endif
#endif
