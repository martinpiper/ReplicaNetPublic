<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ReplicaNet and RNLobby: XPURL Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ReplicaNet and RNLobby
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>RNReplicaNet</b></li><li class="navelem"><a class="el" href="classRNReplicaNet_1_1XPURL.html">XPURL</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classRNReplicaNet_1_1XPURL-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XPURL Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="XPURL_8h_source.html">XPURL.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for XPURL:</div>
<div class="dyncontent">
<div class="center"><img src="classRNReplicaNet_1_1XPURL__inherit__graph.png" border="0" usemap="#XPURL_inherit__map" alt="Inheritance graph"/></div>
<map name="XPURL_inherit__map" id="XPURL_inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3897b6b460c17489fbfdf2c8122bfd9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1XPURL.html#a3897b6b460c17489fbfdf2c8122bfd9e">XPURL</a> ()</td></tr>
<tr class="separator:a3897b6b460c17489fbfdf2c8122bfd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e404e640f9883a96fbe0966ce4ca8e2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1XPURL.html#a4e404e640f9883a96fbe0966ce4ca8e2">~XPURL</a> ()</td></tr>
<tr class="separator:a4e404e640f9883a96fbe0966ce4ca8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08780bb68616ea605c9d2279116a996"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1XPURL.html#aa08780bb68616ea605c9d2279116a996">BeginEnumerateTransports</a> (void)</td></tr>
<tr class="separator:aa08780bb68616ea605c9d2279116a996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51e18ba6d361e51611f1d7e5e0b2c47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRNReplicaNet_1_1Transport.html">Transport</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1XPURL.html#ab51e18ba6d361e51611f1d7e5e0b2c47">EnumerateTransports</a> (void)</td></tr>
<tr class="separator:ab51e18ba6d361e51611f1d7e5e0b2c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e26dc48abcb0a3adb06f6abb351eab7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1XPURL.html#a5e26dc48abcb0a3adb06f6abb351eab7">ParseURLs</a> (const std::string urls)</td></tr>
<tr class="separator:a5e26dc48abcb0a3adb06f6abb351eab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e5d0689ab10e993cfea71d5f248cca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1XPURL.html#a52e5d0689ab10e993cfea71d5f248cca">Poll</a> (void)</td></tr>
<tr class="separator:a52e5d0689ab10e993cfea71d5f248cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108af1ac13bb52b2c2d764701791e702"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1XPURL.html#a108af1ac13bb52b2c2d764701791e702">SetManualPoll</a> (void)</td></tr>
<tr class="separator:a108af1ac13bb52b2c2d764701791e702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b53d44ad3a5a7324104b300f78c2522"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1XPURL.html#a9b53d44ad3a5a7324104b300f78c2522">SetAutomaticPoll</a> (void)</td></tr>
<tr class="separator:a9b53d44ad3a5a7324104b300f78c2522"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a71d248d798aced3981f48cc61adc0d1b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1XPURL.html#a71d248d798aced3981f48cc61adc0d1b">RegisterTransport</a> (<a class="el" href="classRNReplicaNet_1_1Transport.html">Transport</a> &amp;transport)</td></tr>
<tr class="separator:a71d248d798aced3981f48cc61adc0d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97974fbf1827f8d4116c4906510a06d5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1XPURL.html#a97974fbf1827f8d4116c4906510a06d5">RegisterDefaultTransports</a> (void)</td></tr>
<tr class="separator:a97974fbf1827f8d4116c4906510a06d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd643e7202e7c195ed11c32fb6d6e253"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRNReplicaNet_1_1Transport.html">Transport</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1XPURL.html#acd643e7202e7c195ed11c32fb6d6e253">FindTransport</a> (const std::string url)</td></tr>
<tr class="separator:acd643e7202e7c195ed11c32fb6d6e253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c639a6c05835e92fea28d299345dee"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1XPURL.html#a18c639a6c05835e92fea28d299345dee">FreeTransport</a> (<a class="el" href="classRNReplicaNet_1_1Transport.html">Transport</a> *transport)</td></tr>
<tr class="separator:a18c639a6c05835e92fea28d299345dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac1e065c9253999e3d1d98c02c719c9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1XPURL.html#a2ac1e065c9253999e3d1d98c02c719c9">InitialiseNetwork</a> (const bool hardware=false)</td></tr>
<tr class="separator:a2ac1e065c9253999e3d1d98c02c719c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f146130479b62cb3d69539f732d655"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1XPURL.html#af3f146130479b62cb3d69539f732d655">ShutdownNetwork</a> (const bool hardware=false)</td></tr>
<tr class="separator:af3f146130479b62cb3d69539f732d655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9417f435d02b12d9edca1b01a21ebba"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRNReplicaNet_1_1DebugHandler.html">DebugHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1XPURL.html#ae9417f435d02b12d9edca1b01a21ebba">RegisterDebugHandler</a> (<a class="el" href="classRNReplicaNet_1_1DebugHandler.html">DebugHandler</a> *debugHandler=0)</td></tr>
<tr class="separator:ae9417f435d02b12d9edca1b01a21ebba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1533f9c851623727e8492ba63660efe7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRNReplicaNet_1_1DebugHandler.html">DebugHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1XPURL.html#a1533f9c851623727e8492ba63660efe7">GetDebugHandler</a> (void)</td></tr>
<tr class="separator:a1533f9c851623727e8492ba63660efe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classRNReplicaNet_1_1XPURL.html">XPURL</a> decodes and encodes URLs and acts as a common method for interfacing various networking protocols. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3897b6b460c17489fbfdf2c8122bfd9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRNReplicaNet_1_1XPURL.html">XPURL</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The ctor for an <a class="el" href="classRNReplicaNet_1_1XPURL.html">XPURL</a> </p>

</div>
</div>
<a class="anchor" id="a4e404e640f9883a96fbe0966ce4ca8e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classRNReplicaNet_1_1XPURL.html">XPURL</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The dtor for an <a class="el" href="classRNReplicaNet_1_1XPURL.html">XPURL</a> This cleans up everything for this class </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa08780bb68616ea605c9d2279116a996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BeginEnumerateTransports </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts enumerating the current number of <a class="el" href="classRNReplicaNet_1_1Transport.html">Transport</a> types </p>

</div>
</div>
<a class="anchor" id="ab51e18ba6d361e51611f1d7e5e0b2c47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRNReplicaNet_1_1Transport.html">Transport</a>* EnumerateTransports </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumerates the <a class="el" href="classRNReplicaNet_1_1Transport.html">Transport</a> list, <a class="el" href="classRNReplicaNet_1_1XPURL.html#aa08780bb68616ea605c9d2279116a996">BeginEnumerateTransports()</a> must be called before this function Call this function repeatedly in a loop to enumerate through the list </p>
<dl class="section return"><dt>Returns</dt><dd>the next <a class="el" href="classRNReplicaNet_1_1Transport.html">Transport</a> pointer in the list </dd></dl>

</div>
</div>
<a class="anchor" id="acd643e7202e7c195ed11c32fb6d6e253"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRNReplicaNet_1_1Transport.html">Transport</a>* FindTransport </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the matching <a class="el" href="classRNReplicaNet_1_1Transport.html">Transport</a> for the URL </p>
<dl class="section return"><dt>Returns</dt><dd>The new <a class="el" href="classRNReplicaNet_1_1Transport.html">Transport</a> pointer for which Allocate() should be called to create a usable <a class="el" href="classRNReplicaNet_1_1Transport.html">Transport</a> pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a18c639a6c05835e92fea28d299345dee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool FreeTransport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRNReplicaNet_1_1Transport.html">Transport</a> *&#160;</td>
          <td class="paramname"><em>transport</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees any resources for a Transport* returned by <a class="el" href="classRNReplicaNet_1_1XPURL.html#acd643e7202e7c195ed11c32fb6d6e253">FindTransport()</a>-&gt;Allocate(); </p>

</div>
</div>
<a class="anchor" id="a1533f9c851623727e8492ba63660efe7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRNReplicaNet_1_1DebugHandler.html">DebugHandler</a>* GetDebugHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the debug handler set by <a class="el" href="classRNReplicaNet_1_1XPURL.html#ae9417f435d02b12d9edca1b01a21ebba">RegisterDebugHandler()</a> or null. </p>
<dl class="section return"><dt>Returns</dt><dd>The debug handler or null if no debugger handler is registered. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ac1e065c9253999e3d1d98c02c719c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void InitialiseNetwork </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>hardware</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Causes the network layer to start. This can include all system level hardware on the target platform.<br/>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hardware</td><td>Set this to be true to initialise all network hardware. The default is false. It is not necessary to manually call this since the network will start automatically when the first network related function is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e26dc48abcb0a3adb06f6abb351eab7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParseURLs </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>urls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a URL and after each iteration returns a tokenised URL. The first time this function is called pass in the whole URL and on subsequent calls pass in "" </p>
<dl class="section return"><dt>Returns</dt><dd>Each iteration returns a single URL or "" to denote an end to the list of URLs </dd></dl>

</div>
</div>
<a class="anchor" id="a52e5d0689ab10e993cfea71d5f248cca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Poll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This polls <a class="el" href="classRNReplicaNet_1_1XPURL.html">XPURL</a>. Normally an application will yield enough time during threads for <a class="el" href="classRNReplicaNet_1_1XPURL.html">XPURL</a> to function. Sometimes an application that uses a lot of 3D graphics can lock out other threads for quite some time. In these cases you may call <a class="el" href="classRNReplicaNet_1_1XPURL.html#a52e5d0689ab10e993cfea71d5f248cca">XPURL::Poll()</a> to yield some time to <a class="el" href="classRNReplicaNet_1_1XPURL.html">XPURL</a> to perform housekeeping. If a reliable UDP transport is being used this function will also poll the reliable UDP manager.<br/>
 Single threaded considerations:<br/>
 When using the single threaded libraries this method should be called regularly. Unless <a class="el" href="classRNReplicaNet_1_1XPSession.html#a52e5d0689ab10e993cfea71d5f248cca">XPSession::Poll()</a> or <a class="el" href="classRNReplicaNet_1_1ReplicaNet.html#a52e5d0689ab10e993cfea71d5f248cca">ReplicaNet::Poll()</a> is called in which case the default action is that this <a class="el" href="classRNReplicaNet_1_1XPURL.html#a52e5d0689ab10e993cfea71d5f248cca">Poll()</a> method is called. </p>

</div>
</div>
<a class="anchor" id="ae9417f435d02b12d9edca1b01a21ebba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRNReplicaNet_1_1DebugHandler.html">DebugHandler</a>* RegisterDebugHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRNReplicaNet_1_1DebugHandler.html">DebugHandler</a> *&#160;</td>
          <td class="paramname"><em>debugHandler</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This registers an extensible debug handler for use by <a class="el" href="classRNReplicaNet_1_1XPURL.html">XPURL</a>, <a class="el" href="classRNReplicaNet_1_1XPSession.html">XPSession</a>, <a class="el" href="classRNReplicaNet_1_1ReplicaNet.html">ReplicaNet</a> and the Visual Debugger. A <a class="el" href="classRNReplicaNet_1_1PlatformHeap.html#aaa353d9de40a51ad30f86d8447485745">PlatformHeap::ForceFree()</a> will delete the active currently registered <a class="el" href="classRNReplicaNet_1_1DebugHandler.html">DebugHandler</a> class. The application can use <a class="el" href="classRNReplicaNet_1_1XPURL.html#ae9417f435d02b12d9edca1b01a21ebba">RegisterDebugHandler()</a> without a parameter to unregister the <a class="el" href="classRNReplicaNet_1_1DebugHandler.html">DebugHandler</a> and avoid the handler being automatically freed by <a class="el" href="classRNReplicaNet_1_1PlatformHeap.html#aaa353d9de40a51ad30f86d8447485745">PlatformHeap::ForceFree()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">debugHandler</td><td>A pointer to an instance of the debug handler class. The default value is null which disables the debugger output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous debug handler pointer or null if no debugger handler was registered. </dd></dl>

</div>
</div>
<a class="anchor" id="a97974fbf1827f8d4116c4906510a06d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void RegisterDefaultTransports </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This static member function registers all of the default transports such as reliable UDP. </p>

</div>
</div>
<a class="anchor" id="a71d248d798aced3981f48cc61adc0d1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void RegisterTransport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRNReplicaNet_1_1Transport.html">Transport</a> &amp;&#160;</td>
          <td class="paramname"><em>transport</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Registers a <a class="el" href="classRNReplicaNet_1_1Transport.html">Transport</a> pointer with the URL decoder </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport</td><td>the <a class="el" href="classRNReplicaNet_1_1Transport.html">Transport</a> to register </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b53d44ad3a5a7324104b300f78c2522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetAutomaticPoll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the automatic <a class="el" href="classRNReplicaNet_1_1XPURL.html#a52e5d0689ab10e993cfea71d5f248cca">Poll()</a> method for this class and the reliable UDP manager.<br/>
 In multi-threading libraries this restarts the automatic polling thread so that an application does not need the call <a class="el" href="classRNReplicaNet_1_1XPURL.html#a52e5d0689ab10e993cfea71d5f248cca">Poll()</a><br/>
 In single-threading libraries this method has no effect and does not start a thread.<br/>
 The default multi-threading library behaviour is to enable multi-threading automatic polls,<br/>
 The default single-threading library behaviour is to use manual polls,<br/>
 </p>

</div>
</div>
<a class="anchor" id="a108af1ac13bb52b2c2d764701791e702"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetManualPoll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the manual <a class="el" href="classRNReplicaNet_1_1XPURL.html#a52e5d0689ab10e993cfea71d5f248cca">Poll()</a> method for this class and the reliable UDP manager.<br/>
 For multi-threaded libraries this turns off the automatic polling method.<br/>
 This allows an application to time exactly when polls are done.<br/>
 The application must call <a class="el" href="classRNReplicaNet_1_1XPURL.html#a52e5d0689ab10e993cfea71d5f248cca">Poll()</a> on a regular basis. A good place is just before or after the frame update is done. </p>

</div>
</div>
<a class="anchor" id="af3f146130479b62cb3d69539f732d655"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ShutdownNetwork </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>hardware</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Forces the network layer to shutdown if it is started. This can include all system level hardware on the target platform. This should only be used after users of <a class="el" href="classRNReplicaNet_1_1XPURL.html">XPURL</a> classes, such as <a class="el" href="classRNReplicaNet_1_1XPSession.html">XPSession</a> and <a class="el" href="classRNReplicaNet_1_1ReplicaNet.html">ReplicaNet</a>, have been freed. This does not free all internal allocated memory blocks, an example would be for registered factory classes. To force all internal allocated memory to be released <a class="el" href="classRNReplicaNet_1_1PlatformHeap.html#aaa353d9de40a51ad30f86d8447485745">RNReplicaNet::PlatformHeap::ForceFree()</a> should be called. A <a class="el" href="classRNReplicaNet_1_1PlatformHeap.html#aaa353d9de40a51ad30f86d8447485745">PlatformHeap::ForceFree()</a> will call ShutdownNetwork(true). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hardware</td><td>Set this to be true to shutdown all network hardware. The default is false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 16 2020 20:08:34 for ReplicaNet and RNLobby by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
