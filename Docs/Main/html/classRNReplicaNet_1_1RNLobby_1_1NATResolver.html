<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ReplicaNet and RNLobby: NATResolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ReplicaNet and RNLobby
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>RNReplicaNet</b></li><li class="navelem"><b>RNLobby</b></li><li class="navelem"><a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html">NATResolver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classRNReplicaNet_1_1RNLobby_1_1NATResolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">NATResolver Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="NATResolver_8h_source.html">NATResolver.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for NATResolver:</div>
<div class="dyncontent">
<div class="center"><img src="classRNReplicaNet_1_1RNLobby_1_1NATResolver__inherit__graph.png" border="0" usemap="#NATResolver_inherit__map" alt="Inheritance graph"/></div>
<map name="NATResolver_inherit__map" id="NATResolver_inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for NATResolver:</div>
<div class="dyncontent">
<div class="center"><img src="classRNReplicaNet_1_1RNLobby_1_1NATResolver__coll__graph.png" border="0" usemap="#NATResolver_coll__map" alt="Collaboration graph"/></div>
<map name="NATResolver_coll__map" id="NATResolver_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:adc29c2ff13d900c2f185ee95427fb06c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultPort</b> = 4002
 }</td></tr>
<tr class="separator:adc29c2ff13d900c2f185ee95427fb06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a94c2f5766df9d2adc8afd9a1f0ae775e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#a94c2f5766df9d2adc8afd9a1f0ae775e">Start</a> (void)</td></tr>
<tr class="separator:a94c2f5766df9d2adc8afd9a1f0ae775e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae903cde949cc162bc3fc46472c8a8248"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#ae903cde949cc162bc3fc46472c8a8248">Stop</a> (void)</td></tr>
<tr class="separator:ae903cde949cc162bc3fc46472c8a8248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443f552cbd526b3bfecb08f35d582350"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a443f552cbd526b3bfecb08f35d582350"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#a443f552cbd526b3bfecb08f35d582350">SetAutomaticThreadStop</a> (const bool allow=true)</td></tr>
<tr class="memdesc:a443f552cbd526b3bfecb08f35d582350"><td class="mdescLeft">&#160;</td><td class="mdescRight">When the <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html">NATResolver</a> becomes inactive for a period of time this allows the thread to stop processing. <br/></td></tr>
<tr class="separator:a443f552cbd526b3bfecb08f35d582350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5127ed2296cda74e7eb29145caa1c2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#aa5127ed2296cda74e7eb29145caa1c2d">SetAutomaticHostSocketReads</a> (const bool allow=false)</td></tr>
<tr class="separator:aa5127ed2296cda74e7eb29145caa1c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8dd58a7a9ad30e0b783cd6977fca74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#afc8dd58a7a9ad30e0b783cd6977fca74">SetEncryptionKey</a> (const void *data, const int length)</td></tr>
<tr class="separator:afc8dd58a7a9ad30e0b783cd6977fca74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbccc176f658192eba375cbe66a74d35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#adbccc176f658192eba375cbe66a74d35">BeginHosting</a> (<a class="el" href="structRNReplicaNet_1_1s__XPSocket.html">t_XPSocket</a> *socket)</td></tr>
<tr class="separator:adbccc176f658192eba375cbe66a74d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cce80dc5d136c4ff30dd4aa55c8b8d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#a3cce80dc5d136c4ff30dd4aa55c8b8d8">BeginAdvertise</a> (<a class="el" href="structRNReplicaNet_1_1s__XPSocket.html">t_XPSocket</a> *socket, void *userPointer, const bool isAdvertised, const int globalID, const int sessionID, const int nonceID, const bool externalHost=true, const <a class="el" href="structRNReplicaNet_1_1XPAddress.html">XPAddress</a> *optionalHost=0, const bool persistant=false)</td></tr>
<tr class="memdesc:a3cce80dc5d136c4ff30dd4aa55c8b8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advertises a socket with a set of identifying numbers (isAdvertised, globalID, nonceID) which should be globally unique for this socket.  <a href="#a3cce80dc5d136c4ff30dd4aa55c8b8d8">More...</a><br/></td></tr>
<tr class="separator:a3cce80dc5d136c4ff30dd4aa55c8b8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69124c2c02032ebc75641c345fea1caf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#a69124c2c02032ebc75641c345fea1caf">BeginResolve</a> (<a class="el" href="structRNReplicaNet_1_1s__XPSocket.html">t_XPSocket</a> *socket, void *userPointer, const bool isAdvertised, const int globalID, const int sessionID, const int nonceID, const bool tryExternalHost=true, const <a class="el" href="structRNReplicaNet_1_1XPAddress.html">XPAddress</a> *optionalHost=0, const <a class="el" href="structRNReplicaNet_1_1XPAddress.html">XPAddress</a> *optionalFirstTargetTry=0)</td></tr>
<tr class="separator:a69124c2c02032ebc75641c345fea1caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07dc1a0ea550a6c21f73ffc6f543db35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07dc1a0ea550a6c21f73ffc6f543db35"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#a07dc1a0ea550a6c21f73ffc6f543db35">ForgetSocket</a> (const <a class="el" href="structRNReplicaNet_1_1s__XPSocket.html">t_XPSocket</a> *socket)</td></tr>
<tr class="memdesc:a07dc1a0ea550a6c21f73ffc6f543db35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the socket from the <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html">NATResolver</a> index. <br/></td></tr>
<tr class="separator:a07dc1a0ea550a6c21f73ffc6f543db35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7033d014a26930d0b6d9f629e40a85c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7033d014a26930d0b6d9f629e40a85c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#a7033d014a26930d0b6d9f629e40a85c4">ForgetUserPointer</a> (const void *userPointer)</td></tr>
<tr class="memdesc:a7033d014a26930d0b6d9f629e40a85c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forgets all sockets with the same userPointer. <br/></td></tr>
<tr class="separator:a7033d014a26930d0b6d9f629e40a85c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7a46fd9ebad3fd529a005b6be26cce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a7a46fd9ebad3fd529a005b6be26cce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#a3a7a46fd9ebad3fd529a005b6be26cce">ForgetResolve</a> (<a class="el" href="structRNReplicaNet_1_1s__XPSocket.html">t_XPSocket</a> *socket, const bool isAdvertised, const int globalID, const int sessionID, const int nonceID)</td></tr>
<tr class="memdesc:a3a7a46fd9ebad3fd529a005b6be26cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specific resolve request. <br/></td></tr>
<tr class="separator:a3a7a46fd9ebad3fd529a005b6be26cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5a3b79382ea11f67c08e095ae4b1ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#afc5a3b79382ea11f67c08e095ae4b1ce">CallbackParsePacketData</a> (<a class="el" href="structRNReplicaNet_1_1s__XPSocket.html">t_XPSocket</a> *socket, const <a class="el" href="structRNReplicaNet_1_1XPAddress.html">XPAddress</a> &amp;addr, void *data, size_t length)</td></tr>
<tr class="separator:afc5a3b79382ea11f67c08e095ae4b1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac1d94775f0ac813a9e5a60fe383879"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#abac1d94775f0ac813a9e5a60fe383879">SetServer</a> (const <a class="el" href="structRNReplicaNet_1_1XPAddress.html">XPAddress</a> &amp;address)</td></tr>
<tr class="separator:abac1d94775f0ac813a9e5a60fe383879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31d06a11afbde67d8f7e0baac453e1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab31d06a11afbde67d8f7e0baac453e1e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#ab31d06a11afbde67d8f7e0baac453e1e">CallbackResolveFailed</a> (<a class="el" href="structRNReplicaNet_1_1s__XPSocket.html">t_XPSocket</a> *socket, void *userPointer, const int titleID, const bool isAdvertised, const int globalID, const int sessionID, const int nonceID)</td></tr>
<tr class="memdesc:ab31d06a11afbde67d8f7e0baac453e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A virtual callback that is triggered when a NAT resolve attempt fails. <br/></td></tr>
<tr class="separator:ab31d06a11afbde67d8f7e0baac453e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347c76714bdf3f22d3d21be4bb5ef969"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#a347c76714bdf3f22d3d21be4bb5ef969">CallbackResolveResult</a> (<a class="el" href="structRNReplicaNet_1_1s__XPSocket.html">t_XPSocket</a> *socket, void *userPointer, const <a class="el" href="structRNReplicaNet_1_1XPAddress.html">XPAddress</a> &amp;targetAddress, const int titleID, const bool isAdvertised, const int globalID, const int sessionID, const int nonceID)</td></tr>
<tr class="separator:a347c76714bdf3f22d3d21be4bb5ef969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23204f4ad068f007a7d9d8a154537cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af23204f4ad068f007a7d9d8a154537cd"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#af23204f4ad068f007a7d9d8a154537cd">CallbackExternalAddressKnown</a> (<a class="el" href="structRNReplicaNet_1_1s__XPSocket.html">t_XPSocket</a> *socket, void *userPointer, const <a class="el" href="structRNReplicaNet_1_1XPAddress.html">XPAddress</a> &amp;externalAddress, const int titleID, const bool isAdvertised, const int globalID, const int sessionID, const int nonceID)</td></tr>
<tr class="memdesc:af23204f4ad068f007a7d9d8a154537cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A virtual callback that is triggered when an advertised socket it told the external address from being advertised to an external host. <br/></td></tr>
<tr class="separator:af23204f4ad068f007a7d9d8a154537cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This NAT resolver uses incoming data to respond to queries for NAT negotiation. It can also make requests for NAT negotiation. This class can also make queries to NAT resolve. This class is used by <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1TransportNATUDP.html">TransportNATUDP</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3cce80dc5d136c4ff30dd4aa55c8b8d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BeginAdvertise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRNReplicaNet_1_1s__XPSocket.html">t_XPSocket</a> *&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>isAdvertised</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>globalID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sessionID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nonceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>externalHost</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRNReplicaNet_1_1XPAddress.html">XPAddress</a> *&#160;</td>
          <td class="paramname"><em>optionalHost</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>persistant</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advertises a socket with a set of identifying numbers (isAdvertised, globalID, nonceID) which should be globally unique for this socket. </p>
<p>If the <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html">NATResolver</a> thread has not started then this calls <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#a94c2f5766df9d2adc8afd9a1f0ae775e">Start()</a> first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket to advertise. </td></tr>
    <tr><td class="paramname">userPointer</td><td>A user pointer passed to <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html">NATResolver</a> callbacks. </td></tr>
    <tr><td class="paramname">isAdvertised</td><td>Can be true or false indicating if the socket is advertised with a game server. If being used by <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1TransportNATUDP.html">TransportNATUDP</a> this detects if <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1AdvertiseClient.html" title="Maintains a connection to the AdvertiseServer. ">AdvertiseClient</a> is advertising a connection. </td></tr>
    <tr><td class="paramname">globalID</td><td>Must a globally unique number, for example a hash of the public IP address. If being used by <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1TransportNATUDP.html">TransportNATUDP</a> this uses the advertised ID from <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1AdvertiseClient.html" title="Maintains a connection to the AdvertiseServer. ">AdvertiseClient</a> or the currently logged in userID. </td></tr>
    <tr><td class="paramname">nonceID</td><td>Must be a locally unique number, for example the value from NOnceGen::GetNOnce() or the value of the socket pointer cast to an int. If being used by <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1TransportNATUDP.html">TransportNATUDP</a> this uses the value from NOnceGen::GetNOnce(). </td></tr>
    <tr><td class="paramname">externalHost</td><td>If true then this will attempt to ask an external server to help with resolving. The server is set by <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#abac1d94775f0ac813a9e5a60fe383879">SetServer()</a> or by default uses the RNLobby <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html">NATResolver</a> server. </td></tr>
    <tr><td class="paramname">optionalHost</td><td>An optional host to contact to help with resolving. </td></tr>
    <tr><td class="paramname">persistant</td><td>Keeps the socket alive for longer in the <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html">NATResolver</a> index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbccc176f658192eba375cbe66a74d35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BeginHosting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRNReplicaNet_1_1s__XPSocket.html">t_XPSocket</a> *&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hosts a <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html">NATResolver</a> server instance on this socket. The socket is automatically polled is SetAutomaticHostSocketReads(true) is used. If the <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html">NATResolver</a> thread has not started then this calls <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#a94c2f5766df9d2adc8afd9a1f0ae775e">Start()</a> first. </p>

</div>
</div>
<a class="anchor" id="a69124c2c02032ebc75641c345fea1caf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BeginResolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRNReplicaNet_1_1s__XPSocket.html">t_XPSocket</a> *&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>isAdvertised</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>globalID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sessionID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nonceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>tryExternalHost</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRNReplicaNet_1_1XPAddress.html">XPAddress</a> *&#160;</td>
          <td class="paramname"><em>optionalHost</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRNReplicaNet_1_1XPAddress.html">XPAddress</a> *&#160;</td>
          <td class="paramname"><em>optionalFirstTargetTry</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts resolving a connection between this socket and the socket advertised with the set of identifying numbers (isAdvertised, globalID, nonceID). Either <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#ab31d06a11afbde67d8f7e0baac453e1e" title="A virtual callback that is triggered when a NAT resolve attempt fails. ">CallbackResolveFailed()</a> or <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#a347c76714bdf3f22d3d21be4bb5ef969">CallbackResolveResult()</a> will be called. If the <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html">NATResolver</a> thread has not started then this calls <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#a94c2f5766df9d2adc8afd9a1f0ae775e">Start()</a> first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket to resolve. </td></tr>
    <tr><td class="paramname">userPointer</td><td>A user pointer passed to <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html">NATResolver</a> callbacks. </td></tr>
    <tr><td class="paramname">isAdvertised</td><td>A value set by <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#a3cce80dc5d136c4ff30dd4aa55c8b8d8" title="Advertises a socket with a set of identifying numbers (isAdvertised, globalID, nonceID) which should ...">BeginAdvertise()</a>. </td></tr>
    <tr><td class="paramname">globalID</td><td>A value set by <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#a3cce80dc5d136c4ff30dd4aa55c8b8d8" title="Advertises a socket with a set of identifying numbers (isAdvertised, globalID, nonceID) which should ...">BeginAdvertise()</a>. </td></tr>
    <tr><td class="paramname">nonceID</td><td>A value set by <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#a3cce80dc5d136c4ff30dd4aa55c8b8d8" title="Advertises a socket with a set of identifying numbers (isAdvertised, globalID, nonceID) which should ...">BeginAdvertise()</a>. </td></tr>
    <tr><td class="paramname">tryExternalHost</td><td>If true then this will attempt to ask an external server to help with resolving. The server is set by <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#abac1d94775f0ac813a9e5a60fe383879">SetServer()</a> or by default uses the RNLobby <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html">NATResolver</a> server. </td></tr>
    <tr><td class="paramname">optionalHost</td><td>An optional host to contact to help with resolving. </td></tr>
    <tr><td class="paramname">optionalFirstTargetTry</td><td>An optional address to try first, this could be the local LAN IP address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc5a3b79382ea11f67c08e095ae4b1ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CallbackParsePacketData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRNReplicaNet_1_1s__XPSocket.html">t_XPSocket</a> *&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRNReplicaNet_1_1XPAddress.html">XPAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The user may call this function when a packet is received on a socket that where NAT packets can potentially be received. For example, internally the NATUDP <a class="el" href="classRNReplicaNet_1_1Transport.html">Transport</a> uses a reliable UDP manager which calls a hook function, if it exists after is has been installed by RNLobby::RegisterDefaultTransports(), this function then calls <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#afc5a3b79382ea11f67c08e095ae4b1ce">CallbackParsePacketData()</a> for any packets that arrive allowing the extension NATUDP transport to automatically NAT resolve without needed an explicit library dependancy between RNXPURL and RNLobby. If the <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html">NATResolver</a> thread has not started then this calls <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1NATResolver.html#a94c2f5766df9d2adc8afd9a1f0ae775e">Start()</a> first. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the packet is a NAT packet, which implies the packet data doesn't need to be processed by the receiver. </dd>
<dd>
False if the packet isn't a NAT packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a347c76714bdf3f22d3d21be4bb5ef969"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CallbackResolveResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRNReplicaNet_1_1s__XPSocket.html">t_XPSocket</a> *&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRNReplicaNet_1_1XPAddress.html">XPAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>targetAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>titleID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>isAdvertised</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>globalID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sessionID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nonceID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A virtual callback that is triggered when a NAT resolve attempt succeeds. /param targetAddress The target address the socket can send packets to. </p>

</div>
</div>
<a class="anchor" id="aa5127ed2296cda74e7eb29145caa1c2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetAutomaticHostSocketReads </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows the host socket set by BeginHosting to be automatically read and all packets received on that socket to be parsed. Also calls SetAutomaticThreadStop(false) </p>

</div>
</div>
<a class="anchor" id="afc8dd58a7a9ad30e0b783cd6977fca74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetEncryptionKey </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the encryption key to be used by all queries for this server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to use as a seed for the key. This can be NULL to use the default key. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the data to use for creating the key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abac1d94775f0ac813a9e5a60fe383879"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetServer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRNReplicaNet_1_1XPAddress.html">XPAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the address and port of the server. The default for the instance of the class is localhost and port NATResolver::kDefaultPort or the address resolved by a successful <a class="el" href="classRNReplicaNet_1_1RNLobby_1_1BackendClient.html#ab87c572b19f7a7b44107728bde058e10">BackendClient::Start()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The new address and port number to use for the server </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a94c2f5766df9d2adc8afd9a1f0ae775e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts the NAT resolver thread. </p>
<dl class="section return"><dt>Returns</dt><dd>Success returns true, failure returns false. </dd></dl>

</div>
</div>
<a class="anchor" id="ae903cde949cc162bc3fc46472c8a8248"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops the NAT resolver thread. </p>
<dl class="section return"><dt>Returns</dt><dd>Success returns true, failure returns false. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 16 2020 20:08:35 for ReplicaNet and RNLobby by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
